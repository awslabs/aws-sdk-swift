// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class GreengrassClient {
    let client: SdkHttpClient
    let config: GreengrassClientConfiguration
    let serviceName = "Greengrass"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: GreengrassClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class GreengrassClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> GreengrassClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try GreengrassClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension GreengrassClient: GreengrassClientProtocol {
    /// Associates a role with a group. Your Greengrass core will use the role to access AWS cloud services. The role's permissions should allow Greengrass core Lambda functions to perform actions against the cloud.
    public func associateRoleToGroup(input: AssociateRoleToGroupInput, completion: @escaping (SdkResult<AssociateRoleToGroupOutput, AssociateRoleToGroupOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/role"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateRoleToGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateRoleToGroupInput, AssociateRoleToGroupOutput, AssociateRoleToGroupOutputError>(id: "associateRoleToGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateRoleToGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateRoleToGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateRoleToGroupInput, AssociateRoleToGroupOutput, AssociateRoleToGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateRoleToGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Associates a role with your account. AWS IoT Greengrass will use the role to access your Lambda functions and AWS IoT resources. This is necessary for deployments to succeed. The role must have at least minimum permissions in the policy ''AWSGreengrassResourceAccessRolePolicy''.
    public func associateServiceRoleToAccount(input: AssociateServiceRoleToAccountInput, completion: @escaping (SdkResult<AssociateServiceRoleToAccountOutput, AssociateServiceRoleToAccountOutputError>) -> Void)
    {
        let urlPath = "/greengrass/servicerole"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateServiceRoleToAccount")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateServiceRoleToAccountInput, AssociateServiceRoleToAccountOutput, AssociateServiceRoleToAccountOutputError>(id: "associateServiceRoleToAccount")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateServiceRoleToAccountInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateServiceRoleToAccountInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateServiceRoleToAccountInput, AssociateServiceRoleToAccountOutput, AssociateServiceRoleToAccountOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateServiceRoleToAccountInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a connector definition. You may provide the initial version of the connector definition now or use ''CreateConnectorDefinitionVersion'' at a later time.
    public func createConnectorDefinition(input: CreateConnectorDefinitionInput, completion: @escaping (SdkResult<CreateConnectorDefinitionOutput, CreateConnectorDefinitionOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/connectors"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createConnectorDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateConnectorDefinitionInput, CreateConnectorDefinitionOutput, CreateConnectorDefinitionOutputError>(id: "createConnectorDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateConnectorDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateConnectorDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateConnectorDefinitionInput, CreateConnectorDefinitionOutput, CreateConnectorDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateConnectorDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a version of a connector definition which has already been defined.
    public func createConnectorDefinitionVersion(input: CreateConnectorDefinitionVersionInput, completion: @escaping (SdkResult<CreateConnectorDefinitionVersionOutput, CreateConnectorDefinitionVersionOutputError>) -> Void)
    {
        guard let connectorDefinitionId = input.connectorDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component connectorDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/connectors/\(connectorDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createConnectorDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateConnectorDefinitionVersionInput, CreateConnectorDefinitionVersionOutput, CreateConnectorDefinitionVersionOutputError>(id: "createConnectorDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateConnectorDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateConnectorDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateConnectorDefinitionVersionInput, CreateConnectorDefinitionVersionOutput, CreateConnectorDefinitionVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateConnectorDefinitionVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a core definition. You may provide the initial version of the core definition now or use ''CreateCoreDefinitionVersion'' at a later time. Greengrass groups must each contain exactly one Greengrass core.
    public func createCoreDefinition(input: CreateCoreDefinitionInput, completion: @escaping (SdkResult<CreateCoreDefinitionOutput, CreateCoreDefinitionOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/cores"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCoreDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateCoreDefinitionInput, CreateCoreDefinitionOutput, CreateCoreDefinitionOutputError>(id: "createCoreDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateCoreDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateCoreDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateCoreDefinitionInput, CreateCoreDefinitionOutput, CreateCoreDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateCoreDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a version of a core definition that has already been defined. Greengrass groups must each contain exactly one Greengrass core.
    public func createCoreDefinitionVersion(input: CreateCoreDefinitionVersionInput, completion: @escaping (SdkResult<CreateCoreDefinitionVersionOutput, CreateCoreDefinitionVersionOutputError>) -> Void)
    {
        guard let coreDefinitionId = input.coreDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component coreDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/cores/\(coreDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCoreDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateCoreDefinitionVersionInput, CreateCoreDefinitionVersionOutput, CreateCoreDefinitionVersionOutputError>(id: "createCoreDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateCoreDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateCoreDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateCoreDefinitionVersionInput, CreateCoreDefinitionVersionOutput, CreateCoreDefinitionVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateCoreDefinitionVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a deployment. ''CreateDeployment'' requests are idempotent with respect to the ''X-Amzn-Client-Token'' token and the request parameters.
    public func createDeployment(input: CreateDeploymentInput, completion: @escaping (SdkResult<CreateDeploymentOutput, CreateDeploymentOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/deployments"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDeployment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDeploymentInput, CreateDeploymentOutput, CreateDeploymentOutputError>(id: "createDeployment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDeploymentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDeploymentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDeploymentInput, CreateDeploymentOutput, CreateDeploymentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDeploymentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a device definition. You may provide the initial version of the device definition now or use ''CreateDeviceDefinitionVersion'' at a later time.
    public func createDeviceDefinition(input: CreateDeviceDefinitionInput, completion: @escaping (SdkResult<CreateDeviceDefinitionOutput, CreateDeviceDefinitionOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/devices"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDeviceDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDeviceDefinitionInput, CreateDeviceDefinitionOutput, CreateDeviceDefinitionOutputError>(id: "createDeviceDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDeviceDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDeviceDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDeviceDefinitionInput, CreateDeviceDefinitionOutput, CreateDeviceDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDeviceDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a version of a device definition that has already been defined.
    public func createDeviceDefinitionVersion(input: CreateDeviceDefinitionVersionInput, completion: @escaping (SdkResult<CreateDeviceDefinitionVersionOutput, CreateDeviceDefinitionVersionOutputError>) -> Void)
    {
        guard let deviceDefinitionId = input.deviceDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component deviceDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/devices/\(deviceDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDeviceDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDeviceDefinitionVersionInput, CreateDeviceDefinitionVersionOutput, CreateDeviceDefinitionVersionOutputError>(id: "createDeviceDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDeviceDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDeviceDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDeviceDefinitionVersionInput, CreateDeviceDefinitionVersionOutput, CreateDeviceDefinitionVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDeviceDefinitionVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a Lambda function definition which contains a list of Lambda functions and their configurations to be used in a group. You can create an initial version of the definition by providing a list of Lambda functions and their configurations now, or use ''CreateFunctionDefinitionVersion'' later.
    public func createFunctionDefinition(input: CreateFunctionDefinitionInput, completion: @escaping (SdkResult<CreateFunctionDefinitionOutput, CreateFunctionDefinitionOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/functions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createFunctionDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateFunctionDefinitionInput, CreateFunctionDefinitionOutput, CreateFunctionDefinitionOutputError>(id: "createFunctionDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateFunctionDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateFunctionDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateFunctionDefinitionInput, CreateFunctionDefinitionOutput, CreateFunctionDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateFunctionDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a version of a Lambda function definition that has already been defined.
    public func createFunctionDefinitionVersion(input: CreateFunctionDefinitionVersionInput, completion: @escaping (SdkResult<CreateFunctionDefinitionVersionOutput, CreateFunctionDefinitionVersionOutputError>) -> Void)
    {
        guard let functionDefinitionId = input.functionDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component functionDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/functions/\(functionDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createFunctionDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateFunctionDefinitionVersionInput, CreateFunctionDefinitionVersionOutput, CreateFunctionDefinitionVersionOutputError>(id: "createFunctionDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateFunctionDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateFunctionDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateFunctionDefinitionVersionInput, CreateFunctionDefinitionVersionOutput, CreateFunctionDefinitionVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateFunctionDefinitionVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a group. You may provide the initial version of the group or use ''CreateGroupVersion'' at a later time. Tip: You can use the ''gg_group_setup'' package (https://github.com/awslabs/aws-greengrass-group-setup) as a library or command-line application to create and deploy Greengrass groups.
    public func createGroup(input: CreateGroupInput, completion: @escaping (SdkResult<CreateGroupOutput, CreateGroupOutputError>) -> Void)
    {
        let urlPath = "/greengrass/groups"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateGroupInput, CreateGroupOutput, CreateGroupOutputError>(id: "createGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateGroupInput, CreateGroupOutput, CreateGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a CA for the group. If a CA already exists, it will rotate the existing CA.
    public func createGroupCertificateAuthority(input: CreateGroupCertificateAuthorityInput, completion: @escaping (SdkResult<CreateGroupCertificateAuthorityOutput, CreateGroupCertificateAuthorityOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/certificateauthorities"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createGroupCertificateAuthority")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateGroupCertificateAuthorityInput, CreateGroupCertificateAuthorityOutput, CreateGroupCertificateAuthorityOutputError>(id: "createGroupCertificateAuthority")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateGroupCertificateAuthorityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateGroupCertificateAuthorityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateGroupCertificateAuthorityInput, CreateGroupCertificateAuthorityOutput, CreateGroupCertificateAuthorityOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a version of a group which has already been defined.
    public func createGroupVersion(input: CreateGroupVersionInput, completion: @escaping (SdkResult<CreateGroupVersionOutput, CreateGroupVersionOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createGroupVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateGroupVersionInput, CreateGroupVersionOutput, CreateGroupVersionOutputError>(id: "createGroupVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateGroupVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateGroupVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateGroupVersionInput, CreateGroupVersionOutput, CreateGroupVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateGroupVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a logger definition. You may provide the initial version of the logger definition now or use ''CreateLoggerDefinitionVersion'' at a later time.
    public func createLoggerDefinition(input: CreateLoggerDefinitionInput, completion: @escaping (SdkResult<CreateLoggerDefinitionOutput, CreateLoggerDefinitionOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/loggers"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createLoggerDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateLoggerDefinitionInput, CreateLoggerDefinitionOutput, CreateLoggerDefinitionOutputError>(id: "createLoggerDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateLoggerDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateLoggerDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateLoggerDefinitionInput, CreateLoggerDefinitionOutput, CreateLoggerDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateLoggerDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a version of a logger definition that has already been defined.
    public func createLoggerDefinitionVersion(input: CreateLoggerDefinitionVersionInput, completion: @escaping (SdkResult<CreateLoggerDefinitionVersionOutput, CreateLoggerDefinitionVersionOutputError>) -> Void)
    {
        guard let loggerDefinitionId = input.loggerDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component loggerDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/loggers/\(loggerDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createLoggerDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateLoggerDefinitionVersionInput, CreateLoggerDefinitionVersionOutput, CreateLoggerDefinitionVersionOutputError>(id: "createLoggerDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateLoggerDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateLoggerDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateLoggerDefinitionVersionInput, CreateLoggerDefinitionVersionOutput, CreateLoggerDefinitionVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateLoggerDefinitionVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a resource definition which contains a list of resources to be used in a group. You can create an initial version of the definition by providing a list of resources now, or use ''CreateResourceDefinitionVersion'' later.
    public func createResourceDefinition(input: CreateResourceDefinitionInput, completion: @escaping (SdkResult<CreateResourceDefinitionOutput, CreateResourceDefinitionOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/resources"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createResourceDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateResourceDefinitionInput, CreateResourceDefinitionOutput, CreateResourceDefinitionOutputError>(id: "createResourceDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateResourceDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateResourceDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateResourceDefinitionInput, CreateResourceDefinitionOutput, CreateResourceDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateResourceDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a version of a resource definition that has already been defined.
    public func createResourceDefinitionVersion(input: CreateResourceDefinitionVersionInput, completion: @escaping (SdkResult<CreateResourceDefinitionVersionOutput, CreateResourceDefinitionVersionOutputError>) -> Void)
    {
        guard let resourceDefinitionId = input.resourceDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/resources/\(resourceDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createResourceDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateResourceDefinitionVersionInput, CreateResourceDefinitionVersionOutput, CreateResourceDefinitionVersionOutputError>(id: "createResourceDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateResourceDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateResourceDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateResourceDefinitionVersionInput, CreateResourceDefinitionVersionOutput, CreateResourceDefinitionVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateResourceDefinitionVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a software update for a core or group of cores (specified as an IoT thing group.) Use this to update the OTA Agent as well as the Greengrass core software. It makes use of the IoT Jobs feature which provides additional commands to manage a Greengrass core software update job.
    public func createSoftwareUpdateJob(input: CreateSoftwareUpdateJobInput, completion: @escaping (SdkResult<CreateSoftwareUpdateJobOutput, CreateSoftwareUpdateJobOutputError>) -> Void)
    {
        let urlPath = "/greengrass/updates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSoftwareUpdateJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSoftwareUpdateJobInput, CreateSoftwareUpdateJobOutput, CreateSoftwareUpdateJobOutputError>(id: "createSoftwareUpdateJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateSoftwareUpdateJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSoftwareUpdateJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSoftwareUpdateJobInput, CreateSoftwareUpdateJobOutput, CreateSoftwareUpdateJobOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSoftwareUpdateJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a subscription definition. You may provide the initial version of the subscription definition now or use ''CreateSubscriptionDefinitionVersion'' at a later time.
    public func createSubscriptionDefinition(input: CreateSubscriptionDefinitionInput, completion: @escaping (SdkResult<CreateSubscriptionDefinitionOutput, CreateSubscriptionDefinitionOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/subscriptions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSubscriptionDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSubscriptionDefinitionInput, CreateSubscriptionDefinitionOutput, CreateSubscriptionDefinitionOutputError>(id: "createSubscriptionDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateSubscriptionDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSubscriptionDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSubscriptionDefinitionInput, CreateSubscriptionDefinitionOutput, CreateSubscriptionDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSubscriptionDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a version of a subscription definition which has already been defined.
    public func createSubscriptionDefinitionVersion(input: CreateSubscriptionDefinitionVersionInput, completion: @escaping (SdkResult<CreateSubscriptionDefinitionVersionOutput, CreateSubscriptionDefinitionVersionOutputError>) -> Void)
    {
        guard let subscriptionDefinitionId = input.subscriptionDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component subscriptionDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/subscriptions/\(subscriptionDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSubscriptionDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSubscriptionDefinitionVersionInput, CreateSubscriptionDefinitionVersionOutput, CreateSubscriptionDefinitionVersionOutputError>(id: "createSubscriptionDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateSubscriptionDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSubscriptionDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSubscriptionDefinitionVersionInput, CreateSubscriptionDefinitionVersionOutput, CreateSubscriptionDefinitionVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSubscriptionDefinitionVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a connector definition.
    public func deleteConnectorDefinition(input: DeleteConnectorDefinitionInput, completion: @escaping (SdkResult<DeleteConnectorDefinitionOutput, DeleteConnectorDefinitionOutputError>) -> Void)
    {
        guard let connectorDefinitionId = input.connectorDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component connectorDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/connectors/\(connectorDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteConnectorDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteConnectorDefinitionInput, DeleteConnectorDefinitionOutput, DeleteConnectorDefinitionOutputError>(id: "deleteConnectorDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteConnectorDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteConnectorDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteConnectorDefinitionInput, DeleteConnectorDefinitionOutput, DeleteConnectorDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a core definition.
    public func deleteCoreDefinition(input: DeleteCoreDefinitionInput, completion: @escaping (SdkResult<DeleteCoreDefinitionOutput, DeleteCoreDefinitionOutputError>) -> Void)
    {
        guard let coreDefinitionId = input.coreDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component coreDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/cores/\(coreDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCoreDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteCoreDefinitionInput, DeleteCoreDefinitionOutput, DeleteCoreDefinitionOutputError>(id: "deleteCoreDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteCoreDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteCoreDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteCoreDefinitionInput, DeleteCoreDefinitionOutput, DeleteCoreDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a device definition.
    public func deleteDeviceDefinition(input: DeleteDeviceDefinitionInput, completion: @escaping (SdkResult<DeleteDeviceDefinitionOutput, DeleteDeviceDefinitionOutputError>) -> Void)
    {
        guard let deviceDefinitionId = input.deviceDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component deviceDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/devices/\(deviceDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDeviceDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDeviceDefinitionInput, DeleteDeviceDefinitionOutput, DeleteDeviceDefinitionOutputError>(id: "deleteDeviceDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDeviceDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDeviceDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDeviceDefinitionInput, DeleteDeviceDefinitionOutput, DeleteDeviceDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a Lambda function definition.
    public func deleteFunctionDefinition(input: DeleteFunctionDefinitionInput, completion: @escaping (SdkResult<DeleteFunctionDefinitionOutput, DeleteFunctionDefinitionOutputError>) -> Void)
    {
        guard let functionDefinitionId = input.functionDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component functionDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/functions/\(functionDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteFunctionDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteFunctionDefinitionInput, DeleteFunctionDefinitionOutput, DeleteFunctionDefinitionOutputError>(id: "deleteFunctionDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteFunctionDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteFunctionDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteFunctionDefinitionInput, DeleteFunctionDefinitionOutput, DeleteFunctionDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a group.
    public func deleteGroup(input: DeleteGroupInput, completion: @escaping (SdkResult<DeleteGroupOutput, DeleteGroupOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteGroupInput, DeleteGroupOutput, DeleteGroupOutputError>(id: "deleteGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteGroupInput, DeleteGroupOutput, DeleteGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a logger definition.
    public func deleteLoggerDefinition(input: DeleteLoggerDefinitionInput, completion: @escaping (SdkResult<DeleteLoggerDefinitionOutput, DeleteLoggerDefinitionOutputError>) -> Void)
    {
        guard let loggerDefinitionId = input.loggerDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component loggerDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/loggers/\(loggerDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteLoggerDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteLoggerDefinitionInput, DeleteLoggerDefinitionOutput, DeleteLoggerDefinitionOutputError>(id: "deleteLoggerDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteLoggerDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteLoggerDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteLoggerDefinitionInput, DeleteLoggerDefinitionOutput, DeleteLoggerDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a resource definition.
    public func deleteResourceDefinition(input: DeleteResourceDefinitionInput, completion: @escaping (SdkResult<DeleteResourceDefinitionOutput, DeleteResourceDefinitionOutputError>) -> Void)
    {
        guard let resourceDefinitionId = input.resourceDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/resources/\(resourceDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteResourceDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteResourceDefinitionInput, DeleteResourceDefinitionOutput, DeleteResourceDefinitionOutputError>(id: "deleteResourceDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourceDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourceDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteResourceDefinitionInput, DeleteResourceDefinitionOutput, DeleteResourceDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a subscription definition.
    public func deleteSubscriptionDefinition(input: DeleteSubscriptionDefinitionInput, completion: @escaping (SdkResult<DeleteSubscriptionDefinitionOutput, DeleteSubscriptionDefinitionOutputError>) -> Void)
    {
        guard let subscriptionDefinitionId = input.subscriptionDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component subscriptionDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/subscriptions/\(subscriptionDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteSubscriptionDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteSubscriptionDefinitionInput, DeleteSubscriptionDefinitionOutput, DeleteSubscriptionDefinitionOutputError>(id: "deleteSubscriptionDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteSubscriptionDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteSubscriptionDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteSubscriptionDefinitionInput, DeleteSubscriptionDefinitionOutput, DeleteSubscriptionDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Disassociates the role from a group.
    public func disassociateRoleFromGroup(input: DisassociateRoleFromGroupInput, completion: @escaping (SdkResult<DisassociateRoleFromGroupOutput, DisassociateRoleFromGroupOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/role"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateRoleFromGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateRoleFromGroupInput, DisassociateRoleFromGroupOutput, DisassociateRoleFromGroupOutputError>(id: "disassociateRoleFromGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateRoleFromGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateRoleFromGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateRoleFromGroupInput, DisassociateRoleFromGroupOutput, DisassociateRoleFromGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Disassociates the service role from your account. Without a service role, deployments will not work.
    public func disassociateServiceRoleFromAccount(input: DisassociateServiceRoleFromAccountInput, completion: @escaping (SdkResult<DisassociateServiceRoleFromAccountOutput, DisassociateServiceRoleFromAccountOutputError>) -> Void)
    {
        let urlPath = "/greengrass/servicerole"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateServiceRoleFromAccount")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateServiceRoleFromAccountInput, DisassociateServiceRoleFromAccountOutput, DisassociateServiceRoleFromAccountOutputError>(id: "disassociateServiceRoleFromAccount")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateServiceRoleFromAccountInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateServiceRoleFromAccountInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateServiceRoleFromAccountInput, DisassociateServiceRoleFromAccountOutput, DisassociateServiceRoleFromAccountOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves the role associated with a particular group.
    public func getAssociatedRole(input: GetAssociatedRoleInput, completion: @escaping (SdkResult<GetAssociatedRoleOutput, GetAssociatedRoleOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/role"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAssociatedRole")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAssociatedRoleInput, GetAssociatedRoleOutput, GetAssociatedRoleOutputError>(id: "getAssociatedRole")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAssociatedRoleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAssociatedRoleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAssociatedRoleInput, GetAssociatedRoleOutput, GetAssociatedRoleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns the status of a bulk deployment.
    public func getBulkDeploymentStatus(input: GetBulkDeploymentStatusInput, completion: @escaping (SdkResult<GetBulkDeploymentStatusOutput, GetBulkDeploymentStatusOutputError>) -> Void)
    {
        guard let bulkDeploymentId = input.bulkDeploymentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component bulkDeploymentId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/bulk/deployments/\(bulkDeploymentId)/status"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBulkDeploymentStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBulkDeploymentStatusInput, GetBulkDeploymentStatusOutput, GetBulkDeploymentStatusOutputError>(id: "getBulkDeploymentStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBulkDeploymentStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBulkDeploymentStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBulkDeploymentStatusInput, GetBulkDeploymentStatusOutput, GetBulkDeploymentStatusOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves the connectivity information for a core.
    public func getConnectivityInfo(input: GetConnectivityInfoInput, completion: @escaping (SdkResult<GetConnectivityInfoOutput, GetConnectivityInfoOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/things/\(thingName)/connectivityInfo"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getConnectivityInfo")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetConnectivityInfoInput, GetConnectivityInfoOutput, GetConnectivityInfoOutputError>(id: "getConnectivityInfo")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetConnectivityInfoInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetConnectivityInfoInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetConnectivityInfoInput, GetConnectivityInfoOutput, GetConnectivityInfoOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a connector definition.
    public func getConnectorDefinition(input: GetConnectorDefinitionInput, completion: @escaping (SdkResult<GetConnectorDefinitionOutput, GetConnectorDefinitionOutputError>) -> Void)
    {
        guard let connectorDefinitionId = input.connectorDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component connectorDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/connectors/\(connectorDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getConnectorDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetConnectorDefinitionInput, GetConnectorDefinitionOutput, GetConnectorDefinitionOutputError>(id: "getConnectorDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetConnectorDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetConnectorDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetConnectorDefinitionInput, GetConnectorDefinitionOutput, GetConnectorDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a connector definition version, including the connectors that the version contains. Connectors are prebuilt modules that interact with local infrastructure, device protocols, AWS, and other cloud services.
    public func getConnectorDefinitionVersion(input: GetConnectorDefinitionVersionInput, completion: @escaping (SdkResult<GetConnectorDefinitionVersionOutput, GetConnectorDefinitionVersionOutputError>) -> Void)
    {
        guard let connectorDefinitionId = input.connectorDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component connectorDefinitionId unexpectedly nil"))))
            return
        }
        guard let connectorDefinitionVersionId = input.connectorDefinitionVersionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component connectorDefinitionVersionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/connectors/\(connectorDefinitionId)/versions/\(connectorDefinitionVersionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getConnectorDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetConnectorDefinitionVersionInput, GetConnectorDefinitionVersionOutput, GetConnectorDefinitionVersionOutputError>(id: "getConnectorDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetConnectorDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetConnectorDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetConnectorDefinitionVersionInput, GetConnectorDefinitionVersionOutput, GetConnectorDefinitionVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a core definition version.
    public func getCoreDefinition(input: GetCoreDefinitionInput, completion: @escaping (SdkResult<GetCoreDefinitionOutput, GetCoreDefinitionOutputError>) -> Void)
    {
        guard let coreDefinitionId = input.coreDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component coreDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/cores/\(coreDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCoreDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCoreDefinitionInput, GetCoreDefinitionOutput, GetCoreDefinitionOutputError>(id: "getCoreDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCoreDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCoreDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCoreDefinitionInput, GetCoreDefinitionOutput, GetCoreDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a core definition version.
    public func getCoreDefinitionVersion(input: GetCoreDefinitionVersionInput, completion: @escaping (SdkResult<GetCoreDefinitionVersionOutput, GetCoreDefinitionVersionOutputError>) -> Void)
    {
        guard let coreDefinitionId = input.coreDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component coreDefinitionId unexpectedly nil"))))
            return
        }
        guard let coreDefinitionVersionId = input.coreDefinitionVersionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component coreDefinitionVersionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/cores/\(coreDefinitionId)/versions/\(coreDefinitionVersionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCoreDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCoreDefinitionVersionInput, GetCoreDefinitionVersionOutput, GetCoreDefinitionVersionOutputError>(id: "getCoreDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCoreDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCoreDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCoreDefinitionVersionInput, GetCoreDefinitionVersionOutput, GetCoreDefinitionVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns the status of a deployment.
    public func getDeploymentStatus(input: GetDeploymentStatusInput, completion: @escaping (SdkResult<GetDeploymentStatusOutput, GetDeploymentStatusOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        guard let deploymentId = input.deploymentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component deploymentId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/deployments/\(deploymentId)/status"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDeploymentStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDeploymentStatusInput, GetDeploymentStatusOutput, GetDeploymentStatusOutputError>(id: "getDeploymentStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDeploymentStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDeploymentStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDeploymentStatusInput, GetDeploymentStatusOutput, GetDeploymentStatusOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a device definition.
    public func getDeviceDefinition(input: GetDeviceDefinitionInput, completion: @escaping (SdkResult<GetDeviceDefinitionOutput, GetDeviceDefinitionOutputError>) -> Void)
    {
        guard let deviceDefinitionId = input.deviceDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component deviceDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/devices/\(deviceDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDeviceDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDeviceDefinitionInput, GetDeviceDefinitionOutput, GetDeviceDefinitionOutputError>(id: "getDeviceDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDeviceDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDeviceDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDeviceDefinitionInput, GetDeviceDefinitionOutput, GetDeviceDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a device definition version.
    public func getDeviceDefinitionVersion(input: GetDeviceDefinitionVersionInput, completion: @escaping (SdkResult<GetDeviceDefinitionVersionOutput, GetDeviceDefinitionVersionOutputError>) -> Void)
    {
        guard let deviceDefinitionId = input.deviceDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component deviceDefinitionId unexpectedly nil"))))
            return
        }
        guard let deviceDefinitionVersionId = input.deviceDefinitionVersionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component deviceDefinitionVersionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/devices/\(deviceDefinitionId)/versions/\(deviceDefinitionVersionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDeviceDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDeviceDefinitionVersionInput, GetDeviceDefinitionVersionOutput, GetDeviceDefinitionVersionOutputError>(id: "getDeviceDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDeviceDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDeviceDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDeviceDefinitionVersionInput, GetDeviceDefinitionVersionOutput, GetDeviceDefinitionVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a Lambda function definition, including its creation time and latest version.
    public func getFunctionDefinition(input: GetFunctionDefinitionInput, completion: @escaping (SdkResult<GetFunctionDefinitionOutput, GetFunctionDefinitionOutputError>) -> Void)
    {
        guard let functionDefinitionId = input.functionDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component functionDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/functions/\(functionDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFunctionDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFunctionDefinitionInput, GetFunctionDefinitionOutput, GetFunctionDefinitionOutputError>(id: "getFunctionDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFunctionDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFunctionDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFunctionDefinitionInput, GetFunctionDefinitionOutput, GetFunctionDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a Lambda function definition version, including which Lambda functions are included in the version and their configurations.
    public func getFunctionDefinitionVersion(input: GetFunctionDefinitionVersionInput, completion: @escaping (SdkResult<GetFunctionDefinitionVersionOutput, GetFunctionDefinitionVersionOutputError>) -> Void)
    {
        guard let functionDefinitionId = input.functionDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component functionDefinitionId unexpectedly nil"))))
            return
        }
        guard let functionDefinitionVersionId = input.functionDefinitionVersionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component functionDefinitionVersionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/functions/\(functionDefinitionId)/versions/\(functionDefinitionVersionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFunctionDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFunctionDefinitionVersionInput, GetFunctionDefinitionVersionOutput, GetFunctionDefinitionVersionOutputError>(id: "getFunctionDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFunctionDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFunctionDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFunctionDefinitionVersionInput, GetFunctionDefinitionVersionOutput, GetFunctionDefinitionVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a group.
    public func getGroup(input: GetGroupInput, completion: @escaping (SdkResult<GetGroupOutput, GetGroupOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetGroupInput, GetGroupOutput, GetGroupOutputError>(id: "getGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetGroupInput, GetGroupOutput, GetGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retreives the CA associated with a group. Returns the public key of the CA.
    public func getGroupCertificateAuthority(input: GetGroupCertificateAuthorityInput, completion: @escaping (SdkResult<GetGroupCertificateAuthorityOutput, GetGroupCertificateAuthorityOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        guard let certificateAuthorityId = input.certificateAuthorityId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component certificateAuthorityId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/certificateauthorities/\(certificateAuthorityId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getGroupCertificateAuthority")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetGroupCertificateAuthorityInput, GetGroupCertificateAuthorityOutput, GetGroupCertificateAuthorityOutputError>(id: "getGroupCertificateAuthority")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetGroupCertificateAuthorityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetGroupCertificateAuthorityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetGroupCertificateAuthorityInput, GetGroupCertificateAuthorityOutput, GetGroupCertificateAuthorityOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves the current configuration for the CA used by the group.
    public func getGroupCertificateConfiguration(input: GetGroupCertificateConfigurationInput, completion: @escaping (SdkResult<GetGroupCertificateConfigurationOutput, GetGroupCertificateConfigurationOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/certificateauthorities/configuration/expiry"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getGroupCertificateConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetGroupCertificateConfigurationInput, GetGroupCertificateConfigurationOutput, GetGroupCertificateConfigurationOutputError>(id: "getGroupCertificateConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetGroupCertificateConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetGroupCertificateConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetGroupCertificateConfigurationInput, GetGroupCertificateConfigurationOutput, GetGroupCertificateConfigurationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a group version.
    public func getGroupVersion(input: GetGroupVersionInput, completion: @escaping (SdkResult<GetGroupVersionOutput, GetGroupVersionOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        guard let groupVersionId = input.groupVersionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupVersionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/versions/\(groupVersionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getGroupVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetGroupVersionInput, GetGroupVersionOutput, GetGroupVersionOutputError>(id: "getGroupVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetGroupVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetGroupVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetGroupVersionInput, GetGroupVersionOutput, GetGroupVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a logger definition.
    public func getLoggerDefinition(input: GetLoggerDefinitionInput, completion: @escaping (SdkResult<GetLoggerDefinitionOutput, GetLoggerDefinitionOutputError>) -> Void)
    {
        guard let loggerDefinitionId = input.loggerDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component loggerDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/loggers/\(loggerDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getLoggerDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetLoggerDefinitionInput, GetLoggerDefinitionOutput, GetLoggerDefinitionOutputError>(id: "getLoggerDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetLoggerDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetLoggerDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetLoggerDefinitionInput, GetLoggerDefinitionOutput, GetLoggerDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a logger definition version.
    public func getLoggerDefinitionVersion(input: GetLoggerDefinitionVersionInput, completion: @escaping (SdkResult<GetLoggerDefinitionVersionOutput, GetLoggerDefinitionVersionOutputError>) -> Void)
    {
        guard let loggerDefinitionId = input.loggerDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component loggerDefinitionId unexpectedly nil"))))
            return
        }
        guard let loggerDefinitionVersionId = input.loggerDefinitionVersionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component loggerDefinitionVersionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/loggers/\(loggerDefinitionId)/versions/\(loggerDefinitionVersionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getLoggerDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetLoggerDefinitionVersionInput, GetLoggerDefinitionVersionOutput, GetLoggerDefinitionVersionOutputError>(id: "getLoggerDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetLoggerDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetLoggerDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetLoggerDefinitionVersionInput, GetLoggerDefinitionVersionOutput, GetLoggerDefinitionVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a resource definition, including its creation time and latest version.
    public func getResourceDefinition(input: GetResourceDefinitionInput, completion: @escaping (SdkResult<GetResourceDefinitionOutput, GetResourceDefinitionOutputError>) -> Void)
    {
        guard let resourceDefinitionId = input.resourceDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/resources/\(resourceDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getResourceDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetResourceDefinitionInput, GetResourceDefinitionOutput, GetResourceDefinitionOutputError>(id: "getResourceDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetResourceDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetResourceDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetResourceDefinitionInput, GetResourceDefinitionOutput, GetResourceDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a resource definition version, including which resources are included in the version.
    public func getResourceDefinitionVersion(input: GetResourceDefinitionVersionInput, completion: @escaping (SdkResult<GetResourceDefinitionVersionOutput, GetResourceDefinitionVersionOutputError>) -> Void)
    {
        guard let resourceDefinitionId = input.resourceDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceDefinitionId unexpectedly nil"))))
            return
        }
        guard let resourceDefinitionVersionId = input.resourceDefinitionVersionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceDefinitionVersionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/resources/\(resourceDefinitionId)/versions/\(resourceDefinitionVersionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getResourceDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetResourceDefinitionVersionInput, GetResourceDefinitionVersionOutput, GetResourceDefinitionVersionOutputError>(id: "getResourceDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetResourceDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetResourceDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetResourceDefinitionVersionInput, GetResourceDefinitionVersionOutput, GetResourceDefinitionVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves the service role that is attached to your account.
    public func getServiceRoleForAccount(input: GetServiceRoleForAccountInput, completion: @escaping (SdkResult<GetServiceRoleForAccountOutput, GetServiceRoleForAccountOutputError>) -> Void)
    {
        let urlPath = "/greengrass/servicerole"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getServiceRoleForAccount")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetServiceRoleForAccountInput, GetServiceRoleForAccountOutput, GetServiceRoleForAccountOutputError>(id: "getServiceRoleForAccount")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetServiceRoleForAccountInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetServiceRoleForAccountInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetServiceRoleForAccountInput, GetServiceRoleForAccountOutput, GetServiceRoleForAccountOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a subscription definition.
    public func getSubscriptionDefinition(input: GetSubscriptionDefinitionInput, completion: @escaping (SdkResult<GetSubscriptionDefinitionOutput, GetSubscriptionDefinitionOutputError>) -> Void)
    {
        guard let subscriptionDefinitionId = input.subscriptionDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component subscriptionDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/subscriptions/\(subscriptionDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSubscriptionDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSubscriptionDefinitionInput, GetSubscriptionDefinitionOutput, GetSubscriptionDefinitionOutputError>(id: "getSubscriptionDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSubscriptionDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSubscriptionDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetSubscriptionDefinitionInput, GetSubscriptionDefinitionOutput, GetSubscriptionDefinitionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a subscription definition version.
    public func getSubscriptionDefinitionVersion(input: GetSubscriptionDefinitionVersionInput, completion: @escaping (SdkResult<GetSubscriptionDefinitionVersionOutput, GetSubscriptionDefinitionVersionOutputError>) -> Void)
    {
        guard let subscriptionDefinitionId = input.subscriptionDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component subscriptionDefinitionId unexpectedly nil"))))
            return
        }
        guard let subscriptionDefinitionVersionId = input.subscriptionDefinitionVersionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component subscriptionDefinitionVersionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/subscriptions/\(subscriptionDefinitionId)/versions/\(subscriptionDefinitionVersionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSubscriptionDefinitionVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSubscriptionDefinitionVersionInput, GetSubscriptionDefinitionVersionOutput, GetSubscriptionDefinitionVersionOutputError>(id: "getSubscriptionDefinitionVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSubscriptionDefinitionVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSubscriptionDefinitionVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetSubscriptionDefinitionVersionInput, GetSubscriptionDefinitionVersionOutput, GetSubscriptionDefinitionVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Get the runtime configuration of a thing.
    public func getThingRuntimeConfiguration(input: GetThingRuntimeConfigurationInput, completion: @escaping (SdkResult<GetThingRuntimeConfigurationOutput, GetThingRuntimeConfigurationOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/things/\(thingName)/runtimeconfig"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getThingRuntimeConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetThingRuntimeConfigurationInput, GetThingRuntimeConfigurationOutput, GetThingRuntimeConfigurationOutputError>(id: "getThingRuntimeConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetThingRuntimeConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetThingRuntimeConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetThingRuntimeConfigurationInput, GetThingRuntimeConfigurationOutput, GetThingRuntimeConfigurationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets a paginated list of the deployments that have been started in a bulk deployment operation, and their current deployment status.
    public func listBulkDeploymentDetailedReports(input: ListBulkDeploymentDetailedReportsInput, completion: @escaping (SdkResult<ListBulkDeploymentDetailedReportsOutput, ListBulkDeploymentDetailedReportsOutputError>) -> Void)
    {
        guard let bulkDeploymentId = input.bulkDeploymentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component bulkDeploymentId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/bulk/deployments/\(bulkDeploymentId)/detailed-reports"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listBulkDeploymentDetailedReports")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListBulkDeploymentDetailedReportsInput, ListBulkDeploymentDetailedReportsOutput, ListBulkDeploymentDetailedReportsOutputError>(id: "listBulkDeploymentDetailedReports")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListBulkDeploymentDetailedReportsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListBulkDeploymentDetailedReportsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListBulkDeploymentDetailedReportsInput, ListBulkDeploymentDetailedReportsOutput, ListBulkDeploymentDetailedReportsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns a list of bulk deployments.
    public func listBulkDeployments(input: ListBulkDeploymentsInput, completion: @escaping (SdkResult<ListBulkDeploymentsOutput, ListBulkDeploymentsOutputError>) -> Void)
    {
        let urlPath = "/greengrass/bulk/deployments"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listBulkDeployments")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListBulkDeploymentsInput, ListBulkDeploymentsOutput, ListBulkDeploymentsOutputError>(id: "listBulkDeployments")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListBulkDeploymentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListBulkDeploymentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListBulkDeploymentsInput, ListBulkDeploymentsOutput, ListBulkDeploymentsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists the versions of a connector definition, which are containers for connectors. Connectors run on the Greengrass core and contain built-in integration with local infrastructure, device protocols, AWS, and other cloud services.
    public func listConnectorDefinitionVersions(input: ListConnectorDefinitionVersionsInput, completion: @escaping (SdkResult<ListConnectorDefinitionVersionsOutput, ListConnectorDefinitionVersionsOutputError>) -> Void)
    {
        guard let connectorDefinitionId = input.connectorDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component connectorDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/connectors/\(connectorDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listConnectorDefinitionVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListConnectorDefinitionVersionsInput, ListConnectorDefinitionVersionsOutput, ListConnectorDefinitionVersionsOutputError>(id: "listConnectorDefinitionVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListConnectorDefinitionVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListConnectorDefinitionVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListConnectorDefinitionVersionsInput, ListConnectorDefinitionVersionsOutput, ListConnectorDefinitionVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of connector definitions.
    public func listConnectorDefinitions(input: ListConnectorDefinitionsInput, completion: @escaping (SdkResult<ListConnectorDefinitionsOutput, ListConnectorDefinitionsOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/connectors"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listConnectorDefinitions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListConnectorDefinitionsInput, ListConnectorDefinitionsOutput, ListConnectorDefinitionsOutputError>(id: "listConnectorDefinitions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListConnectorDefinitionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListConnectorDefinitionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListConnectorDefinitionsInput, ListConnectorDefinitionsOutput, ListConnectorDefinitionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists the versions of a core definition.
    public func listCoreDefinitionVersions(input: ListCoreDefinitionVersionsInput, completion: @escaping (SdkResult<ListCoreDefinitionVersionsOutput, ListCoreDefinitionVersionsOutputError>) -> Void)
    {
        guard let coreDefinitionId = input.coreDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component coreDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/cores/\(coreDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listCoreDefinitionVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListCoreDefinitionVersionsInput, ListCoreDefinitionVersionsOutput, ListCoreDefinitionVersionsOutputError>(id: "listCoreDefinitionVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListCoreDefinitionVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListCoreDefinitionVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListCoreDefinitionVersionsInput, ListCoreDefinitionVersionsOutput, ListCoreDefinitionVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of core definitions.
    public func listCoreDefinitions(input: ListCoreDefinitionsInput, completion: @escaping (SdkResult<ListCoreDefinitionsOutput, ListCoreDefinitionsOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/cores"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listCoreDefinitions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListCoreDefinitionsInput, ListCoreDefinitionsOutput, ListCoreDefinitionsOutputError>(id: "listCoreDefinitions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListCoreDefinitionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListCoreDefinitionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListCoreDefinitionsInput, ListCoreDefinitionsOutput, ListCoreDefinitionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns a history of deployments for the group.
    public func listDeployments(input: ListDeploymentsInput, completion: @escaping (SdkResult<ListDeploymentsOutput, ListDeploymentsOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/deployments"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDeployments")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDeploymentsInput, ListDeploymentsOutput, ListDeploymentsOutputError>(id: "listDeployments")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDeploymentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDeploymentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDeploymentsInput, ListDeploymentsOutput, ListDeploymentsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists the versions of a device definition.
    public func listDeviceDefinitionVersions(input: ListDeviceDefinitionVersionsInput, completion: @escaping (SdkResult<ListDeviceDefinitionVersionsOutput, ListDeviceDefinitionVersionsOutputError>) -> Void)
    {
        guard let deviceDefinitionId = input.deviceDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component deviceDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/devices/\(deviceDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDeviceDefinitionVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDeviceDefinitionVersionsInput, ListDeviceDefinitionVersionsOutput, ListDeviceDefinitionVersionsOutputError>(id: "listDeviceDefinitionVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDeviceDefinitionVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDeviceDefinitionVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDeviceDefinitionVersionsInput, ListDeviceDefinitionVersionsOutput, ListDeviceDefinitionVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of device definitions.
    public func listDeviceDefinitions(input: ListDeviceDefinitionsInput, completion: @escaping (SdkResult<ListDeviceDefinitionsOutput, ListDeviceDefinitionsOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/devices"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDeviceDefinitions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDeviceDefinitionsInput, ListDeviceDefinitionsOutput, ListDeviceDefinitionsOutputError>(id: "listDeviceDefinitions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDeviceDefinitionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDeviceDefinitionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDeviceDefinitionsInput, ListDeviceDefinitionsOutput, ListDeviceDefinitionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists the versions of a Lambda function definition.
    public func listFunctionDefinitionVersions(input: ListFunctionDefinitionVersionsInput, completion: @escaping (SdkResult<ListFunctionDefinitionVersionsOutput, ListFunctionDefinitionVersionsOutputError>) -> Void)
    {
        guard let functionDefinitionId = input.functionDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component functionDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/functions/\(functionDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listFunctionDefinitionVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListFunctionDefinitionVersionsInput, ListFunctionDefinitionVersionsOutput, ListFunctionDefinitionVersionsOutputError>(id: "listFunctionDefinitionVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListFunctionDefinitionVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListFunctionDefinitionVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListFunctionDefinitionVersionsInput, ListFunctionDefinitionVersionsOutput, ListFunctionDefinitionVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of Lambda function definitions.
    public func listFunctionDefinitions(input: ListFunctionDefinitionsInput, completion: @escaping (SdkResult<ListFunctionDefinitionsOutput, ListFunctionDefinitionsOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/functions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listFunctionDefinitions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListFunctionDefinitionsInput, ListFunctionDefinitionsOutput, ListFunctionDefinitionsOutputError>(id: "listFunctionDefinitions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListFunctionDefinitionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListFunctionDefinitionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListFunctionDefinitionsInput, ListFunctionDefinitionsOutput, ListFunctionDefinitionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves the current CAs for a group.
    public func listGroupCertificateAuthorities(input: ListGroupCertificateAuthoritiesInput, completion: @escaping (SdkResult<ListGroupCertificateAuthoritiesOutput, ListGroupCertificateAuthoritiesOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/certificateauthorities"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listGroupCertificateAuthorities")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListGroupCertificateAuthoritiesInput, ListGroupCertificateAuthoritiesOutput, ListGroupCertificateAuthoritiesOutputError>(id: "listGroupCertificateAuthorities")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListGroupCertificateAuthoritiesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListGroupCertificateAuthoritiesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListGroupCertificateAuthoritiesInput, ListGroupCertificateAuthoritiesOutput, ListGroupCertificateAuthoritiesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists the versions of a group.
    public func listGroupVersions(input: ListGroupVersionsInput, completion: @escaping (SdkResult<ListGroupVersionsOutput, ListGroupVersionsOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listGroupVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListGroupVersionsInput, ListGroupVersionsOutput, ListGroupVersionsOutputError>(id: "listGroupVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListGroupVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListGroupVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListGroupVersionsInput, ListGroupVersionsOutput, ListGroupVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of groups.
    public func listGroups(input: ListGroupsInput, completion: @escaping (SdkResult<ListGroupsOutput, ListGroupsOutputError>) -> Void)
    {
        let urlPath = "/greengrass/groups"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListGroupsInput, ListGroupsOutput, ListGroupsOutputError>(id: "listGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListGroupsInput, ListGroupsOutput, ListGroupsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists the versions of a logger definition.
    public func listLoggerDefinitionVersions(input: ListLoggerDefinitionVersionsInput, completion: @escaping (SdkResult<ListLoggerDefinitionVersionsOutput, ListLoggerDefinitionVersionsOutputError>) -> Void)
    {
        guard let loggerDefinitionId = input.loggerDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component loggerDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/loggers/\(loggerDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listLoggerDefinitionVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListLoggerDefinitionVersionsInput, ListLoggerDefinitionVersionsOutput, ListLoggerDefinitionVersionsOutputError>(id: "listLoggerDefinitionVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListLoggerDefinitionVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListLoggerDefinitionVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListLoggerDefinitionVersionsInput, ListLoggerDefinitionVersionsOutput, ListLoggerDefinitionVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of logger definitions.
    public func listLoggerDefinitions(input: ListLoggerDefinitionsInput, completion: @escaping (SdkResult<ListLoggerDefinitionsOutput, ListLoggerDefinitionsOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/loggers"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listLoggerDefinitions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListLoggerDefinitionsInput, ListLoggerDefinitionsOutput, ListLoggerDefinitionsOutputError>(id: "listLoggerDefinitions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListLoggerDefinitionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListLoggerDefinitionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListLoggerDefinitionsInput, ListLoggerDefinitionsOutput, ListLoggerDefinitionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists the versions of a resource definition.
    public func listResourceDefinitionVersions(input: ListResourceDefinitionVersionsInput, completion: @escaping (SdkResult<ListResourceDefinitionVersionsOutput, ListResourceDefinitionVersionsOutputError>) -> Void)
    {
        guard let resourceDefinitionId = input.resourceDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/resources/\(resourceDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listResourceDefinitionVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListResourceDefinitionVersionsInput, ListResourceDefinitionVersionsOutput, ListResourceDefinitionVersionsOutputError>(id: "listResourceDefinitionVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListResourceDefinitionVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListResourceDefinitionVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListResourceDefinitionVersionsInput, ListResourceDefinitionVersionsOutput, ListResourceDefinitionVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of resource definitions.
    public func listResourceDefinitions(input: ListResourceDefinitionsInput, completion: @escaping (SdkResult<ListResourceDefinitionsOutput, ListResourceDefinitionsOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/resources"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listResourceDefinitions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListResourceDefinitionsInput, ListResourceDefinitionsOutput, ListResourceDefinitionsOutputError>(id: "listResourceDefinitions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListResourceDefinitionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListResourceDefinitionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListResourceDefinitionsInput, ListResourceDefinitionsOutput, ListResourceDefinitionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists the versions of a subscription definition.
    public func listSubscriptionDefinitionVersions(input: ListSubscriptionDefinitionVersionsInput, completion: @escaping (SdkResult<ListSubscriptionDefinitionVersionsOutput, ListSubscriptionDefinitionVersionsOutputError>) -> Void)
    {
        guard let subscriptionDefinitionId = input.subscriptionDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component subscriptionDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/subscriptions/\(subscriptionDefinitionId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSubscriptionDefinitionVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSubscriptionDefinitionVersionsInput, ListSubscriptionDefinitionVersionsOutput, ListSubscriptionDefinitionVersionsOutputError>(id: "listSubscriptionDefinitionVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSubscriptionDefinitionVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSubscriptionDefinitionVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSubscriptionDefinitionVersionsInput, ListSubscriptionDefinitionVersionsOutput, ListSubscriptionDefinitionVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of subscription definitions.
    public func listSubscriptionDefinitions(input: ListSubscriptionDefinitionsInput, completion: @escaping (SdkResult<ListSubscriptionDefinitionsOutput, ListSubscriptionDefinitionsOutputError>) -> Void)
    {
        let urlPath = "/greengrass/definition/subscriptions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSubscriptionDefinitions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSubscriptionDefinitionsInput, ListSubscriptionDefinitionsOutput, ListSubscriptionDefinitionsOutputError>(id: "listSubscriptionDefinitions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSubscriptionDefinitionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSubscriptionDefinitionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSubscriptionDefinitionsInput, ListSubscriptionDefinitionsOutput, ListSubscriptionDefinitionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of resource tags for a resource arn.
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutput, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Resets a group's deployments.
    public func resetDeployments(input: ResetDeploymentsInput, completion: @escaping (SdkResult<ResetDeploymentsOutput, ResetDeploymentsOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/deployments/$reset"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "resetDeployments")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ResetDeploymentsInput, ResetDeploymentsOutput, ResetDeploymentsOutputError>(id: "resetDeployments")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ResetDeploymentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ResetDeploymentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ResetDeploymentsInput, ResetDeploymentsOutput, ResetDeploymentsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ResetDeploymentsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deploys multiple groups in one operation. This action starts the bulk deployment of a specified set of group versions. Each group version deployment will be triggered with an adaptive rate that has a fixed upper limit. We recommend that you include an ''X-Amzn-Client-Token'' token in every ''StartBulkDeployment'' request. These requests are idempotent with respect to the token and the request parameters.
    public func startBulkDeployment(input: StartBulkDeploymentInput, completion: @escaping (SdkResult<StartBulkDeploymentOutput, StartBulkDeploymentOutputError>) -> Void)
    {
        let urlPath = "/greengrass/bulk/deployments"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startBulkDeployment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartBulkDeploymentInput, StartBulkDeploymentOutput, StartBulkDeploymentOutputError>(id: "startBulkDeployment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartBulkDeploymentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartBulkDeploymentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartBulkDeploymentInput, StartBulkDeploymentOutput, StartBulkDeploymentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartBulkDeploymentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Stops the execution of a bulk deployment. This action returns a status of ''Stopping'' until the deployment is stopped. You cannot start a new bulk deployment while a previous deployment is in the ''Stopping'' state. This action doesn't rollback completed deployments or cancel pending deployments.
    public func stopBulkDeployment(input: StopBulkDeploymentInput, completion: @escaping (SdkResult<StopBulkDeploymentOutput, StopBulkDeploymentOutputError>) -> Void)
    {
        guard let bulkDeploymentId = input.bulkDeploymentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component bulkDeploymentId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/bulk/deployments/\(bulkDeploymentId)/$stop"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "stopBulkDeployment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StopBulkDeploymentInput, StopBulkDeploymentOutput, StopBulkDeploymentOutputError>(id: "stopBulkDeployment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StopBulkDeploymentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StopBulkDeploymentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StopBulkDeploymentInput, StopBulkDeploymentOutput, StopBulkDeploymentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Adds tags to a Greengrass resource. Valid resources are 'Group', 'ConnectorDefinition', 'CoreDefinition', 'DeviceDefinition', 'FunctionDefinition', 'LoggerDefinition', 'SubscriptionDefinition', 'ResourceDefinition', and 'BulkDeployment'.
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutput, TagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutput, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutput, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Remove resource tags from a Greengrass Resource.
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutput, UntagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates the connectivity information for the core. Any devices that belong to the group which has this core will receive this information in order to find the location of the core and connect to it.
    public func updateConnectivityInfo(input: UpdateConnectivityInfoInput, completion: @escaping (SdkResult<UpdateConnectivityInfoOutput, UpdateConnectivityInfoOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/things/\(thingName)/connectivityInfo"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateConnectivityInfo")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateConnectivityInfoInput, UpdateConnectivityInfoOutput, UpdateConnectivityInfoOutputError>(id: "updateConnectivityInfo")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateConnectivityInfoInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateConnectivityInfoInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateConnectivityInfoInput, UpdateConnectivityInfoOutput, UpdateConnectivityInfoOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateConnectivityInfoInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a connector definition.
    public func updateConnectorDefinition(input: UpdateConnectorDefinitionInput, completion: @escaping (SdkResult<UpdateConnectorDefinitionOutput, UpdateConnectorDefinitionOutputError>) -> Void)
    {
        guard let connectorDefinitionId = input.connectorDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component connectorDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/connectors/\(connectorDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateConnectorDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateConnectorDefinitionInput, UpdateConnectorDefinitionOutput, UpdateConnectorDefinitionOutputError>(id: "updateConnectorDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateConnectorDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateConnectorDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateConnectorDefinitionInput, UpdateConnectorDefinitionOutput, UpdateConnectorDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateConnectorDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a core definition.
    public func updateCoreDefinition(input: UpdateCoreDefinitionInput, completion: @escaping (SdkResult<UpdateCoreDefinitionOutput, UpdateCoreDefinitionOutputError>) -> Void)
    {
        guard let coreDefinitionId = input.coreDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component coreDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/cores/\(coreDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateCoreDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateCoreDefinitionInput, UpdateCoreDefinitionOutput, UpdateCoreDefinitionOutputError>(id: "updateCoreDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateCoreDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateCoreDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateCoreDefinitionInput, UpdateCoreDefinitionOutput, UpdateCoreDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateCoreDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a device definition.
    public func updateDeviceDefinition(input: UpdateDeviceDefinitionInput, completion: @escaping (SdkResult<UpdateDeviceDefinitionOutput, UpdateDeviceDefinitionOutputError>) -> Void)
    {
        guard let deviceDefinitionId = input.deviceDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component deviceDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/devices/\(deviceDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDeviceDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDeviceDefinitionInput, UpdateDeviceDefinitionOutput, UpdateDeviceDefinitionOutputError>(id: "updateDeviceDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDeviceDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDeviceDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateDeviceDefinitionInput, UpdateDeviceDefinitionOutput, UpdateDeviceDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDeviceDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a Lambda function definition.
    public func updateFunctionDefinition(input: UpdateFunctionDefinitionInput, completion: @escaping (SdkResult<UpdateFunctionDefinitionOutput, UpdateFunctionDefinitionOutputError>) -> Void)
    {
        guard let functionDefinitionId = input.functionDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component functionDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/functions/\(functionDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateFunctionDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateFunctionDefinitionInput, UpdateFunctionDefinitionOutput, UpdateFunctionDefinitionOutputError>(id: "updateFunctionDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateFunctionDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateFunctionDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateFunctionDefinitionInput, UpdateFunctionDefinitionOutput, UpdateFunctionDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateFunctionDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a group.
    public func updateGroup(input: UpdateGroupInput, completion: @escaping (SdkResult<UpdateGroupOutput, UpdateGroupOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateGroupInput, UpdateGroupOutput, UpdateGroupOutputError>(id: "updateGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateGroupInput, UpdateGroupOutput, UpdateGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates the Certificate expiry time for a group.
    public func updateGroupCertificateConfiguration(input: UpdateGroupCertificateConfigurationInput, completion: @escaping (SdkResult<UpdateGroupCertificateConfigurationOutput, UpdateGroupCertificateConfigurationOutputError>) -> Void)
    {
        guard let groupId = input.groupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component groupId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/groups/\(groupId)/certificateauthorities/configuration/expiry"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateGroupCertificateConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateGroupCertificateConfigurationInput, UpdateGroupCertificateConfigurationOutput, UpdateGroupCertificateConfigurationOutputError>(id: "updateGroupCertificateConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateGroupCertificateConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateGroupCertificateConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateGroupCertificateConfigurationInput, UpdateGroupCertificateConfigurationOutput, UpdateGroupCertificateConfigurationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateGroupCertificateConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a logger definition.
    public func updateLoggerDefinition(input: UpdateLoggerDefinitionInput, completion: @escaping (SdkResult<UpdateLoggerDefinitionOutput, UpdateLoggerDefinitionOutputError>) -> Void)
    {
        guard let loggerDefinitionId = input.loggerDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component loggerDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/loggers/\(loggerDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateLoggerDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateLoggerDefinitionInput, UpdateLoggerDefinitionOutput, UpdateLoggerDefinitionOutputError>(id: "updateLoggerDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateLoggerDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateLoggerDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateLoggerDefinitionInput, UpdateLoggerDefinitionOutput, UpdateLoggerDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateLoggerDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a resource definition.
    public func updateResourceDefinition(input: UpdateResourceDefinitionInput, completion: @escaping (SdkResult<UpdateResourceDefinitionOutput, UpdateResourceDefinitionOutputError>) -> Void)
    {
        guard let resourceDefinitionId = input.resourceDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/resources/\(resourceDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateResourceDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateResourceDefinitionInput, UpdateResourceDefinitionOutput, UpdateResourceDefinitionOutputError>(id: "updateResourceDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateResourceDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateResourceDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateResourceDefinitionInput, UpdateResourceDefinitionOutput, UpdateResourceDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateResourceDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a subscription definition.
    public func updateSubscriptionDefinition(input: UpdateSubscriptionDefinitionInput, completion: @escaping (SdkResult<UpdateSubscriptionDefinitionOutput, UpdateSubscriptionDefinitionOutputError>) -> Void)
    {
        guard let subscriptionDefinitionId = input.subscriptionDefinitionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component subscriptionDefinitionId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/definition/subscriptions/\(subscriptionDefinitionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateSubscriptionDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateSubscriptionDefinitionInput, UpdateSubscriptionDefinitionOutput, UpdateSubscriptionDefinitionOutputError>(id: "updateSubscriptionDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateSubscriptionDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateSubscriptionDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateSubscriptionDefinitionInput, UpdateSubscriptionDefinitionOutput, UpdateSubscriptionDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateSubscriptionDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates the runtime configuration of a thing.
    public func updateThingRuntimeConfiguration(input: UpdateThingRuntimeConfigurationInput, completion: @escaping (SdkResult<UpdateThingRuntimeConfigurationOutput, UpdateThingRuntimeConfigurationOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/things/\(thingName)/runtimeconfig"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateThingRuntimeConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateThingRuntimeConfigurationInput, UpdateThingRuntimeConfigurationOutput, UpdateThingRuntimeConfigurationOutputError>(id: "updateThingRuntimeConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateThingRuntimeConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateThingRuntimeConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateThingRuntimeConfigurationInput, UpdateThingRuntimeConfigurationOutput, UpdateThingRuntimeConfigurationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateThingRuntimeConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
