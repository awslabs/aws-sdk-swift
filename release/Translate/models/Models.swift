// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AppliedTerminology: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case terms = "Terms"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let terms = terms {
            var termsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terms)
            for termlist0 in terms {
                try termsContainer.encode(termlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let termsContainer = try containerValues.decodeIfPresent([Term?].self, forKey: .terms)
        var termsDecoded0:[Term]? = nil
        if let termsContainer = termsContainer {
            termsDecoded0 = [Term]()
            for structure0 in termsContainer {
                if let structure0 = structure0 {
                    termsDecoded0?.append(structure0)
                }
            }
        }
        terms = termsDecoded0
    }
}

extension AppliedTerminology: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AppliedTerminology(name: \(String(describing: name)), terms: \(String(describing: terms)))"}
}

/// <p>The custom terminology applied to the input text by Amazon Translate for the translated text
///       response. This is optional in the response and will only be present if you specified
///       terminology input in the request. Currently, only one terminology can be applied per
///       TranslateText request.</p>
public struct AppliedTerminology: Equatable {
    /// <p>The name of the custom terminology applied to the input text by Amazon Translate for the translated
    ///       text response.</p>
    public let name: String?
    /// <p>The specific terms of the custom terminology applied to the input text by Amazon Translate for the
    ///       translated text response. A maximum of 250 terms will be returned, and the specific terms
    ///       applied will be the first 250 terms in the source text. </p>
    public let terms: [Term]?

    public init (
        name: String? = nil,
        terms: [Term]? = nil
    )
    {
        self.name = name
        self.terms = terms
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Another modification is being made. That modification must complete before you can make
///       your change.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was a conflict processing the request. Try your request again.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateParallelDataInputBodyMiddleware: Middleware {
    public let id: String = "CreateParallelDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateParallelDataInput>
    public typealias MOutput = OperationOutput<CreateParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateParallelDataOutputError>
}

extension CreateParallelDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateParallelDataInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), encryptionKey: \(String(describing: encryptionKey)), name: \(String(describing: name)), parallelDataConfig: \(String(describing: parallelDataConfig)))"}
}

extension CreateParallelDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case name = "Name"
        case parallelDataConfig = "ParallelDataConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parallelDataConfig = parallelDataConfig {
            try encodeContainer.encode(parallelDataConfig, forKey: .parallelDataConfig)
        }
    }
}

public struct CreateParallelDataInputHeadersMiddleware: Middleware {
    public let id: String = "CreateParallelDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateParallelDataInput>
    public typealias MOutput = OperationOutput<CreateParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateParallelDataOutputError>
}

public struct CreateParallelDataInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateParallelDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateParallelDataInput>
    public typealias MOutput = OperationOutput<CreateParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateParallelDataOutputError>
}

public struct CreateParallelDataInput: Equatable {
    /// <p>A unique identifier for the request. This token is automatically generated when you use
    ///       Amazon Translate through an AWS SDK.</p>
    public var clientToken: String?
    /// <p>A custom description for the parallel data resource in Amazon Translate.</p>
    public let description: String?
    /// <p>The encryption key used to encrypt this object.</p>
    public let encryptionKey: EncryptionKey?
    /// <p>A custom name for the parallel data resource in Amazon Translate. You must assign a name
    ///       that is unique in the account and region.</p>
    public let name: String?
    /// <p>Specifies the format and S3 location of the parallel data input file.</p>
    public let parallelDataConfig: ParallelDataConfig?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        encryptionKey: EncryptionKey? = nil,
        name: String? = nil,
        parallelDataConfig: ParallelDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.encryptionKey = encryptionKey
        self.name = name
        self.parallelDataConfig = parallelDataConfig
    }
}

struct CreateParallelDataInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let parallelDataConfig: ParallelDataConfig?
    public let encryptionKey: EncryptionKey?
    public let clientToken: String?
}

extension CreateParallelDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case name = "Name"
        case parallelDataConfig = "ParallelDataConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parallelDataConfigDecoded = try containerValues.decodeIfPresent(ParallelDataConfig.self, forKey: .parallelDataConfig)
        parallelDataConfig = parallelDataConfigDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateParallelDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateParallelDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateParallelDataOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateParallelDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateParallelDataOutputResponse(name: \(String(describing: name)), status: \(String(describing: status)))"}
}

extension CreateParallelDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateParallelDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
            self.status = output.status
        } else {
            self.name = nil
            self.status = nil
        }
    }
}

public struct CreateParallelDataOutputResponse: Equatable {
    /// <p>The custom name that you assigned to the parallel data resource.</p>
    public let name: String?
    /// <p>The status of the parallel data resource. When the resource is ready for you to use, the
    ///       status is <code>ACTIVE</code>.</p>
    public let status: ParallelDataStatus?

    public init (
        name: String? = nil,
        status: ParallelDataStatus? = nil
    )
    {
        self.name = name
        self.status = status
    }
}

struct CreateParallelDataOutputResponseBody: Equatable {
    public let name: String?
    public let status: ParallelDataStatus?
}

extension CreateParallelDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ParallelDataStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteParallelDataInputBodyMiddleware: Middleware {
    public let id: String = "DeleteParallelDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteParallelDataInput>
    public typealias MOutput = OperationOutput<DeleteParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteParallelDataOutputError>
}

extension DeleteParallelDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteParallelDataInput(name: \(String(describing: name)))"}
}

extension DeleteParallelDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteParallelDataInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteParallelDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteParallelDataInput>
    public typealias MOutput = OperationOutput<DeleteParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteParallelDataOutputError>
}

public struct DeleteParallelDataInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteParallelDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteParallelDataInput>
    public typealias MOutput = OperationOutput<DeleteParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteParallelDataOutputError>
}

public struct DeleteParallelDataInput: Equatable {
    /// <p>The name of the parallel data resource that is being deleted.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteParallelDataInputBody: Equatable {
    public let name: String?
}

extension DeleteParallelDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteParallelDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteParallelDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteParallelDataOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteParallelDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteParallelDataOutputResponse(name: \(String(describing: name)), status: \(String(describing: status)))"}
}

extension DeleteParallelDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteParallelDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
            self.status = output.status
        } else {
            self.name = nil
            self.status = nil
        }
    }
}

public struct DeleteParallelDataOutputResponse: Equatable {
    /// <p>The name of the parallel data resource that is being deleted.</p>
    public let name: String?
    /// <p>The status of the parallel data deletion.</p>
    public let status: ParallelDataStatus?

    public init (
        name: String? = nil,
        status: ParallelDataStatus? = nil
    )
    {
        self.name = name
        self.status = status
    }
}

struct DeleteParallelDataOutputResponseBody: Equatable {
    public let name: String?
    public let status: ParallelDataStatus?
}

extension DeleteParallelDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ParallelDataStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteTerminologyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTerminologyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTerminologyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTerminologyInput>
    public typealias MOutput = OperationOutput<DeleteTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTerminologyOutputError>
}

extension DeleteTerminologyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTerminologyInput(name: \(String(describing: name)))"}
}

extension DeleteTerminologyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteTerminologyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTerminologyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTerminologyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTerminologyInput>
    public typealias MOutput = OperationOutput<DeleteTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTerminologyOutputError>
}

public struct DeleteTerminologyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTerminologyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTerminologyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTerminologyInput>
    public typealias MOutput = OperationOutput<DeleteTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTerminologyOutputError>
}

public struct DeleteTerminologyInput: Equatable {
    /// <p>The name of the custom terminology being deleted. </p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteTerminologyInputBody: Equatable {
    public let name: String?
}

extension DeleteTerminologyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteTerminologyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTerminologyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTerminologyOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTerminologyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTerminologyOutputResponse()"}
}

extension DeleteTerminologyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTerminologyOutputResponse: Equatable {

    public init() {}
}

struct DeleteTerminologyOutputResponseBody: Equatable {
}

extension DeleteTerminologyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeTextTranslationJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTextTranslationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTextTranslationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTextTranslationJobInput>
    public typealias MOutput = OperationOutput<DescribeTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTextTranslationJobOutputError>
}

extension DescribeTextTranslationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTextTranslationJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeTextTranslationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeTextTranslationJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTextTranslationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTextTranslationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTextTranslationJobInput>
    public typealias MOutput = OperationOutput<DescribeTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTextTranslationJobOutputError>
}

public struct DescribeTextTranslationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTextTranslationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTextTranslationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTextTranslationJobInput>
    public typealias MOutput = OperationOutput<DescribeTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTextTranslationJobOutputError>
}

public struct DescribeTextTranslationJobInput: Equatable {
    /// <p>The identifier that Amazon Translate generated for the job. The <a>StartTextTranslationJob</a> operation returns this identifier in its
    ///       response.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeTextTranslationJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeTextTranslationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeTextTranslationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTextTranslationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTextTranslationJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTextTranslationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTextTranslationJobOutputResponse(textTranslationJobProperties: \(String(describing: textTranslationJobProperties)))"}
}

extension DescribeTextTranslationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTextTranslationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.textTranslationJobProperties = output.textTranslationJobProperties
        } else {
            self.textTranslationJobProperties = nil
        }
    }
}

public struct DescribeTextTranslationJobOutputResponse: Equatable {
    /// <p>An object that contains the properties associated with an asynchronous batch translation
    ///       job.</p>
    public let textTranslationJobProperties: TextTranslationJobProperties?

    public init (
        textTranslationJobProperties: TextTranslationJobProperties? = nil
    )
    {
        self.textTranslationJobProperties = textTranslationJobProperties
    }
}

struct DescribeTextTranslationJobOutputResponseBody: Equatable {
    public let textTranslationJobProperties: TextTranslationJobProperties?
}

extension DescribeTextTranslationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case textTranslationJobProperties = "TextTranslationJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textTranslationJobPropertiesDecoded = try containerValues.decodeIfPresent(TextTranslationJobProperties.self, forKey: .textTranslationJobProperties)
        textTranslationJobProperties = textTranslationJobPropertiesDecoded
    }
}

extension DetectedLanguageLowConfidenceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectedLanguageLowConfidenceException(detectedLanguageCode: \(String(describing: detectedLanguageCode)), message: \(String(describing: message)))"}
}

extension DetectedLanguageLowConfidenceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectedLanguageLowConfidenceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detectedLanguageCode = output.detectedLanguageCode
            self.message = output.message
        } else {
            self.detectedLanguageCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The confidence that Amazon Comprehend accurately detected the source language is low. If a
///       low confidence level is acceptable for your application, you can use the language in the
///       exception to call Amazon Translate again. For more information, see the <a href="https://docs.aws.amazon.com/comprehend/latest/dg/API_DetectDominantLanguage.html">DetectDominantLanguage</a> operation in the <i>Amazon Comprehend Developer
///         Guide</i>. </p>
public struct DetectedLanguageLowConfidenceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The language code of the auto-detected language from Amazon Comprehend.</p>
    public var detectedLanguageCode: String?
    public var message: String?

    public init (
        detectedLanguageCode: String? = nil,
        message: String? = nil
    )
    {
        self.detectedLanguageCode = detectedLanguageCode
        self.message = message
    }
}

struct DetectedLanguageLowConfidenceExceptionBody: Equatable {
    public let message: String?
    public let detectedLanguageCode: String?
}

extension DetectedLanguageLowConfidenceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectedLanguageCode = "DetectedLanguageCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let detectedLanguageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectedLanguageCode)
        detectedLanguageCode = detectedLanguageCodeDecoded
    }
}

extension EncryptionKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EncryptionKeyType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension EncryptionKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionKey(id: \(String(describing: id)), type: \(String(describing: type)))"}
}

/// <p>The encryption key used to encrypt this object.</p>
public struct EncryptionKey: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the encryption key being used to encrypt the custom
    ///       terminology.</p>
    public let id: String?
    /// <p>The type of encryption key used by Amazon Translate to encrypt custom terminologies.</p>
    public let type: EncryptionKeyType?

    public init (
        id: String? = nil,
        type: EncryptionKeyType? = nil
    )
    {
        self.id = id
        self.type = type
    }
}

public enum EncryptionKeyType {
    case kms
    case sdkUnknown(String)
}

extension EncryptionKeyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionKeyType] {
        return [
            .kms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .kms: return "KMS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionKeyType(rawValue: rawValue) ?? EncryptionKeyType.sdkUnknown(rawValue)
    }
}

public struct GetParallelDataInputBodyMiddleware: Middleware {
    public let id: String = "GetParallelDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParallelDataInput>
    public typealias MOutput = OperationOutput<GetParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParallelDataOutputError>
}

extension GetParallelDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetParallelDataInput(name: \(String(describing: name)))"}
}

extension GetParallelDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetParallelDataInputHeadersMiddleware: Middleware {
    public let id: String = "GetParallelDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParallelDataInput>
    public typealias MOutput = OperationOutput<GetParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParallelDataOutputError>
}

public struct GetParallelDataInputQueryItemMiddleware: Middleware {
    public let id: String = "GetParallelDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParallelDataInput>
    public typealias MOutput = OperationOutput<GetParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParallelDataOutputError>
}

public struct GetParallelDataInput: Equatable {
    /// <p>The name of the parallel data resource that is being retrieved.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetParallelDataInputBody: Equatable {
    public let name: String?
}

extension GetParallelDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetParallelDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParallelDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParallelDataOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParallelDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetParallelDataOutputResponse(auxiliaryDataLocation: \(String(describing: auxiliaryDataLocation)), dataLocation: \(String(describing: dataLocation)), latestUpdateAttemptAuxiliaryDataLocation: \(String(describing: latestUpdateAttemptAuxiliaryDataLocation)), parallelDataProperties: \(String(describing: parallelDataProperties)))"}
}

extension GetParallelDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetParallelDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.auxiliaryDataLocation = output.auxiliaryDataLocation
            self.dataLocation = output.dataLocation
            self.latestUpdateAttemptAuxiliaryDataLocation = output.latestUpdateAttemptAuxiliaryDataLocation
            self.parallelDataProperties = output.parallelDataProperties
        } else {
            self.auxiliaryDataLocation = nil
            self.dataLocation = nil
            self.latestUpdateAttemptAuxiliaryDataLocation = nil
            self.parallelDataProperties = nil
        }
    }
}

public struct GetParallelDataOutputResponse: Equatable {
    /// <p>The Amazon S3 location of a file that provides any errors or warnings that were produced
    ///       by your input file. This file was created when Amazon Translate attempted to create a parallel
    ///       data resource. The location is returned as a presigned URL to that has a 30 minute
    ///       expiration.</p>
    public let auxiliaryDataLocation: ParallelDataDataLocation?
    /// <p>The location of the most recent parallel data input file that was successfully imported
    ///       into Amazon Translate. The location is returned as a presigned URL that has a 30 minute
    ///       expiration.</p>
    public let dataLocation: ParallelDataDataLocation?
    /// <p>The Amazon S3 location of a file that provides any errors or warnings that were produced
    ///       by your input file. This file was created when Amazon Translate attempted to update a parallel
    ///       data resource. The location is returned as a presigned URL to that has a 30 minute
    ///       expiration.</p>
    public let latestUpdateAttemptAuxiliaryDataLocation: ParallelDataDataLocation?
    /// <p>The properties of the parallel data resource that is being retrieved.</p>
    public let parallelDataProperties: ParallelDataProperties?

    public init (
        auxiliaryDataLocation: ParallelDataDataLocation? = nil,
        dataLocation: ParallelDataDataLocation? = nil,
        latestUpdateAttemptAuxiliaryDataLocation: ParallelDataDataLocation? = nil,
        parallelDataProperties: ParallelDataProperties? = nil
    )
    {
        self.auxiliaryDataLocation = auxiliaryDataLocation
        self.dataLocation = dataLocation
        self.latestUpdateAttemptAuxiliaryDataLocation = latestUpdateAttemptAuxiliaryDataLocation
        self.parallelDataProperties = parallelDataProperties
    }
}

struct GetParallelDataOutputResponseBody: Equatable {
    public let parallelDataProperties: ParallelDataProperties?
    public let dataLocation: ParallelDataDataLocation?
    public let auxiliaryDataLocation: ParallelDataDataLocation?
    public let latestUpdateAttemptAuxiliaryDataLocation: ParallelDataDataLocation?
}

extension GetParallelDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auxiliaryDataLocation = "AuxiliaryDataLocation"
        case dataLocation = "DataLocation"
        case latestUpdateAttemptAuxiliaryDataLocation = "LatestUpdateAttemptAuxiliaryDataLocation"
        case parallelDataProperties = "ParallelDataProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parallelDataPropertiesDecoded = try containerValues.decodeIfPresent(ParallelDataProperties.self, forKey: .parallelDataProperties)
        parallelDataProperties = parallelDataPropertiesDecoded
        let dataLocationDecoded = try containerValues.decodeIfPresent(ParallelDataDataLocation.self, forKey: .dataLocation)
        dataLocation = dataLocationDecoded
        let auxiliaryDataLocationDecoded = try containerValues.decodeIfPresent(ParallelDataDataLocation.self, forKey: .auxiliaryDataLocation)
        auxiliaryDataLocation = auxiliaryDataLocationDecoded
        let latestUpdateAttemptAuxiliaryDataLocationDecoded = try containerValues.decodeIfPresent(ParallelDataDataLocation.self, forKey: .latestUpdateAttemptAuxiliaryDataLocation)
        latestUpdateAttemptAuxiliaryDataLocation = latestUpdateAttemptAuxiliaryDataLocationDecoded
    }
}

public struct GetTerminologyInputBodyMiddleware: Middleware {
    public let id: String = "GetTerminologyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTerminologyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTerminologyInput>
    public typealias MOutput = OperationOutput<GetTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTerminologyOutputError>
}

extension GetTerminologyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTerminologyInput(name: \(String(describing: name)), terminologyDataFormat: \(String(describing: terminologyDataFormat)))"}
}

extension GetTerminologyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case terminologyDataFormat = "TerminologyDataFormat"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let terminologyDataFormat = terminologyDataFormat {
            try encodeContainer.encode(terminologyDataFormat.rawValue, forKey: .terminologyDataFormat)
        }
    }
}

public struct GetTerminologyInputHeadersMiddleware: Middleware {
    public let id: String = "GetTerminologyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTerminologyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTerminologyInput>
    public typealias MOutput = OperationOutput<GetTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTerminologyOutputError>
}

public struct GetTerminologyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTerminologyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTerminologyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTerminologyInput>
    public typealias MOutput = OperationOutput<GetTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTerminologyOutputError>
}

public struct GetTerminologyInput: Equatable {
    /// <p>The name of the custom terminology being retrieved.</p>
    public let name: String?
    /// <p>The data format of the custom terminology being retrieved, either CSV or TMX.</p>
    public let terminologyDataFormat: TerminologyDataFormat?

    public init (
        name: String? = nil,
        terminologyDataFormat: TerminologyDataFormat? = nil
    )
    {
        self.name = name
        self.terminologyDataFormat = terminologyDataFormat
    }
}

struct GetTerminologyInputBody: Equatable {
    public let name: String?
    public let terminologyDataFormat: TerminologyDataFormat?
}

extension GetTerminologyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case terminologyDataFormat = "TerminologyDataFormat"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let terminologyDataFormatDecoded = try containerValues.decodeIfPresent(TerminologyDataFormat.self, forKey: .terminologyDataFormat)
        terminologyDataFormat = terminologyDataFormatDecoded
    }
}

extension GetTerminologyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTerminologyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTerminologyOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTerminologyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTerminologyOutputResponse(terminologyDataLocation: \(String(describing: terminologyDataLocation)), terminologyProperties: \(String(describing: terminologyProperties)))"}
}

extension GetTerminologyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTerminologyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.terminologyDataLocation = output.terminologyDataLocation
            self.terminologyProperties = output.terminologyProperties
        } else {
            self.terminologyDataLocation = nil
            self.terminologyProperties = nil
        }
    }
}

public struct GetTerminologyOutputResponse: Equatable {
    /// <p>The data location of the custom terminology being retrieved. The custom terminology file
    ///       is returned in a presigned url that has a 30 minute expiration.</p>
    public let terminologyDataLocation: TerminologyDataLocation?
    /// <p>The properties of the custom terminology being retrieved.</p>
    public let terminologyProperties: TerminologyProperties?

    public init (
        terminologyDataLocation: TerminologyDataLocation? = nil,
        terminologyProperties: TerminologyProperties? = nil
    )
    {
        self.terminologyDataLocation = terminologyDataLocation
        self.terminologyProperties = terminologyProperties
    }
}

struct GetTerminologyOutputResponseBody: Equatable {
    public let terminologyProperties: TerminologyProperties?
    public let terminologyDataLocation: TerminologyDataLocation?
}

extension GetTerminologyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case terminologyDataLocation = "TerminologyDataLocation"
        case terminologyProperties = "TerminologyProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminologyPropertiesDecoded = try containerValues.decodeIfPresent(TerminologyProperties.self, forKey: .terminologyProperties)
        terminologyProperties = terminologyPropertiesDecoded
        let terminologyDataLocationDecoded = try containerValues.decodeIfPresent(TerminologyDataLocation.self, forKey: .terminologyDataLocation)
        terminologyDataLocation = terminologyDataLocationDecoded
    }
}

public struct ImportTerminologyInputBodyMiddleware: Middleware {
    public let id: String = "ImportTerminologyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportTerminologyInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportTerminologyInput>
    public typealias MOutput = OperationOutput<ImportTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportTerminologyOutputError>
}

extension ImportTerminologyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportTerminologyInput(description: \(String(describing: description)), encryptionKey: \(String(describing: encryptionKey)), mergeStrategy: \(String(describing: mergeStrategy)), name: \(String(describing: name)), terminologyData: \(String(describing: terminologyData)))"}
}

extension ImportTerminologyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case mergeStrategy = "MergeStrategy"
        case name = "Name"
        case terminologyData = "TerminologyData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let mergeStrategy = mergeStrategy {
            try encodeContainer.encode(mergeStrategy.rawValue, forKey: .mergeStrategy)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let terminologyData = terminologyData {
            try encodeContainer.encode(terminologyData, forKey: .terminologyData)
        }
    }
}

public struct ImportTerminologyInputHeadersMiddleware: Middleware {
    public let id: String = "ImportTerminologyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportTerminologyInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportTerminologyInput>
    public typealias MOutput = OperationOutput<ImportTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportTerminologyOutputError>
}

public struct ImportTerminologyInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportTerminologyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportTerminologyInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportTerminologyInput>
    public typealias MOutput = OperationOutput<ImportTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportTerminologyOutputError>
}

public struct ImportTerminologyInput: Equatable {
    /// <p>The description of the custom terminology being imported.</p>
    public let description: String?
    /// <p>The encryption key for the custom terminology being imported.</p>
    public let encryptionKey: EncryptionKey?
    /// <p>The merge strategy of the custom terminology being imported. Currently, only the OVERWRITE
    ///       merge strategy is supported. In this case, the imported terminology will overwrite an existing
    ///       terminology of the same name.</p>
    public let mergeStrategy: MergeStrategy?
    /// <p>The name of the custom terminology being imported.</p>
    public let name: String?
    /// <p>The terminology data for the custom terminology being imported.</p>
    public let terminologyData: TerminologyData?

    public init (
        description: String? = nil,
        encryptionKey: EncryptionKey? = nil,
        mergeStrategy: MergeStrategy? = nil,
        name: String? = nil,
        terminologyData: TerminologyData? = nil
    )
    {
        self.description = description
        self.encryptionKey = encryptionKey
        self.mergeStrategy = mergeStrategy
        self.name = name
        self.terminologyData = terminologyData
    }
}

struct ImportTerminologyInputBody: Equatable {
    public let name: String?
    public let mergeStrategy: MergeStrategy?
    public let description: String?
    public let terminologyData: TerminologyData?
    public let encryptionKey: EncryptionKey?
}

extension ImportTerminologyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case mergeStrategy = "MergeStrategy"
        case name = "Name"
        case terminologyData = "TerminologyData"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let mergeStrategyDecoded = try containerValues.decodeIfPresent(MergeStrategy.self, forKey: .mergeStrategy)
        mergeStrategy = mergeStrategyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let terminologyDataDecoded = try containerValues.decodeIfPresent(TerminologyData.self, forKey: .terminologyData)
        terminologyData = terminologyDataDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension ImportTerminologyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportTerminologyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportTerminologyOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportTerminologyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportTerminologyOutputResponse(terminologyProperties: \(String(describing: terminologyProperties)))"}
}

extension ImportTerminologyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportTerminologyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.terminologyProperties = output.terminologyProperties
        } else {
            self.terminologyProperties = nil
        }
    }
}

public struct ImportTerminologyOutputResponse: Equatable {
    /// <p>The properties of the custom terminology being imported.</p>
    public let terminologyProperties: TerminologyProperties?

    public init (
        terminologyProperties: TerminologyProperties? = nil
    )
    {
        self.terminologyProperties = terminologyProperties
    }
}

struct ImportTerminologyOutputResponseBody: Equatable {
    public let terminologyProperties: TerminologyProperties?
}

extension ImportTerminologyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case terminologyProperties = "TerminologyProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminologyPropertiesDecoded = try containerValues.decodeIfPresent(TerminologyProperties.self, forKey: .terminologyProperties)
        terminologyProperties = terminologyPropertiesDecoded
    }
}

extension InputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentType = "ContentType"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension InputDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputDataConfig(contentType: \(String(describing: contentType)), s3Uri: \(String(describing: s3Uri)))"}
}

/// <p>The input configuration properties for requesting a batch translation job.</p>
public struct InputDataConfig: Equatable {
    /// <p>Describes the format of the data that you submit to Amazon Translate as input. You can
    ///       specify one of the following multipurpose internet mail extension (MIME) types:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>text/html</code>: The input data consists of one or more HTML files. Amazon
    ///           Translate translates only the text that resides in the <code>html</code> element in each
    ///           file.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>text/plain</code>: The input data consists of one or more unformatted text
    ///           files. Amazon Translate translates every character in this type of input.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>application/vnd.openxmlformats-officedocument.wordprocessingml.document</code>:
    ///           The input data consists of one or more Word documents (.docx).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>application/vnd.openxmlformats-officedocument.presentationml.presentation</code>:
    ///           The input data consists of one or more PowerPoint Presentation files (.pptx).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</code>: The
    ///           input data consists of one or more Excel Workbook files (.xlsx).</p>
    ///             </li>
    ///          </ul>
    ///          <important>
    ///             <p>If you structure your input data as HTML, ensure that you set this parameter to
    ///           <code>text/html</code>. By doing so, you cut costs by limiting the translation to the
    ///         contents of the <code>html</code> element in each file. Otherwise, if you set this parameter
    ///         to <code>text/plain</code>, your costs will cover the translation of every character.</p>
    ///          </important>
    public let contentType: String?
    /// <p>The URI of the AWS S3 folder that contains the input file. The folder must be in the
    ///       same Region as the API endpoint you are calling.</p>
    public let s3Uri: String?

    public init (
        contentType: String? = nil,
        s3Uri: String? = nil
    )
    {
        self.contentType = contentType
        self.s3Uri = s3Uri
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal server error occurred. Retry your request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidFilterException(message: \(String(describing: message)))"}
}

extension InvalidFilterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidFilterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The filter specified for the operation is invalid. Specify a different filter.</p>
public struct InvalidFilterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidFilterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValueException(message: \(String(describing: message)))"}
}

extension InvalidParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value of the parameter is invalid. Review the value of the parameter you are using to
///       correct it, and then retry your operation.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The request that you made is invalid. Check your request to determine why it's invalid
///       and then retry the request. </p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JobDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentsWithErrorsCount = "DocumentsWithErrorsCount"
        case inputDocumentsCount = "InputDocumentsCount"
        case translatedDocumentsCount = "TranslatedDocumentsCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentsWithErrorsCount = documentsWithErrorsCount {
            try encodeContainer.encode(documentsWithErrorsCount, forKey: .documentsWithErrorsCount)
        }
        if let inputDocumentsCount = inputDocumentsCount {
            try encodeContainer.encode(inputDocumentsCount, forKey: .inputDocumentsCount)
        }
        if let translatedDocumentsCount = translatedDocumentsCount {
            try encodeContainer.encode(translatedDocumentsCount, forKey: .translatedDocumentsCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let translatedDocumentsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .translatedDocumentsCount)
        translatedDocumentsCount = translatedDocumentsCountDecoded
        let documentsWithErrorsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .documentsWithErrorsCount)
        documentsWithErrorsCount = documentsWithErrorsCountDecoded
        let inputDocumentsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inputDocumentsCount)
        inputDocumentsCount = inputDocumentsCountDecoded
    }
}

extension JobDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobDetails(documentsWithErrorsCount: \(String(describing: documentsWithErrorsCount)), inputDocumentsCount: \(String(describing: inputDocumentsCount)), translatedDocumentsCount: \(String(describing: translatedDocumentsCount)))"}
}

/// <p>The number of documents successfully and unsuccessfully processed during a translation
///       job.</p>
public struct JobDetails: Equatable {
    /// <p>The number of documents that could not be processed during a translation job.</p>
    public let documentsWithErrorsCount: Int?
    /// <p>The number of documents used as input in a translation job.</p>
    public let inputDocumentsCount: Int?
    /// <p>The number of documents successfully processed during a translation job.</p>
    public let translatedDocumentsCount: Int?

    public init (
        documentsWithErrorsCount: Int? = nil,
        inputDocumentsCount: Int? = nil,
        translatedDocumentsCount: Int? = nil
    )
    {
        self.documentsWithErrorsCount = documentsWithErrorsCount
        self.inputDocumentsCount = inputDocumentsCount
        self.translatedDocumentsCount = translatedDocumentsCount
    }
}

public enum JobStatus {
    case completed
    case completedWithError
    case failed
    case inProgress
    case stopped
    case stopRequested
    case submitted
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .completed,
            .completedWithError,
            .failed,
            .inProgress,
            .stopped,
            .stopRequested,
            .submitted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .completedWithError: return "COMPLETED_WITH_ERROR"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .stopped: return "STOPPED"
        case .stopRequested: return "STOP_REQUESTED"
        case .submitted: return "SUBMITTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified limit has been exceeded. Review your request and retry it with a quantity
///       below the stated limit.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListParallelDataInputBodyMiddleware: Middleware {
    public let id: String = "ListParallelDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<ListParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListParallelDataInput>
    public typealias MOutput = OperationOutput<ListParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListParallelDataOutputError>
}

extension ListParallelDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListParallelDataInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListParallelDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListParallelDataInputHeadersMiddleware: Middleware {
    public let id: String = "ListParallelDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<ListParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListParallelDataInput>
    public typealias MOutput = OperationOutput<ListParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListParallelDataOutputError>
}

public struct ListParallelDataInputQueryItemMiddleware: Middleware {
    public let id: String = "ListParallelDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<ListParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListParallelDataInput>
    public typealias MOutput = OperationOutput<ListParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListParallelDataOutputError>
}

public struct ListParallelDataInput: Equatable {
    /// <p>The maximum number of parallel data resources returned for each request.</p>
    public let maxResults: Int?
    /// <p>A string that specifies the next page of results to return in a paginated response.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListParallelDataInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListParallelDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListParallelDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListParallelDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListParallelDataOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListParallelDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListParallelDataOutputResponse(nextToken: \(String(describing: nextToken)), parallelDataPropertiesList: \(String(describing: parallelDataPropertiesList)))"}
}

extension ListParallelDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListParallelDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.parallelDataPropertiesList = output.parallelDataPropertiesList
        } else {
            self.nextToken = nil
            self.parallelDataPropertiesList = nil
        }
    }
}

public struct ListParallelDataOutputResponse: Equatable {
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated
    ///       response. This value is null if there are no additional pages.</p>
    public let nextToken: String?
    /// <p>The properties of the parallel data resources returned by this request.</p>
    public let parallelDataPropertiesList: [ParallelDataProperties]?

    public init (
        nextToken: String? = nil,
        parallelDataPropertiesList: [ParallelDataProperties]? = nil
    )
    {
        self.nextToken = nextToken
        self.parallelDataPropertiesList = parallelDataPropertiesList
    }
}

struct ListParallelDataOutputResponseBody: Equatable {
    public let parallelDataPropertiesList: [ParallelDataProperties]?
    public let nextToken: String?
}

extension ListParallelDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case parallelDataPropertiesList = "ParallelDataPropertiesList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parallelDataPropertiesListContainer = try containerValues.decodeIfPresent([ParallelDataProperties?].self, forKey: .parallelDataPropertiesList)
        var parallelDataPropertiesListDecoded0:[ParallelDataProperties]? = nil
        if let parallelDataPropertiesListContainer = parallelDataPropertiesListContainer {
            parallelDataPropertiesListDecoded0 = [ParallelDataProperties]()
            for structure0 in parallelDataPropertiesListContainer {
                if let structure0 = structure0 {
                    parallelDataPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        parallelDataPropertiesList = parallelDataPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTerminologiesInputBodyMiddleware: Middleware {
    public let id: String = "ListTerminologiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTerminologiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTerminologiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTerminologiesInput>
    public typealias MOutput = OperationOutput<ListTerminologiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTerminologiesOutputError>
}

extension ListTerminologiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTerminologiesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTerminologiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTerminologiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTerminologiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTerminologiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTerminologiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTerminologiesInput>
    public typealias MOutput = OperationOutput<ListTerminologiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTerminologiesOutputError>
}

public struct ListTerminologiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTerminologiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTerminologiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTerminologiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTerminologiesInput>
    public typealias MOutput = OperationOutput<ListTerminologiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTerminologiesOutputError>
}

public struct ListTerminologiesInput: Equatable {
    /// <p>The maximum number of custom terminologies returned per list request.</p>
    public let maxResults: Int?
    /// <p>If the result of the request to ListTerminologies was truncated, include the NextToken to
    ///       fetch the next group of custom terminologies. </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTerminologiesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTerminologiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTerminologiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTerminologiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTerminologiesOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTerminologiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTerminologiesOutputResponse(nextToken: \(String(describing: nextToken)), terminologyPropertiesList: \(String(describing: terminologyPropertiesList)))"}
}

extension ListTerminologiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTerminologiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.terminologyPropertiesList = output.terminologyPropertiesList
        } else {
            self.nextToken = nil
            self.terminologyPropertiesList = nil
        }
    }
}

public struct ListTerminologiesOutputResponse: Equatable {
    /// <p> If the response to the ListTerminologies was truncated, the NextToken fetches the next
    ///       group of custom terminologies.</p>
    public let nextToken: String?
    /// <p>The properties list of the custom terminologies returned on the list request.</p>
    public let terminologyPropertiesList: [TerminologyProperties]?

    public init (
        nextToken: String? = nil,
        terminologyPropertiesList: [TerminologyProperties]? = nil
    )
    {
        self.nextToken = nextToken
        self.terminologyPropertiesList = terminologyPropertiesList
    }
}

struct ListTerminologiesOutputResponseBody: Equatable {
    public let terminologyPropertiesList: [TerminologyProperties]?
    public let nextToken: String?
}

extension ListTerminologiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case terminologyPropertiesList = "TerminologyPropertiesList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminologyPropertiesListContainer = try containerValues.decodeIfPresent([TerminologyProperties?].self, forKey: .terminologyPropertiesList)
        var terminologyPropertiesListDecoded0:[TerminologyProperties]? = nil
        if let terminologyPropertiesListContainer = terminologyPropertiesListContainer {
            terminologyPropertiesListDecoded0 = [TerminologyProperties]()
            for structure0 in terminologyPropertiesListContainer {
                if let structure0 = structure0 {
                    terminologyPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        terminologyPropertiesList = terminologyPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTextTranslationJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListTextTranslationJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTextTranslationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTextTranslationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTextTranslationJobsInput>
    public typealias MOutput = OperationOutput<ListTextTranslationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTextTranslationJobsOutputError>
}

extension ListTextTranslationJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTextTranslationJobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTextTranslationJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTextTranslationJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTextTranslationJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTextTranslationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTextTranslationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTextTranslationJobsInput>
    public typealias MOutput = OperationOutput<ListTextTranslationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTextTranslationJobsOutputError>
}

public struct ListTextTranslationJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTextTranslationJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTextTranslationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTextTranslationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTextTranslationJobsInput>
    public typealias MOutput = OperationOutput<ListTextTranslationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTextTranslationJobsOutputError>
}

public struct ListTextTranslationJobsInput: Equatable {
    /// <p>The parameters that specify which batch translation jobs to retrieve. Filters include job
    ///       name, job status, and submission time. You can only set one filter at a time.</p>
    public let filter: TextTranslationJobFilter?
    /// <p>The maximum number of results to return in each page. The default value is 100.</p>
    public let maxResults: Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?

    public init (
        filter: TextTranslationJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTextTranslationJobsInputBody: Equatable {
    public let filter: TextTranslationJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTextTranslationJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(TextTranslationJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTextTranslationJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTextTranslationJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterException" : self = .invalidFilterException(try InvalidFilterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTextTranslationJobsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidFilterException(InvalidFilterException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTextTranslationJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTextTranslationJobsOutputResponse(nextToken: \(String(describing: nextToken)), textTranslationJobPropertiesList: \(String(describing: textTranslationJobPropertiesList)))"}
}

extension ListTextTranslationJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTextTranslationJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.textTranslationJobPropertiesList = output.textTranslationJobPropertiesList
        } else {
            self.nextToken = nil
            self.textTranslationJobPropertiesList = nil
        }
    }
}

public struct ListTextTranslationJobsOutputResponse: Equatable {
    /// <p>The token to use to retreive the next page of results. This value is <code>null</code>
    ///       when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>A list containing the properties of each job that is returned.</p>
    public let textTranslationJobPropertiesList: [TextTranslationJobProperties]?

    public init (
        nextToken: String? = nil,
        textTranslationJobPropertiesList: [TextTranslationJobProperties]? = nil
    )
    {
        self.nextToken = nextToken
        self.textTranslationJobPropertiesList = textTranslationJobPropertiesList
    }
}

struct ListTextTranslationJobsOutputResponseBody: Equatable {
    public let textTranslationJobPropertiesList: [TextTranslationJobProperties]?
    public let nextToken: String?
}

extension ListTextTranslationJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case textTranslationJobPropertiesList = "TextTranslationJobPropertiesList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textTranslationJobPropertiesListContainer = try containerValues.decodeIfPresent([TextTranslationJobProperties?].self, forKey: .textTranslationJobPropertiesList)
        var textTranslationJobPropertiesListDecoded0:[TextTranslationJobProperties]? = nil
        if let textTranslationJobPropertiesListContainer = textTranslationJobPropertiesListContainer {
            textTranslationJobPropertiesListDecoded0 = [TextTranslationJobProperties]()
            for structure0 in textTranslationJobPropertiesListContainer {
                if let structure0 = structure0 {
                    textTranslationJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        textTranslationJobPropertiesList = textTranslationJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum MergeStrategy {
    case overwrite
    case sdkUnknown(String)
}

extension MergeStrategy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MergeStrategy] {
        return [
            .overwrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .overwrite: return "OVERWRITE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MergeStrategy(rawValue: rawValue) ?? MergeStrategy.sdkUnknown(rawValue)
    }
}

extension OutputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension OutputDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputDataConfig(s3Uri: \(String(describing: s3Uri)))"}
}

/// <p>The output configuration properties for a batch translation job.</p>
public struct OutputDataConfig: Equatable {
    /// <p>The URI of the S3 folder that contains a translation job's output file. The folder must
    ///       be in the same Region as the API endpoint that you are calling.</p>
    public let s3Uri: String?

    public init (
        s3Uri: String? = nil
    )
    {
        self.s3Uri = s3Uri
    }
}

extension ParallelDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case format = "Format"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ParallelDataFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension ParallelDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParallelDataConfig(format: \(String(describing: format)), s3Uri: \(String(describing: s3Uri)))"}
}

/// <p>Specifies the format and S3 location of the parallel data input file.</p>
public struct ParallelDataConfig: Equatable {
    /// <p>The format of the parallel data input file.</p>
    public let format: ParallelDataFormat?
    /// <p>The URI of the Amazon S3 folder that contains the parallel data input file. The folder
    ///       must be in the same Region as the API endpoint you are calling.</p>
    public let s3Uri: String?

    public init (
        format: ParallelDataFormat? = nil,
        s3Uri: String? = nil
    )
    {
        self.format = format
        self.s3Uri = s3Uri
    }
}

extension ParallelDataDataLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case location = "Location"
        case repositoryType = "RepositoryType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryType = repositoryType {
            try encodeContainer.encode(repositoryType, forKey: .repositoryType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryType)
        repositoryType = repositoryTypeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
    }
}

extension ParallelDataDataLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParallelDataDataLocation(location: \(String(describing: location)), repositoryType: \(String(describing: repositoryType)))"}
}

/// <p>The location of the most recent parallel data input file that was successfully imported
///       into Amazon Translate.</p>
public struct ParallelDataDataLocation: Equatable {
    /// <p>The Amazon S3 location of the parallel data input file. The location is returned as a
    ///       presigned URL to that has a 30 minute expiration.</p>
    public let location: String?
    /// <p>Describes the repository that contains the parallel data input file.</p>
    public let repositoryType: String?

    public init (
        location: String? = nil,
        repositoryType: String? = nil
    )
    {
        self.location = location
        self.repositoryType = repositoryType
    }
}

public enum ParallelDataFormat {
    case csv
    case tmx
    case tsv
    case sdkUnknown(String)
}

extension ParallelDataFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParallelDataFormat] {
        return [
            .csv,
            .tmx,
            .tsv,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .tmx: return "TMX"
        case .tsv: return "TSV"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParallelDataFormat(rawValue: rawValue) ?? ParallelDataFormat.sdkUnknown(rawValue)
    }
}

extension ParallelDataProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case failedRecordCount = "FailedRecordCount"
        case importedDataSize = "ImportedDataSize"
        case importedRecordCount = "ImportedRecordCount"
        case lastUpdatedAt = "LastUpdatedAt"
        case latestUpdateAttemptAt = "LatestUpdateAttemptAt"
        case latestUpdateAttemptStatus = "LatestUpdateAttemptStatus"
        case message = "Message"
        case name = "Name"
        case parallelDataConfig = "ParallelDataConfig"
        case skippedRecordCount = "SkippedRecordCount"
        case sourceLanguageCode = "SourceLanguageCode"
        case status = "Status"
        case targetLanguageCodes = "TargetLanguageCodes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let failedRecordCount = failedRecordCount {
            try encodeContainer.encode(failedRecordCount, forKey: .failedRecordCount)
        }
        if let importedDataSize = importedDataSize {
            try encodeContainer.encode(importedDataSize, forKey: .importedDataSize)
        }
        if let importedRecordCount = importedRecordCount {
            try encodeContainer.encode(importedRecordCount, forKey: .importedRecordCount)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let latestUpdateAttemptAt = latestUpdateAttemptAt {
            try encodeContainer.encode(latestUpdateAttemptAt.timeIntervalSince1970, forKey: .latestUpdateAttemptAt)
        }
        if let latestUpdateAttemptStatus = latestUpdateAttemptStatus {
            try encodeContainer.encode(latestUpdateAttemptStatus.rawValue, forKey: .latestUpdateAttemptStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parallelDataConfig = parallelDataConfig {
            try encodeContainer.encode(parallelDataConfig, forKey: .parallelDataConfig)
        }
        if let skippedRecordCount = skippedRecordCount {
            try encodeContainer.encode(skippedRecordCount, forKey: .skippedRecordCount)
        }
        if let sourceLanguageCode = sourceLanguageCode {
            try encodeContainer.encode(sourceLanguageCode, forKey: .sourceLanguageCode)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetLanguageCodes = targetLanguageCodes {
            var targetLanguageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLanguageCodes)
            for languagecodestringlist0 in targetLanguageCodes {
                try targetLanguageCodesContainer.encode(languagecodestringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ParallelDataStatus.self, forKey: .status)
        status = statusDecoded
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetLanguageCodes)
        var targetLanguageCodesDecoded0:[String]? = nil
        if let targetLanguageCodesContainer = targetLanguageCodesContainer {
            targetLanguageCodesDecoded0 = [String]()
            for string0 in targetLanguageCodesContainer {
                if let string0 = string0 {
                    targetLanguageCodesDecoded0?.append(string0)
                }
            }
        }
        targetLanguageCodes = targetLanguageCodesDecoded0
        let parallelDataConfigDecoded = try containerValues.decodeIfPresent(ParallelDataConfig.self, forKey: .parallelDataConfig)
        parallelDataConfig = parallelDataConfigDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let importedDataSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .importedDataSize)
        importedDataSize = importedDataSizeDecoded
        let importedRecordCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .importedRecordCount)
        importedRecordCount = importedRecordCountDecoded
        let failedRecordCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failedRecordCount)
        failedRecordCount = failedRecordCountDecoded
        let skippedRecordCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .skippedRecordCount)
        skippedRecordCount = skippedRecordCountDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let latestUpdateAttemptStatusDecoded = try containerValues.decodeIfPresent(ParallelDataStatus.self, forKey: .latestUpdateAttemptStatus)
        latestUpdateAttemptStatus = latestUpdateAttemptStatusDecoded
        let latestUpdateAttemptAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestUpdateAttemptAt)
        latestUpdateAttemptAt = latestUpdateAttemptAtDecoded
    }
}

extension ParallelDataProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParallelDataProperties(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), encryptionKey: \(String(describing: encryptionKey)), failedRecordCount: \(String(describing: failedRecordCount)), importedDataSize: \(String(describing: importedDataSize)), importedRecordCount: \(String(describing: importedRecordCount)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), latestUpdateAttemptAt: \(String(describing: latestUpdateAttemptAt)), latestUpdateAttemptStatus: \(String(describing: latestUpdateAttemptStatus)), message: \(String(describing: message)), name: \(String(describing: name)), parallelDataConfig: \(String(describing: parallelDataConfig)), skippedRecordCount: \(String(describing: skippedRecordCount)), sourceLanguageCode: \(String(describing: sourceLanguageCode)), status: \(String(describing: status)), targetLanguageCodes: \(String(describing: targetLanguageCodes)))"}
}

/// <p>The properties of a parallel data resource.</p>
public struct ParallelDataProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the parallel data resource.</p>
    public let arn: String?
    /// <p>The time at which the parallel data resource was created.</p>
    public let createdAt: Date?
    /// <p>The description assigned to the parallel data resource.</p>
    public let description: String?
    /// <p>The encryption key used to encrypt this object.</p>
    public let encryptionKey: EncryptionKey?
    /// <p>The number of records unsuccessfully imported from the parallel data input file.</p>
    public let failedRecordCount: Int?
    /// <p>The number of UTF-8 characters that Amazon Translate imported from the parallel data input
    ///       file. This number includes only the characters in your translation examples. It does not
    ///       include characters that are used to format your file. For example, if you provided a
    ///       Translation Memory Exchange (.tmx) file, this number does not include the tags.</p>
    public let importedDataSize: Int?
    /// <p>The number of records successfully imported from the parallel data input file.</p>
    public let importedRecordCount: Int?
    /// <p>The time at which the parallel data resource was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The time that the most recent update was attempted.</p>
    public let latestUpdateAttemptAt: Date?
    /// <p>The status of the most recent update attempt for the parallel data resource.</p>
    public let latestUpdateAttemptStatus: ParallelDataStatus?
    /// <p>Additional information from Amazon Translate about the parallel data resource. </p>
    public let message: String?
    /// <p>The custom name assigned to the parallel data resource.</p>
    public let name: String?
    /// <p>Specifies the format and S3 location of the parallel data input file.</p>
    public let parallelDataConfig: ParallelDataConfig?
    /// <p>The number of items in the input file that Amazon Translate skipped when you created or
    ///       updated the parallel data resource. For example, Amazon Translate skips empty records, empty
    ///       target texts, and empty lines.</p>
    public let skippedRecordCount: Int?
    /// <p>The source language of the translations in the parallel data file.</p>
    public let sourceLanguageCode: String?
    /// <p>The status of the parallel data resource. When the parallel data is ready for you to use,
    ///       the status is <code>ACTIVE</code>.</p>
    public let status: ParallelDataStatus?
    /// <p>The language codes for the target languages available in the parallel data file. All
    ///       possible target languages are returned as an array.</p>
    public let targetLanguageCodes: [String]?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        encryptionKey: EncryptionKey? = nil,
        failedRecordCount: Int? = nil,
        importedDataSize: Int? = nil,
        importedRecordCount: Int? = nil,
        lastUpdatedAt: Date? = nil,
        latestUpdateAttemptAt: Date? = nil,
        latestUpdateAttemptStatus: ParallelDataStatus? = nil,
        message: String? = nil,
        name: String? = nil,
        parallelDataConfig: ParallelDataConfig? = nil,
        skippedRecordCount: Int? = nil,
        sourceLanguageCode: String? = nil,
        status: ParallelDataStatus? = nil,
        targetLanguageCodes: [String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.encryptionKey = encryptionKey
        self.failedRecordCount = failedRecordCount
        self.importedDataSize = importedDataSize
        self.importedRecordCount = importedRecordCount
        self.lastUpdatedAt = lastUpdatedAt
        self.latestUpdateAttemptAt = latestUpdateAttemptAt
        self.latestUpdateAttemptStatus = latestUpdateAttemptStatus
        self.message = message
        self.name = name
        self.parallelDataConfig = parallelDataConfig
        self.skippedRecordCount = skippedRecordCount
        self.sourceLanguageCode = sourceLanguageCode
        self.status = status
        self.targetLanguageCodes = targetLanguageCodes
    }
}

public enum ParallelDataStatus {
    case active
    case creating
    case deleting
    case failed
    case updating
    case sdkUnknown(String)
}

extension ParallelDataStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParallelDataStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParallelDataStatus(rawValue: rawValue) ?? ParallelDataStatus.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource you are looking for has not been found. Review the resource you're looking
///       for and see if a different resource will accomplish your needs before retrying the revised
///       request.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Translate service is temporarily unavailable. Please wait a bit and then retry your
///       request.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartTextTranslationJobInputBodyMiddleware: Middleware {
    public let id: String = "StartTextTranslationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTextTranslationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTextTranslationJobInput>
    public typealias MOutput = OperationOutput<StartTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTextTranslationJobOutputError>
}

extension StartTextTranslationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTextTranslationJobInput(clientToken: \(String(describing: clientToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), outputDataConfig: \(String(describing: outputDataConfig)), parallelDataNames: \(String(describing: parallelDataNames)), sourceLanguageCode: \(String(describing: sourceLanguageCode)), targetLanguageCodes: \(String(describing: targetLanguageCodes)), terminologyNames: \(String(describing: terminologyNames)))"}
}

extension StartTextTranslationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case parallelDataNames = "ParallelDataNames"
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCodes = "TargetLanguageCodes"
        case terminologyNames = "TerminologyNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let parallelDataNames = parallelDataNames {
            var parallelDataNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parallelDataNames)
            for resourcenamelist0 in parallelDataNames {
                try parallelDataNamesContainer.encode(resourcenamelist0)
            }
        }
        if let sourceLanguageCode = sourceLanguageCode {
            try encodeContainer.encode(sourceLanguageCode, forKey: .sourceLanguageCode)
        }
        if let targetLanguageCodes = targetLanguageCodes {
            var targetLanguageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLanguageCodes)
            for targetlanguagecodestringlist0 in targetLanguageCodes {
                try targetLanguageCodesContainer.encode(targetlanguagecodestringlist0)
            }
        }
        if let terminologyNames = terminologyNames {
            var terminologyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terminologyNames)
            for resourcenamelist0 in terminologyNames {
                try terminologyNamesContainer.encode(resourcenamelist0)
            }
        }
    }
}

public struct StartTextTranslationJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartTextTranslationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTextTranslationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTextTranslationJobInput>
    public typealias MOutput = OperationOutput<StartTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTextTranslationJobOutputError>
}

public struct StartTextTranslationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartTextTranslationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTextTranslationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTextTranslationJobInput>
    public typealias MOutput = OperationOutput<StartTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTextTranslationJobOutputError>
}

public struct StartTextTranslationJobInput: Equatable {
    /// <p>A unique identifier for the request. This token is auto-generated when using the Amazon Translate
    ///       SDK.</p>
    public var clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of an AWS Identity Access and Management (IAM) role
    ///       that grants Amazon Translate read access to your input data. For more nformation, see <a>identity-and-access-management</a>.</p>
    public let dataAccessRoleArn: String?
    /// <p>Specifies the format and S3 location of the input documents for the translation
    ///       job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The name of the batch translation job to be performed.</p>
    public let jobName: String?
    /// <p>Specifies the S3 folder to which your job output will be saved.
    ///       </p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>The names of the parallel data resources to use in the batch translation job. For a list
    ///       of available parallel data resources, use the <a>ListParallelData</a>
    ///       operation.</p>
    public let parallelDataNames: [String]?
    /// <p>The language code of the input language. For a list of language codes, see <a>what-is-languages</a>.</p>
    ///          <p>Amazon Translate does not automatically detect a source language during batch translation
    ///       jobs.</p>
    public let sourceLanguageCode: String?
    /// <p>The language code of the output language.</p>
    public let targetLanguageCodes: [String]?
    /// <p>The name of the terminology to use in the batch translation job. For a list of available
    ///       terminologies, use the <a>ListTerminologies</a> operation.</p>
    public let terminologyNames: [String]?

    public init (
        clientToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        parallelDataNames: [String]? = nil,
        sourceLanguageCode: String? = nil,
        targetLanguageCodes: [String]? = nil,
        terminologyNames: [String]? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.parallelDataNames = parallelDataNames
        self.sourceLanguageCode = sourceLanguageCode
        self.targetLanguageCodes = targetLanguageCodes
        self.terminologyNames = terminologyNames
    }
}

struct StartTextTranslationJobInputBody: Equatable {
    public let jobName: String?
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let dataAccessRoleArn: String?
    public let sourceLanguageCode: String?
    public let targetLanguageCodes: [String]?
    public let terminologyNames: [String]?
    public let parallelDataNames: [String]?
    public let clientToken: String?
}

extension StartTextTranslationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case parallelDataNames = "ParallelDataNames"
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCodes = "TargetLanguageCodes"
        case terminologyNames = "TerminologyNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetLanguageCodes)
        var targetLanguageCodesDecoded0:[String]? = nil
        if let targetLanguageCodesContainer = targetLanguageCodesContainer {
            targetLanguageCodesDecoded0 = [String]()
            for string0 in targetLanguageCodesContainer {
                if let string0 = string0 {
                    targetLanguageCodesDecoded0?.append(string0)
                }
            }
        }
        targetLanguageCodes = targetLanguageCodesDecoded0
        let terminologyNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .terminologyNames)
        var terminologyNamesDecoded0:[String]? = nil
        if let terminologyNamesContainer = terminologyNamesContainer {
            terminologyNamesDecoded0 = [String]()
            for string0 in terminologyNamesContainer {
                if let string0 = string0 {
                    terminologyNamesDecoded0?.append(string0)
                }
            }
        }
        terminologyNames = terminologyNamesDecoded0
        let parallelDataNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .parallelDataNames)
        var parallelDataNamesDecoded0:[String]? = nil
        if let parallelDataNamesContainer = parallelDataNamesContainer {
            parallelDataNamesDecoded0 = [String]()
            for string0 in parallelDataNamesContainer {
                if let string0 = string0 {
                    parallelDataNamesDecoded0?.append(string0)
                }
            }
        }
        parallelDataNames = parallelDataNamesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartTextTranslationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartTextTranslationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguagePairException" : self = .unsupportedLanguagePairException(try UnsupportedLanguagePairException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartTextTranslationJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unsupportedLanguagePairException(UnsupportedLanguagePairException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartTextTranslationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTextTranslationJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StartTextTranslationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartTextTranslationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartTextTranslationJobOutputResponse: Equatable {
    /// <p>The identifier generated for the job. To get the status of a job, use this ID with the
    ///         <a>DescribeTextTranslationJob</a> operation.</p>
    public let jobId: String?
    /// <p>The status of the job. Possible values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SUBMITTED</code> - The job has been received and is queued for
    ///           processing.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_PROGRESS</code> - Amazon Translate is processing the job.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COMPLETED</code> - The job was successfully completed and the output is
    ///           available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COMPLETED_WITH_ERROR</code> - The job was completed with errors. The errors can
    ///           be analyzed in the job's output.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - The job did not complete. To get details, use the <a>DescribeTextTranslationJob</a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STOP_REQUESTED</code> - The user who started the job has requested that it be
    ///           stopped.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STOPPED</code> - The job has been stopped.</p>
    ///             </li>
    ///          </ul>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartTextTranslationJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StartTextTranslationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StopTextTranslationJobInputBodyMiddleware: Middleware {
    public let id: String = "StopTextTranslationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopTextTranslationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopTextTranslationJobInput>
    public typealias MOutput = OperationOutput<StopTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopTextTranslationJobOutputError>
}

extension StopTextTranslationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopTextTranslationJobInput(jobId: \(String(describing: jobId)))"}
}

extension StopTextTranslationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopTextTranslationJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopTextTranslationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopTextTranslationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopTextTranslationJobInput>
    public typealias MOutput = OperationOutput<StopTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopTextTranslationJobOutputError>
}

public struct StopTextTranslationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopTextTranslationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopTextTranslationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopTextTranslationJobInput>
    public typealias MOutput = OperationOutput<StopTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopTextTranslationJobOutputError>
}

public struct StopTextTranslationJobInput: Equatable {
    /// <p>The job ID of the job to be stopped.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopTextTranslationJobInputBody: Equatable {
    public let jobId: String?
}

extension StopTextTranslationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopTextTranslationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopTextTranslationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopTextTranslationJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopTextTranslationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopTextTranslationJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StopTextTranslationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopTextTranslationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StopTextTranslationJobOutputResponse: Equatable {
    /// <p>The job ID of the stopped batch translation job.</p>
    public let jobId: String?
    /// <p>The status of the designated job. Upon successful completion, the job's status will be
    ///         <code>STOPPED</code>.</p>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StopTextTranslationJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StopTextTranslationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

extension Term: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceText = "SourceText"
        case targetText = "TargetText"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceText = sourceText {
            try encodeContainer.encode(sourceText, forKey: .sourceText)
        }
        if let targetText = targetText {
            try encodeContainer.encode(targetText, forKey: .targetText)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceText)
        sourceText = sourceTextDecoded
        let targetTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetText)
        targetText = targetTextDecoded
    }
}

extension Term: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Term(sourceText: \(String(describing: sourceText)), targetText: \(String(describing: targetText)))"}
}

/// <p>The term being translated by the custom terminology.</p>
public struct Term: Equatable {
    /// <p>The source text of the term being translated by the custom terminology.</p>
    public let sourceText: String?
    /// <p>The target text of the term being translated by the custom terminology.</p>
    public let targetText: String?

    public init (
        sourceText: String? = nil,
        targetText: String? = nil
    )
    {
        self.sourceText = sourceText
        self.targetText = targetText
    }
}

extension TerminologyData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case file = "File"
        case format = "Format"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = file {
            try encodeContainer.encode(file.base64EncodedString(), forKey: .file)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .file)
        file = fileDecoded
        let formatDecoded = try containerValues.decodeIfPresent(TerminologyDataFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension TerminologyData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminologyData(file: \(String(describing: file)), format: \(String(describing: format)))"}
}

/// <p>The data associated with the custom terminology.</p>
public struct TerminologyData: Equatable {
    /// <p>The file containing the custom terminology data. Your version of the AWS SDK performs a
    ///       Base64-encoding on this field before sending a request to the AWS service. Users of the SDK
    ///       should not perform Base64-encoding themselves.</p>
    public let file: Data?
    /// <p>The data format of the custom terminology. Either CSV or TMX.</p>
    public let format: TerminologyDataFormat?

    public init (
        file: Data? = nil,
        format: TerminologyDataFormat? = nil
    )
    {
        self.file = file
        self.format = format
    }
}

public enum TerminologyDataFormat {
    case csv
    case tmx
    case sdkUnknown(String)
}

extension TerminologyDataFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TerminologyDataFormat] {
        return [
            .csv,
            .tmx,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .tmx: return "TMX"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TerminologyDataFormat(rawValue: rawValue) ?? TerminologyDataFormat.sdkUnknown(rawValue)
    }
}

extension TerminologyDataLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case location = "Location"
        case repositoryType = "RepositoryType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryType = repositoryType {
            try encodeContainer.encode(repositoryType, forKey: .repositoryType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryType)
        repositoryType = repositoryTypeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
    }
}

extension TerminologyDataLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminologyDataLocation(location: \(String(describing: location)), repositoryType: \(String(describing: repositoryType)))"}
}

/// <p>The location of the custom terminology data.</p>
public struct TerminologyDataLocation: Equatable {
    /// <p>The location of the custom terminology data.</p>
    public let location: String?
    /// <p>The repository type for the custom terminology data.</p>
    public let repositoryType: String?

    public init (
        location: String? = nil,
        repositoryType: String? = nil
    )
    {
        self.location = location
        self.repositoryType = repositoryType
    }
}

extension TerminologyProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case lastUpdatedAt = "LastUpdatedAt"
        case name = "Name"
        case sizeBytes = "SizeBytes"
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCodes = "TargetLanguageCodes"
        case termCount = "TermCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sizeBytes = sizeBytes {
            try encodeContainer.encode(sizeBytes, forKey: .sizeBytes)
        }
        if let sourceLanguageCode = sourceLanguageCode {
            try encodeContainer.encode(sourceLanguageCode, forKey: .sourceLanguageCode)
        }
        if let targetLanguageCodes = targetLanguageCodes {
            var targetLanguageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLanguageCodes)
            for languagecodestringlist0 in targetLanguageCodes {
                try targetLanguageCodesContainer.encode(languagecodestringlist0)
            }
        }
        if let termCount = termCount {
            try encodeContainer.encode(termCount, forKey: .termCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetLanguageCodes)
        var targetLanguageCodesDecoded0:[String]? = nil
        if let targetLanguageCodesContainer = targetLanguageCodesContainer {
            targetLanguageCodesDecoded0 = [String]()
            for string0 in targetLanguageCodesContainer {
                if let string0 = string0 {
                    targetLanguageCodesDecoded0?.append(string0)
                }
            }
        }
        targetLanguageCodes = targetLanguageCodesDecoded0
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let sizeBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .sizeBytes)
        sizeBytes = sizeBytesDecoded
        let termCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .termCount)
        termCount = termCountDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension TerminologyProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminologyProperties(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), encryptionKey: \(String(describing: encryptionKey)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), sizeBytes: \(String(describing: sizeBytes)), sourceLanguageCode: \(String(describing: sourceLanguageCode)), targetLanguageCodes: \(String(describing: targetLanguageCodes)), termCount: \(String(describing: termCount)))"}
}

/// <p>The properties of the custom terminology.</p>
public struct TerminologyProperties: Equatable {
    /// <p> The Amazon Resource Name (ARN) of the custom terminology. </p>
    public let arn: String?
    /// <p>The time at which the custom terminology was created, based on the timestamp.</p>
    public let createdAt: Date?
    /// <p>The description of the custom terminology properties.</p>
    public let description: String?
    /// <p>The encryption key for the custom terminology.</p>
    public let encryptionKey: EncryptionKey?
    /// <p>The time at which the custom terminology was last update, based on the timestamp.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the custom terminology.</p>
    public let name: String?
    /// <p>The size of the file used when importing a custom terminology.</p>
    public let sizeBytes: Int?
    /// <p>The language code for the source text of the translation request for which the custom
    ///       terminology is being used.</p>
    public let sourceLanguageCode: String?
    /// <p>The language codes for the target languages available with the custom terminology file.
    ///       All possible target languages are returned in array.</p>
    public let targetLanguageCodes: [String]?
    /// <p>The number of terms included in the custom terminology.</p>
    public let termCount: Int?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        encryptionKey: EncryptionKey? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        sizeBytes: Int? = nil,
        sourceLanguageCode: String? = nil,
        targetLanguageCodes: [String]? = nil,
        termCount: Int? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.encryptionKey = encryptionKey
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.sizeBytes = sizeBytes
        self.sourceLanguageCode = sourceLanguageCode
        self.targetLanguageCodes = targetLanguageCodes
        self.termCount = termCount
    }
}

extension TextSizeLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextSizeLimitExceededException(message: \(String(describing: message)))"}
}

extension TextSizeLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TextSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The size of the text you submitted exceeds the size limit. Reduce the size of the text or
///       use a smaller document and then retry your request. </p>
public struct TextSizeLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TextSizeLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension TextSizeLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TextTranslationJobFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submittedAfterTime = "SubmittedAfterTime"
        case submittedBeforeTime = "SubmittedBeforeTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submittedAfterTime = submittedAfterTime {
            try encodeContainer.encode(submittedAfterTime.timeIntervalSince1970, forKey: .submittedAfterTime)
        }
        if let submittedBeforeTime = submittedBeforeTime {
            try encodeContainer.encode(submittedBeforeTime.timeIntervalSince1970, forKey: .submittedBeforeTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submittedBeforeTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submittedBeforeTime)
        submittedBeforeTime = submittedBeforeTimeDecoded
        let submittedAfterTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submittedAfterTime)
        submittedAfterTime = submittedAfterTimeDecoded
    }
}

extension TextTranslationJobFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextTranslationJobFilter(jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), submittedAfterTime: \(String(describing: submittedAfterTime)), submittedBeforeTime: \(String(describing: submittedBeforeTime)))"}
}

/// <p>Provides information for filtering a list of translation jobs. For more information, see
///         <a>ListTextTranslationJobs</a>.</p>
public struct TextTranslationJobFilter: Equatable {
    /// <p>Filters the list of jobs by name.</p>
    public let jobName: String?
    /// <p>Filters the list of jobs based by job status.</p>
    public let jobStatus: JobStatus?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing and
    ///       returns only the jobs submitted after the specified time. Jobs are returned in descending
    ///       order, newest to oldest.</p>
    public let submittedAfterTime: Date?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing and
    ///       returns only the jobs submitted before the specified time. Jobs are returned in ascending
    ///       order, oldest to newest.</p>
    public let submittedBeforeTime: Date?

    public init (
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        submittedAfterTime: Date? = nil,
        submittedBeforeTime: Date? = nil
    )
    {
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.submittedAfterTime = submittedAfterTime
        self.submittedBeforeTime = submittedBeforeTime
    }
}

extension TextTranslationJobProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobDetails = "JobDetails"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case parallelDataNames = "ParallelDataNames"
        case sourceLanguageCode = "SourceLanguageCode"
        case submittedTime = "SubmittedTime"
        case targetLanguageCodes = "TargetLanguageCodes"
        case terminologyNames = "TerminologyNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobDetails = jobDetails {
            try encodeContainer.encode(jobDetails, forKey: .jobDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let parallelDataNames = parallelDataNames {
            var parallelDataNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parallelDataNames)
            for resourcenamelist0 in parallelDataNames {
                try parallelDataNamesContainer.encode(resourcenamelist0)
            }
        }
        if let sourceLanguageCode = sourceLanguageCode {
            try encodeContainer.encode(sourceLanguageCode, forKey: .sourceLanguageCode)
        }
        if let submittedTime = submittedTime {
            try encodeContainer.encode(submittedTime.timeIntervalSince1970, forKey: .submittedTime)
        }
        if let targetLanguageCodes = targetLanguageCodes {
            var targetLanguageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLanguageCodes)
            for targetlanguagecodestringlist0 in targetLanguageCodes {
                try targetLanguageCodesContainer.encode(targetlanguagecodestringlist0)
            }
        }
        if let terminologyNames = terminologyNames {
            var terminologyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terminologyNames)
            for resourcenamelist0 in terminologyNames {
                try terminologyNamesContainer.encode(resourcenamelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobDetailsDecoded = try containerValues.decodeIfPresent(JobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetLanguageCodes)
        var targetLanguageCodesDecoded0:[String]? = nil
        if let targetLanguageCodesContainer = targetLanguageCodesContainer {
            targetLanguageCodesDecoded0 = [String]()
            for string0 in targetLanguageCodesContainer {
                if let string0 = string0 {
                    targetLanguageCodesDecoded0?.append(string0)
                }
            }
        }
        targetLanguageCodes = targetLanguageCodesDecoded0
        let terminologyNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .terminologyNames)
        var terminologyNamesDecoded0:[String]? = nil
        if let terminologyNamesContainer = terminologyNamesContainer {
            terminologyNamesDecoded0 = [String]()
            for string0 in terminologyNamesContainer {
                if let string0 = string0 {
                    terminologyNamesDecoded0?.append(string0)
                }
            }
        }
        terminologyNames = terminologyNamesDecoded0
        let parallelDataNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .parallelDataNames)
        var parallelDataNamesDecoded0:[String]? = nil
        if let parallelDataNamesContainer = parallelDataNamesContainer {
            parallelDataNamesDecoded0 = [String]()
            for string0 in parallelDataNamesContainer {
                if let string0 = string0 {
                    parallelDataNamesDecoded0?.append(string0)
                }
            }
        }
        parallelDataNames = parallelDataNamesDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let submittedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submittedTime)
        submittedTime = submittedTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension TextTranslationJobProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextTranslationJobProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), endTime: \(String(describing: endTime)), inputDataConfig: \(String(describing: inputDataConfig)), jobDetails: \(String(describing: jobDetails)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), message: \(String(describing: message)), outputDataConfig: \(String(describing: outputDataConfig)), parallelDataNames: \(String(describing: parallelDataNames)), sourceLanguageCode: \(String(describing: sourceLanguageCode)), submittedTime: \(String(describing: submittedTime)), targetLanguageCodes: \(String(describing: targetLanguageCodes)), terminologyNames: \(String(describing: terminologyNames)))"}
}

/// <p>Provides information about a translation job.</p>
public struct TextTranslationJobProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an AWS Identity Access and Management (IAM) role
    ///       that granted Amazon Translate read access to the job's input data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The time at which the translation job ended.</p>
    public let endTime: Date?
    /// <p>The input configuration properties that were specified when the job was requested.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The number of documents successfully and unsuccessfully processed during the translation
    ///       job.</p>
    public let jobDetails: JobDetails?
    /// <p>The ID of the translation job.</p>
    public let jobId: String?
    /// <p>The user-defined name of the translation job.</p>
    public let jobName: String?
    /// <p>The status of the translation job.</p>
    public let jobStatus: JobStatus?
    /// <p>An explanation of any errors that may have occured during the translation job.</p>
    public let message: String?
    /// <p>The output configuration properties that were specified when the job was requested.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>A list containing the names of the parallel data resources applied to the translation
    ///       job.</p>
    public let parallelDataNames: [String]?
    /// <p>The language code of the language of the source text. The language must be a language
    ///       supported by Amazon Translate.</p>
    public let sourceLanguageCode: String?
    /// <p>The time at which the translation job was submitted.</p>
    public let submittedTime: Date?
    /// <p>The language code of the language of the target text. The language must be a language
    ///       supported by Amazon Translate.</p>
    public let targetLanguageCodes: [String]?
    /// <p>A list containing the names of the terminologies applied to a translation job. Only one
    ///       terminology can be applied per <a>StartTextTranslationJob</a> request at this
    ///       time.</p>
    public let terminologyNames: [String]?

    public init (
        dataAccessRoleArn: String? = nil,
        endTime: Date? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobDetails: JobDetails? = nil,
        jobId: String? = nil,
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        message: String? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        parallelDataNames: [String]? = nil,
        sourceLanguageCode: String? = nil,
        submittedTime: Date? = nil,
        targetLanguageCodes: [String]? = nil,
        terminologyNames: [String]? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.jobDetails = jobDetails
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.message = message
        self.outputDataConfig = outputDataConfig
        self.parallelDataNames = parallelDataNames
        self.sourceLanguageCode = sourceLanguageCode
        self.submittedTime = submittedTime
        self.targetLanguageCodes = targetLanguageCodes
        self.terminologyNames = terminologyNames
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> You have made too many requests within a short period of time. Wait for a short time and
///       then try your request again.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TranslateTextInputBodyMiddleware: Middleware {
    public let id: String = "TranslateTextInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TranslateTextInput>,
                  next: H) -> Swift.Result<OperationOutput<TranslateTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TranslateTextInput>
    public typealias MOutput = OperationOutput<TranslateTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TranslateTextOutputError>
}

extension TranslateTextInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TranslateTextInput(sourceLanguageCode: \(String(describing: sourceLanguageCode)), targetLanguageCode: \(String(describing: targetLanguageCode)), terminologyNames: \(String(describing: terminologyNames)), text: \(String(describing: text)))"}
}

extension TranslateTextInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCode = "TargetLanguageCode"
        case terminologyNames = "TerminologyNames"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceLanguageCode = sourceLanguageCode {
            try encodeContainer.encode(sourceLanguageCode, forKey: .sourceLanguageCode)
        }
        if let targetLanguageCode = targetLanguageCode {
            try encodeContainer.encode(targetLanguageCode, forKey: .targetLanguageCode)
        }
        if let terminologyNames = terminologyNames {
            var terminologyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terminologyNames)
            for resourcenamelist0 in terminologyNames {
                try terminologyNamesContainer.encode(resourcenamelist0)
            }
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct TranslateTextInputHeadersMiddleware: Middleware {
    public let id: String = "TranslateTextInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TranslateTextInput>,
                  next: H) -> Swift.Result<OperationOutput<TranslateTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TranslateTextInput>
    public typealias MOutput = OperationOutput<TranslateTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TranslateTextOutputError>
}

public struct TranslateTextInputQueryItemMiddleware: Middleware {
    public let id: String = "TranslateTextInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TranslateTextInput>,
                  next: H) -> Swift.Result<OperationOutput<TranslateTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TranslateTextInput>
    public typealias MOutput = OperationOutput<TranslateTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TranslateTextOutputError>
}

public struct TranslateTextInput: Equatable {
    /// <p>The language code for the language of the source text. The language must be a language
    ///       supported by Amazon Translate. For a list of language codes, see <a>what-is-languages</a>.</p>
    ///          <p>To have Amazon Translate determine the source language of your text, you can specify
    ///         <code>auto</code> in the <code>SourceLanguageCode</code> field. If you specify
    ///         <code>auto</code>, Amazon Translate will call <a href="https://docs.aws.amazon.com/comprehend/latest/dg/comprehend-general.html">Amazon
    ///         Comprehend</a> to determine the source language.</p>
    public let sourceLanguageCode: String?
    /// <p>The language code requested for the language of the target text. The language must be a
    ///       language supported by Amazon Translate.</p>
    public let targetLanguageCode: String?
    /// <p>The name of the terminology list file to be used in the TranslateText request. You can use
    ///       1 terminology list at most in a <code>TranslateText</code> request. Terminology lists can
    ///       contain a maximum of 256 terms.</p>
    public let terminologyNames: [String]?
    /// <p>The text to translate. The text string can be a maximum of 5,000 bytes long. Depending on
    ///       your character set, this may be fewer than 5,000 characters.</p>
    public let text: String?

    public init (
        sourceLanguageCode: String? = nil,
        targetLanguageCode: String? = nil,
        terminologyNames: [String]? = nil,
        text: String? = nil
    )
    {
        self.sourceLanguageCode = sourceLanguageCode
        self.targetLanguageCode = targetLanguageCode
        self.terminologyNames = terminologyNames
        self.text = text
    }
}

struct TranslateTextInputBody: Equatable {
    public let text: String?
    public let terminologyNames: [String]?
    public let sourceLanguageCode: String?
    public let targetLanguageCode: String?
}

extension TranslateTextInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCode = "TargetLanguageCode"
        case terminologyNames = "TerminologyNames"
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let terminologyNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .terminologyNames)
        var terminologyNamesDecoded0:[String]? = nil
        if let terminologyNamesContainer = terminologyNamesContainer {
            terminologyNamesDecoded0 = [String]()
            for string0 in terminologyNamesContainer {
                if let string0 = string0 {
                    terminologyNamesDecoded0?.append(string0)
                }
            }
        }
        terminologyNames = terminologyNamesDecoded0
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetLanguageCode)
        targetLanguageCode = targetLanguageCodeDecoded
    }
}

extension TranslateTextOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TranslateTextOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DetectedLanguageLowConfidenceException" : self = .detectedLanguageLowConfidenceException(try DetectedLanguageLowConfidenceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguagePairException" : self = .unsupportedLanguagePairException(try UnsupportedLanguagePairException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TranslateTextOutputError: Swift.Error, Equatable {
    case detectedLanguageLowConfidenceException(DetectedLanguageLowConfidenceException)
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unsupportedLanguagePairException(UnsupportedLanguagePairException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TranslateTextOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TranslateTextOutputResponse(appliedTerminologies: \(String(describing: appliedTerminologies)), sourceLanguageCode: \(String(describing: sourceLanguageCode)), targetLanguageCode: \(String(describing: targetLanguageCode)), translatedText: \(String(describing: translatedText)))"}
}

extension TranslateTextOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TranslateTextOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appliedTerminologies = output.appliedTerminologies
            self.sourceLanguageCode = output.sourceLanguageCode
            self.targetLanguageCode = output.targetLanguageCode
            self.translatedText = output.translatedText
        } else {
            self.appliedTerminologies = nil
            self.sourceLanguageCode = nil
            self.targetLanguageCode = nil
            self.translatedText = nil
        }
    }
}

public struct TranslateTextOutputResponse: Equatable {
    /// <p>The names of the custom terminologies applied to the input text by Amazon Translate for the
    ///       translated text response.</p>
    public let appliedTerminologies: [AppliedTerminology]?
    /// <p>The language code for the language of the source text.</p>
    public let sourceLanguageCode: String?
    /// <p>The language code for the language of the target text. </p>
    public let targetLanguageCode: String?
    /// <p>The translated text.</p>
    public let translatedText: String?

    public init (
        appliedTerminologies: [AppliedTerminology]? = nil,
        sourceLanguageCode: String? = nil,
        targetLanguageCode: String? = nil,
        translatedText: String? = nil
    )
    {
        self.appliedTerminologies = appliedTerminologies
        self.sourceLanguageCode = sourceLanguageCode
        self.targetLanguageCode = targetLanguageCode
        self.translatedText = translatedText
    }
}

struct TranslateTextOutputResponseBody: Equatable {
    public let translatedText: String?
    public let sourceLanguageCode: String?
    public let targetLanguageCode: String?
    public let appliedTerminologies: [AppliedTerminology]?
}

extension TranslateTextOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appliedTerminologies = "AppliedTerminologies"
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCode = "TargetLanguageCode"
        case translatedText = "TranslatedText"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let translatedTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .translatedText)
        translatedText = translatedTextDecoded
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetLanguageCode)
        targetLanguageCode = targetLanguageCodeDecoded
        let appliedTerminologiesContainer = try containerValues.decodeIfPresent([AppliedTerminology?].self, forKey: .appliedTerminologies)
        var appliedTerminologiesDecoded0:[AppliedTerminology]? = nil
        if let appliedTerminologiesContainer = appliedTerminologiesContainer {
            appliedTerminologiesDecoded0 = [AppliedTerminology]()
            for structure0 in appliedTerminologiesContainer {
                if let structure0 = structure0 {
                    appliedTerminologiesDecoded0?.append(structure0)
                }
            }
        }
        appliedTerminologies = appliedTerminologiesDecoded0
    }
}

extension UnsupportedLanguagePairException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedLanguagePairException(message: \(String(describing: message)), sourceLanguageCode: \(String(describing: sourceLanguageCode)), targetLanguageCode: \(String(describing: targetLanguageCode)))"}
}

extension UnsupportedLanguagePairException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedLanguagePairExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.sourceLanguageCode = output.sourceLanguageCode
            self.targetLanguageCode = output.targetLanguageCode
        } else {
            self.message = nil
            self.sourceLanguageCode = nil
            self.targetLanguageCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Translate does not support translation from the language of the source text into the requested
///       target language. For more information, see <a>how-to-error-msg</a>. </p>
public struct UnsupportedLanguagePairException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The language code for the language of the input text. </p>
    public var sourceLanguageCode: String?
    /// <p>The language code for the language of the translated text. </p>
    public var targetLanguageCode: String?

    public init (
        message: String? = nil,
        sourceLanguageCode: String? = nil,
        targetLanguageCode: String? = nil
    )
    {
        self.message = message
        self.sourceLanguageCode = sourceLanguageCode
        self.targetLanguageCode = targetLanguageCode
    }
}

struct UnsupportedLanguagePairExceptionBody: Equatable {
    public let message: String?
    public let sourceLanguageCode: String?
    public let targetLanguageCode: String?
}

extension UnsupportedLanguagePairExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCode = "TargetLanguageCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetLanguageCode)
        targetLanguageCode = targetLanguageCodeDecoded
    }
}

public struct UpdateParallelDataInputBodyMiddleware: Middleware {
    public let id: String = "UpdateParallelDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateParallelDataInput>
    public typealias MOutput = OperationOutput<UpdateParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateParallelDataOutputError>
}

extension UpdateParallelDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateParallelDataInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), name: \(String(describing: name)), parallelDataConfig: \(String(describing: parallelDataConfig)))"}
}

extension UpdateParallelDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case parallelDataConfig = "ParallelDataConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parallelDataConfig = parallelDataConfig {
            try encodeContainer.encode(parallelDataConfig, forKey: .parallelDataConfig)
        }
    }
}

public struct UpdateParallelDataInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateParallelDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateParallelDataInput>
    public typealias MOutput = OperationOutput<UpdateParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateParallelDataOutputError>
}

public struct UpdateParallelDataInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateParallelDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateParallelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateParallelDataInput>
    public typealias MOutput = OperationOutput<UpdateParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateParallelDataOutputError>
}

public struct UpdateParallelDataInput: Equatable {
    /// <p>A unique identifier for the request. This token is automatically generated when you use
    ///       Amazon Translate through an AWS SDK.</p>
    public var clientToken: String?
    /// <p>A custom description for the parallel data resource in Amazon Translate.</p>
    public let description: String?
    /// <p>The name of the parallel data resource being updated.</p>
    public let name: String?
    /// <p>Specifies the format and S3 location of the parallel data input file.</p>
    public let parallelDataConfig: ParallelDataConfig?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        name: String? = nil,
        parallelDataConfig: ParallelDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.parallelDataConfig = parallelDataConfig
    }
}

struct UpdateParallelDataInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let parallelDataConfig: ParallelDataConfig?
    public let clientToken: String?
}

extension UpdateParallelDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case parallelDataConfig = "ParallelDataConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parallelDataConfigDecoded = try containerValues.decodeIfPresent(ParallelDataConfig.self, forKey: .parallelDataConfig)
        parallelDataConfig = parallelDataConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateParallelDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateParallelDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateParallelDataOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateParallelDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateParallelDataOutputResponse(latestUpdateAttemptAt: \(String(describing: latestUpdateAttemptAt)), latestUpdateAttemptStatus: \(String(describing: latestUpdateAttemptStatus)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

extension UpdateParallelDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateParallelDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.latestUpdateAttemptAt = output.latestUpdateAttemptAt
            self.latestUpdateAttemptStatus = output.latestUpdateAttemptStatus
            self.name = output.name
            self.status = output.status
        } else {
            self.latestUpdateAttemptAt = nil
            self.latestUpdateAttemptStatus = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct UpdateParallelDataOutputResponse: Equatable {
    /// <p>The time that the most recent update was attempted.</p>
    public let latestUpdateAttemptAt: Date?
    /// <p>The status of the parallel data update attempt. When the updated parallel data resource is
    ///       ready for you to use, the status is <code>ACTIVE</code>.</p>
    public let latestUpdateAttemptStatus: ParallelDataStatus?
    /// <p>The name of the parallel data resource being updated.</p>
    public let name: String?
    /// <p>The status of the parallel data resource that you are attempting to update. Your update
    ///       request is accepted only if this status is either <code>ACTIVE</code> or
    ///       <code>FAILED</code>.</p>
    public let status: ParallelDataStatus?

    public init (
        latestUpdateAttemptAt: Date? = nil,
        latestUpdateAttemptStatus: ParallelDataStatus? = nil,
        name: String? = nil,
        status: ParallelDataStatus? = nil
    )
    {
        self.latestUpdateAttemptAt = latestUpdateAttemptAt
        self.latestUpdateAttemptStatus = latestUpdateAttemptStatus
        self.name = name
        self.status = status
    }
}

struct UpdateParallelDataOutputResponseBody: Equatable {
    public let name: String?
    public let status: ParallelDataStatus?
    public let latestUpdateAttemptStatus: ParallelDataStatus?
    public let latestUpdateAttemptAt: Date?
}

extension UpdateParallelDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case latestUpdateAttemptAt = "LatestUpdateAttemptAt"
        case latestUpdateAttemptStatus = "LatestUpdateAttemptStatus"
        case name = "Name"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ParallelDataStatus.self, forKey: .status)
        status = statusDecoded
        let latestUpdateAttemptStatusDecoded = try containerValues.decodeIfPresent(ParallelDataStatus.self, forKey: .latestUpdateAttemptStatus)
        latestUpdateAttemptStatus = latestUpdateAttemptStatusDecoded
        let latestUpdateAttemptAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestUpdateAttemptAt)
        latestUpdateAttemptAt = latestUpdateAttemptAtDecoded
    }
}
