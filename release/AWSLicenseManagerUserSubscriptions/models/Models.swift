// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// Details about an Active Directory identity provider.
    public struct ActiveDirectoryIdentityProvider: Swift.Equatable {
        /// The directory ID for an Active Directory identity provider.
        public var directoryId: Swift.String?

        public init (
            directoryId: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
        }
    }

}

extension AssociateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension AssociateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user/AssociateUser"
    }
}

public struct AssociateUserInput: Swift.Equatable {
    /// The domain name of the user.
    public var domain: Swift.String?
    /// The identity provider of the user.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The ID of the EC2 instance, which provides user-based subscriptions.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The user name from the identity provider for the user.
    /// This member is required.
    public var username: Swift.String?

    public init (
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        instanceId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.domain = domain
        self.identityProvider = identityProvider
        self.instanceId = instanceId
        self.username = username
    }
}

struct AssociateUserInputBody: Swift.Equatable {
    let username: Swift.String?
    let instanceId: Swift.String?
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let domain: Swift.String?
}

extension AssociateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension AssociateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceUserSummary = output.instanceUserSummary
        } else {
            self.instanceUserSummary = nil
        }
    }
}

public struct AssociateUserOutputResponse: Swift.Equatable {
    /// Metadata that describes the associate user operation.
    /// This member is required.
    public var instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?

    public init (
        instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary? = nil
    )
    {
        self.instanceUserSummary = instanceUserSummary
    }
}

struct AssociateUserOutputResponseBody: Swift.Equatable {
    let instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?
}

extension AssociateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUserSummary = "InstanceUserSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUserSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary.self, forKey: .instanceUserSummary)
        instanceUserSummary = instanceUserSummaryDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request couldn't be completed because it conflicted with the current state of the resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeregisterIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider = "IdentityProvider"
        case product = "Product"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
    }
}

extension DeregisterIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/identity-provider/DeregisterIdentityProvider"
    }
}

public struct DeregisterIdentityProviderInput: Swift.Equatable {
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?

    public init (
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil
    )
    {
        self.identityProvider = identityProvider
        self.product = product
    }
}

struct DeregisterIdentityProviderInputBody: Swift.Equatable {
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let product: Swift.String?
}

extension DeregisterIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider = "IdentityProvider"
        case product = "Product"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
    }
}

extension DeregisterIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeregisterIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderSummary = output.identityProviderSummary
        } else {
            self.identityProviderSummary = nil
        }
    }
}

public struct DeregisterIdentityProviderOutputResponse: Swift.Equatable {
    /// Metadata that describes the results of an identity provider operation.
    /// This member is required.
    public var identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?

    public init (
        identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary? = nil
    )
    {
        self.identityProviderSummary = identityProviderSummary
    }
}

struct DeregisterIdentityProviderOutputResponseBody: Swift.Equatable {
    let identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?
}

extension DeregisterIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderSummary = "IdentityProviderSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.self, forKey: .identityProviderSummary)
        identityProviderSummary = identityProviderSummaryDecoded
    }
}

extension DisassociateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension DisassociateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user/DisassociateUser"
    }
}

public struct DisassociateUserInput: Swift.Equatable {
    /// The domain name of the user.
    public var domain: Swift.String?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The ID of the EC2 instance, which provides user-based subscriptions.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The user name from the identity provider for the user.
    /// This member is required.
    public var username: Swift.String?

    public init (
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        instanceId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.domain = domain
        self.identityProvider = identityProvider
        self.instanceId = instanceId
        self.username = username
    }
}

struct DisassociateUserInputBody: Swift.Equatable {
    let username: Swift.String?
    let instanceId: Swift.String?
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let domain: Swift.String?
}

extension DisassociateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DisassociateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceUserSummary = output.instanceUserSummary
        } else {
            self.instanceUserSummary = nil
        }
    }
}

public struct DisassociateUserOutputResponse: Swift.Equatable {
    /// Metadata that describes the associate user operation.
    /// This member is required.
    public var instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?

    public init (
        instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary? = nil
    )
    {
        self.instanceUserSummary = instanceUserSummary
    }
}

struct DisassociateUserOutputResponseBody: Swift.Equatable {
    let instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?
}

extension DisassociateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUserSummary = "InstanceUserSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUserSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary.self, forKey: .instanceUserSummary)
        instanceUserSummary = instanceUserSummaryDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute = "Attribute"
        case operation = "Operation"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attribute)
        attribute = attributeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// A filter name and value pair that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.
    public struct Filter: Swift.Equatable {
        /// The name of an attribute to use as a filter.
        public var attribute: Swift.String?
        /// The type of search (For example, eq, geq, leq)
        public var operation: Swift.String?
        /// Value of the filter.
        public var value: Swift.String?

        public init (
            attribute: Swift.String? = nil,
            operation: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.attribute = attribute
            self.operation = operation
            self.value = value
        }
    }

}

extension LicenseManagerUserSubscriptionsClientTypes.IdentityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activedirectoryidentityprovider = "ActiveDirectoryIdentityProvider"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .activedirectoryidentityprovider(activedirectoryidentityprovider):
                try container.encode(activedirectoryidentityprovider, forKey: .activedirectoryidentityprovider)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let activedirectoryidentityproviderDecoded = try values.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider.self, forKey: .activedirectoryidentityprovider)
        if let activedirectoryidentityprovider = activedirectoryidentityproviderDecoded {
            self = .activedirectoryidentityprovider(activedirectoryidentityprovider)
            return
        }
        self = .sdkUnknown("")
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// Details about an identity provider.
    public enum IdentityProvider: Swift.Equatable {
        /// An object that details an Active Directory identity provider.
        case activedirectoryidentityprovider(LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider)
        case sdkUnknown(Swift.String)
    }

}

extension LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureMessage = "FailureMessage"
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case settings = "Settings"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// Describes an identity provider.
    public struct IdentityProviderSummary: Swift.Equatable {
        /// The failure message associated with an identity provider.
        public var failureMessage: Swift.String?
        /// An object that specifies details for the identity provider.
        /// This member is required.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The name of the user-based subscription product.
        /// This member is required.
        public var product: Swift.String?
        /// An object that details the registered identity providerâ€™s product related configuration settings such as the subnets to provision VPC endpoints.
        /// This member is required.
        public var settings: LicenseManagerUserSubscriptionsClientTypes.Settings?
        /// The status of an identity provider.
        /// This member is required.
        public var status: Swift.String?

        public init (
            failureMessage: Swift.String? = nil,
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            product: Swift.String? = nil,
            settings: LicenseManagerUserSubscriptionsClientTypes.Settings? = nil,
            status: Swift.String? = nil
        )
        {
            self.failureMessage = failureMessage
            self.identityProvider = identityProvider
            self.product = product
            self.settings = settings
            self.status = status
        }
    }

}

extension LicenseManagerUserSubscriptionsClientTypes.InstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case lastStatusCheckDate = "LastStatusCheckDate"
        case products = "Products"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let lastStatusCheckDate = self.lastStatusCheckDate {
            try encodeContainer.encode(lastStatusCheckDate, forKey: .lastStatusCheckDate)
        }
        if let products = products {
            var productsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .products)
            for string0 in products {
                try productsContainer.encode(string0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let productsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .products)
        var productsDecoded0:[Swift.String]? = nil
        if let productsContainer = productsContainer {
            productsDecoded0 = [Swift.String]()
            for string0 in productsContainer {
                if let string0 = string0 {
                    productsDecoded0?.append(string0)
                }
            }
        }
        products = productsDecoded0
        let lastStatusCheckDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastStatusCheckDate)
        lastStatusCheckDate = lastStatusCheckDateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// Describes an EC2 instance providing user-based subscriptions.
    public struct InstanceSummary: Swift.Equatable {
        /// The ID of the EC2 instance, which provides user-based subscriptions.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The date of the last status check.
        public var lastStatusCheckDate: Swift.String?
        /// A list of provided user-based subscription products.
        /// This member is required.
        public var products: [Swift.String]?
        /// The status of an EC2 instance resource.
        /// This member is required.
        public var status: Swift.String?
        /// The status message for an EC2 instance.
        public var statusMessage: Swift.String?

        public init (
            instanceId: Swift.String? = nil,
            lastStatusCheckDate: Swift.String? = nil,
            products: [Swift.String]? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
            self.lastStatusCheckDate = lastStatusCheckDate
            self.products = products
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationDate = "AssociationDate"
        case disassociationDate = "DisassociationDate"
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationDate = self.associationDate {
            try encodeContainer.encode(associationDate, forKey: .associationDate)
        }
        if let disassociationDate = self.disassociationDate {
            try encodeContainer.encode(disassociationDate, forKey: .disassociationDate)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let associationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationDate)
        associationDate = associationDateDecoded
        let disassociationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disassociationDate)
        disassociationDate = disassociationDateDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// Describes users of an EC2 instance providing user-based subscriptions.
    public struct InstanceUserSummary: Swift.Equatable {
        /// The date a user was associated with an EC2 instance.
        public var associationDate: Swift.String?
        /// The date a user was disassociated from an EC2 instance.
        public var disassociationDate: Swift.String?
        /// The domain name of the user.
        public var domain: Swift.String?
        /// An object that specifies details for the identity provider.
        /// This member is required.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The ID of the EC2 instance, which provides user-based subscriptions.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The status of a user associated with an EC2 instance.
        /// This member is required.
        public var status: Swift.String?
        /// The status message for users of an EC2 instance.
        public var statusMessage: Swift.String?
        /// The user name from the identity provider for the user.
        /// This member is required.
        public var username: Swift.String?

        public init (
            associationDate: Swift.String? = nil,
            disassociationDate: Swift.String? = nil,
            domain: Swift.String? = nil,
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            instanceId: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.associationDate = associationDate
            self.disassociationDate = disassociationDate
            self.domain = domain
            self.identityProvider = identityProvider
            self.instanceId = instanceId
            self.status = status
            self.statusMessage = statusMessage
            self.username = username
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception occurred with the service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListIdentityProvidersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListIdentityProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/identity-provider/ListIdentityProviders"
    }
}

public struct ListIdentityProvidersInput: Swift.Equatable {
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityProvidersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListIdentityProvidersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityProvidersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIdentityProvidersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListIdentityProvidersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentityProvidersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListIdentityProvidersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderSummaries = output.identityProviderSummaries
            self.nextToken = output.nextToken
        } else {
            self.identityProviderSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListIdentityProvidersOutputResponse: Swift.Equatable {
    /// Metadata that describes the list identity providers operation.
    /// This member is required.
    public var identityProviderSummaries: [LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        identityProviderSummaries: [LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityProviderSummaries = identityProviderSummaries
        self.nextToken = nextToken
    }
}

struct ListIdentityProvidersOutputResponseBody: Swift.Equatable {
    let identityProviderSummaries: [LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]?
    let nextToken: Swift.String?
}

extension ListIdentityProvidersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderSummaries = "IdentityProviderSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderSummariesContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?].self, forKey: .identityProviderSummaries)
        var identityProviderSummariesDecoded0:[LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]? = nil
        if let identityProviderSummariesContainer = identityProviderSummariesContainer {
            identityProviderSummariesDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]()
            for structure0 in identityProviderSummariesContainer {
                if let structure0 = structure0 {
                    identityProviderSummariesDecoded0?.append(structure0)
                }
            }
        }
        identityProviderSummaries = identityProviderSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/instance/ListInstances"
    }
}

public struct ListInstancesInput: Swift.Equatable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstancesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
}

extension ListInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListInstancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceSummaries = output.instanceSummaries
            self.nextToken = output.nextToken
        } else {
            self.instanceSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutputResponse: Swift.Equatable {
    /// Metadata that describes the list instances operation.
    public var instanceSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceSummaries = instanceSummaries
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputResponseBody: Swift.Equatable {
    let instanceSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]?
    let nextToken: Swift.String?
}

extension ListInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceSummaries = "InstanceSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceSummariesContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.InstanceSummary?].self, forKey: .instanceSummaries)
        var instanceSummariesDecoded0:[LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]? = nil
        if let instanceSummariesContainer = instanceSummariesContainer {
            instanceSummariesDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]()
            for structure0 in instanceSummariesContainer {
                if let structure0 = structure0 {
                    instanceSummariesDecoded0?.append(structure0)
                }
            }
        }
        instanceSummaries = instanceSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProductSubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityProvider = "IdentityProvider"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case product = "Product"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
    }
}

extension ListProductSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user/ListProductSubscriptions"
    }
}

public struct ListProductSubscriptionsInput: Swift.Equatable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?

    public init (
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        product: Swift.String? = nil
    )
    {
        self.filters = filters
        self.identityProvider = identityProvider
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.product = product
    }
}

struct ListProductSubscriptionsInputBody: Swift.Equatable {
    let product: Swift.String?
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let maxResults: Swift.Int?
    let filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    let nextToken: Swift.String?
}

extension ListProductSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityProvider = "IdentityProvider"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case product = "Product"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProductSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProductSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProductSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProductSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProductSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.productUserSummaries = output.productUserSummaries
        } else {
            self.nextToken = nil
            self.productUserSummaries = nil
        }
    }
}

public struct ListProductSubscriptionsOutputResponse: Swift.Equatable {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Metadata that describes the list product subscriptions operation.
    public var productUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]?

    public init (
        nextToken: Swift.String? = nil,
        productUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.productUserSummaries = productUserSummaries
    }
}

struct ListProductSubscriptionsOutputResponseBody: Swift.Equatable {
    let productUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]?
    let nextToken: Swift.String?
}

extension ListProductSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case productUserSummaries = "ProductUserSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productUserSummariesContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?].self, forKey: .productUserSummaries)
        var productUserSummariesDecoded0:[LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]? = nil
        if let productUserSummariesContainer = productUserSummariesContainer {
            productUserSummariesDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]()
            for structure0 in productUserSummariesContainer {
                if let structure0 = structure0 {
                    productUserSummariesDecoded0?.append(structure0)
                }
            }
        }
        productUserSummaries = productUserSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUserAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListUserAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user/ListUserAssociations"
    }
}

public struct ListUserAssociationsInput: Swift.Equatable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The ID of the EC2 instance, which provides user-based subscriptions.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.identityProvider = identityProvider
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserAssociationsInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let maxResults: Swift.Int?
    let filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    let nextToken: Swift.String?
}

extension ListUserAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUserAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUserAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUserAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceUserSummaries = output.instanceUserSummaries
            self.nextToken = output.nextToken
        } else {
            self.instanceUserSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListUserAssociationsOutputResponse: Swift.Equatable {
    /// Metadata that describes the list user association operation.
    public var instanceUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceUserSummaries = instanceUserSummaries
        self.nextToken = nextToken
    }
}

struct ListUserAssociationsOutputResponseBody: Swift.Equatable {
    let instanceUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]?
    let nextToken: Swift.String?
}

extension ListUserAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUserSummaries = "InstanceUserSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUserSummariesContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?].self, forKey: .instanceUserSummaries)
        var instanceUserSummariesDecoded0:[LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]? = nil
        if let instanceUserSummariesContainer = instanceUserSummariesContainer {
            instanceUserSummariesDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]()
            for structure0 in instanceUserSummariesContainer {
                if let structure0 = structure0 {
                    instanceUserSummariesDecoded0?.append(structure0)
                }
            }
        }
        instanceUserSummaries = instanceUserSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case subscriptionEndDate = "SubscriptionEndDate"
        case subscriptionStartDate = "SubscriptionStartDate"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let subscriptionEndDate = self.subscriptionEndDate {
            try encodeContainer.encode(subscriptionEndDate, forKey: .subscriptionEndDate)
        }
        if let subscriptionStartDate = self.subscriptionStartDate {
            try encodeContainer.encode(subscriptionStartDate, forKey: .subscriptionStartDate)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let subscriptionStartDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionStartDate)
        subscriptionStartDate = subscriptionStartDateDecoded
        let subscriptionEndDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionEndDate)
        subscriptionEndDate = subscriptionEndDateDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// The summary of the user-based subscription products for a user.
    public struct ProductUserSummary: Swift.Equatable {
        /// The domain name of the user.
        public var domain: Swift.String?
        /// An object that specifies details for the identity provider.
        /// This member is required.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The name of the user-based subscription product.
        /// This member is required.
        public var product: Swift.String?
        /// The status of a product for a user.
        /// This member is required.
        public var status: Swift.String?
        /// The status message for a product for a user.
        public var statusMessage: Swift.String?
        /// The end date of a subscription.
        public var subscriptionEndDate: Swift.String?
        /// The start date of a subscription.
        public var subscriptionStartDate: Swift.String?
        /// The user name from the identity provider of the user.
        /// This member is required.
        public var username: Swift.String?

        public init (
            domain: Swift.String? = nil,
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            product: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            subscriptionEndDate: Swift.String? = nil,
            subscriptionStartDate: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.domain = domain
            self.identityProvider = identityProvider
            self.product = product
            self.status = status
            self.statusMessage = statusMessage
            self.subscriptionEndDate = subscriptionEndDate
            self.subscriptionStartDate = subscriptionStartDate
            self.username = username
        }
    }

}

extension RegisterIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case settings = "Settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }
}

extension RegisterIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/identity-provider/RegisterIdentityProvider"
    }
}

public struct RegisterIdentityProviderInput: Swift.Equatable {
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?
    /// The registered identity providerâ€™s product related configuration settings such as the subnets to provision VPC endpoints.
    public var settings: LicenseManagerUserSubscriptionsClientTypes.Settings?

    public init (
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        settings: LicenseManagerUserSubscriptionsClientTypes.Settings? = nil
    )
    {
        self.identityProvider = identityProvider
        self.product = product
        self.settings = settings
    }
}

struct RegisterIdentityProviderInputBody: Swift.Equatable {
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let product: Swift.String?
    let settings: LicenseManagerUserSubscriptionsClientTypes.Settings?
}

extension RegisterIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case settings = "Settings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension RegisterIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegisterIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderSummary = output.identityProviderSummary
        } else {
            self.identityProviderSummary = nil
        }
    }
}

public struct RegisterIdentityProviderOutputResponse: Swift.Equatable {
    /// Metadata that describes the results of an identity provider operation.
    /// This member is required.
    public var identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?

    public init (
        identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary? = nil
    )
    {
        self.identityProviderSummary = identityProviderSummary
    }
}

struct RegisterIdentityProviderOutputResponseBody: Swift.Equatable {
    let identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?
}

extension RegisterIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderSummary = "IdentityProviderSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.self, forKey: .identityProviderSummary)
        identityProviderSummary = identityProviderSummaryDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource couldn't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because a service quota is exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupId = "SecurityGroupId"
        case subnets = "Subnets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupId = self.securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnet0 in subnets {
                try subnetsContainer.encode(subnet0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// The registered identity providerâ€™s product related configuration settings such as the subnets to provision VPC endpoints, and the security group ID that is associated with the VPC endpoints. The security group should permit inbound TCP port 1688 communication from resources in the VPC.
    public struct Settings: Swift.Equatable {
        /// A security group ID that allows inbound TCP port 1688 communication between resources in your VPC and the VPC endpoint for activation servers.
        /// This member is required.
        public var securityGroupId: Swift.String?
        /// The subnets defined for the registered identity provider.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init (
            securityGroupId: Swift.String? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.securityGroupId = securityGroupId
            self.subnets = subnets
        }
    }

}

extension StartProductSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension StartProductSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user/StartProductSubscription"
    }
}

public struct StartProductSubscriptionInput: Swift.Equatable {
    /// The domain name of the user.
    public var domain: Swift.String?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?
    /// The user name from the identity provider of the user.
    /// This member is required.
    public var username: Swift.String?

    public init (
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.domain = domain
        self.identityProvider = identityProvider
        self.product = product
        self.username = username
    }
}

struct StartProductSubscriptionInputBody: Swift.Equatable {
    let username: Swift.String?
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let product: Swift.String?
    let domain: Swift.String?
}

extension StartProductSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension StartProductSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartProductSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartProductSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartProductSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartProductSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.productUserSummary = output.productUserSummary
        } else {
            self.productUserSummary = nil
        }
    }
}

public struct StartProductSubscriptionOutputResponse: Swift.Equatable {
    /// Metadata that describes the start product subscription operation.
    /// This member is required.
    public var productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?

    public init (
        productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary? = nil
    )
    {
        self.productUserSummary = productUserSummary
    }
}

struct StartProductSubscriptionOutputResponseBody: Swift.Equatable {
    let productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?
}

extension StartProductSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productUserSummary = "ProductUserSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productUserSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary.self, forKey: .productUserSummary)
        productUserSummary = productUserSummaryDecoded
    }
}

extension StopProductSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension StopProductSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user/StopProductSubscription"
    }
}

public struct StopProductSubscriptionInput: Swift.Equatable {
    /// The domain name of the user.
    public var domain: Swift.String?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?
    /// The user name from the identity provider for the user.
    /// This member is required.
    public var username: Swift.String?

    public init (
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.domain = domain
        self.identityProvider = identityProvider
        self.product = product
        self.username = username
    }
}

struct StopProductSubscriptionInputBody: Swift.Equatable {
    let username: Swift.String?
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let product: Swift.String?
    let domain: Swift.String?
}

extension StopProductSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension StopProductSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopProductSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopProductSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopProductSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopProductSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.productUserSummary = output.productUserSummary
        } else {
            self.productUserSummary = nil
        }
    }
}

public struct StopProductSubscriptionOutputResponse: Swift.Equatable {
    /// Metadata that describes the start product subscription operation.
    /// This member is required.
    public var productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?

    public init (
        productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary? = nil
    )
    {
        self.productUserSummary = productUserSummary
    }
}

struct StopProductSubscriptionOutputResponseBody: Swift.Equatable {
    let productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?
}

extension StopProductSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productUserSummary = "ProductUserSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productUserSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary.self, forKey: .productUserSummary)
        productUserSummary = productUserSummaryDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because of request throttling. Retry the request.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateIdentityProviderSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case updateSettings = "UpdateSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let updateSettings = self.updateSettings {
            try encodeContainer.encode(updateSettings, forKey: .updateSettings)
        }
    }
}

extension UpdateIdentityProviderSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/identity-provider/UpdateIdentityProviderSettings"
    }
}

public struct UpdateIdentityProviderSettingsInput: Swift.Equatable {
    /// Details about an identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?
    /// Updates the registered identity providerâ€™s product related configuration settings. You can update any combination of settings in a single operation such as the:
    ///
    /// * Subnets which you want to add to provision VPC endpoints.
    ///
    /// * Subnets which you want to remove the VPC endpoints from.
    ///
    /// * Security group ID which permits traffic to the VPC endpoints.
    /// This member is required.
    public var updateSettings: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings?

    public init (
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        updateSettings: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings? = nil
    )
    {
        self.identityProvider = identityProvider
        self.product = product
        self.updateSettings = updateSettings
    }
}

struct UpdateIdentityProviderSettingsInputBody: Swift.Equatable {
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let product: Swift.String?
    let updateSettings: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings?
}

extension UpdateIdentityProviderSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case updateSettings = "UpdateSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let updateSettingsDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.UpdateSettings.self, forKey: .updateSettings)
        updateSettings = updateSettingsDecoded
    }
}

extension UpdateIdentityProviderSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIdentityProviderSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateIdentityProviderSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIdentityProviderSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateIdentityProviderSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderSummary = output.identityProviderSummary
        } else {
            self.identityProviderSummary = nil
        }
    }
}

public struct UpdateIdentityProviderSettingsOutputResponse: Swift.Equatable {
    /// Describes an identity provider.
    /// This member is required.
    public var identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?

    public init (
        identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary? = nil
    )
    {
        self.identityProviderSummary = identityProviderSummary
    }
}

struct UpdateIdentityProviderSettingsOutputResponseBody: Swift.Equatable {
    let identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?
}

extension UpdateIdentityProviderSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderSummary = "IdentityProviderSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.self, forKey: .identityProviderSummary)
        identityProviderSummary = identityProviderSummaryDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.UpdateSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addSubnets = "AddSubnets"
        case removeSubnets = "RemoveSubnets"
        case securityGroupId = "SecurityGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addSubnets = addSubnets {
            var addSubnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addSubnets)
            for subnet0 in addSubnets {
                try addSubnetsContainer.encode(subnet0)
            }
        }
        if let removeSubnets = removeSubnets {
            var removeSubnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeSubnets)
            for subnet0 in removeSubnets {
                try removeSubnetsContainer.encode(subnet0)
            }
        }
        if let securityGroupId = self.securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addSubnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .addSubnets)
        var addSubnetsDecoded0:[Swift.String]? = nil
        if let addSubnetsContainer = addSubnetsContainer {
            addSubnetsDecoded0 = [Swift.String]()
            for string0 in addSubnetsContainer {
                if let string0 = string0 {
                    addSubnetsDecoded0?.append(string0)
                }
            }
        }
        addSubnets = addSubnetsDecoded0
        let removeSubnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeSubnets)
        var removeSubnetsDecoded0:[Swift.String]? = nil
        if let removeSubnetsContainer = removeSubnetsContainer {
            removeSubnetsDecoded0 = [Swift.String]()
            for string0 in removeSubnetsContainer {
                if let string0 = string0 {
                    removeSubnetsDecoded0?.append(string0)
                }
            }
        }
        removeSubnets = removeSubnetsDecoded0
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// Updates the registered identity providerâ€™s product related configuration settings such as the subnets to provision VPC endpoints.
    public struct UpdateSettings: Swift.Equatable {
        /// The ID of one or more subnets in which License Manager will create a VPC endpoint for products that require connectivity to activation servers.
        /// This member is required.
        public var addSubnets: [Swift.String]?
        /// The ID of one or more subnets to remove.
        /// This member is required.
        public var removeSubnets: [Swift.String]?
        /// A security group ID that allows inbound TCP port 1688 communication between resources in your VPC and the VPC endpoints for activation servers.
        public var securityGroupId: Swift.String?

        public init (
            addSubnets: [Swift.String]? = nil,
            removeSubnets: [Swift.String]? = nil,
            securityGroupId: Swift.String? = nil
        )
        {
            self.addSubnets = addSubnets
            self.removeSubnets = removeSubnets
            self.securityGroupId = securityGroupId
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A parameter is not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
