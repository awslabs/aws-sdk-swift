// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DataPoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timestamp = "Timestamp"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension DataPoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataPoint(timestamp: \(String(describing: timestamp)), value: \(String(describing: value)))"}
}

/// <p>The forecast value for a specific date. Part of the <a>Forecast</a>
///       object.</p>
public struct DataPoint: Equatable {
    /// <p>The timestamp of the specific forecast.</p>
    public let timestamp: String?
    /// <p>The forecast value.</p>
    public let value: Double?

    public init (
        timestamp: String? = nil,
        value: Double? = nil
    )
    {
        self.timestamp = timestamp
        self.value = value
    }
}

extension Forecast: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case predictions = "Predictions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictions = predictions {
            var predictionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .predictions)
            for (dictKey0, predictions0) in predictions {
                try predictionsContainer.encode(predictions0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictionsContainer = try containerValues.decodeIfPresent([String: [DataPoint?]?].self, forKey: .predictions)
        var predictionsDecoded0: [String:[DataPoint]]? = nil
        if let predictionsContainer = predictionsContainer {
            predictionsDecoded0 = [String:[DataPoint]]()
            for (key0, timeseries0) in predictionsContainer {
                var timeseries0Decoded0: [DataPoint]? = nil
                if let timeseries0 = timeseries0 {
                    timeseries0Decoded0 = [DataPoint]()
                    for structure1 in timeseries0 {
                        if let structure1 = structure1 {
                            timeseries0Decoded0?.append(structure1)
                        }
                    }
                }
                predictionsDecoded0?[key0] = timeseries0Decoded0
            }
        }
        predictions = predictionsDecoded0
    }
}

extension Forecast: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Forecast(predictions: \(String(describing: predictions)))"}
}

/// <p>Provides information about a forecast. Returned as part of the <a>QueryForecast</a> response.</p>
public struct Forecast: Equatable {
    /// <p>The forecast.</p>
    ///          <p>The <i>string</i> of the string-to-array map is one of the following
    ///       values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>p10</p>
    ///             </li>
    ///             <li>
    ///                <p>p50</p>
    ///             </li>
    ///             <li>
    ///                <p>p90</p>
    ///             </li>
    ///          </ul>
    public let predictions: [String:[DataPoint]]?

    public init (
        predictions: [String:[DataPoint]]? = nil
    )
    {
        self.predictions = predictions
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value is invalid or is too long.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The token is not valid. Tokens expire after 24 hours.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The limit on the number of requests per second has been exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct QueryForecastInputBodyMiddleware: Middleware {
    public let id: String = "QueryForecastInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryForecastInput>
    public typealias MOutput = OperationOutput<QueryForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryForecastOutputError>
}

extension QueryForecastInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryForecastInput(endDate: \(String(describing: endDate)), filters: \(String(describing: filters)), forecastArn: \(String(describing: forecastArn)), nextToken: \(String(describing: nextToken)), startDate: \(String(describing: startDate)))"}
}

extension QueryForecastInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endDate = "EndDate"
        case filters = "Filters"
        case forecastArn = "ForecastArn"
        case nextToken = "NextToken"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filters)
            for (dictKey0, filters0) in filters {
                try filtersContainer.encode(filters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }
}

public struct QueryForecastInputHeadersMiddleware: Middleware {
    public let id: String = "QueryForecastInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryForecastInput>
    public typealias MOutput = OperationOutput<QueryForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryForecastOutputError>
}

public struct QueryForecastInputQueryItemMiddleware: Middleware {
    public let id: String = "QueryForecastInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryForecastInput>
    public typealias MOutput = OperationOutput<QueryForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryForecastOutputError>
}

public struct QueryForecastInput: Equatable {
    /// <p>The end date for the forecast. Specify the date using this format: yyyy-MM-dd'T'HH:mm:ss
    ///       (ISO 8601 format). For example, 2015-01-01T20:00:00. </p>
    public let endDate: String?
    /// <p>The filtering criteria to apply when retrieving the forecast. For example, to get the
    ///       forecast for <code>client_21</code> in the electricity usage dataset, specify the
    ///       following:</p>
    ///          <p>
    ///             <code>{"item_id" : "client_21"}</code>
    ///          </p>
    ///
    ///
    ///          <p>To get the full forecast, use the <a href="https://docs.aws.amazon.com/en_us/forecast/latest/dg/API_CreateForecastExportJob.html">CreateForecastExportJob</a> operation.</p>
    public let filters: [String:String]?
    /// <p>The Amazon Resource Name (ARN) of the forecast to query.</p>
    public let forecastArn: String?
    /// <p>If the result of the previous request was truncated, the response includes a
    ///         <code>NextToken</code>. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.</p>
    public let nextToken: String?
    /// <p>The start date for the forecast. Specify the date using this format: yyyy-MM-dd'T'HH:mm:ss
    ///       (ISO 8601 format). For example, 2015-01-01T08:00:00.</p>
    public let startDate: String?

    public init (
        endDate: String? = nil,
        filters: [String:String]? = nil,
        forecastArn: String? = nil,
        nextToken: String? = nil,
        startDate: String? = nil
    )
    {
        self.endDate = endDate
        self.filters = filters
        self.forecastArn = forecastArn
        self.nextToken = nextToken
        self.startDate = startDate
    }
}

struct QueryForecastInputBody: Equatable {
    public let forecastArn: String?
    public let startDate: String?
    public let endDate: String?
    public let filters: [String:String]?
    public let nextToken: String?
}

extension QueryForecastInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endDate = "EndDate"
        case filters = "Filters"
        case forecastArn = "ForecastArn"
        case nextToken = "NextToken"
        case startDate = "StartDate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDate)
        endDate = endDateDecoded
        let filtersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .filters)
        var filtersDecoded0: [String:String]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [String:String]()
            for (key0, attributevalue0) in filtersContainer {
                if let attributevalue0 = attributevalue0 {
                    filtersDecoded0?[key0] = attributevalue0
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension QueryForecastOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension QueryForecastOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum QueryForecastOutputError: Swift.Error, Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension QueryForecastOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryForecastOutputResponse(forecast: \(String(describing: forecast)))"}
}

extension QueryForecastOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: QueryForecastOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecast = output.forecast
        } else {
            self.forecast = nil
        }
    }
}

public struct QueryForecastOutputResponse: Equatable {
    /// <p>The forecast.</p>
    public let forecast: Forecast?

    public init (
        forecast: Forecast? = nil
    )
    {
        self.forecast = forecast
    }
}

struct QueryForecastOutputResponseBody: Equatable {
    public let forecast: Forecast?
}

extension QueryForecastOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forecast = "Forecast"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastDecoded = try containerValues.decodeIfPresent(Forecast.self, forKey: .forecast)
        forecast = forecastDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource is in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We can't find that resource. Check the information that you've provided and try
///       again.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
