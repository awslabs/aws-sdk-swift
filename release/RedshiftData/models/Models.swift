// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActiveStatementsExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveStatementsExceededException(message: \(String(describing: message)))"}
}

extension ActiveStatementsExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ActiveStatementsExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of active statements exceeds the limit.</p>
public struct ActiveStatementsExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ActiveStatementsExceededExceptionBody: Equatable {
    public let message: String?
}

extension ActiveStatementsExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelStatementInputBodyMiddleware: Middleware {
    public let id: String = "CancelStatementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelStatementInput>
    public typealias MOutput = OperationOutput<CancelStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelStatementOutputError>
}

extension CancelStatementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelStatementInput(id: \(String(describing: id)))"}
}

extension CancelStatementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct CancelStatementInputHeadersMiddleware: Middleware {
    public let id: String = "CancelStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelStatementInput>
    public typealias MOutput = OperationOutput<CancelStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelStatementOutputError>
}

public struct CancelStatementInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelStatementInput>
    public typealias MOutput = OperationOutput<CancelStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelStatementOutputError>
}

public struct CancelStatementInput: Equatable {
    /// <p>The identifier of the SQL statement to cancel. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
    ///       This identifier is returned by <code>ExecuteStatment</code> and <code>ListStatements</code>. </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct CancelStatementInputBody: Equatable {
    public let id: String?
}

extension CancelStatementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension CancelStatementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelStatementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelStatementOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelStatementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelStatementOutputResponse(status: \(String(describing: status)))"}
}

extension CancelStatementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelStatementOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CancelStatementOutputResponse: Equatable {
    /// <p>A value that indicates whether the cancel statement succeeded (true). </p>
    public let status: Bool?

    public init (
        status: Bool? = nil
    )
    {
        self.status = status
    }
}

struct CancelStatementOutputResponseBody: Equatable {
    public let status: Bool?
}

extension CancelStatementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .status)
        status = statusDecoded
    }
}

extension ColumnMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnDefault
        case isCaseSensitive
        case isCurrency
        case isSigned
        case label
        case length
        case name
        case nullable
        case precision
        case scale
        case schemaName
        case tableName
        case typeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnDefault = columnDefault {
            try encodeContainer.encode(columnDefault, forKey: .columnDefault)
        }
        if isCaseSensitive != false {
            try encodeContainer.encode(isCaseSensitive, forKey: .isCaseSensitive)
        }
        if isCurrency != false {
            try encodeContainer.encode(isCurrency, forKey: .isCurrency)
        }
        if isSigned != false {
            try encodeContainer.encode(isSigned, forKey: .isSigned)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if length != 0 {
            try encodeContainer.encode(length, forKey: .length)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if nullable != 0 {
            try encodeContainer.encode(nullable, forKey: .nullable)
        }
        if precision != 0 {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if scale != 0 {
            try encodeContainer.encode(scale, forKey: .scale)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isCaseSensitiveDecoded = try containerValues.decode(Bool.self, forKey: .isCaseSensitive)
        isCaseSensitive = isCaseSensitiveDecoded
        let isCurrencyDecoded = try containerValues.decode(Bool.self, forKey: .isCurrency)
        isCurrency = isCurrencyDecoded
        let isSignedDecoded = try containerValues.decode(Bool.self, forKey: .isSigned)
        isSigned = isSignedDecoded
        let labelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .label)
        label = labelDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let nullableDecoded = try containerValues.decode(Int.self, forKey: .nullable)
        nullable = nullableDecoded
        let precisionDecoded = try containerValues.decode(Int.self, forKey: .precision)
        precision = precisionDecoded
        let scaleDecoded = try containerValues.decode(Int.self, forKey: .scale)
        scale = scaleDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let lengthDecoded = try containerValues.decode(Int.self, forKey: .length)
        length = lengthDecoded
        let columnDefaultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnDefault)
        columnDefault = columnDefaultDecoded
    }
}

extension ColumnMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnMetadata(columnDefault: \(String(describing: columnDefault)), isCaseSensitive: \(String(describing: isCaseSensitive)), isCurrency: \(String(describing: isCurrency)), isSigned: \(String(describing: isSigned)), label: \(String(describing: label)), length: \(String(describing: length)), name: \(String(describing: name)), nullable: \(String(describing: nullable)), precision: \(String(describing: precision)), scale: \(String(describing: scale)), schemaName: \(String(describing: schemaName)), tableName: \(String(describing: tableName)), typeName: \(String(describing: typeName)))"}
}

/// <p>The properties (metadata) of a column. </p>
public struct ColumnMetadata: Equatable {
    /// <p>The default value of the column. </p>
    public let columnDefault: String?
    /// <p>A value that indicates whether the column is case-sensitive. </p>
    public let isCaseSensitive: Bool
    /// <p>A value that indicates whether the column contains currency values.</p>
    public let isCurrency: Bool
    /// <p>A value that indicates whether an integer column is signed.</p>
    public let isSigned: Bool
    /// <p>The label for the column. </p>
    public let label: String?
    /// <p>The length of the column.</p>
    public let length: Int
    /// <p>The name of the column. </p>
    public let name: String?
    /// <p>A value that indicates whether the column is nullable. </p>
    public let nullable: Int
    /// <p>The precision value of a decimal number column. </p>
    public let precision: Int
    /// <p>The scale value of a decimal number column. </p>
    public let scale: Int
    /// <p>The name of the schema that contains the table that includes the column.</p>
    public let schemaName: String?
    /// <p>The name of the table that includes the column. </p>
    public let tableName: String?
    /// <p>The database-specific data type of the column. </p>
    public let typeName: String?

    public init (
        columnDefault: String? = nil,
        isCaseSensitive: Bool = false,
        isCurrency: Bool = false,
        isSigned: Bool = false,
        label: String? = nil,
        length: Int = 0,
        name: String? = nil,
        nullable: Int = 0,
        precision: Int = 0,
        scale: Int = 0,
        schemaName: String? = nil,
        tableName: String? = nil,
        typeName: String? = nil
    )
    {
        self.columnDefault = columnDefault
        self.isCaseSensitive = isCaseSensitive
        self.isCurrency = isCurrency
        self.isSigned = isSigned
        self.label = label
        self.length = length
        self.name = name
        self.nullable = nullable
        self.precision = precision
        self.scale = scale
        self.schemaName = schemaName
        self.tableName = tableName
        self.typeName = typeName
    }
}

public struct DescribeStatementInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStatementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStatementInput>
    public typealias MOutput = OperationOutput<DescribeStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStatementOutputError>
}

extension DescribeStatementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStatementInput(id: \(String(describing: id)))"}
}

extension DescribeStatementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribeStatementInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStatementInput>
    public typealias MOutput = OperationOutput<DescribeStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStatementOutputError>
}

public struct DescribeStatementInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStatementInput>
    public typealias MOutput = OperationOutput<DescribeStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStatementOutputError>
}

public struct DescribeStatementInput: Equatable {
    /// <p>The identifier of the SQL statement to describe. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
    ///        This identifier is returned by <code>ExecuteStatment</code> and <code>ListStatements</code>. </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeStatementInputBody: Equatable {
    public let id: String?
}

extension DescribeStatementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeStatementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStatementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStatementOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStatementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStatementOutputResponse(clusterIdentifier: \(String(describing: clusterIdentifier)), createdAt: \(String(describing: createdAt)), database: \(String(describing: database)), dbUser: \(String(describing: dbUser)), duration: \(String(describing: duration)), error: \(String(describing: error)), hasResultSet: \(String(describing: hasResultSet)), id: \(String(describing: id)), queryString: \(String(describing: queryString)), redshiftPid: \(String(describing: redshiftPid)), redshiftQueryId: \(String(describing: redshiftQueryId)), resultRows: \(String(describing: resultRows)), resultSize: \(String(describing: resultSize)), secretArn: \(String(describing: secretArn)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

extension DescribeStatementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStatementOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterIdentifier = output.clusterIdentifier
            self.createdAt = output.createdAt
            self.database = output.database
            self.dbUser = output.dbUser
            self.duration = output.duration
            self.error = output.error
            self.hasResultSet = output.hasResultSet
            self.id = output.id
            self.queryString = output.queryString
            self.redshiftPid = output.redshiftPid
            self.redshiftQueryId = output.redshiftQueryId
            self.resultRows = output.resultRows
            self.resultSize = output.resultSize
            self.secretArn = output.secretArn
            self.status = output.status
            self.updatedAt = output.updatedAt
        } else {
            self.clusterIdentifier = nil
            self.createdAt = nil
            self.database = nil
            self.dbUser = nil
            self.duration = 0
            self.error = nil
            self.hasResultSet = nil
            self.id = nil
            self.queryString = nil
            self.redshiftPid = 0
            self.redshiftQueryId = 0
            self.resultRows = 0
            self.resultSize = 0
            self.secretArn = nil
            self.status = nil
            self.updatedAt = nil
        }
    }
}

public struct DescribeStatementOutputResponse: Equatable {
    /// <p>The cluster identifier. </p>
    public let clusterIdentifier: String?
    /// <p>The date and time (UTC) when the SQL statement was submitted to run. </p>
    public let createdAt: Date?
    /// <p>The name of the database. </p>
    public let database: String?
    /// <p>The database user name. </p>
    public let dbUser: String?
    /// <p>The amount of time in nanoseconds that the statement ran. </p>
    public let duration: Int
    /// <p>The error message from the cluster if the SQL statement encountered an error while running. </p>
    public let error: String?
    /// <p>A value that indicates whether the statement has a result set. The result set can be empty. </p>
    public let hasResultSet: Bool?
    /// <p>The identifier of the SQL statement described. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. </p>
    public let id: String?
    /// <p>The SQL statement text. </p>
    public let queryString: String?
    /// <p>The process identifier from Amazon Redshift. </p>
    public let redshiftPid: Int
    /// <p>The identifier of the query generated by Amazon Redshift.
    ///       These identifiers are also available in the <code>query</code> column of the <code>STL_QUERY</code> system view. </p>
    public let redshiftQueryId: Int
    /// <p>Either the number of rows returned from the SQL statement or the number of rows affected.
    ///        If result size is greater than zero, the result rows can be the number of rows affected by SQL statements such as INSERT, UPDATE, DELETE, COPY, and others. </p>
    public let resultRows: Int
    /// <p>The size in bytes of the returned results. </p>
    public let resultSize: Int
    /// <p>The name or Amazon Resource Name (ARN) of the secret that enables access to the database. </p>
    public let secretArn: String?
    /// <p>The status of the SQL statement being described. Status values are defined as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>ABORTED - The query run was stopped by the user. </p>
    ///             </li>
    ///             <li>
    ///                <p>ALL -  A status value that includes all query statuses. This value can be used to filter results. </p>
    ///             </li>
    ///             <li>
    ///                <p>FAILED - The query run failed. </p>
    ///             </li>
    ///             <li>
    ///                <p>FINISHED - The query has finished running. </p>
    ///             </li>
    ///             <li>
    ///                <p>PICKED - The query has been chosen to be run. </p>
    ///             </li>
    ///             <li>
    ///                <p>STARTED - The query run has started. </p>
    ///             </li>
    ///             <li>
    ///                <p>SUBMITTED - The query was submitted, but not yet processed. </p>
    ///             </li>
    ///          </ul>
    public let status: StatusString?
    /// <p>The date and time (UTC) that the metadata for the SQL statement was last updated. An
    ///       example is the time the status last changed. </p>
    public let updatedAt: Date?

    public init (
        clusterIdentifier: String? = nil,
        createdAt: Date? = nil,
        database: String? = nil,
        dbUser: String? = nil,
        duration: Int = 0,
        error: String? = nil,
        hasResultSet: Bool? = nil,
        id: String? = nil,
        queryString: String? = nil,
        redshiftPid: Int = 0,
        redshiftQueryId: Int = 0,
        resultRows: Int = 0,
        resultSize: Int = 0,
        secretArn: String? = nil,
        status: StatusString? = nil,
        updatedAt: Date? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.createdAt = createdAt
        self.database = database
        self.dbUser = dbUser
        self.duration = duration
        self.error = error
        self.hasResultSet = hasResultSet
        self.id = id
        self.queryString = queryString
        self.redshiftPid = redshiftPid
        self.redshiftQueryId = redshiftQueryId
        self.resultRows = resultRows
        self.resultSize = resultSize
        self.secretArn = secretArn
        self.status = status
        self.updatedAt = updatedAt
    }
}

struct DescribeStatementOutputResponseBody: Equatable {
    public let id: String?
    public let queryString: String?
    public let secretArn: String?
    public let dbUser: String?
    public let database: String?
    public let clusterIdentifier: String?
    public let resultRows: Int
    public let resultSize: Int
    public let duration: Int
    public let error: String?
    public let status: StatusString?
    public let createdAt: Date?
    public let updatedAt: Date?
    public let redshiftQueryId: Int
    public let redshiftPid: Int
    public let hasResultSet: Bool?
}

extension DescribeStatementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case createdAt = "CreatedAt"
        case database = "Database"
        case dbUser = "DbUser"
        case duration = "Duration"
        case error = "Error"
        case hasResultSet = "HasResultSet"
        case id = "Id"
        case queryString = "QueryString"
        case redshiftPid = "RedshiftPid"
        case redshiftQueryId = "RedshiftQueryId"
        case resultRows = "ResultRows"
        case resultSize = "ResultSize"
        case secretArn = "SecretArn"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let resultRowsDecoded = try containerValues.decode(Int.self, forKey: .resultRows)
        resultRows = resultRowsDecoded
        let resultSizeDecoded = try containerValues.decode(Int.self, forKey: .resultSize)
        resultSize = resultSizeDecoded
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusString.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let redshiftQueryIdDecoded = try containerValues.decode(Int.self, forKey: .redshiftQueryId)
        redshiftQueryId = redshiftQueryIdDecoded
        let redshiftPidDecoded = try containerValues.decode(Int.self, forKey: .redshiftPid)
        redshiftPid = redshiftPidDecoded
        let hasResultSetDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasResultSet)
        hasResultSet = hasResultSetDecoded
    }
}

public struct DescribeTableInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableInput>
    public typealias MOutput = OperationOutput<DescribeTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableOutputError>
}

extension DescribeTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTableInput(clusterIdentifier: \(String(describing: clusterIdentifier)), connectedDatabase: \(String(describing: connectedDatabase)), database: \(String(describing: database)), dbUser: \(String(describing: dbUser)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), schema: \(String(describing: schema)), secretArn: \(String(describing: secretArn)), table: \(String(describing: table)))"}
}

extension DescribeTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case connectedDatabase = "ConnectedDatabase"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schema = "Schema"
        case secretArn = "SecretArn"
        case table = "Table"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterIdentifier = clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let connectedDatabase = connectedDatabase {
            try encodeContainer.encode(connectedDatabase, forKey: .connectedDatabase)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let table = table {
            try encodeContainer.encode(table, forKey: .table)
        }
    }
}

public struct DescribeTableInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableInput>
    public typealias MOutput = OperationOutput<DescribeTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableOutputError>
}

public struct DescribeTableInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableInput>
    public typealias MOutput = OperationOutput<DescribeTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableOutputError>
}

public struct DescribeTableInput: Equatable {
    /// <p>The cluster identifier. This parameter is required when authenticating using either AWS Secrets Manager or temporary credentials. </p>
    public let clusterIdentifier: String?
    /// <p>A database name. The connected database is specified when you connect with your authentication credentials. </p>
    public let connectedDatabase: String?
    /// <p>The name of the database that contains the tables to be described.
    ///       If <code>ConnectedDatabase</code> is not specified, this is also the database to connect to with your authentication credentials.</p>
    public let database: String?
    /// <p>The database user name. This parameter is required when authenticating using temporary credentials. </p>
    public let dbUser: String?
    /// <p>The maximum number of tables to return in the response.
    ///       If more tables exist than fit in one response, then <code>NextToken</code> is returned to page through the results. </p>
    public let maxResults: Int
    /// <p>A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request. </p>
    public let nextToken: String?
    /// <p>The schema that contains the table. If no schema is specified, then matching tables for all schemas are returned. </p>
    public let schema: String?
    /// <p>The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using AWS Secrets Manager. </p>
    public let secretArn: String?
    /// <p>The table name. If no table is specified, then all tables for all matching schemas are returned.
    ///        If no table and no schema is specified, then all tables for all schemas in the database are returned</p>
    public let table: String?

    public init (
        clusterIdentifier: String? = nil,
        connectedDatabase: String? = nil,
        database: String? = nil,
        dbUser: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        schema: String? = nil,
        secretArn: String? = nil,
        table: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.connectedDatabase = connectedDatabase
        self.database = database
        self.dbUser = dbUser
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schema = schema
        self.secretArn = secretArn
        self.table = table
    }
}

struct DescribeTableInputBody: Equatable {
    public let clusterIdentifier: String?
    public let secretArn: String?
    public let dbUser: String?
    public let database: String?
    public let connectedDatabase: String?
    public let schema: String?
    public let table: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension DescribeTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case connectedDatabase = "ConnectedDatabase"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schema = "Schema"
        case secretArn = "SecretArn"
        case table = "Table"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let connectedDatabaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectedDatabase)
        connectedDatabase = connectedDatabaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let tableDecoded = try containerValues.decodeIfPresent(String.self, forKey: .table)
        table = tableDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTableOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTableOutputResponse(columnList: \(String(describing: columnList)), nextToken: \(String(describing: nextToken)), tableName: \(String(describing: tableName)))"}
}

extension DescribeTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTableOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.columnList = output.columnList
            self.nextToken = output.nextToken
            self.tableName = output.tableName
        } else {
            self.columnList = nil
            self.nextToken = nil
            self.tableName = nil
        }
    }
}

public struct DescribeTableOutputResponse: Equatable {
    /// <p>A list of columns in the table. </p>
    public let columnList: [ColumnMetadata]?
    /// <p>A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request. </p>
    public let nextToken: String?
    /// <p>The table name. </p>
    public let tableName: String?

    public init (
        columnList: [ColumnMetadata]? = nil,
        nextToken: String? = nil,
        tableName: String? = nil
    )
    {
        self.columnList = columnList
        self.nextToken = nextToken
        self.tableName = tableName
    }
}

struct DescribeTableOutputResponseBody: Equatable {
    public let tableName: String?
    public let columnList: [ColumnMetadata]?
    public let nextToken: String?
}

extension DescribeTableOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case columnList = "ColumnList"
        case nextToken = "NextToken"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let columnListContainer = try containerValues.decodeIfPresent([ColumnMetadata?].self, forKey: .columnList)
        var columnListDecoded0:[ColumnMetadata]? = nil
        if let columnListContainer = columnListContainer {
            columnListDecoded0 = [ColumnMetadata]()
            for structure0 in columnListContainer {
                if let structure0 = structure0 {
                    columnListDecoded0?.append(structure0)
                }
            }
        }
        columnList = columnListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ExecuteStatementException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteStatementException(message: \(String(describing: message)), statementId: \(String(describing: statementId)))"}
}

extension ExecuteStatementException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExecuteStatementExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.statementId = output.statementId
        } else {
            self.message = nil
            self.statementId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The SQL statement encountered an environmental error while running.</p>
public struct ExecuteStatementException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The exception message.</p>
    public var message: String?
    /// <p>Statement identifier of the exception.</p>
    public var statementId: String?

    public init (
        message: String? = nil,
        statementId: String? = nil
    )
    {
        self.message = message
        self.statementId = statementId
    }
}

struct ExecuteStatementExceptionBody: Equatable {
    public let message: String?
    public let statementId: String?
}

extension ExecuteStatementExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case statementId = "StatementId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let statementIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementId)
        statementId = statementIdDecoded
    }
}

public struct ExecuteStatementInputBodyMiddleware: Middleware {
    public let id: String = "ExecuteStatementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteStatementInput>
    public typealias MOutput = OperationOutput<ExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteStatementOutputError>
}

extension ExecuteStatementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteStatementInput(clusterIdentifier: \(String(describing: clusterIdentifier)), database: \(String(describing: database)), dbUser: \(String(describing: dbUser)), secretArn: \(String(describing: secretArn)), sql: \(String(describing: sql)), statementName: \(String(describing: statementName)), withEvent: \(String(describing: withEvent)))"}
}

extension ExecuteStatementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case database = "Database"
        case dbUser = "DbUser"
        case secretArn = "SecretArn"
        case sql = "Sql"
        case statementName = "StatementName"
        case withEvent = "WithEvent"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterIdentifier = clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sql = sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let withEvent = withEvent {
            try encodeContainer.encode(withEvent, forKey: .withEvent)
        }
    }
}

public struct ExecuteStatementInputHeadersMiddleware: Middleware {
    public let id: String = "ExecuteStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteStatementInput>
    public typealias MOutput = OperationOutput<ExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteStatementOutputError>
}

public struct ExecuteStatementInputQueryItemMiddleware: Middleware {
    public let id: String = "ExecuteStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteStatementInput>
    public typealias MOutput = OperationOutput<ExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteStatementOutputError>
}

public struct ExecuteStatementInput: Equatable {
    /// <p>The cluster identifier. This parameter is required when authenticating using either AWS Secrets Manager or temporary credentials. </p>
    public let clusterIdentifier: String?
    /// <p>The name of the database. This parameter is required when authenticating using temporary credentials.</p>
    public let database: String?
    /// <p>The database user name. This parameter is required when authenticating using temporary credentials. </p>
    public let dbUser: String?
    /// <p>The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using AWS Secrets Manager. </p>
    public let secretArn: String?
    /// <p>The SQL statement text to run. </p>
    public let sql: String?
    /// <p>The name of the SQL statement. You can name the SQL statement when you create it to identify the query. </p>
    public let statementName: String?
    /// <p>A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statement runs. </p>
    public let withEvent: Bool?

    public init (
        clusterIdentifier: String? = nil,
        database: String? = nil,
        dbUser: String? = nil,
        secretArn: String? = nil,
        sql: String? = nil,
        statementName: String? = nil,
        withEvent: Bool? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.database = database
        self.dbUser = dbUser
        self.secretArn = secretArn
        self.sql = sql
        self.statementName = statementName
        self.withEvent = withEvent
    }
}

struct ExecuteStatementInputBody: Equatable {
    public let sql: String?
    public let clusterIdentifier: String?
    public let secretArn: String?
    public let dbUser: String?
    public let database: String?
    public let withEvent: Bool?
    public let statementName: String?
}

extension ExecuteStatementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case database = "Database"
        case dbUser = "DbUser"
        case secretArn = "SecretArn"
        case sql = "Sql"
        case statementName = "StatementName"
        case withEvent = "WithEvent"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sql)
        sql = sqlDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let withEventDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .withEvent)
        withEvent = withEventDecoded
        let statementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementName)
        statementName = statementNameDecoded
    }
}

extension ExecuteStatementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteStatementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActiveStatementsExceededException" : self = .activeStatementsExceededException(try ActiveStatementsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExecuteStatementException" : self = .executeStatementException(try ExecuteStatementException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteStatementOutputError: Equatable {
    case activeStatementsExceededException(ActiveStatementsExceededException)
    case executeStatementException(ExecuteStatementException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteStatementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteStatementOutputResponse(clusterIdentifier: \(String(describing: clusterIdentifier)), createdAt: \(String(describing: createdAt)), database: \(String(describing: database)), dbUser: \(String(describing: dbUser)), id: \(String(describing: id)), secretArn: \(String(describing: secretArn)))"}
}

extension ExecuteStatementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExecuteStatementOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterIdentifier = output.clusterIdentifier
            self.createdAt = output.createdAt
            self.database = output.database
            self.dbUser = output.dbUser
            self.id = output.id
            self.secretArn = output.secretArn
        } else {
            self.clusterIdentifier = nil
            self.createdAt = nil
            self.database = nil
            self.dbUser = nil
            self.id = nil
            self.secretArn = nil
        }
    }
}

public struct ExecuteStatementOutputResponse: Equatable {
    /// <p>The cluster identifier. </p>
    public let clusterIdentifier: String?
    /// <p>The date and time (UTC) the statement was created. </p>
    public let createdAt: Date?
    /// <p>The name of the database.</p>
    public let database: String?
    /// <p>The database user name.</p>
    public let dbUser: String?
    /// <p>The identifier of the statement to be run. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. </p>
    public let id: String?
    /// <p>The name or ARN of the secret that enables access to the database. </p>
    public let secretArn: String?

    public init (
        clusterIdentifier: String? = nil,
        createdAt: Date? = nil,
        database: String? = nil,
        dbUser: String? = nil,
        id: String? = nil,
        secretArn: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.createdAt = createdAt
        self.database = database
        self.dbUser = dbUser
        self.id = id
        self.secretArn = secretArn
    }
}

struct ExecuteStatementOutputResponseBody: Equatable {
    public let id: String?
    public let createdAt: Date?
    public let clusterIdentifier: String?
    public let dbUser: String?
    public let database: String?
    public let secretArn: String?
}

extension ExecuteStatementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case createdAt = "CreatedAt"
        case database = "Database"
        case dbUser = "DbUser"
        case id = "Id"
        case secretArn = "SecretArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
    }
}

extension Field: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blobValue
        case booleanValue
        case doubleValue
        case isNull
        case longValue
        case sdkUnknown
        case stringValue
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .blobValue(blobValue):
                if let blobValue = blobValue {
                    try container.encode(blobValue.base64EncodedString(), forKey: .blobValue)
                }
            case let .booleanValue(booleanValue):
                if let booleanValue = booleanValue {
                    try container.encode(booleanValue, forKey: .booleanValue)
                }
            case let .doubleValue(doubleValue):
                if let doubleValue = doubleValue {
                    try container.encode(doubleValue, forKey: .doubleValue)
                }
            case let .isNull(isNull):
                if let isNull = isNull {
                    try container.encode(isNull, forKey: .isNull)
                }
            case let .longValue(longValue):
                if let longValue = longValue {
                    try container.encode(longValue, forKey: .longValue)
                }
            case let .stringValue(stringValue):
                if let stringValue = stringValue {
                    try container.encode(stringValue, forKey: .stringValue)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let isNullDecoded = try values.decodeIfPresent(Bool.self, forKey: .isNull)
        if let isNull = isNullDecoded {
            self = .isNull(isNull)
            return
        }
        let booleanValueDecoded = try values.decodeIfPresent(Bool.self, forKey: .booleanValue)
        if let booleanValue = booleanValueDecoded {
            self = .booleanValue(booleanValue)
            return
        }
        let longValueDecoded = try values.decodeIfPresent(Int.self, forKey: .longValue)
        if let longValue = longValueDecoded {
            self = .longValue(longValue)
            return
        }
        let doubleValueDecoded = try values.decodeIfPresent(Double.self, forKey: .doubleValue)
        if let doubleValue = doubleValueDecoded {
            self = .doubleValue(doubleValue)
            return
        }
        let stringValueDecoded = try values.decodeIfPresent(String.self, forKey: .stringValue)
        if let stringValue = stringValueDecoded {
            self = .stringValue(stringValue)
            return
        }
        let blobValueDecoded = try values.decodeIfPresent(Data.self, forKey: .blobValue)
        if let blobValue = blobValueDecoded {
            self = .blobValue(blobValue)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>A data value in a column. </p>
public enum Field: Equatable {
    /// <p>A value that indicates whether the data is NULL. </p>
    case isNull(Bool?)
    /// <p>A value of the Boolean data type. </p>
    case booleanValue(Bool?)
    /// <p>A value of the long data type. </p>
    case longValue(Int?)
    /// <p>A value of the double data type. </p>
    case doubleValue(Double?)
    /// <p>A value of the string data type. </p>
    case stringValue(String?)
    /// <p>A value of the BLOB data type. </p>
    case blobValue(Data?)
    case sdkUnknown(String?)
}

public struct GetStatementResultInputBodyMiddleware: Middleware {
    public let id: String = "GetStatementResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStatementResultInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStatementResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStatementResultInput>
    public typealias MOutput = OperationOutput<GetStatementResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStatementResultOutputError>
}

extension GetStatementResultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStatementResultInput(id: \(String(describing: id)), nextToken: \(String(describing: nextToken)))"}
}

extension GetStatementResultInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetStatementResultInputHeadersMiddleware: Middleware {
    public let id: String = "GetStatementResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStatementResultInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStatementResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStatementResultInput>
    public typealias MOutput = OperationOutput<GetStatementResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStatementResultOutputError>
}

public struct GetStatementResultInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStatementResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStatementResultInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStatementResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStatementResultInput>
    public typealias MOutput = OperationOutput<GetStatementResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStatementResultOutputError>
}

public struct GetStatementResultInput: Equatable {
    /// <p>The identifier of the SQL statement whose results are to be fetched. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
    ///        This identifier is returned by <code>ExecuteStatment</code> and <code>ListStatements</code>. </p>
    public let id: String?
    /// <p>A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request. </p>
    public let nextToken: String?

    public init (
        id: String? = nil,
        nextToken: String? = nil
    )
    {
        self.id = id
        self.nextToken = nextToken
    }
}

struct GetStatementResultInputBody: Equatable {
    public let id: String?
    public let nextToken: String?
}

extension GetStatementResultInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetStatementResultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStatementResultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStatementResultOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStatementResultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStatementResultOutputResponse(columnMetadata: \(String(describing: columnMetadata)), nextToken: \(String(describing: nextToken)), records: \(String(describing: records)), totalNumRows: \(String(describing: totalNumRows)))"}
}

extension GetStatementResultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetStatementResultOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.columnMetadata = output.columnMetadata
            self.nextToken = output.nextToken
            self.records = output.records
            self.totalNumRows = output.totalNumRows
        } else {
            self.columnMetadata = nil
            self.nextToken = nil
            self.records = nil
            self.totalNumRows = 0
        }
    }
}

public struct GetStatementResultOutputResponse: Equatable {
    /// <p>The properties (metadata) of a column. </p>
    public let columnMetadata: [ColumnMetadata]?
    /// <p>A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request. </p>
    public let nextToken: String?
    /// <p>The results of the SQL statement.</p>
    public let records: [[Field]]?
    /// <p>The total number of rows in the result set returned from a query.
    ///        You can use this number to estimate the number of calls to the <code>GetStatementResult</code> operation needed to page through the results. </p>
    public let totalNumRows: Int

    public init (
        columnMetadata: [ColumnMetadata]? = nil,
        nextToken: String? = nil,
        records: [[Field]]? = nil,
        totalNumRows: Int = 0
    )
    {
        self.columnMetadata = columnMetadata
        self.nextToken = nextToken
        self.records = records
        self.totalNumRows = totalNumRows
    }
}

struct GetStatementResultOutputResponseBody: Equatable {
    public let records: [[Field]]?
    public let columnMetadata: [ColumnMetadata]?
    public let totalNumRows: Int
    public let nextToken: String?
}

extension GetStatementResultOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case columnMetadata = "ColumnMetadata"
        case nextToken = "NextToken"
        case records = "Records"
        case totalNumRows = "TotalNumRows"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([[Field?]?].self, forKey: .records)
        var recordsDecoded0:[[Field]]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [[Field]]()
            for list0 in recordsContainer {
                var list0Decoded0: [Field]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Field]()
                    for union1 in list0 {
                        if let union1 = union1 {
                            list0Decoded0?.append(union1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    recordsDecoded0?.append(list0Decoded0)
                }
            }
        }
        records = recordsDecoded0
        let columnMetadataContainer = try containerValues.decodeIfPresent([ColumnMetadata?].self, forKey: .columnMetadata)
        var columnMetadataDecoded0:[ColumnMetadata]? = nil
        if let columnMetadataContainer = columnMetadataContainer {
            columnMetadataDecoded0 = [ColumnMetadata]()
            for structure0 in columnMetadataContainer {
                if let structure0 = structure0 {
                    columnMetadataDecoded0?.append(structure0)
                }
            }
        }
        columnMetadata = columnMetadataDecoded0
        let totalNumRowsDecoded = try containerValues.decode(Int.self, forKey: .totalNumRows)
        totalNumRows = totalNumRowsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Redshift Data API operation failed due to invalid input. </p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The exception message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListDatabasesInputBodyMiddleware: Middleware {
    public let id: String = "ListDatabasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatabasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatabasesInput>
    public typealias MOutput = OperationOutput<ListDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatabasesOutputError>
}

extension ListDatabasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatabasesInput(clusterIdentifier: \(String(describing: clusterIdentifier)), database: \(String(describing: database)), dbUser: \(String(describing: dbUser)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), secretArn: \(String(describing: secretArn)))"}
}

extension ListDatabasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case secretArn = "SecretArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterIdentifier = clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }
}

public struct ListDatabasesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatabasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatabasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatabasesInput>
    public typealias MOutput = OperationOutput<ListDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatabasesOutputError>
}

public struct ListDatabasesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatabasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatabasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatabasesInput>
    public typealias MOutput = OperationOutput<ListDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatabasesOutputError>
}

public struct ListDatabasesInput: Equatable {
    /// <p>The cluster identifier. This parameter is required when authenticating using either AWS Secrets Manager or temporary credentials. </p>
    public let clusterIdentifier: String?
    /// <p>The name of the database. This parameter is required when authenticating using temporary credentials. </p>
    public let database: String?
    /// <p>The database user name. This parameter is required when authenticating using temporary credentials. </p>
    public let dbUser: String?
    /// <p>The maximum number of databases to return in the response.
    ///        If more databases exist than fit in one response, then <code>NextToken</code> is returned to page through the results. </p>
    public let maxResults: Int
    /// <p>A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request. </p>
    public let nextToken: String?
    /// <p>The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using AWS Secrets Manager. </p>
    public let secretArn: String?

    public init (
        clusterIdentifier: String? = nil,
        database: String? = nil,
        dbUser: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        secretArn: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.database = database
        self.dbUser = dbUser
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.secretArn = secretArn
    }
}

struct ListDatabasesInputBody: Equatable {
    public let clusterIdentifier: String?
    public let database: String?
    public let secretArn: String?
    public let dbUser: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListDatabasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case secretArn = "SecretArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatabasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatabasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatabasesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatabasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatabasesOutputResponse(databases: \(String(describing: databases)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatabasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatabasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.databases = output.databases
            self.nextToken = output.nextToken
        } else {
            self.databases = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatabasesOutputResponse: Equatable {
    /// <p>The names of databases. </p>
    public let databases: [String]?
    /// <p>A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request. </p>
    public let nextToken: String?

    public init (
        databases: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

struct ListDatabasesOutputResponseBody: Equatable {
    public let databases: [String]?
    public let nextToken: String?
}

extension ListDatabasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databases = "Databases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databasesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .databases)
        var databasesDecoded0:[String]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [String]()
            for string0 in databasesContainer {
                if let string0 = string0 {
                    databasesDecoded0?.append(string0)
                }
            }
        }
        databases = databasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSchemasInputBodyMiddleware: Middleware {
    public let id: String = "ListSchemasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemasInput>
    public typealias MOutput = OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemasOutputError>
}

extension ListSchemasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemasInput(clusterIdentifier: \(String(describing: clusterIdentifier)), connectedDatabase: \(String(describing: connectedDatabase)), database: \(String(describing: database)), dbUser: \(String(describing: dbUser)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), schemaPattern: \(String(describing: schemaPattern)), secretArn: \(String(describing: secretArn)))"}
}

extension ListSchemasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case connectedDatabase = "ConnectedDatabase"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaPattern = "SchemaPattern"
        case secretArn = "SecretArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterIdentifier = clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let connectedDatabase = connectedDatabase {
            try encodeContainer.encode(connectedDatabase, forKey: .connectedDatabase)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaPattern = schemaPattern {
            try encodeContainer.encode(schemaPattern, forKey: .schemaPattern)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }
}

public struct ListSchemasInputHeadersMiddleware: Middleware {
    public let id: String = "ListSchemasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemasInput>
    public typealias MOutput = OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemasOutputError>
}

public struct ListSchemasInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSchemasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemasInput>
    public typealias MOutput = OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemasOutputError>
}

public struct ListSchemasInput: Equatable {
    /// <p>The cluster identifier. This parameter is required when authenticating using either AWS Secrets Manager or temporary credentials. </p>
    public let clusterIdentifier: String?
    /// <p>A database name. The connected database is specified when you connect with your authentication credentials. </p>
    public let connectedDatabase: String?
    /// <p>The name of the database that contains the schemas to list.
    ///      If <code>ConnectedDatabase</code> is not specified, this is also the database to connect to with your authentication credentials.</p>
    public let database: String?
    /// <p>The database user name. This parameter is required when authenticating using temporary credentials. </p>
    public let dbUser: String?
    /// <p>The maximum number of schemas to return in the response.
    ///        If more schemas exist than fit in one response, then <code>NextToken</code> is returned to page through the results. </p>
    public let maxResults: Int
    /// <p>A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request. </p>
    public let nextToken: String?
    /// <p>A pattern to filter results by schema name. Within a schema pattern, "%" means match any
    ///       substring of 0 or more characters and "_" means match any one character. Only schema name
    ///       entries matching the search pattern are returned. </p>
    public let schemaPattern: String?
    /// <p>The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using AWS Secrets Manager. </p>
    public let secretArn: String?

    public init (
        clusterIdentifier: String? = nil,
        connectedDatabase: String? = nil,
        database: String? = nil,
        dbUser: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        schemaPattern: String? = nil,
        secretArn: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.connectedDatabase = connectedDatabase
        self.database = database
        self.dbUser = dbUser
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaPattern = schemaPattern
        self.secretArn = secretArn
    }
}

struct ListSchemasInputBody: Equatable {
    public let clusterIdentifier: String?
    public let secretArn: String?
    public let dbUser: String?
    public let database: String?
    public let connectedDatabase: String?
    public let schemaPattern: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListSchemasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case connectedDatabase = "ConnectedDatabase"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaPattern = "SchemaPattern"
        case secretArn = "SecretArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let connectedDatabaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectedDatabase)
        connectedDatabase = connectedDatabaseDecoded
        let schemaPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaPattern)
        schemaPattern = schemaPatternDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSchemasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSchemasOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemasOutputResponse(nextToken: \(String(describing: nextToken)), schemas: \(String(describing: schemas)))"}
}

extension ListSchemasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSchemasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct ListSchemasOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request. </p>
    public let nextToken: String?
    /// <p>The schemas that match the request pattern. </p>
    public let schemas: [String]?

    public init (
        nextToken: String? = nil,
        schemas: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct ListSchemasOutputResponseBody: Equatable {
    public let schemas: [String]?
    public let nextToken: String?
}

extension ListSchemasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([String?].self, forKey: .schemas)
        var schemasDecoded0:[String]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [String]()
            for string0 in schemasContainer {
                if let string0 = string0 {
                    schemasDecoded0?.append(string0)
                }
            }
        }
        schemas = schemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStatementsInputBodyMiddleware: Middleware {
    public let id: String = "ListStatementsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStatementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStatementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStatementsInput>
    public typealias MOutput = OperationOutput<ListStatementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStatementsOutputError>
}

extension ListStatementsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStatementsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), roleLevel: \(String(describing: roleLevel)), statementName: \(String(describing: statementName)), status: \(String(describing: status)))"}
}

extension ListStatementsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case roleLevel = "RoleLevel"
        case statementName = "StatementName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let roleLevel = roleLevel {
            try encodeContainer.encode(roleLevel, forKey: .roleLevel)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListStatementsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStatementsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStatementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStatementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStatementsInput>
    public typealias MOutput = OperationOutput<ListStatementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStatementsOutputError>
}

public struct ListStatementsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStatementsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStatementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStatementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStatementsInput>
    public typealias MOutput = OperationOutput<ListStatementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStatementsOutputError>
}

public struct ListStatementsInput: Equatable {
    /// <p>The maximum number of SQL statements to return in the response.
    ///        If more SQL statements exist than fit in one response, then <code>NextToken</code> is returned to page through the results. </p>
    public let maxResults: Int
    /// <p>A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request. </p>
    public let nextToken: String?
    /// <p>A value that filters which statements to return in the response. If true, all statements run by the caller's IAM role are returned.
    ///       If false, only statements run by the caller's IAM role in the current IAM session are returned.  The default is true. </p>
    public let roleLevel: Bool?
    /// <p>The name of the SQL statement specified as input to <code>ExecuteStatement</code> to identify the query.
    ///       You can list multiple statements by providing a prefix that matches the beginning of the statement name.
    ///       For example, to list myStatement1, myStatement2, myStatement3, and so on, then provide the a value of <code>myStatement</code>.
    ///       Data API does a case-sensitive match of SQL statement names to the prefix value you provide. </p>
    public let statementName: String?
    /// <p>The status of the SQL statement to list. Status values are defined as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>ABORTED - The query run was stopped by the user. </p>
    ///             </li>
    ///             <li>
    ///                <p>ALL -  A status value that includes all query statuses. This value can be used to filter results. </p>
    ///             </li>
    ///             <li>
    ///                <p>FAILED - The query run failed. </p>
    ///             </li>
    ///             <li>
    ///                <p>FINISHED - The query has finished running. </p>
    ///             </li>
    ///             <li>
    ///                <p>PICKED - The query has been chosen to be run. </p>
    ///             </li>
    ///             <li>
    ///                <p>STARTED - The query run has started. </p>
    ///             </li>
    ///             <li>
    ///                <p>SUBMITTED - The query was submitted, but not yet processed. </p>
    ///             </li>
    ///          </ul>
    public let status: StatusString?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        roleLevel: Bool? = nil,
        statementName: String? = nil,
        status: StatusString? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.roleLevel = roleLevel
        self.statementName = statementName
        self.status = status
    }
}

struct ListStatementsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int
    public let statementName: String?
    public let status: StatusString?
    public let roleLevel: Bool?
}

extension ListStatementsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case roleLevel = "RoleLevel"
        case statementName = "StatementName"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let statementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusString.self, forKey: .status)
        status = statusDecoded
        let roleLevelDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .roleLevel)
        roleLevel = roleLevelDecoded
    }
}

extension ListStatementsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStatementsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStatementsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStatementsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStatementsOutputResponse(nextToken: \(String(describing: nextToken)), statements: \(String(describing: statements)))"}
}

extension ListStatementsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStatementsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.statements = output.statements
        } else {
            self.nextToken = nil
            self.statements = nil
        }
    }
}

public struct ListStatementsOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request. </p>
    public let nextToken: String?
    /// <p>The SQL statements. </p>
    public let statements: [StatementData]?

    public init (
        nextToken: String? = nil,
        statements: [StatementData]? = nil
    )
    {
        self.nextToken = nextToken
        self.statements = statements
    }
}

struct ListStatementsOutputResponseBody: Equatable {
    public let statements: [StatementData]?
    public let nextToken: String?
}

extension ListStatementsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case statements = "Statements"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([StatementData?].self, forKey: .statements)
        var statementsDecoded0:[StatementData]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [StatementData]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTablesInputBodyMiddleware: Middleware {
    public let id: String = "ListTablesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTablesInput>
    public typealias MOutput = OperationOutput<ListTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTablesOutputError>
}

extension ListTablesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTablesInput(clusterIdentifier: \(String(describing: clusterIdentifier)), connectedDatabase: \(String(describing: connectedDatabase)), database: \(String(describing: database)), dbUser: \(String(describing: dbUser)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), schemaPattern: \(String(describing: schemaPattern)), secretArn: \(String(describing: secretArn)), tablePattern: \(String(describing: tablePattern)))"}
}

extension ListTablesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case connectedDatabase = "ConnectedDatabase"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaPattern = "SchemaPattern"
        case secretArn = "SecretArn"
        case tablePattern = "TablePattern"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterIdentifier = clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let connectedDatabase = connectedDatabase {
            try encodeContainer.encode(connectedDatabase, forKey: .connectedDatabase)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaPattern = schemaPattern {
            try encodeContainer.encode(schemaPattern, forKey: .schemaPattern)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let tablePattern = tablePattern {
            try encodeContainer.encode(tablePattern, forKey: .tablePattern)
        }
    }
}

public struct ListTablesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTablesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTablesInput>
    public typealias MOutput = OperationOutput<ListTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTablesOutputError>
}

public struct ListTablesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTablesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTablesInput>
    public typealias MOutput = OperationOutput<ListTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTablesOutputError>
}

public struct ListTablesInput: Equatable {
    /// <p>The cluster identifier. This parameter is required when authenticating using either AWS Secrets Manager or temporary credentials. </p>
    public let clusterIdentifier: String?
    /// <p>A database name. The connected database is specified when you connect with your authentication credentials. </p>
    public let connectedDatabase: String?
    /// <p>The name of the database that contains the tables to list.
    ///       If <code>ConnectedDatabase</code> is not specified, this is also the database to connect to with your authentication credentials.</p>
    public let database: String?
    /// <p>The database user name. This parameter is required when authenticating using temporary credentials. </p>
    public let dbUser: String?
    /// <p>The maximum number of tables to return in the response.
    ///        If more tables exist than fit in one response, then <code>NextToken</code> is returned to page through the results. </p>
    public let maxResults: Int
    /// <p>A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request. </p>
    public let nextToken: String?
    /// <p>A pattern to filter results by schema name. Within a schema pattern, "%" means match any
    ///       substring of 0 or more characters and "_" means match any one character. Only schema name
    ///       entries matching the search pattern are returned. If <code>SchemaPattern</code> is not specified, then all tables that match
    ///        <code>TablePattern</code> are returned.
    ///        If neither <code>SchemaPattern</code> or <code>TablePattern</code> are specified, then all tables are returned. </p>
    public let schemaPattern: String?
    /// <p>The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using AWS Secrets Manager. </p>
    public let secretArn: String?
    /// <p>A pattern to filter results by table name. Within a table pattern, "%" means match any
    ///       substring of 0 or more characters and "_" means match any one character. Only table name
    ///       entries matching the search pattern are returned. If <code>TablePattern</code> is not specified, then all tables that match
    ///        <code>SchemaPattern</code>are returned.
    ///        If neither <code>SchemaPattern</code> or <code>TablePattern</code> are specified, then all tables are returned. </p>
    public let tablePattern: String?

    public init (
        clusterIdentifier: String? = nil,
        connectedDatabase: String? = nil,
        database: String? = nil,
        dbUser: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        schemaPattern: String? = nil,
        secretArn: String? = nil,
        tablePattern: String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.connectedDatabase = connectedDatabase
        self.database = database
        self.dbUser = dbUser
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaPattern = schemaPattern
        self.secretArn = secretArn
        self.tablePattern = tablePattern
    }
}

struct ListTablesInputBody: Equatable {
    public let clusterIdentifier: String?
    public let secretArn: String?
    public let dbUser: String?
    public let database: String?
    public let connectedDatabase: String?
    public let schemaPattern: String?
    public let tablePattern: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListTablesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case connectedDatabase = "ConnectedDatabase"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaPattern = "SchemaPattern"
        case secretArn = "SecretArn"
        case tablePattern = "TablePattern"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let connectedDatabaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectedDatabase)
        connectedDatabase = connectedDatabaseDecoded
        let schemaPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaPattern)
        schemaPattern = schemaPatternDecoded
        let tablePatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tablePattern)
        tablePattern = tablePatternDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTablesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTablesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTablesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTablesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTablesOutputResponse(nextToken: \(String(describing: nextToken)), tables: \(String(describing: tables)))"}
}

extension ListTablesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTablesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tables = output.tables
        } else {
            self.nextToken = nil
            self.tables = nil
        }
    }
}

public struct ListTablesOutputResponse: Equatable {
    /// <p>A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request. </p>
    public let nextToken: String?
    /// <p>The tables that match the request pattern. </p>
    public let tables: [TableMember]?

    public init (
        nextToken: String? = nil,
        tables: [TableMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.tables = tables
    }
}

struct ListTablesOutputResponseBody: Equatable {
    public let tables: [TableMember]?
    public let nextToken: String?
}

extension ListTablesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tables = "Tables"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tablesContainer = try containerValues.decodeIfPresent([TableMember?].self, forKey: .tables)
        var tablesDecoded0:[TableMember]? = nil
        if let tablesContainer = tablesContainer {
            tablesDecoded0 = [TableMember]()
            for structure0 in tablesContainer {
                if let structure0 = structure0 {
                    tablesDecoded0?.append(structure0)
                }
            }
        }
        tables = tablesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Redshift Data API operation failed due to a missing resource. </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception message.</p>
    public var message: String?
    /// <p>Resource identifier associated with the exception.</p>
    public var resourceId: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension StatementData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case id = "Id"
        case queryString = "QueryString"
        case secretArn = "SecretArn"
        case statementName = "StatementName"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusString.self, forKey: .status)
        status = statusDecoded
        let statementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension StatementData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatementData(createdAt: \(String(describing: createdAt)), id: \(String(describing: id)), queryString: \(String(describing: queryString)), secretArn: \(String(describing: secretArn)), statementName: \(String(describing: statementName)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>The SQL statement to run.</p>
public struct StatementData: Equatable {
    /// <p>The date and time (UTC) the statement was created. </p>
    public let createdAt: Date?
    /// <p>The SQL statement identifier. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. </p>
    public let id: String?
    /// <p>The SQL statement.</p>
    public let queryString: String?
    /// <p>The name or Amazon Resource Name (ARN) of the secret that enables access to the database. </p>
    public let secretArn: String?
    /// <p>The name of the SQL statement. </p>
    public let statementName: String?
    /// <p>The status of the SQL statement. An
    ///        example is the that the SQL statement finished.
    ///       </p>
    public let status: StatusString?
    /// <p>The date and time (UTC) that the statement metadata was last updated.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        id: String? = nil,
        queryString: String? = nil,
        secretArn: String? = nil,
        statementName: String? = nil,
        status: StatusString? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.id = id
        self.queryString = queryString
        self.secretArn = secretArn
        self.statementName = statementName
        self.status = status
        self.updatedAt = updatedAt
    }
}

public enum StatusString {
    case aborted
    case all
    case failed
    case finished
    case picked
    case started
    case submitted
    case sdkUnknown(String)
}

extension StatusString : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StatusString] {
        return [
            .aborted,
            .all,
            .failed,
            .finished,
            .picked,
            .started,
            .submitted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aborted: return "ABORTED"
        case .all: return "ALL"
        case .failed: return "FAILED"
        case .finished: return "FINISHED"
        case .picked: return "PICKED"
        case .started: return "STARTED"
        case .submitted: return "SUBMITTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StatusString(rawValue: rawValue) ?? StatusString.sdkUnknown(rawValue)
    }
}

extension TableMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case schema
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension TableMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableMember(name: \(String(describing: name)), schema: \(String(describing: schema)), type: \(String(describing: type)))"}
}

/// <p>The properties of a table. </p>
public struct TableMember: Equatable {
    /// <p>The name of the table. </p>
    public let name: String?
    /// <p>The schema containing the table. </p>
    public let schema: String?
    /// <p>The type of the table. Possible values include TABLE, VIEW, SYSTEM TABLE, GLOBAL
    ///       TEMPORARY, LOCAL TEMPORARY, ALIAS, and SYNONYM. </p>
    public let type: String?

    public init (
        name: String? = nil,
        schema: String? = nil,
        type: String? = nil
    )
    {
        self.name = name
        self.schema = schema
        self.type = type
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Redshift Data API operation failed due to invalid input. </p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
