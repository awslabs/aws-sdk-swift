// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class RedshiftDataClient {
    let client: SdkHttpClient
    let config: RedshiftDataClientConfiguration
    let serviceName = "Redshift Data"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: RedshiftDataClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class RedshiftDataClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> RedshiftDataClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try RedshiftDataClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension RedshiftDataClient: RedshiftDataClientProtocol {
    /// <p>Cancels a running query. To be canceled, a query must be running. </p>
    public func cancelStatement(input: CancelStatementInput, completion: @escaping (SdkResult<CancelStatementOutputResponse, CancelStatementOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelStatement")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift-data.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift-data")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelStatementInput, CancelStatementOutputResponse, CancelStatementOutputError>(id: "cancelStatement")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelStatementInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelStatementInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelStatementInput, CancelStatementOutputResponse, CancelStatementOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CancelStatementInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CancelStatementInput, CancelStatementOutputResponse, CancelStatementOutputError>(xAmzTarget: "RedshiftData.CancelStatement"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the details about a specific instance when a query was run by the Amazon Redshift Data API. The information
    ///       includes when the query started, when it finished, the query status, the number of rows returned, and the SQL
    ///       statement. </p>
    public func describeStatement(input: DescribeStatementInput, completion: @escaping (SdkResult<DescribeStatementOutputResponse, DescribeStatementOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeStatement")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift-data.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift-data")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeStatementInput, DescribeStatementOutputResponse, DescribeStatementOutputError>(id: "describeStatement")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeStatementInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeStatementInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeStatementInput, DescribeStatementOutputResponse, DescribeStatementOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeStatementInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeStatementInput, DescribeStatementOutputResponse, DescribeStatementOutputError>(xAmzTarget: "RedshiftData.DescribeStatement"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the detailed information about a table from metadata in the cluster. The
    ///       information includes its columns.
    ///       A token is returned to page through the column list.
    ///       Depending on the authorization method, use one of the
    ///       following combinations of request parameters: </p>
    ///          <ul>
    ///             <li>
    ///                <p>AWS Secrets Manager - specify the Amazon Resource Name (ARN) of the secret and the
    ///          cluster identifier that matches the cluster in the secret. </p>
    ///             </li>
    ///             <li>
    ///                <p>Temporary credentials - specify the cluster identifier, the database name, and the database
    ///           user name. Permission to call the <code>redshift:GetClusterCredentials</code> operation is
    ///           required to use this method. </p>
    ///             </li>
    ///          </ul>
    public func describeTable(input: DescribeTableInput, completion: @escaping (SdkResult<DescribeTableOutputResponse, DescribeTableOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeTable")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift-data.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift-data")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeTableInput, DescribeTableOutputResponse, DescribeTableOutputError>(id: "describeTable")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeTableInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeTableInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeTableInput, DescribeTableOutputResponse, DescribeTableOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeTableInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeTableInput, DescribeTableOutputResponse, DescribeTableOutputError>(xAmzTarget: "RedshiftData.DescribeTable"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Runs an SQL statement, which can be data manipulation language (DML) or data definition
    ///       language (DDL). This statement must be a single SQL statement.
    ///       Depending on the authorization
    ///       method, use one of the following combinations of request parameters: </p>
    ///          <ul>
    ///             <li>
    ///                <p>AWS Secrets Manager - specify the Amazon Resource Name (ARN) of the secret and the
    ///          cluster identifier that matches the cluster in the secret. </p>
    ///             </li>
    ///             <li>
    ///                <p>Temporary credentials - specify the cluster identifier, the database name, and the
    ///           database user name. Permission to call the <code>redshift:GetClusterCredentials</code>
    ///           operation is required to use this method. </p>
    ///             </li>
    ///          </ul>
    public func executeStatement(input: ExecuteStatementInput, completion: @escaping (SdkResult<ExecuteStatementOutputResponse, ExecuteStatementOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "executeStatement")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift-data.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift-data")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ExecuteStatementInput, ExecuteStatementOutputResponse, ExecuteStatementOutputError>(id: "executeStatement")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ExecuteStatementInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ExecuteStatementInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ExecuteStatementInput, ExecuteStatementOutputResponse, ExecuteStatementOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ExecuteStatementInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ExecuteStatementInput, ExecuteStatementOutputResponse, ExecuteStatementOutputError>(xAmzTarget: "RedshiftData.ExecuteStatement"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Fetches the temporarily cached result of an SQL statement.
    ///        A token is returned to page through the statement results. </p>
    public func getStatementResult(input: GetStatementResultInput, completion: @escaping (SdkResult<GetStatementResultOutputResponse, GetStatementResultOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getStatementResult")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift-data.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift-data")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetStatementResultInput, GetStatementResultOutputResponse, GetStatementResultOutputError>(id: "getStatementResult")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetStatementResultInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetStatementResultInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetStatementResultInput, GetStatementResultOutputResponse, GetStatementResultOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetStatementResultInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetStatementResultInput, GetStatementResultOutputResponse, GetStatementResultOutputError>(xAmzTarget: "RedshiftData.GetStatementResult"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the databases in a cluster.
    ///       A token is returned to page through the database list.
    ///       Depending on the authorization method, use one of the
    ///       following combinations of request parameters: </p>
    ///          <ul>
    ///             <li>
    ///                <p>AWS Secrets Manager - specify the Amazon Resource Name (ARN) of the secret and the
    ///          cluster identifier that matches the cluster in the secret. </p>
    ///             </li>
    ///             <li>
    ///                <p>Temporary credentials - specify the cluster identifier, the database name, and the
    ///           database user name. Permission to call the <code>redshift:GetClusterCredentials</code>
    ///           operation is required to use this method. </p>
    ///             </li>
    ///          </ul>
    public func listDatabases(input: ListDatabasesInput, completion: @escaping (SdkResult<ListDatabasesOutputResponse, ListDatabasesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDatabases")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift-data.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift-data")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDatabasesInput, ListDatabasesOutputResponse, ListDatabasesOutputError>(id: "listDatabases")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDatabasesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDatabasesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDatabasesInput, ListDatabasesOutputResponse, ListDatabasesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListDatabasesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListDatabasesInput, ListDatabasesOutputResponse, ListDatabasesOutputError>(xAmzTarget: "RedshiftData.ListDatabases"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the schemas in a database.
    ///       A token is returned to page through the schema list.
    ///       Depending on the authorization method, use one of the
    ///       following combinations of request parameters: </p>
    ///          <ul>
    ///             <li>
    ///                <p>AWS Secrets Manager - specify the Amazon Resource Name (ARN) of the secret and the
    ///          cluster identifier that matches the cluster in the secret. </p>
    ///             </li>
    ///             <li>
    ///                <p>Temporary credentials - specify the cluster identifier, the database name, and the
    ///           database user name. Permission to call the <code>redshift:GetClusterCredentials</code>
    ///           operation is required to use this method. </p>
    ///             </li>
    ///          </ul>
    public func listSchemas(input: ListSchemasInput, completion: @escaping (SdkResult<ListSchemasOutputResponse, ListSchemasOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSchemas")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift-data.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift-data")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSchemasInput, ListSchemasOutputResponse, ListSchemasOutputError>(id: "listSchemas")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSchemasInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSchemasInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSchemasInput, ListSchemasOutputResponse, ListSchemasOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListSchemasInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListSchemasInput, ListSchemasOutputResponse, ListSchemasOutputError>(xAmzTarget: "RedshiftData.ListSchemas"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List of SQL statements. By default, only finished statements are shown.
    ///         A token is returned to page through the statement list. </p>
    public func listStatements(input: ListStatementsInput, completion: @escaping (SdkResult<ListStatementsOutputResponse, ListStatementsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listStatements")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift-data.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift-data")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListStatementsInput, ListStatementsOutputResponse, ListStatementsOutputError>(id: "listStatements")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListStatementsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListStatementsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListStatementsInput, ListStatementsOutputResponse, ListStatementsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListStatementsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListStatementsInput, ListStatementsOutputResponse, ListStatementsOutputError>(xAmzTarget: "RedshiftData.ListStatements"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the tables in a database. If neither <code>SchemaPattern</code> nor <code>TablePattern</code> are specified, then
    ///        all tables in the database are returned.
    ///       A token is returned to page through the table list.
    ///       Depending on the authorization method, use one of the
    ///       following combinations of request parameters: </p>
    ///          <ul>
    ///             <li>
    ///                <p>AWS Secrets Manager - specify the Amazon Resource Name (ARN) of the secret and the
    ///          cluster identifier that matches the cluster in the secret. </p>
    ///             </li>
    ///             <li>
    ///                <p>Temporary credentials - specify the cluster identifier, the database name, and the
    ///           database user name. Permission to call the <code>redshift:GetClusterCredentials</code>
    ///           operation is required to use this method. </p>
    ///             </li>
    ///          </ul>
    public func listTables(input: ListTablesInput, completion: @escaping (SdkResult<ListTablesOutputResponse, ListTablesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTables")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "redshift-data.\(config.region).amazonaws.com")
                      .withSigningName(value: "redshift-data")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTablesInput, ListTablesOutputResponse, ListTablesOutputError>(id: "listTables")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTablesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTablesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTablesInput, ListTablesOutputResponse, ListTablesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListTablesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListTablesInput, ListTablesOutputResponse, ListTablesOutputError>(xAmzTarget: "RedshiftData.ListTables"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
