// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ArtifactStatus {
    case approved
    case inProgress
    case rejected
    case sdkUnknown(String)
}

extension ArtifactStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ArtifactStatus] {
        return [
            .approved,
            .inProgress,
            .rejected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approved: return "APPROVED"
        case .inProgress: return "IN_PROGRESS"
        case .rejected: return "REJECTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ArtifactStatus(rawValue: rawValue) ?? ArtifactStatus.sdkUnknown(rawValue)
    }
}

extension AttachmentItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentId = "AttachmentId"
        case attachmentName = "AttachmentName"
        case contentType = "ContentType"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if let attachmentName = attachmentName {
            try encodeContainer.encode(attachmentName, forKey: .attachmentName)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let attachmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let attachmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentName)
        attachmentName = attachmentNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ArtifactStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AttachmentItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachmentItem(attachmentId: \(String(describing: attachmentId)), attachmentName: \(String(describing: attachmentName)), contentType: \(String(describing: contentType)), status: \(String(describing: status)))"}
}

/// <p>The case-insensitive input to indicate standard MIME type that describes the format of the file
///             that will be uploaded.</p>
public struct AttachmentItem: Equatable {
    /// <p>A unique identifier for the attachment.</p>
    public let attachmentId: String?
    /// <p>A case-sensitive name of the attachment being uploaded.</p>
    public let attachmentName: String?
    /// <p>Describes the MIME file type of the attachment. For a list of supported file types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#feature-limits">Feature specifications</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public let contentType: String?
    /// <p>Status of the attachment.</p>
    public let status: ArtifactStatus?

    public init (
        attachmentId: String? = nil,
        attachmentName: String? = nil,
        contentType: String? = nil,
        status: ArtifactStatus? = nil
    )
    {
        self.attachmentId = attachmentId
        self.attachmentName = attachmentName
        self.contentType = contentType
        self.status = status
    }
}

public enum ChatItemType {
    case attachment
    case chatEnded
    case connectionAck
    case event
    case message
    case participantJoined
    case participantLeft
    case transferFailed
    case transferSucceeded
    case typing
    case sdkUnknown(String)
}

extension ChatItemType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChatItemType] {
        return [
            .attachment,
            .chatEnded,
            .connectionAck,
            .event,
            .message,
            .participantJoined,
            .participantLeft,
            .transferFailed,
            .transferSucceeded,
            .typing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .attachment: return "ATTACHMENT"
        case .chatEnded: return "CHAT_ENDED"
        case .connectionAck: return "CONNECTION_ACK"
        case .event: return "EVENT"
        case .message: return "MESSAGE"
        case .participantJoined: return "PARTICIPANT_JOINED"
        case .participantLeft: return "PARTICIPANT_LEFT"
        case .transferFailed: return "TRANSFER_FAILED"
        case .transferSucceeded: return "TRANSFER_SUCCEEDED"
        case .typing: return "TYPING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChatItemType(rawValue: rawValue) ?? ChatItemType.sdkUnknown(rawValue)
    }
}

public struct CompleteAttachmentUploadInputBodyMiddleware: Middleware {
    public let id: String = "CompleteAttachmentUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteAttachmentUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteAttachmentUploadInput>
    public typealias MOutput = OperationOutput<CompleteAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteAttachmentUploadOutputError>
}

extension CompleteAttachmentUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteAttachmentUploadInput(attachmentIds: \(String(describing: attachmentIds)), clientToken: \(String(describing: clientToken)), connectionToken: \(String(describing: connectionToken)))"}
}

extension CompleteAttachmentUploadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentIds = "AttachmentIds"
        case clientToken = "ClientToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentIds = attachmentIds {
            var attachmentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentIds)
            for attachmentidlist0 in attachmentIds {
                try attachmentIdsContainer.encode(attachmentidlist0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct CompleteAttachmentUploadInputHeadersMiddleware: Middleware {
    public let id: String = "CompleteAttachmentUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteAttachmentUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteAttachmentUploadInput>
    public typealias MOutput = OperationOutput<CompleteAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteAttachmentUploadOutputError>
}

public struct CompleteAttachmentUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "CompleteAttachmentUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteAttachmentUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteAttachmentUploadInput>
    public typealias MOutput = OperationOutput<CompleteAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteAttachmentUploadOutputError>
}

public struct CompleteAttachmentUploadInput: Equatable {
    /// <p>A list of unique identifiers for the attachments.</p>
    public let attachmentIds: [String]?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///             request.</p>
    public var clientToken: String?
    /// <p>The authentication token associated with the participant's connection.</p>
    public let connectionToken: String?

    public init (
        attachmentIds: [String]? = nil,
        clientToken: String? = nil,
        connectionToken: String? = nil
    )
    {
        self.attachmentIds = attachmentIds
        self.clientToken = clientToken
        self.connectionToken = connectionToken
    }
}

struct CompleteAttachmentUploadInputBody: Equatable {
    public let attachmentIds: [String]?
    public let clientToken: String?
}

extension CompleteAttachmentUploadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachmentIds = "AttachmentIds"
        case clientToken = "ClientToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attachmentIds)
        var attachmentIdsDecoded0:[String]? = nil
        if let attachmentIdsContainer = attachmentIdsContainer {
            attachmentIdsDecoded0 = [String]()
            for string0 in attachmentIdsContainer {
                if let string0 = string0 {
                    attachmentIdsDecoded0?.append(string0)
                }
            }
        }
        attachmentIds = attachmentIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CompleteAttachmentUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteAttachmentUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteAttachmentUploadOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteAttachmentUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteAttachmentUploadOutputResponse()"}
}

extension CompleteAttachmentUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CompleteAttachmentUploadOutputResponse: Equatable {

    public init() {}
}

struct CompleteAttachmentUploadOutputResponseBody: Equatable {
}

extension CompleteAttachmentUploadOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An attachment with that identifier is already being uploaded.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectionCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionToken = "ConnectionToken"
        case expiry = "Expiry"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionToken = connectionToken {
            try encodeContainer.encode(connectionToken, forKey: .connectionToken)
        }
        if let expiry = expiry {
            try encodeContainer.encode(expiry, forKey: .expiry)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionToken)
        connectionToken = connectionTokenDecoded
        let expiryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expiry)
        expiry = expiryDecoded
    }
}

extension ConnectionCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionCredentials(connectionToken: \(String(describing: connectionToken)), expiry: \(String(describing: expiry)))"}
}

/// <p>Connection credentials. </p>
public struct ConnectionCredentials: Equatable {
    /// <p>The connection token.</p>
    public let connectionToken: String?
    /// <p>The expiration of the token.</p>
    ///         <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example,
    ///             2019-11-08T02:41:28.172Z.</p>
    public let expiry: String?

    public init (
        connectionToken: String? = nil,
        expiry: String? = nil
    )
    {
        self.connectionToken = connectionToken
        self.expiry = expiry
    }
}

public enum ConnectionType {
    case connectionCredentials
    case websocket
    case sdkUnknown(String)
}

extension ConnectionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionType] {
        return [
            .connectionCredentials,
            .websocket,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connectionCredentials: return "CONNECTION_CREDENTIALS"
        case .websocket: return "WEBSOCKET"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
    }
}

public struct CreateParticipantConnectionInputBodyMiddleware: Middleware {
    public let id: String = "CreateParticipantConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateParticipantConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateParticipantConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateParticipantConnectionInput>
    public typealias MOutput = OperationOutput<CreateParticipantConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateParticipantConnectionOutputError>
}

extension CreateParticipantConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateParticipantConnectionInput(participantToken: \(String(describing: participantToken)), type: \(String(describing: type)))"}
}

extension CreateParticipantConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for connectiontypelist0 in type {
                try typeContainer.encode(connectiontypelist0.rawValue)
            }
        }
    }
}

public struct CreateParticipantConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateParticipantConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateParticipantConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateParticipantConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let participantToken = input.operationInput.participantToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: String(participantToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateParticipantConnectionInput>
    public typealias MOutput = OperationOutput<CreateParticipantConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateParticipantConnectionOutputError>
}

public struct CreateParticipantConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateParticipantConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateParticipantConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateParticipantConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateParticipantConnectionInput>
    public typealias MOutput = OperationOutput<CreateParticipantConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateParticipantConnectionOutputError>
}

public struct CreateParticipantConnectionInput: Equatable {
    /// <p>This is a header parameter.</p>
    ///         <p>The Participant Token as obtained from <a href="https://docs.aws.amazon.com/connect/latest/APIReference/API_StartChatContact.html">StartChatContact</a>
    ///             API response.</p>
    public let participantToken: String?
    /// <p>Type of connection information required.</p>
    public let type: [ConnectionType]?

    public init (
        participantToken: String? = nil,
        type: [ConnectionType]? = nil
    )
    {
        self.participantToken = participantToken
        self.type = type
    }
}

struct CreateParticipantConnectionInputBody: Equatable {
    public let type: [ConnectionType]?
}

extension CreateParticipantConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeContainer = try containerValues.decodeIfPresent([ConnectionType?].self, forKey: .type)
        var typeDecoded0:[ConnectionType]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [ConnectionType]()
            for string0 in typeContainer {
                if let string0 = string0 {
                    typeDecoded0?.append(string0)
                }
            }
        }
        type = typeDecoded0
    }
}

extension CreateParticipantConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateParticipantConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateParticipantConnectionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateParticipantConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateParticipantConnectionOutputResponse(connectionCredentials: \(String(describing: connectionCredentials)), websocket: \(String(describing: websocket)))"}
}

extension CreateParticipantConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateParticipantConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectionCredentials = output.connectionCredentials
            self.websocket = output.websocket
        } else {
            self.connectionCredentials = nil
            self.websocket = nil
        }
    }
}

public struct CreateParticipantConnectionOutputResponse: Equatable {
    /// <p>Creates the participant's connection credentials. The authentication token associated
    ///             with the participant's connection.</p>
    public let connectionCredentials: ConnectionCredentials?
    /// <p>Creates the participant's websocket connection.</p>
    public let websocket: Websocket?

    public init (
        connectionCredentials: ConnectionCredentials? = nil,
        websocket: Websocket? = nil
    )
    {
        self.connectionCredentials = connectionCredentials
        self.websocket = websocket
    }
}

struct CreateParticipantConnectionOutputResponseBody: Equatable {
    public let websocket: Websocket?
    public let connectionCredentials: ConnectionCredentials?
}

extension CreateParticipantConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionCredentials = "ConnectionCredentials"
        case websocket = "Websocket"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websocketDecoded = try containerValues.decodeIfPresent(Websocket.self, forKey: .websocket)
        websocket = websocketDecoded
        let connectionCredentialsDecoded = try containerValues.decodeIfPresent(ConnectionCredentials.self, forKey: .connectionCredentials)
        connectionCredentials = connectionCredentialsDecoded
    }
}

public struct DisconnectParticipantInputBodyMiddleware: Middleware {
    public let id: String = "DisconnectParticipantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisconnectParticipantInput>,
                  next: H) -> Swift.Result<OperationOutput<DisconnectParticipantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisconnectParticipantInput>
    public typealias MOutput = OperationOutput<DisconnectParticipantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisconnectParticipantOutputError>
}

extension DisconnectParticipantInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisconnectParticipantInput(clientToken: \(String(describing: clientToken)), connectionToken: \(String(describing: connectionToken)))"}
}

extension DisconnectParticipantInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct DisconnectParticipantInputHeadersMiddleware: Middleware {
    public let id: String = "DisconnectParticipantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisconnectParticipantInput>,
                  next: H) -> Swift.Result<OperationOutput<DisconnectParticipantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisconnectParticipantInput>
    public typealias MOutput = OperationOutput<DisconnectParticipantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisconnectParticipantOutputError>
}

public struct DisconnectParticipantInputQueryItemMiddleware: Middleware {
    public let id: String = "DisconnectParticipantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisconnectParticipantInput>,
                  next: H) -> Swift.Result<OperationOutput<DisconnectParticipantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisconnectParticipantInput>
    public typealias MOutput = OperationOutput<DisconnectParticipantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisconnectParticipantOutputError>
}

public struct DisconnectParticipantInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///             request.</p>
    public var clientToken: String?
    /// <p>The authentication token associated with the participant's connection.</p>
    public let connectionToken: String?

    public init (
        clientToken: String? = nil,
        connectionToken: String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionToken = connectionToken
    }
}

struct DisconnectParticipantInputBody: Equatable {
    public let clientToken: String?
}

extension DisconnectParticipantInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisconnectParticipantOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisconnectParticipantOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisconnectParticipantOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisconnectParticipantOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisconnectParticipantOutputResponse()"}
}

extension DisconnectParticipantOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisconnectParticipantOutputResponse: Equatable {

    public init() {}
}

struct DisconnectParticipantOutputResponseBody: Equatable {
}

extension DisconnectParticipantOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct GetAttachmentInputBodyMiddleware: Middleware {
    public let id: String = "GetAttachmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAttachmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAttachmentInput>
    public typealias MOutput = OperationOutput<GetAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAttachmentOutputError>
}

extension GetAttachmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAttachmentInput(attachmentId: \(String(describing: attachmentId)), connectionToken: \(String(describing: connectionToken)))"}
}

extension GetAttachmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentId = "AttachmentId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
    }
}

public struct GetAttachmentInputHeadersMiddleware: Middleware {
    public let id: String = "GetAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAttachmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAttachmentInput>
    public typealias MOutput = OperationOutput<GetAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAttachmentOutputError>
}

public struct GetAttachmentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAttachmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAttachmentInput>
    public typealias MOutput = OperationOutput<GetAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAttachmentOutputError>
}

public struct GetAttachmentInput: Equatable {
    /// <p>A unique identifier for the attachment.</p>
    public let attachmentId: String?
    /// <p>The authentication token associated with the participant's connection.</p>
    public let connectionToken: String?

    public init (
        attachmentId: String? = nil,
        connectionToken: String? = nil
    )
    {
        self.attachmentId = attachmentId
        self.connectionToken = connectionToken
    }
}

struct GetAttachmentInputBody: Equatable {
    public let attachmentId: String?
}

extension GetAttachmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachmentId = "AttachmentId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
    }
}

extension GetAttachmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAttachmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAttachmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAttachmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAttachmentOutputResponse(url: \(String(describing: url)), urlExpiry: \(String(describing: urlExpiry)))"}
}

extension GetAttachmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.url = output.url
            self.urlExpiry = output.urlExpiry
        } else {
            self.url = nil
            self.urlExpiry = nil
        }
    }
}

public struct GetAttachmentOutputResponse: Equatable {
    /// <p>The pre-signed URL using which file would be downloaded from Amazon S3 by the API caller.</p>
    public let url: String?
    /// <p>The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
    public let urlExpiry: String?

    public init (
        url: String? = nil,
        urlExpiry: String? = nil
    )
    {
        self.url = url
        self.urlExpiry = urlExpiry
    }
}

struct GetAttachmentOutputResponseBody: Equatable {
    public let url: String?
    public let urlExpiry: String?
}

extension GetAttachmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case url = "Url"
        case urlExpiry = "UrlExpiry"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
    }
}

public struct GetTranscriptInputBodyMiddleware: Middleware {
    public let id: String = "GetTranscriptInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTranscriptInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTranscriptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTranscriptInput>
    public typealias MOutput = OperationOutput<GetTranscriptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTranscriptOutputError>
}

extension GetTranscriptInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTranscriptInput(connectionToken: \(String(describing: connectionToken)), contactId: \(String(describing: contactId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), scanDirection: \(String(describing: scanDirection)), sortOrder: \(String(describing: sortOrder)), startPosition: \(String(describing: startPosition)))"}
}

extension GetTranscriptInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scanDirection = "ScanDirection"
        case sortOrder = "SortOrder"
        case startPosition = "StartPosition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let scanDirection = scanDirection {
            try encodeContainer.encode(scanDirection.rawValue, forKey: .scanDirection)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
        if let startPosition = startPosition {
            try encodeContainer.encode(startPosition, forKey: .startPosition)
        }
    }
}

public struct GetTranscriptInputHeadersMiddleware: Middleware {
    public let id: String = "GetTranscriptInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTranscriptInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTranscriptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTranscriptInput>
    public typealias MOutput = OperationOutput<GetTranscriptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTranscriptOutputError>
}

public struct GetTranscriptInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTranscriptInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTranscriptInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTranscriptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTranscriptInput>
    public typealias MOutput = OperationOutput<GetTranscriptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTranscriptOutputError>
}

public struct GetTranscriptInput: Equatable {
    /// <p>The authentication token associated with the participant's connection.</p>
    public let connectionToken: String?
    /// <p>The contactId from the current contact chain for which transcript is needed.</p>
    public let contactId: String?
    /// <p>The maximum number of results to return in the page. Default: 10. </p>
    public let maxResults: Int
    /// <p>The pagination token. Use the value returned previously in the next subsequent request
    ///             to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The direction from StartPosition from which to retrieve message. Default: BACKWARD
    ///             when no StartPosition is provided, FORWARD with StartPosition. </p>
    public let scanDirection: ScanDirection?
    /// <p>The sort order for the records. Default: DESCENDING.</p>
    public let sortOrder: SortKey?
    /// <p>A filtering option for where to start.</p>
    public let startPosition: StartPosition?

    public init (
        connectionToken: String? = nil,
        contactId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        scanDirection: ScanDirection? = nil,
        sortOrder: SortKey? = nil,
        startPosition: StartPosition? = nil
    )
    {
        self.connectionToken = connectionToken
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scanDirection = scanDirection
        self.sortOrder = sortOrder
        self.startPosition = startPosition
    }
}

struct GetTranscriptInputBody: Equatable {
    public let contactId: String?
    public let maxResults: Int
    public let nextToken: String?
    public let scanDirection: ScanDirection?
    public let sortOrder: SortKey?
    public let startPosition: StartPosition?
}

extension GetTranscriptInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scanDirection = "ScanDirection"
        case sortOrder = "SortOrder"
        case startPosition = "StartPosition"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let scanDirectionDecoded = try containerValues.decodeIfPresent(ScanDirection.self, forKey: .scanDirection)
        scanDirection = scanDirectionDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortKey.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let startPositionDecoded = try containerValues.decodeIfPresent(StartPosition.self, forKey: .startPosition)
        startPosition = startPositionDecoded
    }
}

extension GetTranscriptOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTranscriptOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTranscriptOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTranscriptOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTranscriptOutputResponse(initialContactId: \(String(describing: initialContactId)), nextToken: \(String(describing: nextToken)), transcript: \(String(describing: transcript)))"}
}

extension GetTranscriptOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTranscriptOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.initialContactId = output.initialContactId
            self.nextToken = output.nextToken
            self.transcript = output.transcript
        } else {
            self.initialContactId = nil
            self.nextToken = nil
            self.transcript = nil
        }
    }
}

public struct GetTranscriptOutputResponse: Equatable {
    /// <p>The initial contact ID for the contact. </p>
    public let initialContactId: String?
    /// <p>The pagination token. Use the value returned previously in the next subsequent request
    ///             to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The list of messages in the session.</p>
    public let transcript: [Item]?

    public init (
        initialContactId: String? = nil,
        nextToken: String? = nil,
        transcript: [Item]? = nil
    )
    {
        self.initialContactId = initialContactId
        self.nextToken = nextToken
        self.transcript = transcript
    }
}

struct GetTranscriptOutputResponseBody: Equatable {
    public let initialContactId: String?
    public let transcript: [Item]?
    public let nextToken: String?
}

extension GetTranscriptOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initialContactId = "InitialContactId"
        case nextToken = "NextToken"
        case transcript = "Transcript"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialContactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let transcriptContainer = try containerValues.decodeIfPresent([Item?].self, forKey: .transcript)
        var transcriptDecoded0:[Item]? = nil
        if let transcriptContainer = transcriptContainer {
            transcriptDecoded0 = [Item]()
            for structure0 in transcriptContainer {
                if let structure0 = structure0 {
                    transcriptDecoded0?.append(structure0)
                }
            }
        }
        transcript = transcriptDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception occurs when there is an internal failure in the Amazon Connect service.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Item: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case absoluteTime = "AbsoluteTime"
        case attachments = "Attachments"
        case content = "Content"
        case contentType = "ContentType"
        case displayName = "DisplayName"
        case id = "Id"
        case participantId = "ParticipantId"
        case participantRole = "ParticipantRole"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absoluteTime = absoluteTime {
            try encodeContainer.encode(absoluteTime, forKey: .absoluteTime)
        }
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachments0 in attachments {
                try attachmentsContainer.encode(attachments0)
            }
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let participantId = participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let participantRole = participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChatItemType.self, forKey: .type)
        type = typeDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([AttachmentItem?].self, forKey: .attachments)
        var attachmentsDecoded0:[AttachmentItem]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [AttachmentItem]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
    }
}

extension Item: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Item(absoluteTime: \(String(describing: absoluteTime)), attachments: \(String(describing: attachments)), content: \(String(describing: content)), contentType: \(String(describing: contentType)), displayName: \(String(describing: displayName)), id: \(String(describing: id)), participantId: \(String(describing: participantId)), participantRole: \(String(describing: participantRole)), type: \(String(describing: type)))"}
}

/// <p>An item - message or event - that has been sent. </p>
public struct Item: Equatable {
    /// <p>The time when the message or event was sent.</p>
    ///         <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example,
    ///             2019-11-08T02:41:28.172Z.</p>
    public let absoluteTime: String?
    /// <p>Provides information about the attachments.</p>
    public let attachments: [AttachmentItem]?
    /// <p>The content of the message or event.</p>
    public let content: String?
    /// <p>The type of content of the item.</p>
    public let contentType: String?
    /// <p>The chat display name of the sender.</p>
    public let displayName: String?
    /// <p>The ID of the item.</p>
    public let id: String?
    /// <p>The ID of the sender in the session.</p>
    public let participantId: String?
    /// <p>The role of the sender. For example, is it a customer, agent, or system.</p>
    public let participantRole: ParticipantRole?
    /// <p>Type of the item: message or event. </p>
    public let type: ChatItemType?

    public init (
        absoluteTime: String? = nil,
        attachments: [AttachmentItem]? = nil,
        content: String? = nil,
        contentType: String? = nil,
        displayName: String? = nil,
        id: String? = nil,
        participantId: String? = nil,
        participantRole: ParticipantRole? = nil,
        type: ChatItemType? = nil
    )
    {
        self.absoluteTime = absoluteTime
        self.attachments = attachments
        self.content = content
        self.contentType = contentType
        self.displayName = displayName
        self.id = id
        self.participantId = participantId
        self.participantRole = participantRole
        self.type = type
    }
}

public enum ParticipantRole {
    case agent
    case customer
    case system
    case sdkUnknown(String)
}

extension ParticipantRole : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParticipantRole] {
        return [
            .agent,
            .customer,
            .system,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .agent: return "AGENT"
        case .customer: return "CUSTOMER"
        case .system: return "SYSTEM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParticipantRole(rawValue: rawValue) ?? ParticipantRole.sdkUnknown(rawValue)
    }
}

public enum ScanDirection {
    case backward
    case forward
    case sdkUnknown(String)
}

extension ScanDirection : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScanDirection] {
        return [
            .backward,
            .forward,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .backward: return "BACKWARD"
        case .forward: return "FORWARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScanDirection(rawValue: rawValue) ?? ScanDirection.sdkUnknown(rawValue)
    }
}

public struct SendEventInputBodyMiddleware: Middleware {
    public let id: String = "SendEventInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendEventInput>,
                  next: H) -> Swift.Result<OperationOutput<SendEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendEventInput>
    public typealias MOutput = OperationOutput<SendEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendEventOutputError>
}

extension SendEventInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendEventInput(clientToken: \(String(describing: clientToken)), connectionToken: \(String(describing: connectionToken)), content: \(String(describing: content)), contentType: \(String(describing: contentType)))"}
}

extension SendEventInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

public struct SendEventInputHeadersMiddleware: Middleware {
    public let id: String = "SendEventInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendEventInput>,
                  next: H) -> Swift.Result<OperationOutput<SendEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendEventInput>
    public typealias MOutput = OperationOutput<SendEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendEventOutputError>
}

public struct SendEventInputQueryItemMiddleware: Middleware {
    public let id: String = "SendEventInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendEventInput>,
                  next: H) -> Swift.Result<OperationOutput<SendEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendEventInput>
    public typealias MOutput = OperationOutput<SendEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendEventOutputError>
}

public struct SendEventInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///             request.</p>
    public var clientToken: String?
    /// <p>The authentication token associated with the participant's connection.</p>
    public let connectionToken: String?
    /// <p>The content of the event to be sent (for example, message text). This is not yet
    ///             supported.</p>
    public let content: String?
    /// <p>The content type of the request. Supported types are:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                 <p>application/vnd.amazonaws.connect.event.typing</p>
    ///             </li>
    ///             <li>
    ///                 <p>application/vnd.amazonaws.connect.event.connection.acknowledged</p>
    ///             </li>
    ///          </ul>
    public let contentType: String?

    public init (
        clientToken: String? = nil,
        connectionToken: String? = nil,
        content: String? = nil,
        contentType: String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionToken = connectionToken
        self.content = content
        self.contentType = contentType
    }
}

struct SendEventInputBody: Equatable {
    public let contentType: String?
    public let content: String?
    public let clientToken: String?
}

extension SendEventInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension SendEventOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendEventOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendEventOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendEventOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendEventOutputResponse(absoluteTime: \(String(describing: absoluteTime)), id: \(String(describing: id)))"}
}

extension SendEventOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendEventOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.absoluteTime = output.absoluteTime
            self.id = output.id
        } else {
            self.absoluteTime = nil
            self.id = nil
        }
    }
}

public struct SendEventOutputResponse: Equatable {
    /// <p>The time when the event was sent.</p>
    ///         <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example,
    ///             2019-11-08T02:41:28.172Z.</p>
    public let absoluteTime: String?
    /// <p>The ID of the response.</p>
    public let id: String?

    public init (
        absoluteTime: String? = nil,
        id: String? = nil
    )
    {
        self.absoluteTime = absoluteTime
        self.id = id
    }
}

struct SendEventOutputResponseBody: Equatable {
    public let id: String?
    public let absoluteTime: String?
}

extension SendEventOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case absoluteTime = "AbsoluteTime"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
    }
}

public struct SendMessageInputBodyMiddleware: Middleware {
    public let id: String = "SendMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<SendMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendMessageInput>
    public typealias MOutput = OperationOutput<SendMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendMessageOutputError>
}

extension SendMessageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendMessageInput(clientToken: \(String(describing: clientToken)), connectionToken: \(String(describing: connectionToken)), content: \(String(describing: content)), contentType: \(String(describing: contentType)))"}
}

extension SendMessageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

public struct SendMessageInputHeadersMiddleware: Middleware {
    public let id: String = "SendMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<SendMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendMessageInput>
    public typealias MOutput = OperationOutput<SendMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendMessageOutputError>
}

public struct SendMessageInputQueryItemMiddleware: Middleware {
    public let id: String = "SendMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<SendMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendMessageInput>
    public typealias MOutput = OperationOutput<SendMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendMessageOutputError>
}

public struct SendMessageInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///             request.</p>
    public var clientToken: String?
    /// <p>The authentication token associated with the connection.</p>
    public let connectionToken: String?
    /// <p>The content of the message.</p>
    public let content: String?
    /// <p>The type of the content. Supported types are text/plain.</p>
    public let contentType: String?

    public init (
        clientToken: String? = nil,
        connectionToken: String? = nil,
        content: String? = nil,
        contentType: String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionToken = connectionToken
        self.content = content
        self.contentType = contentType
    }
}

struct SendMessageInputBody: Equatable {
    public let contentType: String?
    public let content: String?
    public let clientToken: String?
}

extension SendMessageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension SendMessageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendMessageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendMessageOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendMessageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendMessageOutputResponse(absoluteTime: \(String(describing: absoluteTime)), id: \(String(describing: id)))"}
}

extension SendMessageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendMessageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.absoluteTime = output.absoluteTime
            self.id = output.id
        } else {
            self.absoluteTime = nil
            self.id = nil
        }
    }
}

public struct SendMessageOutputResponse: Equatable {
    /// <p>The time when the message was sent.</p>
    ///         <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example,
    ///             2019-11-08T02:41:28.172Z.</p>
    public let absoluteTime: String?
    /// <p>The ID of the message.</p>
    public let id: String?

    public init (
        absoluteTime: String? = nil,
        id: String? = nil
    )
    {
        self.absoluteTime = absoluteTime
        self.id = id
    }
}

struct SendMessageOutputResponseBody: Equatable {
    public let id: String?
    public let absoluteTime: String?
}

extension SendMessageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case absoluteTime = "AbsoluteTime"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of attachments per contact exceeds the quota.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SortKey {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension SortKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortKey] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASCENDING"
        case .descending: return "DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortKey(rawValue: rawValue) ?? SortKey.sdkUnknown(rawValue)
    }
}

public struct StartAttachmentUploadInputBodyMiddleware: Middleware {
    public let id: String = "StartAttachmentUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAttachmentUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAttachmentUploadInput>
    public typealias MOutput = OperationOutput<StartAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAttachmentUploadOutputError>
}

extension StartAttachmentUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAttachmentUploadInput(attachmentName: \(String(describing: attachmentName)), attachmentSizeInBytes: \(String(describing: attachmentSizeInBytes)), clientToken: \(String(describing: clientToken)), connectionToken: \(String(describing: connectionToken)), contentType: \(String(describing: contentType)))"}
}

extension StartAttachmentUploadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentName = "AttachmentName"
        case attachmentSizeInBytes = "AttachmentSizeInBytes"
        case clientToken = "ClientToken"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentName = attachmentName {
            try encodeContainer.encode(attachmentName, forKey: .attachmentName)
        }
        if attachmentSizeInBytes != 0 {
            try encodeContainer.encode(attachmentSizeInBytes, forKey: .attachmentSizeInBytes)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

public struct StartAttachmentUploadInputHeadersMiddleware: Middleware {
    public let id: String = "StartAttachmentUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAttachmentUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAttachmentUploadInput>
    public typealias MOutput = OperationOutput<StartAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAttachmentUploadOutputError>
}

public struct StartAttachmentUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "StartAttachmentUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAttachmentUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAttachmentUploadInput>
    public typealias MOutput = OperationOutput<StartAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAttachmentUploadOutputError>
}

public struct StartAttachmentUploadInput: Equatable {
    /// <p>A case-sensitive name of the attachment being uploaded.</p>
    public let attachmentName: String?
    /// <p>The size of the attachment in bytes.</p>
    public let attachmentSizeInBytes: Int
    /// <p>A unique case sensitive identifier to support idempotency of request.</p>
    public var clientToken: String?
    /// <p>The authentication token associated with the participant's connection.</p>
    public let connectionToken: String?
    /// <p>Describes the MIME file type of the attachment. For a list of supported file types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#feature-limits">Feature specifications</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public let contentType: String?

    public init (
        attachmentName: String? = nil,
        attachmentSizeInBytes: Int = 0,
        clientToken: String? = nil,
        connectionToken: String? = nil,
        contentType: String? = nil
    )
    {
        self.attachmentName = attachmentName
        self.attachmentSizeInBytes = attachmentSizeInBytes
        self.clientToken = clientToken
        self.connectionToken = connectionToken
        self.contentType = contentType
    }
}

struct StartAttachmentUploadInputBody: Equatable {
    public let contentType: String?
    public let attachmentSizeInBytes: Int
    public let attachmentName: String?
    public let clientToken: String?
}

extension StartAttachmentUploadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachmentName = "AttachmentName"
        case attachmentSizeInBytes = "AttachmentSizeInBytes"
        case clientToken = "ClientToken"
        case contentType = "ContentType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let attachmentSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .attachmentSizeInBytes)
        attachmentSizeInBytes = attachmentSizeInBytesDecoded
        let attachmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentName)
        attachmentName = attachmentNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartAttachmentUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAttachmentUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAttachmentUploadOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAttachmentUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAttachmentUploadOutputResponse(attachmentId: \(String(describing: attachmentId)), uploadMetadata: \(String(describing: uploadMetadata)))"}
}

extension StartAttachmentUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartAttachmentUploadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attachmentId = output.attachmentId
            self.uploadMetadata = output.uploadMetadata
        } else {
            self.attachmentId = nil
            self.uploadMetadata = nil
        }
    }
}

public struct StartAttachmentUploadOutputResponse: Equatable {
    /// <p>A unique identifier for the attachment.</p>
    public let attachmentId: String?
    /// <p>Fields to be used while uploading the attachment.</p>
    public let uploadMetadata: UploadMetadata?

    public init (
        attachmentId: String? = nil,
        uploadMetadata: UploadMetadata? = nil
    )
    {
        self.attachmentId = attachmentId
        self.uploadMetadata = uploadMetadata
    }
}

struct StartAttachmentUploadOutputResponseBody: Equatable {
    public let attachmentId: String?
    public let uploadMetadata: UploadMetadata?
}

extension StartAttachmentUploadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachmentId = "AttachmentId"
        case uploadMetadata = "UploadMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let uploadMetadataDecoded = try containerValues.decodeIfPresent(UploadMetadata.self, forKey: .uploadMetadata)
        uploadMetadata = uploadMetadataDecoded
    }
}

extension StartPosition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case absoluteTime = "AbsoluteTime"
        case id = "Id"
        case mostRecent = "MostRecent"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absoluteTime = absoluteTime {
            try encodeContainer.encode(absoluteTime, forKey: .absoluteTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if mostRecent != 0 {
            try encodeContainer.encode(mostRecent, forKey: .mostRecent)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
        let mostRecentDecoded = try containerValues.decode(Int.self, forKey: .mostRecent)
        mostRecent = mostRecentDecoded
    }
}

extension StartPosition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartPosition(absoluteTime: \(String(describing: absoluteTime)), id: \(String(describing: id)), mostRecent: \(String(describing: mostRecent)))"}
}

/// <p>A filtering option for where to start. For example, if you sent 100 messages, start
///             with message 50. </p>
public struct StartPosition: Equatable {
    /// <p>The time in ISO format where to start.</p>
    ///         <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example,
    ///             2019-11-08T02:41:28.172Z.</p>
    public let absoluteTime: String?
    /// <p>The ID of the message or event where to start. </p>
    public let id: String?
    /// <p>The start position of the most recent message where you want to start. </p>
    public let mostRecent: Int

    public init (
        absoluteTime: String? = nil,
        id: String? = nil,
        mostRecent: Int = 0
    )
    {
        self.absoluteTime = absoluteTime
        self.id = id
        self.mostRecent = mostRecent
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UploadMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case headersToInclude = "HeadersToInclude"
        case url = "Url"
        case urlExpiry = "UrlExpiry"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headersToInclude = headersToInclude {
            var headersToIncludeContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .headersToInclude)
            for (dictKey0, uploadmetadatasignedheaders0) in headersToInclude {
                try headersToIncludeContainer.encode(uploadmetadatasignedheaders0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let urlExpiry = urlExpiry {
            try encodeContainer.encode(urlExpiry, forKey: .urlExpiry)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
        let headersToIncludeContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .headersToInclude)
        var headersToIncludeDecoded0: [String:String]? = nil
        if let headersToIncludeContainer = headersToIncludeContainer {
            headersToIncludeDecoded0 = [String:String]()
            for (key0, uploadmetadatasignedheadersvalue0) in headersToIncludeContainer {
                if let uploadmetadatasignedheadersvalue0 = uploadmetadatasignedheadersvalue0 {
                    headersToIncludeDecoded0?[key0] = uploadmetadatasignedheadersvalue0
                }
            }
        }
        headersToInclude = headersToIncludeDecoded0
    }
}

extension UploadMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadMetadata(headersToInclude: \(String(describing: headersToInclude)), url: \(String(describing: url)), urlExpiry: \(String(describing: urlExpiry)))"}
}

/// <p>Fields to be used while uploading the attachment.</p>
public struct UploadMetadata: Equatable {
    /// <p>The headers to be provided while uploading the file to the URL.</p>
    public let headersToInclude: [String:String]?
    /// <p>The pre-signed URL using which file would be downloaded from Amazon S3 by the API caller.</p>
    public let url: String?
    /// <p>The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
    public let urlExpiry: String?

    public init (
        headersToInclude: [String:String]? = nil,
        url: String? = nil,
        urlExpiry: String? = nil
    )
    {
        self.headersToInclude = headersToInclude
        self.url = url
        self.urlExpiry = urlExpiry
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints specified by Amazon Connect.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Websocket: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionExpiry = "ConnectionExpiry"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionExpiry = connectionExpiry {
            try encodeContainer.encode(connectionExpiry, forKey: .connectionExpiry)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let connectionExpiryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionExpiry)
        connectionExpiry = connectionExpiryDecoded
    }
}

extension Websocket: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Websocket(connectionExpiry: \(String(describing: connectionExpiry)), url: \(String(describing: url)))"}
}

/// <p>The websocket for the participant's connection.</p>
public struct Websocket: Equatable {
    /// <p>The URL expiration timestamp in ISO date format.</p>
    ///         <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example,
    ///             2019-11-08T02:41:28.172Z.</p>
    public let connectionExpiry: String?
    /// <p>The URL of the websocket.</p>
    public let url: String?

    public init (
        connectionExpiry: String? = nil,
        url: String? = nil
    )
    {
        self.connectionExpiry = connectionExpiry
        self.url = url
    }
}
