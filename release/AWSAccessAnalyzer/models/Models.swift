// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessAnalyzerClientTypes.AccessPreview: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case configurations
        case createdAt
        case id
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configurations)
            for (dictKey0, configurationsmap0) in configurations {
                try configurationsContainer.encode(configurationsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let configurationsContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0: [Swift.String:AccessAnalyzerClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Configuration]()
            for (key0, configuration0) in configurationsContainer {
                if let configuration0 = configuration0 {
                    configurationsDecoded0?[key0] = configuration0
                }
            }
        }
        configurations = configurationsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AccessPreviewStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AccessPreviewStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AccessAnalyzerClientTypes.AccessPreview: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessPreview(analyzerArn: \(Swift.String(describing: analyzerArn)), configurations: \(Swift.String(describing: configurations)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains information about an access preview.
    public struct AccessPreview: Swift.Equatable {
        /// The ARN of the analyzer used to generate the access preview.
        /// This member is required.
        public var analyzerArn: Swift.String?
        /// A map of resource ARNs for the proposed resource configuration.
        /// This member is required.
        public var configurations: [Swift.String:AccessAnalyzerClientTypes.Configuration]?
        /// The time at which the access preview was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The unique ID for the access preview.
        /// This member is required.
        public var id: Swift.String?
        /// The status of the access preview.
        ///
        ///
        ///
        ///                   Creating - The access preview creation is in progress.
        ///
        ///
        ///
        ///                   Completed - The access preview is complete. You can preview findings
        ///                for external access to the resource.
        ///
        ///
        ///
        ///                   Failed - The access preview creation has failed.
        ///
        ///
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.AccessPreviewStatus?
        /// Provides more details about the current status of the access preview.
        ///          For example, if the creation of the access preview fails, a Failed status
        ///          is returned. This failure can be due to an internal issue with the analysis or due to an
        ///          invalid resource configuration.
        public var statusReason: AccessAnalyzerClientTypes.AccessPreviewStatusReason?

        public init (
            analyzerArn: Swift.String? = nil,
            configurations: [Swift.String:AccessAnalyzerClientTypes.Configuration]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            status: AccessAnalyzerClientTypes.AccessPreviewStatus? = nil,
            statusReason: AccessAnalyzerClientTypes.AccessPreviewStatusReason? = nil
        )
        {
            self.analyzerArn = analyzerArn
            self.configurations = configurations
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension AccessAnalyzerClientTypes.AccessPreviewFinding: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case changeType
        case condition
        case createdAt
        case error
        case existingFindingId
        case existingFindingStatus
        case id
        case isPublic
        case principal
        case resource
        case resourceOwnerAccount
        case resourceType
        case sources
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            var actionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .action)
            for actionlist0 in action {
                try actionContainer.encode(actionlist0)
            }
        }
        if let changeType = changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let condition = condition {
            var conditionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .condition)
            for (dictKey0, conditionkeymap0) in condition {
                try conditionContainer.encode(conditionkeymap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let existingFindingId = existingFindingId {
            try encodeContainer.encode(existingFindingId, forKey: .existingFindingId)
        }
        if let existingFindingStatus = existingFindingStatus {
            try encodeContainer.encode(existingFindingStatus.rawValue, forKey: .existingFindingStatus)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isPublic = isPublic {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let principal = principal {
            var principalContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .principal)
            for (dictKey0, principalmap0) in principal {
                try principalContainer.encode(principalmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceOwnerAccount = resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for findingsourcelist0 in sources {
                try sourcesContainer.encode(findingsourcelist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let existingFindingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .existingFindingId)
        existingFindingId = existingFindingIdDecoded
        let existingFindingStatusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingStatus.self, forKey: .existingFindingStatus)
        existingFindingStatus = existingFindingStatusDecoded
        let principalContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principal)
        var principalDecoded0: [Swift.String:Swift.String]? = nil
        if let principalContainer = principalContainer {
            principalDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in principalContainer {
                if let string0 = string0 {
                    principalDecoded0?[key0] = string0
                }
            }
        }
        principal = principalDecoded0
        let actionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .action)
        var actionDecoded0:[Swift.String]? = nil
        if let actionContainer = actionContainer {
            actionDecoded0 = [Swift.String]()
            for string0 in actionContainer {
                if let string0 = string0 {
                    actionDecoded0?.append(string0)
                }
            }
        }
        action = actionDecoded0
        let conditionContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .condition)
        var conditionDecoded0: [Swift.String:Swift.String]? = nil
        if let conditionContainer = conditionContainer {
            conditionDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in conditionContainer {
                if let string0 = string0 {
                    conditionDecoded0?[key0] = string0
                }
            }
        }
        condition = conditionDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let isPublicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.FindingSource?].self, forKey: .sources)
        var sourcesDecoded0:[AccessAnalyzerClientTypes.FindingSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [AccessAnalyzerClientTypes.FindingSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension AccessAnalyzerClientTypes.AccessPreviewFinding: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessPreviewFinding(action: \(Swift.String(describing: action)), changeType: \(Swift.String(describing: changeType)), condition: \(Swift.String(describing: condition)), createdAt: \(Swift.String(describing: createdAt)), error: \(Swift.String(describing: error)), existingFindingId: \(Swift.String(describing: existingFindingId)), existingFindingStatus: \(Swift.String(describing: existingFindingStatus)), id: \(Swift.String(describing: id)), isPublic: \(Swift.String(describing: isPublic)), principal: \(Swift.String(describing: principal)), resource: \(Swift.String(describing: resource)), resourceOwnerAccount: \(Swift.String(describing: resourceOwnerAccount)), resourceType: \(Swift.String(describing: resourceType)), sources: \(Swift.String(describing: sources)), status: \(Swift.String(describing: status)))"}
}

extension AccessAnalyzerClientTypes {
    /// An access preview finding generated by the access preview.
    public struct AccessPreviewFinding: Swift.Equatable {
        /// The action in the analyzed policy statement that an external principal has permission to
        ///          perform.
        public var action: [Swift.String]?
        /// Provides context on how the access preview finding compares to existing access
        ///          identified in IAM Access Analyzer.
        ///
        ///
        ///
        ///                   New - The finding is for newly-introduced access.
        ///
        ///
        ///
        ///                   Unchanged - The preview finding is an existing finding that would
        ///                remain unchanged.
        ///
        ///
        ///
        ///                   Changed - The preview finding is an existing finding with a change in
        ///                status.
        ///
        ///
        ///          For example, a Changed finding with preview status Resolved
        ///          and existing status Active indicates the existing Active finding
        ///          would become Resolved as a result of the proposed permissions change.
        /// This member is required.
        public var changeType: AccessAnalyzerClientTypes.FindingChangeType?
        /// The condition in the analyzed policy statement that resulted in a finding.
        public var condition: [Swift.String:Swift.String]?
        /// The time at which the access preview finding was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// An error.
        public var error: Swift.String?
        /// The existing ID of the finding in IAM Access Analyzer, provided only for existing
        ///          findings.
        public var existingFindingId: Swift.String?
        /// The existing status of the finding, provided only for existing findings.
        public var existingFindingStatus: AccessAnalyzerClientTypes.FindingStatus?
        /// The ID of the access preview finding. This ID uniquely identifies the element in the
        ///          list of access preview findings and is not related to the finding ID in Access
        ///          Analyzer.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates whether the policy that generated the finding allows public access to the
        ///          resource.
        public var isPublic: Swift.Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public var principal: [Swift.String:Swift.String]?
        /// The resource that an external principal has access to. This is the resource associated
        ///          with the access preview.
        public var resource: Swift.String?
        /// The Amazon Web Services account ID that owns the resource. For most Amazon Web Services resources, the owning
        ///          account is the account in which the resource was created.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource that can be accessed in the finding.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// The sources of the finding. This indicates how the access that generated the finding is
        ///          granted. It is populated for Amazon S3 bucket findings.
        public var sources: [AccessAnalyzerClientTypes.FindingSource]?
        /// The preview status of the finding. This is what the status of the finding would be after
        ///          permissions deployment. For example, a Changed finding with preview status
        ///             Resolved and existing status Active indicates the existing
        ///             Active finding would become Resolved as a result of the
        ///          proposed permissions change.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.FindingStatus?

        public init (
            action: [Swift.String]? = nil,
            changeType: AccessAnalyzerClientTypes.FindingChangeType? = nil,
            condition: [Swift.String:Swift.String]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            error: Swift.String? = nil,
            existingFindingId: Swift.String? = nil,
            existingFindingStatus: AccessAnalyzerClientTypes.FindingStatus? = nil,
            id: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            principal: [Swift.String:Swift.String]? = nil,
            resource: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            sources: [AccessAnalyzerClientTypes.FindingSource]? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil
        )
        {
            self.action = action
            self.changeType = changeType
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.existingFindingId = existingFindingId
            self.existingFindingStatus = existingFindingStatus
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum AccessPreviewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPreviewStatus] {
            return [
                .completed,
                .creating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessPreviewStatus(rawValue: rawValue) ?? AccessPreviewStatus.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.AccessPreviewStatusReason: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AccessPreviewStatusReasonCode.self, forKey: .code)
        code = codeDecoded
    }
}

extension AccessAnalyzerClientTypes.AccessPreviewStatusReason: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessPreviewStatusReason(code: \(Swift.String(describing: code)))"}
}

extension AccessAnalyzerClientTypes {
    /// Provides more details about the current status of the access preview. For example, if
    ///          the creation of the access preview fails, a Failed status is returned. This
    ///          failure can be due to an internal issue with the analysis or due to an invalid proposed
    ///          resource configuration.
    public struct AccessPreviewStatusReason: Swift.Equatable {
        /// The reason code for the current status of the access preview.
        /// This member is required.
        public var code: AccessAnalyzerClientTypes.AccessPreviewStatusReasonCode?

        public init (
            code: AccessAnalyzerClientTypes.AccessPreviewStatusReasonCode? = nil
        )
        {
            self.code = code
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum AccessPreviewStatusReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case invalidConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPreviewStatusReasonCode] {
            return [
                .internalError,
                .invalidConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case .invalidConfiguration: return "INVALID_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessPreviewStatusReasonCode(rawValue: rawValue) ?? AccessPreviewStatusReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.AccessPreviewSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case createdAt
        case id
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AccessPreviewStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AccessPreviewStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AccessAnalyzerClientTypes.AccessPreviewSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessPreviewSummary(analyzerArn: \(Swift.String(describing: analyzerArn)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains a summary of information about an access preview.
    public struct AccessPreviewSummary: Swift.Equatable {
        /// The ARN of the analyzer used to generate the access preview.
        /// This member is required.
        public var analyzerArn: Swift.String?
        /// The time at which the access preview was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The unique ID for the access preview.
        /// This member is required.
        public var id: Swift.String?
        /// The status of the access preview.
        ///
        ///
        ///
        ///                   Creating - The access preview creation is in progress.
        ///
        ///
        ///
        ///                   Completed - The access preview is complete and previews the findings
        ///                for external access to the resource.
        ///
        ///
        ///
        ///                   Failed - The access preview creation has failed.
        ///
        ///
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.AccessPreviewStatus?
        /// Provides more details about the current status of the access preview. For example, if
        ///          the creation of the access preview fails, a Failed status is returned. This
        ///          failure can be due to an internal issue with the analysis or due to an invalid proposed
        ///          resource configuration.
        public var statusReason: AccessAnalyzerClientTypes.AccessPreviewStatusReason?

        public init (
            analyzerArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            status: AccessAnalyzerClientTypes.AccessPreviewStatus? = nil,
            statusReason: AccessAnalyzerClientTypes.AccessPreviewStatusReason? = nil
        )
        {
            self.analyzerArn = analyzerArn
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension AccessAnalyzerClientTypes.AclGrantee: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case sdkUnknown
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .id(id):
                try container.encode(id, forKey: .id)
            case let .uri(uri):
                try container.encode(uri, forKey: .uri)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .id)
        if let id = idDecoded {
            self = .id(id)
            return
        }
        let uriDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .uri)
        if let uri = uriDecoded {
            self = .uri(uri)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AccessAnalyzerClientTypes {
    /// You specify each grantee as a type-value pair using one of these types. You can specify
    ///          only one type of grantee. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketAcl.html">PutBucketAcl.
    public enum AclGrantee: Swift.Equatable, Swift.Hashable {
        /// The value specified is the canonical user ID of an Amazon Web Services account.
        case id(Swift.String)
        /// Used for granting permissions to a predefined group.
        case uri(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AccessAnalyzerClientTypes {
    public enum AclPermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullControl
        case read
        case readAcp
        case write
        case writeAcp
        case sdkUnknown(Swift.String)

        public static var allCases: [AclPermission] {
            return [
                .fullControl,
                .read,
                .readAcp,
                .write,
                .writeAcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullControl: return "FULL_CONTROL"
            case .read: return "READ"
            case .readAcp: return "READ_ACP"
            case .write: return "WRITE"
            case .writeAcp: return "WRITE_ACP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AclPermission(rawValue: rawValue) ?? AclPermission.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.AnalyzedResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case analyzedAt
        case createdAt
        case error
        case isPublic
        case resourceArn
        case resourceOwnerAccount
        case resourceType
        case sharedVia
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0)
            }
        }
        if let analyzedAt = analyzedAt {
            try encodeContainer.encode(analyzedAt.timeIntervalSince1970, forKey: .analyzedAt)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let isPublic = isPublic {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerAccount = resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sharedVia = sharedVia {
            var sharedViaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedVia)
            for sharedvialist0 in sharedVia {
                try sharedViaContainer.encode(sharedvialist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let analyzedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .analyzedAt)
        analyzedAt = analyzedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let isPublicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let sharedViaContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sharedVia)
        var sharedViaDecoded0:[Swift.String]? = nil
        if let sharedViaContainer = sharedViaContainer {
            sharedViaDecoded0 = [Swift.String]()
            for string0 in sharedViaContainer {
                if let string0 = string0 {
                    sharedViaDecoded0?.append(string0)
                }
            }
        }
        sharedVia = sharedViaDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

extension AccessAnalyzerClientTypes.AnalyzedResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnalyzedResource(actions: \(Swift.String(describing: actions)), analyzedAt: \(Swift.String(describing: analyzedAt)), createdAt: \(Swift.String(describing: createdAt)), error: \(Swift.String(describing: error)), isPublic: \(Swift.String(describing: isPublic)), resourceArn: \(Swift.String(describing: resourceArn)), resourceOwnerAccount: \(Swift.String(describing: resourceOwnerAccount)), resourceType: \(Swift.String(describing: resourceType)), sharedVia: \(Swift.String(describing: sharedVia)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains details about the analyzed resource.
    public struct AnalyzedResource: Swift.Equatable {
        /// The actions that an external principal is granted permission to use by the policy that
        ///          generated the finding.
        public var actions: [Swift.String]?
        /// The time at which the resource was analyzed.
        /// This member is required.
        public var analyzedAt: ClientRuntime.Date?
        /// The time at which the finding was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// An error message.
        public var error: Swift.String?
        /// Indicates whether the policy that generated the finding grants public access to the
        ///          resource.
        /// This member is required.
        public var isPublic: Swift.Bool?
        /// The ARN of the resource that was analyzed.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource that was analyzed.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// Indicates how the access that generated the finding is granted. This is populated for
        ///          Amazon S3 bucket findings.
        public var sharedVia: [Swift.String]?
        /// The current status of the finding generated from the analyzed resource.
        public var status: AccessAnalyzerClientTypes.FindingStatus?
        /// The time at which the finding was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            actions: [Swift.String]? = nil,
            analyzedAt: ClientRuntime.Date? = nil,
            createdAt: ClientRuntime.Date? = nil,
            error: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            resourceArn: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            sharedVia: [Swift.String]? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.actions = actions
            self.analyzedAt = analyzedAt
            self.createdAt = createdAt
            self.error = error
            self.isPublic = isPublic
            self.resourceArn = resourceArn
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sharedVia = sharedVia
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension AccessAnalyzerClientTypes.AnalyzedResourceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case resourceOwnerAccount
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerAccount = resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AccessAnalyzerClientTypes.AnalyzedResourceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnalyzedResourceSummary(resourceArn: \(Swift.String(describing: resourceArn)), resourceOwnerAccount: \(Swift.String(describing: resourceOwnerAccount)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains the ARN of the analyzed resource.
    public struct AnalyzedResourceSummary: Swift.Equatable {
        /// The ARN of the analyzed resource.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of resource that was analyzed.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?

        public init (
            resourceArn: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil
        )
        {
            self.resourceArn = resourceArn
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum AnalyzerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case disabled
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyzerStatus] {
            return [
                .active,
                .creating,
                .disabled,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .disabled: return "DISABLED"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyzerStatus(rawValue: rawValue) ?? AnalyzerStatus.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.AnalyzerSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastResourceAnalyzed
        case lastResourceAnalyzedAt
        case name
        case status
        case statusReason
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastResourceAnalyzed = lastResourceAnalyzed {
            try encodeContainer.encode(lastResourceAnalyzed, forKey: .lastResourceAnalyzed)
        }
        if let lastResourceAnalyzedAt = lastResourceAnalyzedAt {
            try encodeContainer.encode(lastResourceAnalyzedAt.timeIntervalSince1970, forKey: .lastResourceAnalyzedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastResourceAnalyzedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastResourceAnalyzed)
        lastResourceAnalyzed = lastResourceAnalyzedDecoded
        let lastResourceAnalyzedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastResourceAnalyzedAt)
        lastResourceAnalyzedAt = lastResourceAnalyzedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AnalyzerStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.StatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AccessAnalyzerClientTypes.AnalyzerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnalyzerSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), lastResourceAnalyzed: \(Swift.String(describing: lastResourceAnalyzed)), lastResourceAnalyzedAt: \(Swift.String(describing: lastResourceAnalyzedAt)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains information about the analyzer.
    public struct AnalyzerSummary: Swift.Equatable {
        /// The ARN of the analyzer.
        /// This member is required.
        public var arn: Swift.String?
        /// A timestamp for the time at which the analyzer was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The resource that was most recently analyzed by the analyzer.
        public var lastResourceAnalyzed: Swift.String?
        /// The time at which the most recently analyzed resource was analyzed.
        public var lastResourceAnalyzedAt: ClientRuntime.Date?
        /// The name of the analyzer.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the analyzer. An Active analyzer successfully monitors
        ///          supported resources and generates new findings. The analyzer is Disabled when
        ///          a user action, such as removing trusted access for Identity and Access Management Access Analyzer from Organizations, causes
        ///          the analyzer to stop generating new findings. The status is Creating when the
        ///          analyzer creation is in progress and Failed when the analyzer creation has
        ///          failed.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.AnalyzerStatus?
        /// The statusReason provides more details about the current status of the
        ///          analyzer. For example, if the creation for the analyzer fails, a Failed status
        ///          is returned. For an analyzer with organization as the type, this failure can be due to an
        ///          issue with creating the service-linked roles required in the member accounts of the Amazon Web Services
        ///          organization.
        public var statusReason: AccessAnalyzerClientTypes.StatusReason?
        /// The tags added to the analyzer.
        public var tags: [Swift.String:Swift.String]?
        /// The type of analyzer, which corresponds to the zone of trust chosen for the
        ///          analyzer.
        /// This member is required.
        public var type: AccessAnalyzerClientTypes.ModelType?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastResourceAnalyzed: Swift.String? = nil,
            lastResourceAnalyzedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: AccessAnalyzerClientTypes.AnalyzerStatus? = nil,
            statusReason: AccessAnalyzerClientTypes.StatusReason? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: AccessAnalyzerClientTypes.ModelType? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastResourceAnalyzed = lastResourceAnalyzed
            self.lastResourceAnalyzedAt = lastResourceAnalyzedAt
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.type = type
        }
    }

}

public struct ApplyArchiveRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyArchiveRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplyArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplyArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyArchiveRuleOutputError>
}

extension ApplyArchiveRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplyArchiveRuleInput(analyzerArn: \(Swift.String(describing: analyzerArn)), clientToken: \(Swift.String(describing: clientToken)), ruleName: \(Swift.String(describing: ruleName)))"}
}

extension ApplyArchiveRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case clientToken
        case ruleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }
}

public struct ApplyArchiveRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyArchiveRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplyArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplyArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyArchiveRuleOutputError>
}

public struct ApplyArchiveRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyArchiveRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplyArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplyArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyArchiveRuleOutputError>
}

public struct ApplyArchiveRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyArchiveRuleInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ApplyArchiveRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/archive-rule"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ApplyArchiveRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyArchiveRuleOutputError>
}

/// Retroactively applies an archive rule.
public struct ApplyArchiveRuleInput: Swift.Equatable {
    /// The Amazon resource name (ARN) of the analyzer.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// The name of the rule to apply.
    /// This member is required.
    public var ruleName: Swift.String?

    public init (
        analyzerArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.clientToken = clientToken
        self.ruleName = ruleName
    }
}

struct ApplyArchiveRuleInputBody: Swift.Equatable {
    public let analyzerArn: Swift.String?
    public let ruleName: Swift.String?
    public let clientToken: Swift.String?
}

extension ApplyArchiveRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case clientToken
        case ruleName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ApplyArchiveRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ApplyArchiveRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplyArchiveRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplyArchiveRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplyArchiveRuleOutputResponse()"}
}

extension ApplyArchiveRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ApplyArchiveRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct ApplyArchiveRuleOutputResponseBody: Swift.Equatable {
}

extension ApplyArchiveRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AccessAnalyzerClientTypes.ArchiveRuleSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case filter
        case ruleName
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, filtercriteriamap0) in filter {
                try filterContainer.encode(filtercriteriamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Criterion?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension AccessAnalyzerClientTypes.ArchiveRuleSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArchiveRuleSummary(createdAt: \(Swift.String(describing: createdAt)), filter: \(Swift.String(describing: filter)), ruleName: \(Swift.String(describing: ruleName)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains information about an archive rule.
    public struct ArchiveRuleSummary: Swift.Equatable {
        /// The time at which the archive rule was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A filter used to define the archive rule.
        /// This member is required.
        public var filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
        /// The name of the archive rule.
        /// This member is required.
        public var ruleName: Swift.String?
        /// The time at which the archive rule was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil,
            ruleName: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.filter = filter
            self.ruleName = ruleName
            self.updatedAt = updatedAt
        }
    }

}

extension CancelPolicyGenerationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelPolicyGenerationInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension CancelPolicyGenerationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CancelPolicyGenerationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelPolicyGenerationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelPolicyGenerationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelPolicyGenerationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelPolicyGenerationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelPolicyGenerationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelPolicyGenerationOutputError>
}

public struct CancelPolicyGenerationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelPolicyGenerationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelPolicyGenerationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelPolicyGenerationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelPolicyGenerationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelPolicyGenerationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelPolicyGenerationOutputError>
}

public struct CancelPolicyGenerationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelPolicyGenerationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CancelPolicyGenerationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelPolicyGenerationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let jobId = input.jobId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("jobId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/policy/generation/\(jobId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelPolicyGenerationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelPolicyGenerationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelPolicyGenerationOutputError>
}

public struct CancelPolicyGenerationInput: Swift.Equatable {
    /// The JobId that is returned by the StartPolicyGeneration
    ///          operation. The JobId can be used with GetGeneratedPolicy to
    ///          retrieve the generated policies or used with CancelPolicyGeneration to cancel
    ///          the policy generation request.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelPolicyGenerationInputBody: Swift.Equatable {
}

extension CancelPolicyGenerationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelPolicyGenerationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelPolicyGenerationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelPolicyGenerationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelPolicyGenerationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelPolicyGenerationOutputResponse()"}
}

extension CancelPolicyGenerationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelPolicyGenerationOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelPolicyGenerationOutputResponseBody: Swift.Equatable {
}

extension CancelPolicyGenerationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AccessAnalyzerClientTypes.CloudTrailDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole
        case endTime
        case startTime
        case trails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let trails = trails {
            var trailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trails)
            for traillist0 in trails {
                try trailsContainer.encode(traillist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.Trail?].self, forKey: .trails)
        var trailsDecoded0:[AccessAnalyzerClientTypes.Trail]? = nil
        if let trailsContainer = trailsContainer {
            trailsDecoded0 = [AccessAnalyzerClientTypes.Trail]()
            for structure0 in trailsContainer {
                if let structure0 = structure0 {
                    trailsDecoded0?.append(structure0)
                }
            }
        }
        trails = trailsDecoded0
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension AccessAnalyzerClientTypes.CloudTrailDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudTrailDetails(accessRole: \(Swift.String(describing: accessRole)), endTime: \(Swift.String(describing: endTime)), startTime: \(Swift.String(describing: startTime)), trails: \(Swift.String(describing: trails)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains information about CloudTrail access.
    public struct CloudTrailDetails: Swift.Equatable {
        /// The ARN of the service role that IAM Access Analyzer uses to access your CloudTrail trail and
        ///          service last accessed information.
        /// This member is required.
        public var accessRole: Swift.String?
        /// The end of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with
        ///          a timestamp after this time are not considered to generate a policy. If this is not
        ///          included in the request, the default value is the current time.
        public var endTime: ClientRuntime.Date?
        /// The start of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events
        ///          with a timestamp before this time are not considered to generate a policy.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// A Trail object that contains settings for a trail.
        /// This member is required.
        public var trails: [AccessAnalyzerClientTypes.Trail]?

        public init (
            accessRole: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil,
            trails: [AccessAnalyzerClientTypes.Trail]? = nil
        )
        {
            self.accessRole = accessRole
            self.endTime = endTime
            self.startTime = startTime
            self.trails = trails
        }
    }

}

extension AccessAnalyzerClientTypes.CloudTrailProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case startTime
        case trailProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let trailProperties = trailProperties {
            var trailPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trailProperties)
            for trailpropertieslist0 in trailProperties {
                try trailPropertiesContainer.encode(trailpropertieslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailPropertiesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.TrailProperties?].self, forKey: .trailProperties)
        var trailPropertiesDecoded0:[AccessAnalyzerClientTypes.TrailProperties]? = nil
        if let trailPropertiesContainer = trailPropertiesContainer {
            trailPropertiesDecoded0 = [AccessAnalyzerClientTypes.TrailProperties]()
            for structure0 in trailPropertiesContainer {
                if let structure0 = structure0 {
                    trailPropertiesDecoded0?.append(structure0)
                }
            }
        }
        trailProperties = trailPropertiesDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension AccessAnalyzerClientTypes.CloudTrailProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudTrailProperties(endTime: \(Swift.String(describing: endTime)), startTime: \(Swift.String(describing: startTime)), trailProperties: \(Swift.String(describing: trailProperties)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains information about CloudTrail access.
    public struct CloudTrailProperties: Swift.Equatable {
        /// The end of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with
        ///          a timestamp after this time are not considered to generate a policy. If this is not
        ///          included in the request, the default value is the current time.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The start of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events
        ///          with a timestamp before this time are not considered to generate a policy.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// A TrailProperties object that contains settings for trail
        ///          properties.
        /// This member is required.
        public var trailProperties: [AccessAnalyzerClientTypes.TrailProperties]?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil,
            trailProperties: [AccessAnalyzerClientTypes.TrailProperties]? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
            self.trailProperties = trailProperties
        }
    }

}

extension AccessAnalyzerClientTypes.Configuration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamrole = "iamRole"
        case kmskey = "kmsKey"
        case s3bucket = "s3Bucket"
        case sdkUnknown
        case secretsmanagersecret = "secretsManagerSecret"
        case sqsqueue = "sqsQueue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .iamrole(iamrole):
                try container.encode(iamrole, forKey: .iamrole)
            case let .kmskey(kmskey):
                try container.encode(kmskey, forKey: .kmskey)
            case let .s3bucket(s3bucket):
                try container.encode(s3bucket, forKey: .s3bucket)
            case let .secretsmanagersecret(secretsmanagersecret):
                try container.encode(secretsmanagersecret, forKey: .secretsmanagersecret)
            case let .sqsqueue(sqsqueue):
                try container.encode(sqsqueue, forKey: .sqsqueue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let iamroleDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.IamRoleConfiguration.self, forKey: .iamrole)
        if let iamrole = iamroleDecoded {
            self = .iamrole(iamrole)
            return
        }
        let kmskeyDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.KmsKeyConfiguration.self, forKey: .kmskey)
        if let kmskey = kmskeyDecoded {
            self = .kmskey(kmskey)
            return
        }
        let secretsmanagersecretDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration.self, forKey: .secretsmanagersecret)
        if let secretsmanagersecret = secretsmanagersecretDecoded {
            self = .secretsmanagersecret(secretsmanagersecret)
            return
        }
        let s3bucketDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.S3BucketConfiguration.self, forKey: .s3bucket)
        if let s3bucket = s3bucketDecoded {
            self = .s3bucket(s3bucket)
            return
        }
        let sqsqueueDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.SqsQueueConfiguration.self, forKey: .sqsqueue)
        if let sqsqueue = sqsqueueDecoded {
            self = .sqsqueue(sqsqueue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AccessAnalyzerClientTypes {
    /// Access control configuration structures for your resource. You specify the configuration
    ///          as a type-value pair. You can specify only one type of access control configuration.
    public enum Configuration: Swift.Equatable {
        /// The access control configuration is for an IAM role.
        case iamrole(AccessAnalyzerClientTypes.IamRoleConfiguration)
        /// The access control configuration is for a KMS key.
        case kmskey(AccessAnalyzerClientTypes.KmsKeyConfiguration)
        /// The access control configuration is for a Secrets Manager secret.
        case secretsmanagersecret(AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration)
        /// The access control configuration is for an Amazon S3 Bucket.
        case s3bucket(AccessAnalyzerClientTypes.S3BucketConfiguration)
        /// The access control configuration is for an Amazon SQS queue.
        case sqsqueue(AccessAnalyzerClientTypes.SqsQueueConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A conflict exception error.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateAccessPreviewInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessPreviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccessPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccessPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessPreviewOutputError>
}

extension CreateAccessPreviewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccessPreviewInput(analyzerArn: \(Swift.String(describing: analyzerArn)), clientToken: \(Swift.String(describing: clientToken)), configurations: \(Swift.String(describing: configurations)))"}
}

extension CreateAccessPreviewInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case clientToken
        case configurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configurations)
            for (dictKey0, configurationsmap0) in configurations {
                try configurationsContainer.encode(configurationsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAccessPreviewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessPreviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccessPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccessPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessPreviewOutputError>
}

public struct CreateAccessPreviewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessPreviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccessPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccessPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessPreviewOutputError>
}

public struct CreateAccessPreviewInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessPreviewInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateAccessPreviewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/access-preview"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAccessPreviewInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessPreviewOutputError>
}

public struct CreateAccessPreviewInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the account analyzer used to generate the access preview. You can only create an
    ///          access preview for analyzers with an Account type and Active
    ///          status.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// Access control configuration for your resource that is used to generate the access
    ///          preview. The access preview includes findings for external access allowed to the resource
    ///          with the proposed access control configuration. The configuration must contain exactly one
    ///          element.
    /// This member is required.
    public var configurations: [Swift.String:AccessAnalyzerClientTypes.Configuration]?

    public init (
        analyzerArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configurations: [Swift.String:AccessAnalyzerClientTypes.Configuration]? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.clientToken = clientToken
        self.configurations = configurations
    }
}

struct CreateAccessPreviewInputBody: Swift.Equatable {
    public let analyzerArn: Swift.String?
    public let configurations: [Swift.String:AccessAnalyzerClientTypes.Configuration]?
    public let clientToken: Swift.String?
}

extension CreateAccessPreviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case clientToken
        case configurations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let configurationsContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0: [Swift.String:AccessAnalyzerClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Configuration]()
            for (key0, configuration0) in configurationsContainer {
                if let configuration0 = configuration0 {
                    configurationsDecoded0?[key0] = configuration0
                }
            }
        }
        configurations = configurationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAccessPreviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessPreviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccessPreviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessPreviewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccessPreviewOutputResponse(id: \(Swift.String(describing: id)))"}
}

extension CreateAccessPreviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAccessPreviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateAccessPreviewOutputResponse: Swift.Equatable {
    /// The unique ID for the access preview.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CreateAccessPreviewOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
}

extension CreateAccessPreviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateAnalyzerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAnalyzerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAnalyzerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAnalyzerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAnalyzerOutputError>
}

extension CreateAnalyzerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAnalyzerInput(analyzerName: \(Swift.String(describing: analyzerName)), archiveRules: \(Swift.String(describing: archiveRules)), clientToken: \(Swift.String(describing: clientToken)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateAnalyzerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerName
        case archiveRules
        case clientToken
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerName = analyzerName {
            try encodeContainer.encode(analyzerName, forKey: .analyzerName)
        }
        if let archiveRules = archiveRules {
            var archiveRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .archiveRules)
            for inlinearchiveruleslist0 in archiveRules {
                try archiveRulesContainer.encode(inlinearchiveruleslist0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateAnalyzerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAnalyzerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAnalyzerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAnalyzerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAnalyzerOutputError>
}

public struct CreateAnalyzerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAnalyzerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAnalyzerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAnalyzerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAnalyzerOutputError>
}

public struct CreateAnalyzerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAnalyzerInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateAnalyzerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/analyzer"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAnalyzerInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAnalyzerOutputError>
}

/// Creates an analyzer.
public struct CreateAnalyzerInput: Swift.Equatable {
    /// The name of the analyzer to create.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// Specifies the archive rules to add for the analyzer. Archive rules automatically archive
    ///          findings that meet the criteria you define for the rule.
    public var archiveRules: [AccessAnalyzerClientTypes.InlineArchiveRule]?
    /// A client token.
    public var clientToken: Swift.String?
    /// The tags to apply to the analyzer.
    public var tags: [Swift.String:Swift.String]?
    /// The type of analyzer to create. Only ACCOUNT and ORGANIZATION analyzers are supported.
    ///          You can create only one analyzer per account per Region. You can create up to 5 analyzers
    ///          per organization per Region.
    /// This member is required.
    public var type: AccessAnalyzerClientTypes.ModelType?

    public init (
        analyzerName: Swift.String? = nil,
        archiveRules: [AccessAnalyzerClientTypes.InlineArchiveRule]? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: AccessAnalyzerClientTypes.ModelType? = nil
    )
    {
        self.analyzerName = analyzerName
        self.archiveRules = archiveRules
        self.clientToken = clientToken
        self.tags = tags
        self.type = type
    }
}

struct CreateAnalyzerInputBody: Swift.Equatable {
    public let analyzerName: Swift.String?
    public let type: AccessAnalyzerClientTypes.ModelType?
    public let archiveRules: [AccessAnalyzerClientTypes.InlineArchiveRule]?
    public let tags: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateAnalyzerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerName
        case archiveRules
        case clientToken
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerName)
        analyzerName = analyzerNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let archiveRulesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.InlineArchiveRule?].self, forKey: .archiveRules)
        var archiveRulesDecoded0:[AccessAnalyzerClientTypes.InlineArchiveRule]? = nil
        if let archiveRulesContainer = archiveRulesContainer {
            archiveRulesDecoded0 = [AccessAnalyzerClientTypes.InlineArchiveRule]()
            for structure0 in archiveRulesContainer {
                if let structure0 = structure0 {
                    archiveRulesDecoded0?.append(structure0)
                }
            }
        }
        archiveRules = archiveRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAnalyzerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnalyzerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAnalyzerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnalyzerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAnalyzerOutputResponse(arn: \(Swift.String(describing: arn)))"}
}

extension CreateAnalyzerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAnalyzerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

/// The response to the request to create an analyzer.
public struct CreateAnalyzerOutputResponse: Swift.Equatable {
    /// The ARN of the analyzer that was created by the request.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateAnalyzerOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension CreateAnalyzerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct CreateArchiveRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateArchiveRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateArchiveRuleOutputError>
}

extension CreateArchiveRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateArchiveRuleInput(analyzerName: \(Swift.String(describing: analyzerName)), clientToken: \(Swift.String(describing: clientToken)), filter: \(Swift.String(describing: filter)), ruleName: \(Swift.String(describing: ruleName)))"}
}

extension CreateArchiveRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case filter
        case ruleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, filtercriteriamap0) in filter {
                try filterContainer.encode(filtercriteriamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }
}

public struct CreateArchiveRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateArchiveRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateArchiveRuleOutputError>
}

public struct CreateArchiveRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateArchiveRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateArchiveRuleOutputError>
}

public struct CreateArchiveRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateArchiveRuleInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateArchiveRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let analyzerName = input.analyzerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("analyzerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateArchiveRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateArchiveRuleOutputError>
}

/// Creates an archive rule.
public struct CreateArchiveRuleInput: Swift.Equatable {
    /// The name of the created analyzer.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// The criteria for the rule.
    /// This member is required.
    public var filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    /// The name of the rule to create.
    /// This member is required.
    public var ruleName: Swift.String?

    public init (
        analyzerName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
        self.filter = filter
        self.ruleName = ruleName
    }
}

struct CreateArchiveRuleInputBody: Swift.Equatable {
    public let ruleName: Swift.String?
    public let filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    public let clientToken: Swift.String?
}

extension CreateArchiveRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case filter
        case ruleName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Criterion?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateArchiveRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateArchiveRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateArchiveRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateArchiveRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateArchiveRuleOutputResponse()"}
}

extension CreateArchiveRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateArchiveRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateArchiveRuleOutputResponseBody: Swift.Equatable {
}

extension CreateArchiveRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AccessAnalyzerClientTypes.Criterion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contains
        case eq
        case exists
        case neq
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contains = contains {
            var containsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contains)
            for valuelist0 in contains {
                try containsContainer.encode(valuelist0)
            }
        }
        if let eq = eq {
            var eqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eq)
            for valuelist0 in eq {
                try eqContainer.encode(valuelist0)
            }
        }
        if let exists = exists {
            try encodeContainer.encode(exists, forKey: .exists)
        }
        if let neq = neq {
            var neqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neq)
            for valuelist0 in neq {
                try neqContainer.encode(valuelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eq)
        var eqDecoded0:[Swift.String]? = nil
        if let eqContainer = eqContainer {
            eqDecoded0 = [Swift.String]()
            for string0 in eqContainer {
                if let string0 = string0 {
                    eqDecoded0?.append(string0)
                }
            }
        }
        eq = eqDecoded0
        let neqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .neq)
        var neqDecoded0:[Swift.String]? = nil
        if let neqContainer = neqContainer {
            neqDecoded0 = [Swift.String]()
            for string0 in neqContainer {
                if let string0 = string0 {
                    neqDecoded0?.append(string0)
                }
            }
        }
        neq = neqDecoded0
        let containsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .contains)
        var containsDecoded0:[Swift.String]? = nil
        if let containsContainer = containsContainer {
            containsDecoded0 = [Swift.String]()
            for string0 in containsContainer {
                if let string0 = string0 {
                    containsDecoded0?.append(string0)
                }
            }
        }
        contains = containsDecoded0
        let existsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .exists)
        exists = existsDecoded
    }
}

extension AccessAnalyzerClientTypes.Criterion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Criterion(contains: \(Swift.String(describing: contains)), eq: \(Swift.String(describing: eq)), exists: \(Swift.String(describing: exists)), neq: \(Swift.String(describing: neq)))"}
}

extension AccessAnalyzerClientTypes {
    /// The criteria to use in the filter that defines the archive rule.
    public struct Criterion: Swift.Equatable {
        /// A "contains" operator to match for the filter used to create the rule.
        public var contains: [Swift.String]?
        /// An "equals" operator to match for the filter used to create the rule.
        public var eq: [Swift.String]?
        /// An "exists" operator to match for the filter used to create the rule.
        public var exists: Swift.Bool?
        /// A "not equals" operator to match for the filter used to create the rule.
        public var neq: [Swift.String]?

        public init (
            contains: [Swift.String]? = nil,
            eq: [Swift.String]? = nil,
            exists: Swift.Bool? = nil,
            neq: [Swift.String]? = nil
        )
        {
            self.contains = contains
            self.eq = eq
            self.exists = exists
            self.neq = neq
        }
    }

}

extension DeleteAnalyzerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAnalyzerInput(analyzerName: \(Swift.String(describing: analyzerName)), clientToken: \(Swift.String(describing: clientToken)))"}
}

extension DeleteAnalyzerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAnalyzerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAnalyzerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAnalyzerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAnalyzerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAnalyzerOutputError>
}

public struct DeleteAnalyzerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAnalyzerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAnalyzerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAnalyzerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAnalyzerOutputError>
}

public struct DeleteAnalyzerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAnalyzerInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAnalyzerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let analyzerName = input.analyzerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("analyzerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/analyzer/\(analyzerName.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAnalyzerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAnalyzerOutputError>
}

/// Deletes an analyzer.
public struct DeleteAnalyzerInput: Swift.Equatable {
    /// The name of the analyzer to delete.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?

    public init (
        analyzerName: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
    }
}

struct DeleteAnalyzerInputBody: Swift.Equatable {
}

extension DeleteAnalyzerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAnalyzerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnalyzerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAnalyzerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnalyzerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAnalyzerOutputResponse()"}
}

extension DeleteAnalyzerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAnalyzerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAnalyzerOutputResponseBody: Swift.Equatable {
}

extension DeleteAnalyzerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteArchiveRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteArchiveRuleInput(analyzerName: \(Swift.String(describing: analyzerName)), clientToken: \(Swift.String(describing: clientToken)), ruleName: \(Swift.String(describing: ruleName)))"}
}

extension DeleteArchiveRuleInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteArchiveRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteArchiveRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteArchiveRuleOutputError>
}

public struct DeleteArchiveRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteArchiveRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteArchiveRuleOutputError>
}

public struct DeleteArchiveRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteArchiveRuleInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteArchiveRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let analyzerName = input.analyzerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("analyzerName is nil and needs a value for the path of this operation"))))
        }
        guard let ruleName = input.ruleName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("ruleName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule/\(ruleName.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteArchiveRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteArchiveRuleOutputError>
}

/// Deletes an archive rule.
public struct DeleteArchiveRuleInput: Swift.Equatable {
    /// The name of the analyzer that associated with the archive rule to delete.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// The name of the rule to delete.
    /// This member is required.
    public var ruleName: Swift.String?

    public init (
        analyzerName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
        self.ruleName = ruleName
    }
}

struct DeleteArchiveRuleInputBody: Swift.Equatable {
}

extension DeleteArchiveRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteArchiveRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteArchiveRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteArchiveRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteArchiveRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteArchiveRuleOutputResponse()"}
}

extension DeleteArchiveRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteArchiveRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteArchiveRuleOutputResponseBody: Swift.Equatable {
}

extension DeleteArchiveRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AccessAnalyzerClientTypes.Finding: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case analyzedAt
        case condition
        case createdAt
        case error
        case id
        case isPublic
        case principal
        case resource
        case resourceOwnerAccount
        case resourceType
        case sources
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            var actionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .action)
            for actionlist0 in action {
                try actionContainer.encode(actionlist0)
            }
        }
        if let analyzedAt = analyzedAt {
            try encodeContainer.encode(analyzedAt.timeIntervalSince1970, forKey: .analyzedAt)
        }
        if let condition = condition {
            var conditionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .condition)
            for (dictKey0, conditionkeymap0) in condition {
                try conditionContainer.encode(conditionkeymap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isPublic = isPublic {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let principal = principal {
            var principalContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .principal)
            for (dictKey0, principalmap0) in principal {
                try principalContainer.encode(principalmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceOwnerAccount = resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for findingsourcelist0 in sources {
                try sourcesContainer.encode(findingsourcelist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let principalContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principal)
        var principalDecoded0: [Swift.String:Swift.String]? = nil
        if let principalContainer = principalContainer {
            principalDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in principalContainer {
                if let string0 = string0 {
                    principalDecoded0?[key0] = string0
                }
            }
        }
        principal = principalDecoded0
        let actionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .action)
        var actionDecoded0:[Swift.String]? = nil
        if let actionContainer = actionContainer {
            actionDecoded0 = [Swift.String]()
            for string0 in actionContainer {
                if let string0 = string0 {
                    actionDecoded0?.append(string0)
                }
            }
        }
        action = actionDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let isPublicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let conditionContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .condition)
        var conditionDecoded0: [Swift.String:Swift.String]? = nil
        if let conditionContainer = conditionContainer {
            conditionDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in conditionContainer {
                if let string0 = string0 {
                    conditionDecoded0?[key0] = string0
                }
            }
        }
        condition = conditionDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let analyzedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .analyzedAt)
        analyzedAt = analyzedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.FindingSource?].self, forKey: .sources)
        var sourcesDecoded0:[AccessAnalyzerClientTypes.FindingSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [AccessAnalyzerClientTypes.FindingSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension AccessAnalyzerClientTypes.Finding: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Finding(action: \(Swift.String(describing: action)), analyzedAt: \(Swift.String(describing: analyzedAt)), condition: \(Swift.String(describing: condition)), createdAt: \(Swift.String(describing: createdAt)), error: \(Swift.String(describing: error)), id: \(Swift.String(describing: id)), isPublic: \(Swift.String(describing: isPublic)), principal: \(Swift.String(describing: principal)), resource: \(Swift.String(describing: resource)), resourceOwnerAccount: \(Swift.String(describing: resourceOwnerAccount)), resourceType: \(Swift.String(describing: resourceType)), sources: \(Swift.String(describing: sources)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains information about a finding.
    public struct Finding: Swift.Equatable {
        /// The action in the analyzed policy statement that an external principal has permission to
        ///          use.
        public var action: [Swift.String]?
        /// The time at which the resource was analyzed.
        /// This member is required.
        public var analyzedAt: ClientRuntime.Date?
        /// The condition in the analyzed policy statement that resulted in a finding.
        /// This member is required.
        public var condition: [Swift.String:Swift.String]?
        /// The time at which the finding was generated.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// An error.
        public var error: Swift.String?
        /// The ID of the finding.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates whether the policy that generated the finding allows public access to the
        ///          resource.
        public var isPublic: Swift.Bool?
        /// The external principal that access to a resource within the zone of trust.
        public var principal: [Swift.String:Swift.String]?
        /// The resource that an external principal has access to.
        public var resource: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource identified in the finding.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// The sources of the finding. This indicates how the access that generated the finding is
        ///          granted. It is populated for Amazon S3 bucket findings.
        public var sources: [AccessAnalyzerClientTypes.FindingSource]?
        /// The current status of the finding.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.FindingStatus?
        /// The time at which the finding was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            action: [Swift.String]? = nil,
            analyzedAt: ClientRuntime.Date? = nil,
            condition: [Swift.String:Swift.String]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            error: Swift.String? = nil,
            id: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            principal: [Swift.String:Swift.String]? = nil,
            resource: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            sources: [AccessAnalyzerClientTypes.FindingSource]? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.action = action
            self.analyzedAt = analyzedAt
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum FindingChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case changed
        case new
        case unchanged
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingChangeType] {
            return [
                .changed,
                .new,
                .unchanged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .changed: return "CHANGED"
            case .new: return "NEW"
            case .unchanged: return "UNCHANGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingChangeType(rawValue: rawValue) ?? FindingChangeType.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.FindingSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detail
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingSourceType.self, forKey: .type)
        type = typeDecoded
        let detailDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingSourceDetail.self, forKey: .detail)
        detail = detailDecoded
    }
}

extension AccessAnalyzerClientTypes.FindingSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FindingSource(detail: \(Swift.String(describing: detail)), type: \(Swift.String(describing: type)))"}
}

extension AccessAnalyzerClientTypes {
    /// The source of the finding. This indicates how the access that generated the finding is
    ///          granted. It is populated for Amazon S3 bucket findings.
    public struct FindingSource: Swift.Equatable {
        /// Includes details about how the access that generated the finding is granted. This is
        ///          populated for Amazon S3 bucket findings.
        public var detail: AccessAnalyzerClientTypes.FindingSourceDetail?
        /// Indicates the type of access that generated the finding.
        /// This member is required.
        public var type: AccessAnalyzerClientTypes.FindingSourceType?

        public init (
            detail: AccessAnalyzerClientTypes.FindingSourceDetail? = nil,
            type: AccessAnalyzerClientTypes.FindingSourceType? = nil
        )
        {
            self.detail = detail
            self.type = type
        }
    }

}

extension AccessAnalyzerClientTypes.FindingSourceDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointArn = accessPointArn {
            try encodeContainer.encode(accessPointArn, forKey: .accessPointArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
    }
}

extension AccessAnalyzerClientTypes.FindingSourceDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FindingSourceDetail(accessPointArn: \(Swift.String(describing: accessPointArn)))"}
}

extension AccessAnalyzerClientTypes {
    /// Includes details about how the access that generated the finding is granted. This is
    ///          populated for Amazon S3 bucket findings.
    public struct FindingSourceDetail: Swift.Equatable {
        /// The ARN of the access point that generated the finding. The ARN format depends on
        ///          whether the ARN represents an access point or a multi-region access point.
        public var accessPointArn: Swift.String?

        public init (
            accessPointArn: Swift.String? = nil
        )
        {
            self.accessPointArn = accessPointArn
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum FindingSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bucketAcl
        case policy
        case s3AccessPoint
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingSourceType] {
            return [
                .bucketAcl,
                .policy,
                .s3AccessPoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bucketAcl: return "BUCKET_ACL"
            case .policy: return "POLICY"
            case .s3AccessPoint: return "S3_ACCESS_POINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingSourceType(rawValue: rawValue) ?? FindingSourceType.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes {
    public enum FindingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case archived
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatus] {
            return [
                .active,
                .archived,
                .resolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingStatus(rawValue: rawValue) ?? FindingStatus.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes {
    public enum FindingStatusUpdate: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatusUpdate] {
            return [
                .active,
                .archived,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingStatusUpdate(rawValue: rawValue) ?? FindingStatusUpdate.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.FindingSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case analyzedAt
        case condition
        case createdAt
        case error
        case id
        case isPublic
        case principal
        case resource
        case resourceOwnerAccount
        case resourceType
        case sources
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            var actionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .action)
            for actionlist0 in action {
                try actionContainer.encode(actionlist0)
            }
        }
        if let analyzedAt = analyzedAt {
            try encodeContainer.encode(analyzedAt.timeIntervalSince1970, forKey: .analyzedAt)
        }
        if let condition = condition {
            var conditionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .condition)
            for (dictKey0, conditionkeymap0) in condition {
                try conditionContainer.encode(conditionkeymap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isPublic = isPublic {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let principal = principal {
            var principalContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .principal)
            for (dictKey0, principalmap0) in principal {
                try principalContainer.encode(principalmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceOwnerAccount = resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for findingsourcelist0 in sources {
                try sourcesContainer.encode(findingsourcelist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let principalContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principal)
        var principalDecoded0: [Swift.String:Swift.String]? = nil
        if let principalContainer = principalContainer {
            principalDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in principalContainer {
                if let string0 = string0 {
                    principalDecoded0?[key0] = string0
                }
            }
        }
        principal = principalDecoded0
        let actionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .action)
        var actionDecoded0:[Swift.String]? = nil
        if let actionContainer = actionContainer {
            actionDecoded0 = [Swift.String]()
            for string0 in actionContainer {
                if let string0 = string0 {
                    actionDecoded0?.append(string0)
                }
            }
        }
        action = actionDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let isPublicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let conditionContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .condition)
        var conditionDecoded0: [Swift.String:Swift.String]? = nil
        if let conditionContainer = conditionContainer {
            conditionDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in conditionContainer {
                if let string0 = string0 {
                    conditionDecoded0?[key0] = string0
                }
            }
        }
        condition = conditionDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let analyzedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .analyzedAt)
        analyzedAt = analyzedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.FindingSource?].self, forKey: .sources)
        var sourcesDecoded0:[AccessAnalyzerClientTypes.FindingSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [AccessAnalyzerClientTypes.FindingSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension AccessAnalyzerClientTypes.FindingSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FindingSummary(action: \(Swift.String(describing: action)), analyzedAt: \(Swift.String(describing: analyzedAt)), condition: \(Swift.String(describing: condition)), createdAt: \(Swift.String(describing: createdAt)), error: \(Swift.String(describing: error)), id: \(Swift.String(describing: id)), isPublic: \(Swift.String(describing: isPublic)), principal: \(Swift.String(describing: principal)), resource: \(Swift.String(describing: resource)), resourceOwnerAccount: \(Swift.String(describing: resourceOwnerAccount)), resourceType: \(Swift.String(describing: resourceType)), sources: \(Swift.String(describing: sources)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains information about a finding.
    public struct FindingSummary: Swift.Equatable {
        /// The action in the analyzed policy statement that an external principal has permission to
        ///          use.
        public var action: [Swift.String]?
        /// The time at which the resource-based policy that generated the finding was
        ///          analyzed.
        /// This member is required.
        public var analyzedAt: ClientRuntime.Date?
        /// The condition in the analyzed policy statement that resulted in a finding.
        /// This member is required.
        public var condition: [Swift.String:Swift.String]?
        /// The time at which the finding was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The error that resulted in an Error finding.
        public var error: Swift.String?
        /// The ID of the finding.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates whether the finding reports a resource that has a policy that allows public
        ///          access.
        public var isPublic: Swift.Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public var principal: [Swift.String:Swift.String]?
        /// The resource that the external principal has access to.
        public var resource: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource that the external principal has access to.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// The sources of the finding. This indicates how the access that generated the finding is
        ///          granted. It is populated for Amazon S3 bucket findings.
        public var sources: [AccessAnalyzerClientTypes.FindingSource]?
        /// The status of the finding.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.FindingStatus?
        /// The time at which the finding was most recently updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            action: [Swift.String]? = nil,
            analyzedAt: ClientRuntime.Date? = nil,
            condition: [Swift.String:Swift.String]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            error: Swift.String? = nil,
            id: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            principal: [Swift.String:Swift.String]? = nil,
            resource: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            sources: [AccessAnalyzerClientTypes.FindingSource]? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.action = action
            self.analyzedAt = analyzedAt
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension AccessAnalyzerClientTypes.GeneratedPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension AccessAnalyzerClientTypes.GeneratedPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeneratedPolicy(policy: \(Swift.String(describing: policy)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains the text for the generated policy.
    public struct GeneratedPolicy: Swift.Equatable {
        /// The text to use as the content for the new policy. The policy is created using the
        ///             <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html">CreatePolicy action.
        /// This member is required.
        public var policy: Swift.String?

        public init (
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }

}

extension AccessAnalyzerClientTypes.GeneratedPolicyProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudTrailProperties
        case isComplete
        case principalArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudTrailProperties = cloudTrailProperties {
            try encodeContainer.encode(cloudTrailProperties, forKey: .cloudTrailProperties)
        }
        if let isComplete = isComplete {
            try encodeContainer.encode(isComplete, forKey: .isComplete)
        }
        if let principalArn = principalArn {
            try encodeContainer.encode(principalArn, forKey: .principalArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isCompleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isComplete)
        isComplete = isCompleteDecoded
        let principalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalArn)
        principalArn = principalArnDecoded
        let cloudTrailPropertiesDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.CloudTrailProperties.self, forKey: .cloudTrailProperties)
        cloudTrailProperties = cloudTrailPropertiesDecoded
    }
}

extension AccessAnalyzerClientTypes.GeneratedPolicyProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeneratedPolicyProperties(cloudTrailProperties: \(Swift.String(describing: cloudTrailProperties)), isComplete: \(Swift.String(describing: isComplete)), principalArn: \(Swift.String(describing: principalArn)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains the generated policy details.
    public struct GeneratedPolicyProperties: Swift.Equatable {
        /// Lists details about the Trail used to generated policy.
        public var cloudTrailProperties: AccessAnalyzerClientTypes.CloudTrailProperties?
        /// This value is set to true if the generated policy contains all possible
        ///          actions for a service that IAM Access Analyzer identified from the CloudTrail trail that you specified,
        ///          and false otherwise.
        public var isComplete: Swift.Bool?
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        /// This member is required.
        public var principalArn: Swift.String?

        public init (
            cloudTrailProperties: AccessAnalyzerClientTypes.CloudTrailProperties? = nil,
            isComplete: Swift.Bool? = nil,
            principalArn: Swift.String? = nil
        )
        {
            self.cloudTrailProperties = cloudTrailProperties
            self.isComplete = isComplete
            self.principalArn = principalArn
        }
    }

}

extension AccessAnalyzerClientTypes.GeneratedPolicyResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedPolicies
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedPolicies = generatedPolicies {
            var generatedPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .generatedPolicies)
            for generatedpolicylist0 in generatedPolicies {
                try generatedPoliciesContainer.encode(generatedpolicylist0)
            }
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertiesDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.GeneratedPolicyProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let generatedPoliciesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.GeneratedPolicy?].self, forKey: .generatedPolicies)
        var generatedPoliciesDecoded0:[AccessAnalyzerClientTypes.GeneratedPolicy]? = nil
        if let generatedPoliciesContainer = generatedPoliciesContainer {
            generatedPoliciesDecoded0 = [AccessAnalyzerClientTypes.GeneratedPolicy]()
            for structure0 in generatedPoliciesContainer {
                if let structure0 = structure0 {
                    generatedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        generatedPolicies = generatedPoliciesDecoded0
    }
}

extension AccessAnalyzerClientTypes.GeneratedPolicyResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeneratedPolicyResult(generatedPolicies: \(Swift.String(describing: generatedPolicies)), properties: \(Swift.String(describing: properties)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains the text for the generated policy and its details.
    public struct GeneratedPolicyResult: Swift.Equatable {
        /// The text to use as the content for the new policy. The policy is created using the
        ///             <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html">CreatePolicy action.
        public var generatedPolicies: [AccessAnalyzerClientTypes.GeneratedPolicy]?
        /// A GeneratedPolicyProperties object that contains properties of the
        ///          generated policy.
        /// This member is required.
        public var properties: AccessAnalyzerClientTypes.GeneratedPolicyProperties?

        public init (
            generatedPolicies: [AccessAnalyzerClientTypes.GeneratedPolicy]? = nil,
            properties: AccessAnalyzerClientTypes.GeneratedPolicyProperties? = nil
        )
        {
            self.generatedPolicies = generatedPolicies
            self.properties = properties
        }
    }

}

extension GetAccessPreviewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccessPreviewInput(accessPreviewId: \(Swift.String(describing: accessPreviewId)), analyzerArn: \(Swift.String(describing: analyzerArn)))"}
}

extension GetAccessPreviewInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAccessPreviewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessPreviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessPreviewOutputError>
}

public struct GetAccessPreviewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessPreviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let analyzerArn = input.operationInput.analyzerArn {
            let analyzerArnQueryItem = ClientRuntime.URLQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
            input.builder.withQueryItem(analyzerArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessPreviewOutputError>
}

public struct GetAccessPreviewInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessPreviewInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAccessPreviewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accessPreviewId = input.accessPreviewId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accessPreviewId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/access-preview/\(accessPreviewId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccessPreviewInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessPreviewOutputError>
}

public struct GetAccessPreviewInput: Swift.Equatable {
    /// The unique ID for the access preview.
    /// This member is required.
    public var accessPreviewId: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer used to generate the access preview.
    /// This member is required.
    public var analyzerArn: Swift.String?

    public init (
        accessPreviewId: Swift.String? = nil,
        analyzerArn: Swift.String? = nil
    )
    {
        self.accessPreviewId = accessPreviewId
        self.analyzerArn = analyzerArn
    }
}

struct GetAccessPreviewInputBody: Swift.Equatable {
}

extension GetAccessPreviewInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccessPreviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccessPreviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessPreviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessPreviewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccessPreviewOutputResponse(accessPreview: \(Swift.String(describing: accessPreview)))"}
}

extension GetAccessPreviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccessPreviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPreview = output.accessPreview
        } else {
            self.accessPreview = nil
        }
    }
}

public struct GetAccessPreviewOutputResponse: Swift.Equatable {
    /// An object that contains information about the access preview.
    /// This member is required.
    public var accessPreview: AccessAnalyzerClientTypes.AccessPreview?

    public init (
        accessPreview: AccessAnalyzerClientTypes.AccessPreview? = nil
    )
    {
        self.accessPreview = accessPreview
    }
}

struct GetAccessPreviewOutputResponseBody: Swift.Equatable {
    public let accessPreview: AccessAnalyzerClientTypes.AccessPreview?
}

extension GetAccessPreviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPreview
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPreviewDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AccessPreview.self, forKey: .accessPreview)
        accessPreview = accessPreviewDecoded
    }
}

extension GetAnalyzedResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAnalyzedResourceInput(analyzerArn: \(Swift.String(describing: analyzerArn)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension GetAnalyzedResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAnalyzedResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAnalyzedResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAnalyzedResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAnalyzedResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAnalyzedResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAnalyzedResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAnalyzedResourceOutputError>
}

public struct GetAnalyzedResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAnalyzedResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAnalyzedResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAnalyzedResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        if let analyzerArn = input.operationInput.analyzerArn {
            let analyzerArnQueryItem = ClientRuntime.URLQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
            input.builder.withQueryItem(analyzerArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAnalyzedResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAnalyzedResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAnalyzedResourceOutputError>
}

public struct GetAnalyzedResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAnalyzedResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAnalyzedResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAnalyzedResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/analyzed-resource"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAnalyzedResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAnalyzedResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAnalyzedResourceOutputError>
}

/// Retrieves an analyzed resource.
public struct GetAnalyzedResourceInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer to retrieve information from.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The ARN of the resource to retrieve information about.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        analyzerArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.resourceArn = resourceArn
    }
}

struct GetAnalyzedResourceInputBody: Swift.Equatable {
}

extension GetAnalyzedResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAnalyzedResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnalyzedResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnalyzedResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnalyzedResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAnalyzedResourceOutputResponse(resource: \(Swift.String(describing: resource)))"}
}

extension GetAnalyzedResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAnalyzedResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resource = output.resource
        } else {
            self.resource = nil
        }
    }
}

/// The response to the request.
public struct GetAnalyzedResourceOutputResponse: Swift.Equatable {
    /// An AnalyzedResource object that contains information that IAM Access Analyzer
    ///          found when it analyzed the resource.
    public var resource: AccessAnalyzerClientTypes.AnalyzedResource?

    public init (
        resource: AccessAnalyzerClientTypes.AnalyzedResource? = nil
    )
    {
        self.resource = resource
    }
}

struct GetAnalyzedResourceOutputResponseBody: Swift.Equatable {
    public let resource: AccessAnalyzerClientTypes.AnalyzedResource?
}

extension GetAnalyzedResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AnalyzedResource.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension GetAnalyzerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAnalyzerInput(analyzerName: \(Swift.String(describing: analyzerName)))"}
}

extension GetAnalyzerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAnalyzerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAnalyzerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAnalyzerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAnalyzerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAnalyzerOutputError>
}

public struct GetAnalyzerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAnalyzerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAnalyzerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAnalyzerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAnalyzerOutputError>
}

public struct GetAnalyzerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAnalyzerInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAnalyzerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let analyzerName = input.analyzerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("analyzerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/analyzer/\(analyzerName.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAnalyzerInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAnalyzerOutputError>
}

/// Retrieves an analyzer.
public struct GetAnalyzerInput: Swift.Equatable {
    /// The name of the analyzer retrieved.
    /// This member is required.
    public var analyzerName: Swift.String?

    public init (
        analyzerName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
    }
}

struct GetAnalyzerInputBody: Swift.Equatable {
}

extension GetAnalyzerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAnalyzerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnalyzerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnalyzerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnalyzerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAnalyzerOutputResponse(analyzer: \(Swift.String(describing: analyzer)))"}
}

extension GetAnalyzerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAnalyzerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analyzer = output.analyzer
        } else {
            self.analyzer = nil
        }
    }
}

/// The response to the request.
public struct GetAnalyzerOutputResponse: Swift.Equatable {
    /// An AnalyzerSummary object that contains information about the
    ///          analyzer.
    /// This member is required.
    public var analyzer: AccessAnalyzerClientTypes.AnalyzerSummary?

    public init (
        analyzer: AccessAnalyzerClientTypes.AnalyzerSummary? = nil
    )
    {
        self.analyzer = analyzer
    }
}

struct GetAnalyzerOutputResponseBody: Swift.Equatable {
    public let analyzer: AccessAnalyzerClientTypes.AnalyzerSummary?
}

extension GetAnalyzerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AnalyzerSummary.self, forKey: .analyzer)
        analyzer = analyzerDecoded
    }
}

extension GetArchiveRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetArchiveRuleInput(analyzerName: \(Swift.String(describing: analyzerName)), ruleName: \(Swift.String(describing: ruleName)))"}
}

extension GetArchiveRuleInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetArchiveRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetArchiveRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetArchiveRuleOutputError>
}

public struct GetArchiveRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetArchiveRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetArchiveRuleOutputError>
}

public struct GetArchiveRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetArchiveRuleInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetArchiveRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let analyzerName = input.analyzerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("analyzerName is nil and needs a value for the path of this operation"))))
        }
        guard let ruleName = input.ruleName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("ruleName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule/\(ruleName.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetArchiveRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetArchiveRuleOutputError>
}

/// Retrieves an archive rule.
public struct GetArchiveRuleInput: Swift.Equatable {
    /// The name of the analyzer to retrieve rules from.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// The name of the rule to retrieve.
    /// This member is required.
    public var ruleName: Swift.String?

    public init (
        analyzerName: Swift.String? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.ruleName = ruleName
    }
}

struct GetArchiveRuleInputBody: Swift.Equatable {
}

extension GetArchiveRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetArchiveRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetArchiveRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetArchiveRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetArchiveRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetArchiveRuleOutputResponse(archiveRule: \(Swift.String(describing: archiveRule)))"}
}

extension GetArchiveRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetArchiveRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archiveRule = output.archiveRule
        } else {
            self.archiveRule = nil
        }
    }
}

/// The response to the request.
public struct GetArchiveRuleOutputResponse: Swift.Equatable {
    /// Contains information about an archive rule.
    /// This member is required.
    public var archiveRule: AccessAnalyzerClientTypes.ArchiveRuleSummary?

    public init (
        archiveRule: AccessAnalyzerClientTypes.ArchiveRuleSummary? = nil
    )
    {
        self.archiveRule = archiveRule
    }
}

struct GetArchiveRuleOutputResponseBody: Swift.Equatable {
    public let archiveRule: AccessAnalyzerClientTypes.ArchiveRuleSummary?
}

extension GetArchiveRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveRule
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveRuleDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ArchiveRuleSummary.self, forKey: .archiveRule)
        archiveRule = archiveRuleDecoded
    }
}

extension GetFindingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFindingInput(analyzerArn: \(Swift.String(describing: analyzerArn)), id: \(Swift.String(describing: id)))"}
}

extension GetFindingInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFindingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFindingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFindingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFindingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFindingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFindingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFindingOutputError>
}

public struct GetFindingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFindingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFindingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFindingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let analyzerArn = input.operationInput.analyzerArn {
            let analyzerArnQueryItem = ClientRuntime.URLQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
            input.builder.withQueryItem(analyzerArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFindingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFindingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFindingOutputError>
}

public struct GetFindingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFindingInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetFindingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFindingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/finding/\(id.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFindingInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFindingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFindingOutputError>
}

/// Retrieves a finding.
public struct GetFindingInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer that generated the finding.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The ID of the finding to retrieve.
    /// This member is required.
    public var id: Swift.String?

    public init (
        analyzerArn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.id = id
    }
}

struct GetFindingInputBody: Swift.Equatable {
}

extension GetFindingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFindingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFindingOutputResponse(finding: \(Swift.String(describing: finding)))"}
}

extension GetFindingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFindingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.finding = output.finding
        } else {
            self.finding = nil
        }
    }
}

/// The response to the request.
public struct GetFindingOutputResponse: Swift.Equatable {
    /// A finding object that contains finding details.
    public var finding: AccessAnalyzerClientTypes.Finding?

    public init (
        finding: AccessAnalyzerClientTypes.Finding? = nil
    )
    {
        self.finding = finding
    }
}

struct GetFindingOutputResponseBody: Swift.Equatable {
    public let finding: AccessAnalyzerClientTypes.Finding?
}

extension GetFindingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finding
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.Finding.self, forKey: .finding)
        finding = findingDecoded
    }
}

extension GetGeneratedPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGeneratedPolicyInput(includeResourcePlaceholders: \(Swift.String(describing: includeResourcePlaceholders)), includeServiceLevelTemplate: \(Swift.String(describing: includeServiceLevelTemplate)), jobId: \(Swift.String(describing: jobId)))"}
}

extension GetGeneratedPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetGeneratedPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGeneratedPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetGeneratedPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGeneratedPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetGeneratedPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetGeneratedPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGeneratedPolicyOutputError>
}

public struct GetGeneratedPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGeneratedPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetGeneratedPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGeneratedPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let includeResourcePlaceholders = input.operationInput.includeResourcePlaceholders {
            let includeResourcePlaceholdersQueryItem = ClientRuntime.URLQueryItem(name: "includeResourcePlaceholders".urlPercentEncoding(), value: Swift.String(includeResourcePlaceholders).urlPercentEncoding())
            input.builder.withQueryItem(includeResourcePlaceholdersQueryItem)
        }
        if let includeServiceLevelTemplate = input.operationInput.includeServiceLevelTemplate {
            let includeServiceLevelTemplateQueryItem = ClientRuntime.URLQueryItem(name: "includeServiceLevelTemplate".urlPercentEncoding(), value: Swift.String(includeServiceLevelTemplate).urlPercentEncoding())
            input.builder.withQueryItem(includeServiceLevelTemplateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetGeneratedPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetGeneratedPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGeneratedPolicyOutputError>
}

public struct GetGeneratedPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGeneratedPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetGeneratedPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGeneratedPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let jobId = input.jobId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("jobId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/policy/generation/\(jobId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetGeneratedPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetGeneratedPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGeneratedPolicyOutputError>
}

public struct GetGeneratedPolicyInput: Swift.Equatable {
    /// The level of detail that you want to generate. You can specify whether to generate
    ///          policies with placeholders for resource ARNs for actions that support resource level
    ///          granularity in policies.
    ///          For example, in the resource section of a policy, you can receive a placeholder such as
    ///             "Resource":"arn:aws:s3:::${BucketName}" instead of "*".
    public var includeResourcePlaceholders: Swift.Bool?
    /// The level of detail that you want to generate. You can specify whether to generate
    ///          service-level policies.
    ///          IAM Access Analyzer uses iam:servicelastaccessed to identify services that have
    ///          been used recently to create this service-level template.
    public var includeServiceLevelTemplate: Swift.Bool?
    /// The JobId that is returned by the StartPolicyGeneration
    ///          operation. The JobId can be used with GetGeneratedPolicy to
    ///          retrieve the generated policies or used with CancelPolicyGeneration to cancel
    ///          the policy generation request.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        includeResourcePlaceholders: Swift.Bool? = nil,
        includeServiceLevelTemplate: Swift.Bool? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.includeResourcePlaceholders = includeResourcePlaceholders
        self.includeServiceLevelTemplate = includeServiceLevelTemplate
        self.jobId = jobId
    }
}

struct GetGeneratedPolicyInputBody: Swift.Equatable {
}

extension GetGeneratedPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGeneratedPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGeneratedPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGeneratedPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGeneratedPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGeneratedPolicyOutputResponse(generatedPolicyResult: \(Swift.String(describing: generatedPolicyResult)), jobDetails: \(Swift.String(describing: jobDetails)))"}
}

extension GetGeneratedPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetGeneratedPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.generatedPolicyResult = output.generatedPolicyResult
            self.jobDetails = output.jobDetails
        } else {
            self.generatedPolicyResult = nil
            self.jobDetails = nil
        }
    }
}

public struct GetGeneratedPolicyOutputResponse: Swift.Equatable {
    /// A GeneratedPolicyResult object that contains the generated policies and
    ///          associated details.
    /// This member is required.
    public var generatedPolicyResult: AccessAnalyzerClientTypes.GeneratedPolicyResult?
    /// A GeneratedPolicyDetails object that contains details about the generated
    ///          policy.
    /// This member is required.
    public var jobDetails: AccessAnalyzerClientTypes.JobDetails?

    public init (
        generatedPolicyResult: AccessAnalyzerClientTypes.GeneratedPolicyResult? = nil,
        jobDetails: AccessAnalyzerClientTypes.JobDetails? = nil
    )
    {
        self.generatedPolicyResult = generatedPolicyResult
        self.jobDetails = jobDetails
    }
}

struct GetGeneratedPolicyOutputResponseBody: Swift.Equatable {
    public let jobDetails: AccessAnalyzerClientTypes.JobDetails?
    public let generatedPolicyResult: AccessAnalyzerClientTypes.GeneratedPolicyResult?
}

extension GetGeneratedPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedPolicyResult
        case jobDetails
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDetailsDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.JobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
        let generatedPolicyResultDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.GeneratedPolicyResult.self, forKey: .generatedPolicyResult)
        generatedPolicyResult = generatedPolicyResultDecoded
    }
}

extension AccessAnalyzerClientTypes.IamRoleConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustPolicy = trustPolicy {
            try encodeContainer.encode(trustPolicy, forKey: .trustPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustPolicy)
        trustPolicy = trustPolicyDecoded
    }
}

extension AccessAnalyzerClientTypes.IamRoleConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IamRoleConfiguration(trustPolicy: \(Swift.String(describing: trustPolicy)))"}
}

extension AccessAnalyzerClientTypes {
    /// The proposed access control configuration for an IAM role. You can propose a
    ///          configuration for a new IAM role or an existing IAM role that you own by specifying the
    ///          trust policy. If the configuration is for a new IAM role, you must specify the trust
    ///          policy. If the configuration is for an existing IAM role that you own and you do not
    ///          propose the trust policy, the access preview uses the existing trust policy for the role.
    ///          The proposed trust policy cannot be an empty string. For more information about role trust
    ///          policy limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html">IAM and STS
    ///          quotas.
    public struct IamRoleConfiguration: Swift.Equatable {
        /// The proposed trust policy for the IAM role.
        public var trustPolicy: Swift.String?

        public init (
            trustPolicy: Swift.String? = nil
        )
        {
            self.trustPolicy = trustPolicy
        }
    }

}

extension AccessAnalyzerClientTypes.InlineArchiveRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ruleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, filtercriteriamap0) in filter {
                try filterContainer.encode(filtercriteriamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Criterion?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
    }
}

extension AccessAnalyzerClientTypes.InlineArchiveRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InlineArchiveRule(filter: \(Swift.String(describing: filter)), ruleName: \(Swift.String(describing: ruleName)))"}
}

extension AccessAnalyzerClientTypes {
    /// An criterion statement in an archive rule. Each archive rule may have multiple
    ///          criteria.
    public struct InlineArchiveRule: Swift.Equatable {
        /// The condition and values for a criterion.
        /// This member is required.
        public var filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
        /// The name of the rule.
        /// This member is required.
        public var ruleName: Swift.String?

        public init (
            filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil,
            ruleName: Swift.String? = nil
        )
        {
            self.filter = filter
            self.ruleName = ruleName
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Internal server error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The seconds to wait to retry.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessAnalyzerClientTypes.InternetConfiguration: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AccessAnalyzerClientTypes.InternetConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternetConfiguration()"}
}

extension AccessAnalyzerClientTypes {
    /// This configuration sets the network origin for the Amazon S3 access point or multi-region
    ///          access point to Internet.
    public struct InternetConfiguration: Swift.Equatable {

        public init() {}
    }

}

extension AccessAnalyzerClientTypes.JobDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedOn
        case jobError
        case jobId
        case startedOn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedOn = completedOn {
            try encodeContainer.encode(completedOn.timeIntervalSince1970, forKey: .completedOn)
        }
        if let jobError = jobError {
            try encodeContainer.encode(jobError, forKey: .jobError)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let startedOn = startedOn {
            try encodeContainer.encode(startedOn.timeIntervalSince1970, forKey: .startedOn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let startedOnDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedOn)
        startedOn = startedOnDecoded
        let completedOnDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedOn)
        completedOn = completedOnDecoded
        let jobErrorDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.JobError.self, forKey: .jobError)
        jobError = jobErrorDecoded
    }
}

extension AccessAnalyzerClientTypes.JobDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobDetails(completedOn: \(Swift.String(describing: completedOn)), jobError: \(Swift.String(describing: jobError)), jobId: \(Swift.String(describing: jobId)), startedOn: \(Swift.String(describing: startedOn)), status: \(Swift.String(describing: status)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains details about the policy generation request.
    public struct JobDetails: Swift.Equatable {
        /// A timestamp of when the job was completed.
        public var completedOn: ClientRuntime.Date?
        /// The job error for the policy generation request.
        public var jobError: AccessAnalyzerClientTypes.JobError?
        /// The JobId that is returned by the StartPolicyGeneration
        ///          operation. The JobId can be used with GetGeneratedPolicy to
        ///          retrieve the generated policies or used with CancelPolicyGeneration to cancel
        ///          the policy generation request.
        /// This member is required.
        public var jobId: Swift.String?
        /// A timestamp of when the job was started.
        /// This member is required.
        public var startedOn: ClientRuntime.Date?
        /// The status of the job request.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.JobStatus?

        public init (
            completedOn: ClientRuntime.Date? = nil,
            jobError: AccessAnalyzerClientTypes.JobError? = nil,
            jobId: Swift.String? = nil,
            startedOn: ClientRuntime.Date? = nil,
            status: AccessAnalyzerClientTypes.JobStatus? = nil
        )
        {
            self.completedOn = completedOn
            self.jobError = jobError
            self.jobId = jobId
            self.startedOn = startedOn
            self.status = status
        }
    }

}

extension AccessAnalyzerClientTypes.JobError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.JobErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessAnalyzerClientTypes.JobError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobError(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains the details about the policy generation error.
    public struct JobError: Swift.Equatable {
        /// The job error code.
        /// This member is required.
        public var code: AccessAnalyzerClientTypes.JobErrorCode?
        /// Specific information about the error. For example, which service quota was exceeded or
        ///          which resource was not found.
        /// This member is required.
        public var message: Swift.String?

        public init (
            code: AccessAnalyzerClientTypes.JobErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum JobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authorizationError
        case resourceNotFoundError
        case serviceError
        case serviceQuotaExceededError
        case sdkUnknown(Swift.String)

        public static var allCases: [JobErrorCode] {
            return [
                .authorizationError,
                .resourceNotFoundError,
                .serviceError,
                .serviceQuotaExceededError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authorizationError: return "AUTHORIZATION_ERROR"
            case .resourceNotFoundError: return "RESOURCE_NOT_FOUND_ERROR"
            case .serviceError: return "SERVICE_ERROR"
            case .serviceQuotaExceededError: return "SERVICE_QUOTA_EXCEEDED_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobErrorCode(rawValue: rawValue) ?? JobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.KmsGrantConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraints
        case granteePrincipal
        case issuingAccount
        case operations
        case retiringPrincipal
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraints = constraints {
            try encodeContainer.encode(constraints, forKey: .constraints)
        }
        if let granteePrincipal = granteePrincipal {
            try encodeContainer.encode(granteePrincipal, forKey: .granteePrincipal)
        }
        if let issuingAccount = issuingAccount {
            try encodeContainer.encode(issuingAccount, forKey: .issuingAccount)
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for kmsgrantoperationslist0 in operations {
                try operationsContainer.encode(kmsgrantoperationslist0.rawValue)
            }
        }
        if let retiringPrincipal = retiringPrincipal {
            try encodeContainer.encode(retiringPrincipal, forKey: .retiringPrincipal)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.KmsGrantOperation?].self, forKey: .operations)
        var operationsDecoded0:[AccessAnalyzerClientTypes.KmsGrantOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [AccessAnalyzerClientTypes.KmsGrantOperation]()
            for string0 in operationsContainer {
                if let string0 = string0 {
                    operationsDecoded0?.append(string0)
                }
            }
        }
        operations = operationsDecoded0
        let granteePrincipalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteePrincipal)
        granteePrincipal = granteePrincipalDecoded
        let retiringPrincipalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retiringPrincipal)
        retiringPrincipal = retiringPrincipalDecoded
        let constraintsDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.KmsGrantConstraints.self, forKey: .constraints)
        constraints = constraintsDecoded
        let issuingAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuingAccount)
        issuingAccount = issuingAccountDecoded
    }
}

extension AccessAnalyzerClientTypes.KmsGrantConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KmsGrantConfiguration(constraints: \(Swift.String(describing: constraints)), granteePrincipal: \(Swift.String(describing: granteePrincipal)), issuingAccount: \(Swift.String(describing: issuingAccount)), operations: \(Swift.String(describing: operations)), retiringPrincipal: \(Swift.String(describing: retiringPrincipal)))"}
}

extension AccessAnalyzerClientTypes {
    /// A proposed grant configuration for a KMS key. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateGrant.html">CreateGrant.
    public struct KmsGrantConfiguration: Swift.Equatable {
        /// Use this structure to propose allowing <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
        ///             operations in the grant only when the operation request includes the specified
        ///             <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">encryption
        ///          context.
        public var constraints: AccessAnalyzerClientTypes.KmsGrantConstraints?
        /// The principal that is given permission to perform the operations that the grant
        ///          permits.
        /// This member is required.
        public var granteePrincipal: Swift.String?
        ///  The Amazon Web Services account under which the grant was issued. The account is used to propose
        ///          KMS grants issued by accounts other than the owner of the key.
        /// This member is required.
        public var issuingAccount: Swift.String?
        /// A list of operations that the grant permits.
        /// This member is required.
        public var operations: [AccessAnalyzerClientTypes.KmsGrantOperation]?
        /// The principal that is given permission to retire the grant by using <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_RetireGrant.html">RetireGrant operation.
        public var retiringPrincipal: Swift.String?

        public init (
            constraints: AccessAnalyzerClientTypes.KmsGrantConstraints? = nil,
            granteePrincipal: Swift.String? = nil,
            issuingAccount: Swift.String? = nil,
            operations: [AccessAnalyzerClientTypes.KmsGrantOperation]? = nil,
            retiringPrincipal: Swift.String? = nil
        )
        {
            self.constraints = constraints
            self.granteePrincipal = granteePrincipal
            self.issuingAccount = issuingAccount
            self.operations = operations
            self.retiringPrincipal = retiringPrincipal
        }
    }

}

extension AccessAnalyzerClientTypes.KmsGrantConstraints: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionContextEquals
        case encryptionContextSubset
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionContextEquals = encryptionContextEquals {
            var encryptionContextEqualsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .encryptionContextEquals)
            for (dictKey0, kmsconstraintsmap0) in encryptionContextEquals {
                try encryptionContextEqualsContainer.encode(kmsconstraintsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let encryptionContextSubset = encryptionContextSubset {
            var encryptionContextSubsetContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .encryptionContextSubset)
            for (dictKey0, kmsconstraintsmap0) in encryptionContextSubset {
                try encryptionContextSubsetContainer.encode(kmsconstraintsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionContextEqualsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .encryptionContextEquals)
        var encryptionContextEqualsDecoded0: [Swift.String:Swift.String]? = nil
        if let encryptionContextEqualsContainer = encryptionContextEqualsContainer {
            encryptionContextEqualsDecoded0 = [Swift.String:Swift.String]()
            for (key0, kmsconstraintsvalue0) in encryptionContextEqualsContainer {
                if let kmsconstraintsvalue0 = kmsconstraintsvalue0 {
                    encryptionContextEqualsDecoded0?[key0] = kmsconstraintsvalue0
                }
            }
        }
        encryptionContextEquals = encryptionContextEqualsDecoded0
        let encryptionContextSubsetContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .encryptionContextSubset)
        var encryptionContextSubsetDecoded0: [Swift.String:Swift.String]? = nil
        if let encryptionContextSubsetContainer = encryptionContextSubsetContainer {
            encryptionContextSubsetDecoded0 = [Swift.String:Swift.String]()
            for (key0, kmsconstraintsvalue0) in encryptionContextSubsetContainer {
                if let kmsconstraintsvalue0 = kmsconstraintsvalue0 {
                    encryptionContextSubsetDecoded0?[key0] = kmsconstraintsvalue0
                }
            }
        }
        encryptionContextSubset = encryptionContextSubsetDecoded0
    }
}

extension AccessAnalyzerClientTypes.KmsGrantConstraints: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KmsGrantConstraints(encryptionContextEquals: \(Swift.String(describing: encryptionContextEquals)), encryptionContextSubset: \(Swift.String(describing: encryptionContextSubset)))"}
}

extension AccessAnalyzerClientTypes {
    /// Use this structure to propose allowing <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
    ///             operations in the grant only when the operation request includes the specified
    ///             <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">encryption
    ///          context. You can specify only one type of encryption context. An empty map is
    ///          treated as not specified. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_GrantConstraints.html">GrantConstraints.
    public struct KmsGrantConstraints: Swift.Equatable {
        /// A list of key-value pairs that must match the encryption context in the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
        ///             operation request. The grant allows the operation only when the encryption
        ///          context in the request is the same as the encryption context specified in this
        ///          constraint.
        public var encryptionContextEquals: [Swift.String:Swift.String]?
        /// A list of key-value pairs that must be included in the encryption context of the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
        ///             operation request. The grant allows the cryptographic operation only when the
        ///          encryption context in the request includes the key-value pairs specified in this
        ///          constraint, although it can include additional key-value pairs.
        public var encryptionContextSubset: [Swift.String:Swift.String]?

        public init (
            encryptionContextEquals: [Swift.String:Swift.String]? = nil,
            encryptionContextSubset: [Swift.String:Swift.String]? = nil
        )
        {
            self.encryptionContextEquals = encryptionContextEquals
            self.encryptionContextSubset = encryptionContextSubset
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum KmsGrantOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createGrant
        case decrypt
        case describeKey
        case encrypt
        case generateDataKey
        case generateDataKeyPair
        case generateDataKeyPairWithoutPlaintext
        case generateDataKeyWithoutPlaintext
        case getPublicKey
        case reencryptFrom
        case reencryptTo
        case retireGrant
        case sign
        case verify
        case sdkUnknown(Swift.String)

        public static var allCases: [KmsGrantOperation] {
            return [
                .createGrant,
                .decrypt,
                .describeKey,
                .encrypt,
                .generateDataKey,
                .generateDataKeyPair,
                .generateDataKeyPairWithoutPlaintext,
                .generateDataKeyWithoutPlaintext,
                .getPublicKey,
                .reencryptFrom,
                .reencryptTo,
                .retireGrant,
                .sign,
                .verify,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createGrant: return "CreateGrant"
            case .decrypt: return "Decrypt"
            case .describeKey: return "DescribeKey"
            case .encrypt: return "Encrypt"
            case .generateDataKey: return "GenerateDataKey"
            case .generateDataKeyPair: return "GenerateDataKeyPair"
            case .generateDataKeyPairWithoutPlaintext: return "GenerateDataKeyPairWithoutPlaintext"
            case .generateDataKeyWithoutPlaintext: return "GenerateDataKeyWithoutPlaintext"
            case .getPublicKey: return "GetPublicKey"
            case .reencryptFrom: return "ReEncryptFrom"
            case .reencryptTo: return "ReEncryptTo"
            case .retireGrant: return "RetireGrant"
            case .sign: return "Sign"
            case .verify: return "Verify"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KmsGrantOperation(rawValue: rawValue) ?? KmsGrantOperation.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.KmsKeyConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants
        case keyPolicies
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grants = grants {
            var grantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grants)
            for kmsgrantconfigurationslist0 in grants {
                try grantsContainer.encode(kmsgrantconfigurationslist0)
            }
        }
        if let keyPolicies = keyPolicies {
            var keyPoliciesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .keyPolicies)
            for (dictKey0, kmskeypoliciesmap0) in keyPolicies {
                try keyPoliciesContainer.encode(kmskeypoliciesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPoliciesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .keyPolicies)
        var keyPoliciesDecoded0: [Swift.String:Swift.String]? = nil
        if let keyPoliciesContainer = keyPoliciesContainer {
            keyPoliciesDecoded0 = [Swift.String:Swift.String]()
            for (key0, kmskeypolicy0) in keyPoliciesContainer {
                if let kmskeypolicy0 = kmskeypolicy0 {
                    keyPoliciesDecoded0?[key0] = kmskeypolicy0
                }
            }
        }
        keyPolicies = keyPoliciesDecoded0
        let grantsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.KmsGrantConfiguration?].self, forKey: .grants)
        var grantsDecoded0:[AccessAnalyzerClientTypes.KmsGrantConfiguration]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [AccessAnalyzerClientTypes.KmsGrantConfiguration]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
    }
}

extension AccessAnalyzerClientTypes.KmsKeyConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KmsKeyConfiguration(grants: \(Swift.String(describing: grants)), keyPolicies: \(Swift.String(describing: keyPolicies)))"}
}

extension AccessAnalyzerClientTypes {
    /// Proposed access control configuration for a KMS key. You can propose a configuration
    ///          for a new KMS key or an existing KMS key that you own by specifying the key policy and
    ///          KMS grant configuration. If the configuration is for an existing key and you do not
    ///          specify the key policy, the access preview uses the existing policy for the key. If the
    ///          access preview is for a new resource and you do not specify the key policy, then the access
    ///          preview uses the default key policy. The proposed key policy cannot be an empty string. For
    ///          more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default">Default key
    ///             policy. For more information about key policy limits, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/resource-limits.html">Resource
    ///             quotas.
    ///          <p/>
    public struct KmsKeyConfiguration: Swift.Equatable {
        /// A list of proposed grant configurations for the KMS key. If the proposed grant
        ///          configuration is for an existing key, the access preview uses the proposed list of grant
        ///          configurations in place of the existing grants. Otherwise, the access preview uses the
        ///          existing grants for the key.
        public var grants: [AccessAnalyzerClientTypes.KmsGrantConfiguration]?
        /// Resource policy configuration for the KMS key. The only valid value for the name of
        ///          the key policy is default. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default">Default key
        ///             policy.
        public var keyPolicies: [Swift.String:Swift.String]?

        public init (
            grants: [AccessAnalyzerClientTypes.KmsGrantConfiguration]? = nil,
            keyPolicies: [Swift.String:Swift.String]? = nil
        )
        {
            self.grants = grants
            self.keyPolicies = keyPolicies
        }
    }

}

public struct ListAccessPreviewFindingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessPreviewFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessPreviewFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessPreviewFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessPreviewFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessPreviewFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessPreviewFindingsOutputError>
}

extension ListAccessPreviewFindingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccessPreviewFindingsInput(accessPreviewId: \(Swift.String(describing: accessPreviewId)), analyzerArn: \(Swift.String(describing: analyzerArn)), filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAccessPreviewFindingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, filtercriteriamap0) in filter {
                try filterContainer.encode(filtercriteriamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAccessPreviewFindingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessPreviewFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessPreviewFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessPreviewFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessPreviewFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessPreviewFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessPreviewFindingsOutputError>
}

public struct ListAccessPreviewFindingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessPreviewFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessPreviewFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessPreviewFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessPreviewFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessPreviewFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessPreviewFindingsOutputError>
}

public struct ListAccessPreviewFindingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessPreviewFindingsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAccessPreviewFindingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessPreviewFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accessPreviewId = input.accessPreviewId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accessPreviewId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/access-preview/\(accessPreviewId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAccessPreviewFindingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessPreviewFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessPreviewFindingsOutputError>
}

public struct ListAccessPreviewFindingsInput: Swift.Equatable {
    /// The unique ID for the access preview.
    /// This member is required.
    public var accessPreviewId: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer used to generate the access.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// Criteria to filter the returned findings.
    public var filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        accessPreviewId: Swift.String? = nil,
        analyzerArn: Swift.String? = nil,
        filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPreviewId = accessPreviewId
        self.analyzerArn = analyzerArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccessPreviewFindingsInputBody: Swift.Equatable {
    public let analyzerArn: Swift.String?
    public let filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAccessPreviewFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Criterion?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAccessPreviewFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessPreviewFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessPreviewFindingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessPreviewFindingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccessPreviewFindingsOutputResponse(findings: \(Swift.String(describing: findings)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAccessPreviewFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAccessPreviewFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPreviewFindingsOutputResponse: Swift.Equatable {
    /// A list of access preview findings that match the specified filter criteria.
    /// This member is required.
    public var findings: [AccessAnalyzerClientTypes.AccessPreviewFinding]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        findings: [AccessAnalyzerClientTypes.AccessPreviewFinding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ListAccessPreviewFindingsOutputResponseBody: Swift.Equatable {
    public let findings: [AccessAnalyzerClientTypes.AccessPreviewFinding]?
    public let nextToken: Swift.String?
}

extension ListAccessPreviewFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.AccessPreviewFinding?].self, forKey: .findings)
        var findingsDecoded0:[AccessAnalyzerClientTypes.AccessPreviewFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [AccessAnalyzerClientTypes.AccessPreviewFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccessPreviewsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccessPreviewsInput(analyzerArn: \(Swift.String(describing: analyzerArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAccessPreviewsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAccessPreviewsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessPreviewsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessPreviewsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessPreviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessPreviewsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessPreviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessPreviewsOutputError>
}

public struct ListAccessPreviewsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessPreviewsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessPreviewsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessPreviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let analyzerArn = input.operationInput.analyzerArn {
            let analyzerArnQueryItem = ClientRuntime.URLQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
            input.builder.withQueryItem(analyzerArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessPreviewsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessPreviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessPreviewsOutputError>
}

public struct ListAccessPreviewsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessPreviewsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAccessPreviewsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessPreviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/access-preview"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAccessPreviewsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessPreviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessPreviewsOutputError>
}

public struct ListAccessPreviewsInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer used to generate the access preview.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        analyzerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccessPreviewsInputBody: Swift.Equatable {
}

extension ListAccessPreviewsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAccessPreviewsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessPreviewsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessPreviewsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessPreviewsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccessPreviewsOutputResponse(accessPreviews: \(Swift.String(describing: accessPreviews)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAccessPreviewsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAccessPreviewsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPreviews = output.accessPreviews
            self.nextToken = output.nextToken
        } else {
            self.accessPreviews = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPreviewsOutputResponse: Swift.Equatable {
    /// A list of access previews retrieved for the analyzer.
    /// This member is required.
    public var accessPreviews: [AccessAnalyzerClientTypes.AccessPreviewSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        accessPreviews: [AccessAnalyzerClientTypes.AccessPreviewSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPreviews = accessPreviews
        self.nextToken = nextToken
    }
}

struct ListAccessPreviewsOutputResponseBody: Swift.Equatable {
    public let accessPreviews: [AccessAnalyzerClientTypes.AccessPreviewSummary]?
    public let nextToken: Swift.String?
}

extension ListAccessPreviewsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPreviews
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPreviewsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.AccessPreviewSummary?].self, forKey: .accessPreviews)
        var accessPreviewsDecoded0:[AccessAnalyzerClientTypes.AccessPreviewSummary]? = nil
        if let accessPreviewsContainer = accessPreviewsContainer {
            accessPreviewsDecoded0 = [AccessAnalyzerClientTypes.AccessPreviewSummary]()
            for structure0 in accessPreviewsContainer {
                if let structure0 = structure0 {
                    accessPreviewsDecoded0?.append(structure0)
                }
            }
        }
        accessPreviews = accessPreviewsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAnalyzedResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAnalyzedResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAnalyzedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAnalyzedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAnalyzedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAnalyzedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAnalyzedResourcesOutputError>
}

extension ListAnalyzedResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAnalyzedResourcesInput(analyzerArn: \(Swift.String(describing: analyzerArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ListAnalyzedResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case maxResults
        case nextToken
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

public struct ListAnalyzedResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAnalyzedResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAnalyzedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAnalyzedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAnalyzedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAnalyzedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAnalyzedResourcesOutputError>
}

public struct ListAnalyzedResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAnalyzedResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAnalyzedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAnalyzedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAnalyzedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAnalyzedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAnalyzedResourcesOutputError>
}

public struct ListAnalyzedResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAnalyzedResourcesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAnalyzedResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAnalyzedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/analyzed-resource"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAnalyzedResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAnalyzedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAnalyzedResourcesOutputError>
}

/// Retrieves a list of resources that have been analyzed.
public struct ListAnalyzedResourcesInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer to retrieve a list of analyzed resources from.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The type of resource.
    public var resourceType: AccessAnalyzerClientTypes.ResourceType?

    public init (
        analyzerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: AccessAnalyzerClientTypes.ResourceType? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListAnalyzedResourcesInputBody: Swift.Equatable {
    public let analyzerArn: Swift.String?
    public let resourceType: AccessAnalyzerClientTypes.ResourceType?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAnalyzedResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case maxResults
        case nextToken
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAnalyzedResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnalyzedResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnalyzedResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnalyzedResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAnalyzedResourcesOutputResponse(analyzedResources: \(Swift.String(describing: analyzedResources)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAnalyzedResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAnalyzedResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analyzedResources = output.analyzedResources
            self.nextToken = output.nextToken
        } else {
            self.analyzedResources = nil
            self.nextToken = nil
        }
    }
}

/// The response to the request.
public struct ListAnalyzedResourcesOutputResponse: Swift.Equatable {
    /// A list of resources that were analyzed.
    /// This member is required.
    public var analyzedResources: [AccessAnalyzerClientTypes.AnalyzedResourceSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        analyzedResources: [AccessAnalyzerClientTypes.AnalyzedResourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzedResources = analyzedResources
        self.nextToken = nextToken
    }
}

struct ListAnalyzedResourcesOutputResponseBody: Swift.Equatable {
    public let analyzedResources: [AccessAnalyzerClientTypes.AnalyzedResourceSummary]?
    public let nextToken: Swift.String?
}

extension ListAnalyzedResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzedResources
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzedResourcesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.AnalyzedResourceSummary?].self, forKey: .analyzedResources)
        var analyzedResourcesDecoded0:[AccessAnalyzerClientTypes.AnalyzedResourceSummary]? = nil
        if let analyzedResourcesContainer = analyzedResourcesContainer {
            analyzedResourcesDecoded0 = [AccessAnalyzerClientTypes.AnalyzedResourceSummary]()
            for structure0 in analyzedResourcesContainer {
                if let structure0 = structure0 {
                    analyzedResourcesDecoded0?.append(structure0)
                }
            }
        }
        analyzedResources = analyzedResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnalyzersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAnalyzersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), type: \(Swift.String(describing: type)))"}
}

extension ListAnalyzersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAnalyzersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAnalyzersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAnalyzersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAnalyzersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAnalyzersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAnalyzersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAnalyzersOutputError>
}

public struct ListAnalyzersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAnalyzersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAnalyzersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAnalyzersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let type = input.operationInput.type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAnalyzersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAnalyzersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAnalyzersOutputError>
}

public struct ListAnalyzersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAnalyzersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAnalyzersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAnalyzersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/analyzer"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAnalyzersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAnalyzersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAnalyzersOutputError>
}

/// Retrieves a list of analyzers.
public struct ListAnalyzersInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The type of analyzer.
    public var type: AccessAnalyzerClientTypes.ModelType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: AccessAnalyzerClientTypes.ModelType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListAnalyzersInputBody: Swift.Equatable {
}

extension ListAnalyzersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAnalyzersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnalyzersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnalyzersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnalyzersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAnalyzersOutputResponse(analyzers: \(Swift.String(describing: analyzers)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAnalyzersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAnalyzersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analyzers = output.analyzers
            self.nextToken = output.nextToken
        } else {
            self.analyzers = nil
            self.nextToken = nil
        }
    }
}

/// The response to the request.
public struct ListAnalyzersOutputResponse: Swift.Equatable {
    /// The analyzers retrieved.
    /// This member is required.
    public var analyzers: [AccessAnalyzerClientTypes.AnalyzerSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        analyzers: [AccessAnalyzerClientTypes.AnalyzerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzers = analyzers
        self.nextToken = nextToken
    }
}

struct ListAnalyzersOutputResponseBody: Swift.Equatable {
    public let analyzers: [AccessAnalyzerClientTypes.AnalyzerSummary]?
    public let nextToken: Swift.String?
}

extension ListAnalyzersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzers
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzersContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.AnalyzerSummary?].self, forKey: .analyzers)
        var analyzersDecoded0:[AccessAnalyzerClientTypes.AnalyzerSummary]? = nil
        if let analyzersContainer = analyzersContainer {
            analyzersDecoded0 = [AccessAnalyzerClientTypes.AnalyzerSummary]()
            for structure0 in analyzersContainer {
                if let structure0 = structure0 {
                    analyzersDecoded0?.append(structure0)
                }
            }
        }
        analyzers = analyzersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListArchiveRulesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListArchiveRulesInput(analyzerName: \(Swift.String(describing: analyzerName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListArchiveRulesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListArchiveRulesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListArchiveRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListArchiveRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListArchiveRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListArchiveRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListArchiveRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListArchiveRulesOutputError>
}

public struct ListArchiveRulesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListArchiveRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListArchiveRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListArchiveRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListArchiveRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListArchiveRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListArchiveRulesOutputError>
}

public struct ListArchiveRulesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListArchiveRulesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListArchiveRulesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListArchiveRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let analyzerName = input.analyzerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("analyzerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListArchiveRulesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListArchiveRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListArchiveRulesOutputError>
}

/// Retrieves a list of archive rules created for the specified analyzer.
public struct ListArchiveRulesInput: Swift.Equatable {
    /// The name of the analyzer to retrieve rules from.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// The maximum number of results to return in the request.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        analyzerName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListArchiveRulesInputBody: Swift.Equatable {
}

extension ListArchiveRulesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListArchiveRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListArchiveRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListArchiveRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListArchiveRulesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListArchiveRulesOutputResponse(archiveRules: \(Swift.String(describing: archiveRules)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListArchiveRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListArchiveRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archiveRules = output.archiveRules
            self.nextToken = output.nextToken
        } else {
            self.archiveRules = nil
            self.nextToken = nil
        }
    }
}

/// The response to the request.
public struct ListArchiveRulesOutputResponse: Swift.Equatable {
    /// A list of archive rules created for the specified analyzer.
    /// This member is required.
    public var archiveRules: [AccessAnalyzerClientTypes.ArchiveRuleSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        archiveRules: [AccessAnalyzerClientTypes.ArchiveRuleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.archiveRules = archiveRules
        self.nextToken = nextToken
    }
}

struct ListArchiveRulesOutputResponseBody: Swift.Equatable {
    public let archiveRules: [AccessAnalyzerClientTypes.ArchiveRuleSummary]?
    public let nextToken: Swift.String?
}

extension ListArchiveRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveRules
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveRulesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.ArchiveRuleSummary?].self, forKey: .archiveRules)
        var archiveRulesDecoded0:[AccessAnalyzerClientTypes.ArchiveRuleSummary]? = nil
        if let archiveRulesContainer = archiveRulesContainer {
            archiveRulesDecoded0 = [AccessAnalyzerClientTypes.ArchiveRuleSummary]()
            for structure0 in archiveRulesContainer {
                if let structure0 = structure0 {
                    archiveRulesDecoded0?.append(structure0)
                }
            }
        }
        archiveRules = archiveRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFindingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFindingsOutputError>
}

extension ListFindingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFindingsInput(analyzerArn: \(Swift.String(describing: analyzerArn)), filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), sort: \(Swift.String(describing: sort)))"}
}

extension ListFindingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case filter
        case maxResults
        case nextToken
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, filtercriteriamap0) in filter {
                try filterContainer.encode(filtercriteriamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

public struct ListFindingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFindingsOutputError>
}

public struct ListFindingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFindingsOutputError>
}

public struct ListFindingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFindingsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListFindingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/finding"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFindingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFindingsOutputError>
}

/// Retrieves a list of findings generated by the specified analyzer.
public struct ListFindingsInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer to retrieve findings from.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A filter to match for the findings to return.
    public var filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The sort order for the findings returned.
    public var sort: AccessAnalyzerClientTypes.SortCriteria?

    public init (
        analyzerArn: Swift.String? = nil,
        filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: AccessAnalyzerClientTypes.SortCriteria? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

struct ListFindingsInputBody: Swift.Equatable {
    public let analyzerArn: Swift.String?
    public let filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    public let sort: AccessAnalyzerClientTypes.SortCriteria?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case filter
        case maxResults
        case nextToken
        case sort
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Criterion?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let sortDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.SortCriteria.self, forKey: .sort)
        sort = sortDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFindingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFindingsOutputResponse(findings: \(Swift.String(describing: findings)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

/// The response to the request.
public struct ListFindingsOutputResponse: Swift.Equatable {
    /// A list of findings retrieved from the analyzer that match the filter criteria specified,
    ///          if any.
    /// This member is required.
    public var findings: [AccessAnalyzerClientTypes.FindingSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        findings: [AccessAnalyzerClientTypes.FindingSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputResponseBody: Swift.Equatable {
    public let findings: [AccessAnalyzerClientTypes.FindingSummary]?
    public let nextToken: Swift.String?
}

extension ListFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.FindingSummary?].self, forKey: .findings)
        var findingsDecoded0:[AccessAnalyzerClientTypes.FindingSummary]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [AccessAnalyzerClientTypes.FindingSummary]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPolicyGenerationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPolicyGenerationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), principalArn: \(Swift.String(describing: principalArn)))"}
}

extension ListPolicyGenerationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPolicyGenerationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPolicyGenerationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPolicyGenerationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPolicyGenerationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPolicyGenerationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPolicyGenerationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPolicyGenerationsOutputError>
}

public struct ListPolicyGenerationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPolicyGenerationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPolicyGenerationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPolicyGenerationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let principalArn = input.operationInput.principalArn {
            let principalArnQueryItem = ClientRuntime.URLQueryItem(name: "principalArn".urlPercentEncoding(), value: Swift.String(principalArn).urlPercentEncoding())
            input.builder.withQueryItem(principalArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPolicyGenerationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPolicyGenerationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPolicyGenerationsOutputError>
}

public struct ListPolicyGenerationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPolicyGenerationsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPolicyGenerationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPolicyGenerationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/policy/generation"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPolicyGenerationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPolicyGenerationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPolicyGenerationsOutputError>
}

public struct ListPolicyGenerationsInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The ARN of the IAM entity (user or role) for which you are generating a policy. Use
    ///          this with ListGeneratedPolicies to filter the results to only include results
    ///          for a specific principal.
    public var principalArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalArn = principalArn
    }
}

struct ListPolicyGenerationsInputBody: Swift.Equatable {
}

extension ListPolicyGenerationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPolicyGenerationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPolicyGenerationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPolicyGenerationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPolicyGenerationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPolicyGenerationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), policyGenerations: \(Swift.String(describing: policyGenerations)))"}
}

extension ListPolicyGenerationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPolicyGenerationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policyGenerations = output.policyGenerations
        } else {
            self.nextToken = nil
            self.policyGenerations = nil
        }
    }
}

public struct ListPolicyGenerationsOutputResponse: Swift.Equatable {
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// A PolicyGeneration object that contains details about the generated
    ///          policy.
    /// This member is required.
    public var policyGenerations: [AccessAnalyzerClientTypes.PolicyGeneration]?

    public init (
        nextToken: Swift.String? = nil,
        policyGenerations: [AccessAnalyzerClientTypes.PolicyGeneration]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyGenerations = policyGenerations
    }
}

struct ListPolicyGenerationsOutputResponseBody: Swift.Equatable {
    public let policyGenerations: [AccessAnalyzerClientTypes.PolicyGeneration]?
    public let nextToken: Swift.String?
}

extension ListPolicyGenerationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case policyGenerations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyGenerationsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.PolicyGeneration?].self, forKey: .policyGenerations)
        var policyGenerationsDecoded0:[AccessAnalyzerClientTypes.PolicyGeneration]? = nil
        if let policyGenerationsContainer = policyGenerationsContainer {
            policyGenerationsDecoded0 = [AccessAnalyzerClientTypes.PolicyGeneration]()
            for structure0 in policyGenerationsContainer {
                if let structure0 = structure0 {
                    policyGenerationsDecoded0?.append(structure0)
                }
            }
        }
        policyGenerations = policyGenerationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

/// Retrieves a list of tags applied to the specified resource.
public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource to retrieve tags from.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// The response to the request.
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags that are applied to the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AccessAnalyzerClientTypes {
    public enum Locale: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case de
        case en
        case es
        case fr
        case it
        case ja
        case ko
        case ptBr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [Locale] {
            return [
                .de,
                .en,
                .es,
                .fr,
                .it,
                .ja,
                .ko,
                .ptBr,
                .zhCn,
                .zhTw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .de: return "DE"
            case .en: return "EN"
            case .es: return "ES"
            case .fr: return "FR"
            case .it: return "IT"
            case .ja: return "JA"
            case .ko: return "KO"
            case .ptBr: return "PT_BR"
            case .zhCn: return "ZH_CN"
            case .zhTw: return "ZH_TW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Locale(rawValue: rawValue) ?? Locale.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.Location: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
        case span
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            var pathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .path)
            for pathelementlist0 in path {
                try pathContainer.encode(pathelementlist0)
            }
        }
        if let span = span {
            try encodeContainer.encode(span, forKey: .span)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.PathElement?].self, forKey: .path)
        var pathDecoded0:[AccessAnalyzerClientTypes.PathElement]? = nil
        if let pathContainer = pathContainer {
            pathDecoded0 = [AccessAnalyzerClientTypes.PathElement]()
            for union0 in pathContainer {
                if let union0 = union0 {
                    pathDecoded0?.append(union0)
                }
            }
        }
        path = pathDecoded0
        let spanDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.Span.self, forKey: .span)
        span = spanDecoded
    }
}

extension AccessAnalyzerClientTypes.Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Location(path: \(Swift.String(describing: path)), span: \(Swift.String(describing: span)))"}
}

extension AccessAnalyzerClientTypes {
    /// A location in a policy that is represented as a path through the JSON representation and
    ///          a corresponding span.
    public struct Location: Swift.Equatable {
        /// A path in a policy, represented as a sequence of path elements.
        /// This member is required.
        public var path: [AccessAnalyzerClientTypes.PathElement]?
        /// A span in a policy.
        /// This member is required.
        public var span: AccessAnalyzerClientTypes.Span?

        public init (
            path: [AccessAnalyzerClientTypes.PathElement]? = nil,
            span: AccessAnalyzerClientTypes.Span? = nil
        )
        {
            self.path = path
            self.span = span
        }
    }

}

extension AccessAnalyzerClientTypes.NetworkOriginConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case internetconfiguration = "internetConfiguration"
        case sdkUnknown
        case vpcconfiguration = "vpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .internetconfiguration(internetconfiguration):
                try container.encode(internetconfiguration, forKey: .internetconfiguration)
            case let .vpcconfiguration(vpcconfiguration):
                try container.encode(vpcconfiguration, forKey: .vpcconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let vpcconfigurationDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.VpcConfiguration.self, forKey: .vpcconfiguration)
        if let vpcconfiguration = vpcconfigurationDecoded {
            self = .vpcconfiguration(vpcconfiguration)
            return
        }
        let internetconfigurationDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.InternetConfiguration.self, forKey: .internetconfiguration)
        if let internetconfiguration = internetconfigurationDecoded {
            self = .internetconfiguration(internetconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AccessAnalyzerClientTypes {
    /// The proposed InternetConfiguration or VpcConfiguration to
    ///          apply to the Amazon S3 access point. VpcConfiguration does not apply to
    ///          multi-region access points. You can make the access point accessible from the internet, or
    ///          you can specify that all requests made through that access point must originate from a
    ///          specific virtual private cloud (VPC). You can specify only one type of network
    ///          configuration. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/creating-access-points.html">Creating access
    ///          points.
    public enum NetworkOriginConfiguration: Swift.Equatable {
        /// The proposed virtual private cloud (VPC) configuration for the Amazon S3 access point. VPC
        ///          configuration does not apply to multi-region access points. For more information, see
        ///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_VpcConfiguration.html">VpcConfiguration.
        case vpcconfiguration(AccessAnalyzerClientTypes.VpcConfiguration)
        /// The configuration for the Amazon S3 access point or multi-region access point with an
        ///             Internet origin.
        case internetconfiguration(AccessAnalyzerClientTypes.InternetConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension AccessAnalyzerClientTypes {
    public enum OrderBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderBy] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderBy(rawValue: rawValue) ?? OrderBy.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.PathElement: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case index
        case key
        case sdkUnknown
        case substring
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .index(index):
                try container.encode(index, forKey: .index)
            case let .key(key):
                try container.encode(key, forKey: .key)
            case let .substring(substring):
                try container.encode(substring, forKey: .substring)
            case let .value(value):
                try container.encode(value, forKey: .value)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .index)
        if let index = indexDecoded {
            self = .index(index)
            return
        }
        let keyDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .key)
        if let key = keyDecoded {
            self = .key(key)
            return
        }
        let substringDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.Substring.self, forKey: .substring)
        if let substring = substringDecoded {
            self = .substring(substring)
            return
        }
        let valueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .value)
        if let value = valueDecoded {
            self = .value(value)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AccessAnalyzerClientTypes {
    /// A single element in a path through the JSON representation of a policy.
    public enum PathElement: Swift.Equatable {
        /// Refers to an index in a JSON array.
        case index(Swift.Int)
        /// Refers to a key in a JSON object.
        case key(Swift.String)
        /// Refers to a substring of a literal string in a JSON object.
        case substring(AccessAnalyzerClientTypes.Substring)
        /// Refers to the value associated with a given key in a JSON object.
        case value(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AccessAnalyzerClientTypes.PolicyGeneration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedOn
        case jobId
        case principalArn
        case startedOn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedOn = completedOn {
            try encodeContainer.encode(completedOn.timeIntervalSince1970, forKey: .completedOn)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let principalArn = principalArn {
            try encodeContainer.encode(principalArn, forKey: .principalArn)
        }
        if let startedOn = startedOn {
            try encodeContainer.encode(startedOn.timeIntervalSince1970, forKey: .startedOn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let principalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalArn)
        principalArn = principalArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let startedOnDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedOn)
        startedOn = startedOnDecoded
        let completedOnDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedOn)
        completedOn = completedOnDecoded
    }
}

extension AccessAnalyzerClientTypes.PolicyGeneration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyGeneration(completedOn: \(Swift.String(describing: completedOn)), jobId: \(Swift.String(describing: jobId)), principalArn: \(Swift.String(describing: principalArn)), startedOn: \(Swift.String(describing: startedOn)), status: \(Swift.String(describing: status)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains details about the policy generation status and properties.
    public struct PolicyGeneration: Swift.Equatable {
        /// A timestamp of when the policy generation was completed.
        public var completedOn: ClientRuntime.Date?
        /// The JobId that is returned by the StartPolicyGeneration
        ///          operation. The JobId can be used with GetGeneratedPolicy to
        ///          retrieve the generated policies or used with CancelPolicyGeneration to cancel
        ///          the policy generation request.
        /// This member is required.
        public var jobId: Swift.String?
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        /// This member is required.
        public var principalArn: Swift.String?
        /// A timestamp of when the policy generation started.
        /// This member is required.
        public var startedOn: ClientRuntime.Date?
        /// The status of the policy generation request.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.JobStatus?

        public init (
            completedOn: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            principalArn: Swift.String? = nil,
            startedOn: ClientRuntime.Date? = nil,
            status: AccessAnalyzerClientTypes.JobStatus? = nil
        )
        {
            self.completedOn = completedOn
            self.jobId = jobId
            self.principalArn = principalArn
            self.startedOn = startedOn
            self.status = status
        }
    }

}

extension AccessAnalyzerClientTypes.PolicyGenerationDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principalArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principalArn = principalArn {
            try encodeContainer.encode(principalArn, forKey: .principalArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalArn)
        principalArn = principalArnDecoded
    }
}

extension AccessAnalyzerClientTypes.PolicyGenerationDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyGenerationDetails(principalArn: \(Swift.String(describing: principalArn)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains the ARN details about the IAM entity for which the policy is
    ///          generated.
    public struct PolicyGenerationDetails: Swift.Equatable {
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        /// This member is required.
        public var principalArn: Swift.String?

        public init (
            principalArn: Swift.String? = nil
        )
        {
            self.principalArn = principalArn
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum PolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case identityPolicy
        case resourcePolicy
        case serviceControlPolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyType] {
            return [
                .identityPolicy,
                .resourcePolicy,
                .serviceControlPolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .identityPolicy: return "IDENTITY_POLICY"
            case .resourcePolicy: return "RESOURCE_POLICY"
            case .serviceControlPolicy: return "SERVICE_CONTROL_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyType(rawValue: rawValue) ?? PolicyType.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.Position: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column
        case line
        case offset
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let line = line {
            try encodeContainer.encode(line, forKey: .line)
        }
        if let offset = offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .line)
        line = lineDecoded
        let columnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .column)
        column = columnDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offset)
        offset = offsetDecoded
    }
}

extension AccessAnalyzerClientTypes.Position: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Position(column: \(Swift.String(describing: column)), line: \(Swift.String(describing: line)), offset: \(Swift.String(describing: offset)))"}
}

extension AccessAnalyzerClientTypes {
    /// A position in a policy.
    public struct Position: Swift.Equatable {
        /// The column of the position, starting from 0.
        /// This member is required.
        public var column: Swift.Int?
        /// The line of the position, starting from 1.
        /// This member is required.
        public var line: Swift.Int?
        /// The offset within the policy that corresponds to the position, starting from 0.
        /// This member is required.
        public var offset: Swift.Int?

        public init (
            column: Swift.Int? = nil,
            line: Swift.Int? = nil,
            offset: Swift.Int? = nil
        )
        {
            self.column = column
            self.line = line
            self.offset = offset
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum ReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsServiceAccessDisabled
        case delegatedAdministratorDeregistered
        case organizationDeleted
        case serviceLinkedRoleCreationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ReasonCode] {
            return [
                .awsServiceAccessDisabled,
                .delegatedAdministratorDeregistered,
                .organizationDeleted,
                .serviceLinkedRoleCreationFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsServiceAccessDisabled: return "AWS_SERVICE_ACCESS_DISABLED"
            case .delegatedAdministratorDeregistered: return "DELEGATED_ADMINISTRATOR_DEREGISTERED"
            case .organizationDeleted: return "ORGANIZATION_DELETED"
            case .serviceLinkedRoleCreationFailed: return "SERVICE_LINKED_ROLE_CREATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReasonCode(rawValue: rawValue) ?? ReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AccessAnalyzerClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsIamRole
        case awsKmsKey
        case awsLambdaFunction
        case awsLambdaLayerversion
        case awsS3Bucket
        case awsSecretsmanagerSecret
        case awsSqsQueue
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .awsIamRole,
                .awsKmsKey,
                .awsLambdaFunction,
                .awsLambdaLayerversion,
                .awsS3Bucket,
                .awsSecretsmanagerSecret,
                .awsSqsQueue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsIamRole: return "AWS::IAM::Role"
            case .awsKmsKey: return "AWS::KMS::Key"
            case .awsLambdaFunction: return "AWS::Lambda::Function"
            case .awsLambdaLayerversion: return "AWS::Lambda::LayerVersion"
            case .awsS3Bucket: return "AWS::S3::Bucket"
            case .awsSecretsmanagerSecret: return "AWS::SecretsManager::Secret"
            case .awsSqsQueue: return "AWS::SQS::Queue"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.S3AccessPointConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointPolicy
        case networkOrigin
        case publicAccessBlock
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointPolicy = accessPointPolicy {
            try encodeContainer.encode(accessPointPolicy, forKey: .accessPointPolicy)
        }
        if let networkOrigin = networkOrigin {
            try encodeContainer.encode(networkOrigin, forKey: .networkOrigin)
        }
        if let publicAccessBlock = publicAccessBlock {
            try encodeContainer.encode(publicAccessBlock, forKey: .publicAccessBlock)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointPolicy)
        accessPointPolicy = accessPointPolicyDecoded
        let publicAccessBlockDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration.self, forKey: .publicAccessBlock)
        publicAccessBlock = publicAccessBlockDecoded
        let networkOriginDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.NetworkOriginConfiguration.self, forKey: .networkOrigin)
        networkOrigin = networkOriginDecoded
    }
}

extension AccessAnalyzerClientTypes.S3AccessPointConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3AccessPointConfiguration(accessPointPolicy: \(Swift.String(describing: accessPointPolicy)), networkOrigin: \(Swift.String(describing: networkOrigin)), publicAccessBlock: \(Swift.String(describing: publicAccessBlock)))"}
}

extension AccessAnalyzerClientTypes {
    /// The configuration for an Amazon S3 access point or multi-region access point for the bucket.
    ///          You can propose up to 10 access points or multi-region access points per bucket. If the
    ///          proposed Amazon S3 access point configuration is for an existing bucket, the access preview uses
    ///          the proposed access point configuration in place of the existing access points. To propose
    ///          an access point without a policy, you can provide an empty string as the access point
    ///          policy. For more information, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/AmazonS3/latest/dev/creating-access-points.html">Creating access points. For more information about access point policy limits,
    ///          see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-points-restrictions-limitations.html">Access points
    ///             restrictions and limitations.
    public struct S3AccessPointConfiguration: Swift.Equatable {
        /// The access point or multi-region access point policy.
        public var accessPointPolicy: Swift.String?
        /// The proposed Internet and VpcConfiguration to apply to this
        ///          Amazon S3 access point. VpcConfiguration does not apply to multi-region access
        ///          points. If the access preview is for a new resource and neither is specified, the access
        ///          preview uses Internet for the network origin. If the access preview is for an
        ///          existing resource and neither is specified, the access preview uses the exiting network
        ///          origin.
        public var networkOrigin: AccessAnalyzerClientTypes.NetworkOriginConfiguration?
        /// The proposed S3PublicAccessBlock configuration to apply to this Amazon S3 access
        ///          point or multi-region access point.
        public var publicAccessBlock: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration?

        public init (
            accessPointPolicy: Swift.String? = nil,
            networkOrigin: AccessAnalyzerClientTypes.NetworkOriginConfiguration? = nil,
            publicAccessBlock: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration? = nil
        )
        {
            self.accessPointPolicy = accessPointPolicy
            self.networkOrigin = networkOrigin
            self.publicAccessBlock = publicAccessBlock
        }
    }

}

extension AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantee
        case permission
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantee = grantee {
            try encodeContainer.encode(grantee, forKey: .grantee)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AclPermission.self, forKey: .permission)
        permission = permissionDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AclGrantee.self, forKey: .grantee)
        grantee = granteeDecoded
    }
}

extension AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3BucketAclGrantConfiguration(grantee: \(Swift.String(describing: grantee)), permission: \(Swift.String(describing: permission)))"}
}

extension AccessAnalyzerClientTypes {
    /// A proposed access control list grant configuration for an Amazon S3 bucket. For more
    ///          information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#setting-acls">How to Specify an
    ///          ACL.
    public struct S3BucketAclGrantConfiguration: Swift.Equatable {
        /// The grantee to whom youre assigning access rights.
        /// This member is required.
        public var grantee: AccessAnalyzerClientTypes.AclGrantee?
        /// The permissions being granted.
        /// This member is required.
        public var permission: AccessAnalyzerClientTypes.AclPermission?

        public init (
            grantee: AccessAnalyzerClientTypes.AclGrantee? = nil,
            permission: AccessAnalyzerClientTypes.AclPermission? = nil
        )
        {
            self.grantee = grantee
            self.permission = permission
        }
    }

}

extension AccessAnalyzerClientTypes.S3BucketConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPoints
        case bucketAclGrants
        case bucketPolicy
        case bucketPublicAccessBlock
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPoints = accessPoints {
            var accessPointsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .accessPoints)
            for (dictKey0, s3accesspointconfigurationsmap0) in accessPoints {
                try accessPointsContainer.encode(s3accesspointconfigurationsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let bucketAclGrants = bucketAclGrants {
            var bucketAclGrantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bucketAclGrants)
            for s3bucketaclgrantconfigurationslist0 in bucketAclGrants {
                try bucketAclGrantsContainer.encode(s3bucketaclgrantconfigurationslist0)
            }
        }
        if let bucketPolicy = bucketPolicy {
            try encodeContainer.encode(bucketPolicy, forKey: .bucketPolicy)
        }
        if let bucketPublicAccessBlock = bucketPublicAccessBlock {
            try encodeContainer.encode(bucketPublicAccessBlock, forKey: .bucketPublicAccessBlock)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPolicy)
        bucketPolicy = bucketPolicyDecoded
        let bucketAclGrantsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration?].self, forKey: .bucketAclGrants)
        var bucketAclGrantsDecoded0:[AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration]? = nil
        if let bucketAclGrantsContainer = bucketAclGrantsContainer {
            bucketAclGrantsDecoded0 = [AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration]()
            for structure0 in bucketAclGrantsContainer {
                if let structure0 = structure0 {
                    bucketAclGrantsDecoded0?.append(structure0)
                }
            }
        }
        bucketAclGrants = bucketAclGrantsDecoded0
        let bucketPublicAccessBlockDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration.self, forKey: .bucketPublicAccessBlock)
        bucketPublicAccessBlock = bucketPublicAccessBlockDecoded
        let accessPointsContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.S3AccessPointConfiguration?].self, forKey: .accessPoints)
        var accessPointsDecoded0: [Swift.String:AccessAnalyzerClientTypes.S3AccessPointConfiguration]? = nil
        if let accessPointsContainer = accessPointsContainer {
            accessPointsDecoded0 = [Swift.String:AccessAnalyzerClientTypes.S3AccessPointConfiguration]()
            for (key0, s3accesspointconfiguration0) in accessPointsContainer {
                if let s3accesspointconfiguration0 = s3accesspointconfiguration0 {
                    accessPointsDecoded0?[key0] = s3accesspointconfiguration0
                }
            }
        }
        accessPoints = accessPointsDecoded0
    }
}

extension AccessAnalyzerClientTypes.S3BucketConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3BucketConfiguration(accessPoints: \(Swift.String(describing: accessPoints)), bucketAclGrants: \(Swift.String(describing: bucketAclGrants)), bucketPolicy: \(Swift.String(describing: bucketPolicy)), bucketPublicAccessBlock: \(Swift.String(describing: bucketPublicAccessBlock)))"}
}

extension AccessAnalyzerClientTypes {
    /// Proposed access control configuration for an Amazon S3 bucket. You can propose a
    ///          configuration for a new Amazon S3 bucket or an existing Amazon S3 bucket that you own by specifying
    ///          the Amazon S3 bucket policy, bucket ACLs, bucket BPA settings, Amazon S3 access points, and
    ///          multi-region access points attached to the bucket. If the configuration is for an existing
    ///          Amazon S3 bucket and you do not specify the Amazon S3 bucket policy, the access preview uses the
    ///          existing policy attached to the bucket. If the access preview is for a new resource and you
    ///          do not specify the Amazon S3 bucket policy, the access preview assumes a bucket without a
    ///          policy. To propose deletion of an existing bucket policy, you can specify an empty string.
    ///          For more information about bucket policy limits, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html">Bucket Policy
    ///          Examples.
    public struct S3BucketConfiguration: Swift.Equatable {
        /// The configuration of Amazon S3 access points or multi-region access points for the bucket.
        ///          You can propose up to 10 new access points per bucket.
        public var accessPoints: [Swift.String:AccessAnalyzerClientTypes.S3AccessPointConfiguration]?
        /// The proposed list of ACL grants for the Amazon S3 bucket. You can propose up to 100 ACL
        ///          grants per bucket. If the proposed grant configuration is for an existing bucket, the
        ///          access preview uses the proposed list of grant configurations in place of the existing
        ///          grants. Otherwise, the access preview uses the existing grants for the bucket.
        public var bucketAclGrants: [AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration]?
        /// The proposed bucket policy for the Amazon S3 bucket.
        public var bucketPolicy: Swift.String?
        /// The proposed block public access configuration for the Amazon S3 bucket.
        public var bucketPublicAccessBlock: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration?

        public init (
            accessPoints: [Swift.String:AccessAnalyzerClientTypes.S3AccessPointConfiguration]? = nil,
            bucketAclGrants: [AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration]? = nil,
            bucketPolicy: Swift.String? = nil,
            bucketPublicAccessBlock: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration? = nil
        )
        {
            self.accessPoints = accessPoints
            self.bucketAclGrants = bucketAclGrants
            self.bucketPolicy = bucketPolicy
            self.bucketPublicAccessBlock = bucketPublicAccessBlock
        }
    }

}

extension AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ignorePublicAcls
        case restrictPublicBuckets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ignorePublicAcls = ignorePublicAcls {
            try encodeContainer.encode(ignorePublicAcls, forKey: .ignorePublicAcls)
        }
        if let restrictPublicBuckets = restrictPublicBuckets {
            try encodeContainer.encode(restrictPublicBuckets, forKey: .restrictPublicBuckets)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ignorePublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignorePublicAcls)
        ignorePublicAcls = ignorePublicAclsDecoded
        let restrictPublicBucketsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .restrictPublicBuckets)
        restrictPublicBuckets = restrictPublicBucketsDecoded
    }
}

extension AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3PublicAccessBlockConfiguration(ignorePublicAcls: \(Swift.String(describing: ignorePublicAcls)), restrictPublicBuckets: \(Swift.String(describing: restrictPublicBuckets)))"}
}

extension AccessAnalyzerClientTypes {
    /// The PublicAccessBlock configuration to apply to this Amazon S3 bucket. If the
    ///          proposed configuration is for an existing Amazon S3 bucket and the configuration is not
    ///          specified, the access preview uses the existing setting. If the proposed configuration is
    ///          for a new bucket and the configuration is not specified, the access preview uses
    ///             false. If the proposed configuration is for a new access point or
    ///          multi-region access point and the access point BPA configuration is not specified, the
    ///          access preview uses true. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-publicaccessblockconfiguration.html">PublicAccessBlockConfiguration.
    public struct S3PublicAccessBlockConfiguration: Swift.Equatable {
        ///  Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this
        ///          bucket.
        /// This member is required.
        public var ignorePublicAcls: Swift.Bool?
        ///  Specifies whether Amazon S3 should restrict public bucket policies for this bucket.
        /// This member is required.
        public var restrictPublicBuckets: Swift.Bool?

        public init (
            ignorePublicAcls: Swift.Bool? = nil,
            restrictPublicBuckets: Swift.Bool? = nil
        )
        {
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }

}

extension AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId
        case secretPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let secretPolicy = secretPolicy {
            try encodeContainer.encode(secretPolicy, forKey: .secretPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretPolicy)
        secretPolicy = secretPolicyDecoded
    }
}

extension AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SecretsManagerSecretConfiguration(kmsKeyId: \(Swift.String(describing: kmsKeyId)), secretPolicy: \(Swift.String(describing: secretPolicy)))"}
}

extension AccessAnalyzerClientTypes {
    /// The configuration for a Secrets Manager secret. For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html">CreateSecret.
    ///          You can propose a configuration for a new secret or an existing secret that you own by
    ///          specifying the secret policy and optional KMS encryption key. If the configuration is for
    ///          an existing secret and you do not specify the secret policy, the access preview uses the
    ///          existing policy for the secret. If the access preview is for a new resource and you do not
    ///          specify the policy, the access preview assumes a secret without a policy. To propose
    ///          deletion of an existing policy, you can specify an empty string. If the proposed
    ///          configuration is for a new secret and you do not specify the KMS key ID, the access
    ///          preview uses the default CMK of the Amazon Web Services account. If you specify an empty string for the
    ///          KMS key ID, the access preview uses the default CMK of the Amazon Web Services account. For more
    ///          information about secret policy limits, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_limits.html">Quotas for
    ///             Secrets Manager..
    public struct SecretsManagerSecretConfiguration: Swift.Equatable {
        /// The proposed ARN, key ID, or alias of the KMS customer master key (CMK).
        public var kmsKeyId: Swift.String?
        /// The proposed resource policy defining who can access or manage the secret.
        public var secretPolicy: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            secretPolicy: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.secretPolicy = secretPolicy
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Service quote met error.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The resource ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AccessAnalyzerClientTypes.SortCriteria: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName
        case orderBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let orderBy = orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension AccessAnalyzerClientTypes.SortCriteria: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SortCriteria(attributeName: \(Swift.String(describing: attributeName)), orderBy: \(Swift.String(describing: orderBy)))"}
}

extension AccessAnalyzerClientTypes {
    /// The criteria used to sort.
    public struct SortCriteria: Swift.Equatable {
        /// The name of the attribute to sort on.
        public var attributeName: Swift.String?
        /// The sort order, ascending or descending.
        public var orderBy: AccessAnalyzerClientTypes.OrderBy?

        public init (
            attributeName: Swift.String? = nil,
            orderBy: AccessAnalyzerClientTypes.OrderBy? = nil
        )
        {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }
    }

}

extension AccessAnalyzerClientTypes.Span: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end
        case start
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.Position.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.Position.self, forKey: .end)
        end = endDecoded
    }
}

extension AccessAnalyzerClientTypes.Span: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Span(end: \(Swift.String(describing: end)), start: \(Swift.String(describing: start)))"}
}

extension AccessAnalyzerClientTypes {
    /// A span in a policy. The span consists of a start position (inclusive) and end position
    ///          (exclusive).
    public struct Span: Swift.Equatable {
        /// The end position of the span (exclusive).
        /// This member is required.
        public var end: AccessAnalyzerClientTypes.Position?
        /// The start position of the span (inclusive).
        /// This member is required.
        public var start: AccessAnalyzerClientTypes.Position?

        public init (
            end: AccessAnalyzerClientTypes.Position? = nil,
            start: AccessAnalyzerClientTypes.Position? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension AccessAnalyzerClientTypes.SqsQueueConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queuePolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queuePolicy = queuePolicy {
            try encodeContainer.encode(queuePolicy, forKey: .queuePolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queuePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queuePolicy)
        queuePolicy = queuePolicyDecoded
    }
}

extension AccessAnalyzerClientTypes.SqsQueueConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SqsQueueConfiguration(queuePolicy: \(Swift.String(describing: queuePolicy)))"}
}

extension AccessAnalyzerClientTypes {
    /// The proposed access control configuration for an Amazon SQS queue. You can propose a
    ///          configuration for a new Amazon SQS queue or an existing Amazon SQS queue that you own by specifying
    ///          the Amazon SQS policy. If the configuration is for an existing Amazon SQS queue and you do not
    ///          specify the Amazon SQS policy, the access preview uses the existing Amazon SQS policy for the queue.
    ///          If the access preview is for a new resource and you do not specify the policy, the access
    ///          preview assumes an Amazon SQS queue without a policy. To propose deletion of an existing Amazon SQS
    ///          queue policy, you can specify an empty string for the Amazon SQS policy. For more information
    ///          about Amazon SQS policy limits, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-policies.html">Quotas related
    ///             to policies.
    public struct SqsQueueConfiguration: Swift.Equatable {
        ///  The proposed resource policy for the Amazon SQS queue.
        public var queuePolicy: Swift.String?

        public init (
            queuePolicy: Swift.String? = nil
        )
        {
            self.queuePolicy = queuePolicy
        }
    }

}

public struct StartPolicyGenerationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPolicyGenerationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartPolicyGenerationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPolicyGenerationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartPolicyGenerationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartPolicyGenerationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPolicyGenerationOutputError>
}

extension StartPolicyGenerationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartPolicyGenerationInput(clientToken: \(Swift.String(describing: clientToken)), cloudTrailDetails: \(Swift.String(describing: cloudTrailDetails)), policyGenerationDetails: \(Swift.String(describing: policyGenerationDetails)))"}
}

extension StartPolicyGenerationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case cloudTrailDetails
        case policyGenerationDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let cloudTrailDetails = cloudTrailDetails {
            try encodeContainer.encode(cloudTrailDetails, forKey: .cloudTrailDetails)
        }
        if let policyGenerationDetails = policyGenerationDetails {
            try encodeContainer.encode(policyGenerationDetails, forKey: .policyGenerationDetails)
        }
    }
}

public struct StartPolicyGenerationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPolicyGenerationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartPolicyGenerationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPolicyGenerationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartPolicyGenerationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartPolicyGenerationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPolicyGenerationOutputError>
}

public struct StartPolicyGenerationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPolicyGenerationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartPolicyGenerationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPolicyGenerationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartPolicyGenerationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartPolicyGenerationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPolicyGenerationOutputError>
}

public struct StartPolicyGenerationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPolicyGenerationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartPolicyGenerationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPolicyGenerationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/policy/generation"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartPolicyGenerationInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartPolicyGenerationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPolicyGenerationOutputError>
}

public struct StartPolicyGenerationInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request. Idempotency ensures that an API request completes only once. With an idempotent
    ///          request, if the original request completes successfully, the subsequent retries with the
    ///          same client token return the result from the original successful request and they have no
    ///          additional effect.
    ///          If you do not specify a client token, one is automatically generated by the Amazon Web Services
    ///          SDK.
    public var clientToken: Swift.String?
    /// A CloudTrailDetails object that contains details about a Trail
    ///          that you want to analyze to generate policies.
    public var cloudTrailDetails: AccessAnalyzerClientTypes.CloudTrailDetails?
    /// Contains the ARN of the IAM entity (user or role) for which you are generating a
    ///          policy.
    /// This member is required.
    public var policyGenerationDetails: AccessAnalyzerClientTypes.PolicyGenerationDetails?

    public init (
        clientToken: Swift.String? = nil,
        cloudTrailDetails: AccessAnalyzerClientTypes.CloudTrailDetails? = nil,
        policyGenerationDetails: AccessAnalyzerClientTypes.PolicyGenerationDetails? = nil
    )
    {
        self.clientToken = clientToken
        self.cloudTrailDetails = cloudTrailDetails
        self.policyGenerationDetails = policyGenerationDetails
    }
}

struct StartPolicyGenerationInputBody: Swift.Equatable {
    public let policyGenerationDetails: AccessAnalyzerClientTypes.PolicyGenerationDetails?
    public let cloudTrailDetails: AccessAnalyzerClientTypes.CloudTrailDetails?
    public let clientToken: Swift.String?
}

extension StartPolicyGenerationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case cloudTrailDetails
        case policyGenerationDetails
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyGenerationDetailsDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.PolicyGenerationDetails.self, forKey: .policyGenerationDetails)
        policyGenerationDetails = policyGenerationDetailsDecoded
        let cloudTrailDetailsDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.CloudTrailDetails.self, forKey: .cloudTrailDetails)
        cloudTrailDetails = cloudTrailDetailsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartPolicyGenerationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartPolicyGenerationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartPolicyGenerationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartPolicyGenerationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartPolicyGenerationOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension StartPolicyGenerationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartPolicyGenerationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartPolicyGenerationOutputResponse: Swift.Equatable {
    /// The JobId that is returned by the StartPolicyGeneration
    ///          operation. The JobId can be used with GetGeneratedPolicy to
    ///          retrieve the generated policies or used with CancelPolicyGeneration to cancel
    ///          the policy generation request.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartPolicyGenerationOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StartPolicyGenerationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StartResourceScanInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartResourceScanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartResourceScanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartResourceScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartResourceScanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartResourceScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartResourceScanOutputError>
}

extension StartResourceScanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartResourceScanInput(analyzerArn: \(Swift.String(describing: analyzerArn)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension StartResourceScanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct StartResourceScanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartResourceScanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartResourceScanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartResourceScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartResourceScanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartResourceScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartResourceScanOutputError>
}

public struct StartResourceScanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartResourceScanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartResourceScanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartResourceScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartResourceScanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartResourceScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartResourceScanOutputError>
}

public struct StartResourceScanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartResourceScanInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartResourceScanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartResourceScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/resource/scan"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartResourceScanInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartResourceScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartResourceScanOutputError>
}

/// Starts a scan of the policies applied to the specified resource.
public struct StartResourceScanInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer to use to scan the policies applied to the specified
    ///          resource.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The ARN of the resource to scan.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        analyzerArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.resourceArn = resourceArn
    }
}

struct StartResourceScanInputBody: Swift.Equatable {
    public let analyzerArn: Swift.String?
    public let resourceArn: Swift.String?
}

extension StartResourceScanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension StartResourceScanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartResourceScanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartResourceScanOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartResourceScanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartResourceScanOutputResponse()"}
}

extension StartResourceScanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartResourceScanOutputResponse: Swift.Equatable {

    public init() {}
}

struct StartResourceScanOutputResponseBody: Swift.Equatable {
}

extension StartResourceScanOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AccessAnalyzerClientTypes.StatusReason: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ReasonCode.self, forKey: .code)
        code = codeDecoded
    }
}

extension AccessAnalyzerClientTypes.StatusReason: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StatusReason(code: \(Swift.String(describing: code)))"}
}

extension AccessAnalyzerClientTypes {
    /// Provides more details about the current status of the analyzer. For example, if the
    ///          creation for the analyzer fails, a Failed status is returned. For an analyzer
    ///          with organization as the type, this failure can be due to an issue with creating the
    ///          service-linked roles required in the member accounts of the Amazon Web Services organization.
    public struct StatusReason: Swift.Equatable {
        /// The reason code for the current status of the analyzer.
        /// This member is required.
        public var code: AccessAnalyzerClientTypes.ReasonCode?

        public init (
            code: AccessAnalyzerClientTypes.ReasonCode? = nil
        )
        {
            self.code = code
        }
    }

}

extension AccessAnalyzerClientTypes.Substring: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case length
        case start
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let length = length {
            try encodeContainer.encode(length, forKey: .length)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .start)
        start = startDecoded
        let lengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .length)
        length = lengthDecoded
    }
}

extension AccessAnalyzerClientTypes.Substring: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Substring(length: \(Swift.String(describing: length)), start: \(Swift.String(describing: start)))"}
}

extension AccessAnalyzerClientTypes {
    /// A reference to a substring of a literal string in a JSON document.
    public struct Substring: Swift.Equatable {
        /// The length of the substring.
        /// This member is required.
        public var length: Swift.Int?
        /// The start index of the substring, starting from 0.
        /// This member is required.
        public var start: Swift.Int?

        public init (
            length: Swift.Int? = nil,
            start: Swift.Int? = nil
        )
        {
            self.length = length
            self.start = start
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

/// Adds a tag to the specified resource.
public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to add the tag to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The response to the request.
public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Throttling limit exceeded error.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The seconds to wait to retry.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessAnalyzerClientTypes.Trail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allRegions
        case cloudTrailArn
        case regions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allRegions = allRegions {
            try encodeContainer.encode(allRegions, forKey: .allRegions)
        }
        if let cloudTrailArn = cloudTrailArn {
            try encodeContainer.encode(cloudTrailArn, forKey: .cloudTrailArn)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for regionlist0 in regions {
                try regionsContainer.encode(regionlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudTrailArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudTrailArn)
        cloudTrailArn = cloudTrailArnDecoded
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let allRegionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allRegions)
        allRegions = allRegionsDecoded
    }
}

extension AccessAnalyzerClientTypes.Trail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Trail(allRegions: \(Swift.String(describing: allRegions)), cloudTrailArn: \(Swift.String(describing: cloudTrailArn)), regions: \(Swift.String(describing: regions)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains details about the CloudTrail trail being analyzed to generate a policy.
    public struct Trail: Swift.Equatable {
        /// Possible values are true or false. If set to
        ///          true, IAM Access Analyzer retrieves CloudTrail data from all regions to analyze and
        ///          generate a policy.
        public var allRegions: Swift.Bool?
        /// Specifies the ARN of the trail. The format of a trail ARN is
        ///             arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail.
        /// This member is required.
        public var cloudTrailArn: Swift.String?
        /// A list of regions to get CloudTrail data from and analyze to generate a policy.
        public var regions: [Swift.String]?

        public init (
            allRegions: Swift.Bool? = nil,
            cloudTrailArn: Swift.String? = nil,
            regions: [Swift.String]? = nil
        )
        {
            self.allRegions = allRegions
            self.cloudTrailArn = cloudTrailArn
            self.regions = regions
        }
    }

}

extension AccessAnalyzerClientTypes.TrailProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allRegions
        case cloudTrailArn
        case regions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allRegions = allRegions {
            try encodeContainer.encode(allRegions, forKey: .allRegions)
        }
        if let cloudTrailArn = cloudTrailArn {
            try encodeContainer.encode(cloudTrailArn, forKey: .cloudTrailArn)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for regionlist0 in regions {
                try regionsContainer.encode(regionlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudTrailArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudTrailArn)
        cloudTrailArn = cloudTrailArnDecoded
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let allRegionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allRegions)
        allRegions = allRegionsDecoded
    }
}

extension AccessAnalyzerClientTypes.TrailProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrailProperties(allRegions: \(Swift.String(describing: allRegions)), cloudTrailArn: \(Swift.String(describing: cloudTrailArn)), regions: \(Swift.String(describing: regions)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains details about the CloudTrail trail being analyzed to generate a policy.
    public struct TrailProperties: Swift.Equatable {
        /// Possible values are true or false. If set to
        ///          true, IAM Access Analyzer retrieves CloudTrail data from all regions to analyze and
        ///          generate a policy.
        public var allRegions: Swift.Bool?
        /// Specifies the ARN of the trail. The format of a trail ARN is
        ///             arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail.
        /// This member is required.
        public var cloudTrailArn: Swift.String?
        /// A list of regions to get CloudTrail data from and analyze to generate a policy.
        public var regions: [Swift.String]?

        public init (
            allRegions: Swift.Bool? = nil,
            cloudTrailArn: Swift.String? = nil,
            regions: [Swift.String]? = nil
        )
        {
            self.allRegions = allRegions
            self.cloudTrailArn = cloudTrailArn
            self.regions = regions
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case organization
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .account,
                .organization,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .organization: return "ORGANIZATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

/// Removes a tag from the specified resource.
public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to remove the tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key for the tag to add.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The response to the request.
public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateArchiveRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateArchiveRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateArchiveRuleOutputError>
}

extension UpdateArchiveRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateArchiveRuleInput(analyzerName: \(Swift.String(describing: analyzerName)), clientToken: \(Swift.String(describing: clientToken)), filter: \(Swift.String(describing: filter)), ruleName: \(Swift.String(describing: ruleName)))"}
}

extension UpdateArchiveRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, filtercriteriamap0) in filter {
                try filterContainer.encode(filtercriteriamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateArchiveRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateArchiveRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateArchiveRuleOutputError>
}

public struct UpdateArchiveRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateArchiveRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateArchiveRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateArchiveRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateArchiveRuleOutputError>
}

public struct UpdateArchiveRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateArchiveRuleInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateArchiveRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let analyzerName = input.analyzerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("analyzerName is nil and needs a value for the path of this operation"))))
        }
        guard let ruleName = input.ruleName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("ruleName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule/\(ruleName.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateArchiveRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateArchiveRuleOutputError>
}

/// Updates the specified archive rule.
public struct UpdateArchiveRuleInput: Swift.Equatable {
    /// The name of the analyzer to update the archive rules for.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// A filter to match for the rules to update. Only rules that match the filter are
    ///          updated.
    /// This member is required.
    public var filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    /// The name of the rule to update.
    /// This member is required.
    public var ruleName: Swift.String?

    public init (
        analyzerName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
        self.filter = filter
        self.ruleName = ruleName
    }
}

struct UpdateArchiveRuleInputBody: Swift.Equatable {
    public let filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    public let clientToken: Swift.String?
}

extension UpdateArchiveRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case filter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Criterion?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateArchiveRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateArchiveRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateArchiveRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateArchiveRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateArchiveRuleOutputResponse()"}
}

extension UpdateArchiveRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateArchiveRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateArchiveRuleOutputResponseBody: Swift.Equatable {
}

extension UpdateArchiveRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateFindingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFindingsOutputError>
}

extension UpdateFindingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFindingsInput(analyzerArn: \(Swift.String(describing: analyzerArn)), clientToken: \(Swift.String(describing: clientToken)), ids: \(Swift.String(describing: ids)), resourceArn: \(Swift.String(describing: resourceArn)), status: \(Swift.String(describing: status)))"}
}

extension UpdateFindingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case clientToken
        case ids
        case resourceArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for findingidlist0 in ids {
                try idsContainer.encode(findingidlist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateFindingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFindingsOutputError>
}

public struct UpdateFindingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFindingsOutputError>
}

public struct UpdateFindingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFindingsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateFindingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/finding"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFindingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFindingsOutputError>
}

/// Updates findings with the new values provided in the request.
public struct UpdateFindingsInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer that generated the findings to update.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// The IDs of the findings to update.
    public var ids: [Swift.String]?
    /// The ARN of the resource identified in the finding.
    public var resourceArn: Swift.String?
    /// The state represents the action to take to update the finding Status. Use
    ///             ARCHIVE to change an Active finding to an Archived finding. Use
    ///             ACTIVE to change an Archived finding to an Active finding.
    /// This member is required.
    public var status: AccessAnalyzerClientTypes.FindingStatusUpdate?

    public init (
        analyzerArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ids: [Swift.String]? = nil,
        resourceArn: Swift.String? = nil,
        status: AccessAnalyzerClientTypes.FindingStatusUpdate? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.clientToken = clientToken
        self.ids = ids
        self.resourceArn = resourceArn
        self.status = status
    }
}

struct UpdateFindingsInputBody: Swift.Equatable {
    public let analyzerArn: Swift.String?
    public let status: AccessAnalyzerClientTypes.FindingStatusUpdate?
    public let ids: [Swift.String]?
    public let resourceArn: Swift.String?
    public let clientToken: Swift.String?
}

extension UpdateFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case clientToken
        case ids
        case resourceArn
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingStatusUpdate.self, forKey: .status)
        status = statusDecoded
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFindingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFindingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFindingsOutputResponse()"}
}

extension UpdateFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFindingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateFindingsOutputResponseBody: Swift.Equatable {
}

extension UpdateFindingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AccessAnalyzerClientTypes.ValidatePolicyFinding: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingDetails
        case findingType
        case issueCode
        case learnMoreLink
        case locations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingDetails = findingDetails {
            try encodeContainer.encode(findingDetails, forKey: .findingDetails)
        }
        if let findingType = findingType {
            try encodeContainer.encode(findingType.rawValue, forKey: .findingType)
        }
        if let issueCode = issueCode {
            try encodeContainer.encode(issueCode, forKey: .issueCode)
        }
        if let learnMoreLink = learnMoreLink {
            try encodeContainer.encode(learnMoreLink, forKey: .learnMoreLink)
        }
        if let locations = locations {
            var locationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .locations)
            for locationlist0 in locations {
                try locationsContainer.encode(locationlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingDetails)
        findingDetails = findingDetailsDecoded
        let findingTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ValidatePolicyFindingType.self, forKey: .findingType)
        findingType = findingTypeDecoded
        let issueCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issueCode)
        issueCode = issueCodeDecoded
        let learnMoreLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .learnMoreLink)
        learnMoreLink = learnMoreLinkDecoded
        let locationsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.Location?].self, forKey: .locations)
        var locationsDecoded0:[AccessAnalyzerClientTypes.Location]? = nil
        if let locationsContainer = locationsContainer {
            locationsDecoded0 = [AccessAnalyzerClientTypes.Location]()
            for structure0 in locationsContainer {
                if let structure0 = structure0 {
                    locationsDecoded0?.append(structure0)
                }
            }
        }
        locations = locationsDecoded0
    }
}

extension AccessAnalyzerClientTypes.ValidatePolicyFinding: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidatePolicyFinding(findingDetails: \(Swift.String(describing: findingDetails)), findingType: \(Swift.String(describing: findingType)), issueCode: \(Swift.String(describing: issueCode)), learnMoreLink: \(Swift.String(describing: learnMoreLink)), locations: \(Swift.String(describing: locations)))"}
}

extension AccessAnalyzerClientTypes {
    /// A finding in a policy. Each finding is an actionable recommendation that can be used to
    ///          improve the policy.
    public struct ValidatePolicyFinding: Swift.Equatable {
        /// A localized message that explains the finding and provides guidance on how to address
        ///          it.
        /// This member is required.
        public var findingDetails: Swift.String?
        /// The impact of the finding.
        ///          Security warnings report when the policy allows access that we consider overly
        ///          permissive.
        ///          Errors report when a part of the policy is not functional.
        ///          Warnings report non-security issues when a policy does not conform to policy writing
        ///          best practices.
        ///          Suggestions recommend stylistic improvements in the policy that do not impact
        ///          access.
        /// This member is required.
        public var findingType: AccessAnalyzerClientTypes.ValidatePolicyFindingType?
        /// The issue code provides an identifier of the issue associated with this finding.
        /// This member is required.
        public var issueCode: Swift.String?
        /// A link to additional documentation about the type of finding.
        /// This member is required.
        public var learnMoreLink: Swift.String?
        /// The list of locations in the policy document that are related to the finding. The issue
        ///          code provides a summary of an issue identified by the finding.
        /// This member is required.
        public var locations: [AccessAnalyzerClientTypes.Location]?

        public init (
            findingDetails: Swift.String? = nil,
            findingType: AccessAnalyzerClientTypes.ValidatePolicyFindingType? = nil,
            issueCode: Swift.String? = nil,
            learnMoreLink: Swift.String? = nil,
            locations: [AccessAnalyzerClientTypes.Location]? = nil
        )
        {
            self.findingDetails = findingDetails
            self.findingType = findingType
            self.issueCode = issueCode
            self.learnMoreLink = learnMoreLink
            self.locations = locations
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum ValidatePolicyFindingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case securityWarning
        case suggestion
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidatePolicyFindingType] {
            return [
                .error,
                .securityWarning,
                .suggestion,
                .warning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .securityWarning: return "SECURITY_WARNING"
            case .suggestion: return "SUGGESTION"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidatePolicyFindingType(rawValue: rawValue) ?? ValidatePolicyFindingType.sdkUnknown(rawValue)
        }
    }
}

public struct ValidatePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidatePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidatePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidatePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidatePolicyOutputError>
}

extension ValidatePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidatePolicyInput(locale: \(Swift.String(describing: locale)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), policyDocument: \(Swift.String(describing: policyDocument)), policyType: \(Swift.String(describing: policyType)))"}
}

extension ValidatePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case policyDocument
        case policyType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyType = policyType {
            try encodeContainer.encode(policyType.rawValue, forKey: .policyType)
        }
    }
}

public struct ValidatePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidatePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidatePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidatePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidatePolicyOutputError>
}

public struct ValidatePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidatePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidatePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidatePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidatePolicyOutputError>
}

public struct ValidatePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidatePolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ValidatePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/policy/validation"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ValidatePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<ValidatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidatePolicyOutputError>
}

public struct ValidatePolicyInput: Swift.Equatable {
    /// The locale to use for localizing the findings.
    public var locale: AccessAnalyzerClientTypes.Locale?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The JSON policy document to use as the content for the policy.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The type of policy to validate. Identity policies grant permissions to IAM principals.
    ///          Identity policies include managed and inline policies for IAM roles, users, and groups.
    ///          They also include service-control policies (SCPs) that are attached to an Amazon Web Services
    ///          organization, organizational unit (OU), or an account.
    ///          Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust
    ///          policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic
    ///          input such as identity policy or resource policy or a specific input such as managed policy
    ///          or Amazon S3 bucket policy.
    /// This member is required.
    public var policyType: AccessAnalyzerClientTypes.PolicyType?

    public init (
        locale: AccessAnalyzerClientTypes.Locale? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyType: AccessAnalyzerClientTypes.PolicyType? = nil
    )
    {
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyDocument = policyDocument
        self.policyType = policyType
    }
}

struct ValidatePolicyInputBody: Swift.Equatable {
    public let locale: AccessAnalyzerClientTypes.Locale?
    public let policyDocument: Swift.String?
    public let policyType: AccessAnalyzerClientTypes.PolicyType?
}

extension ValidatePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case policyDocument
        case policyType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.PolicyType.self, forKey: .policyType)
        policyType = policyTypeDecoded
    }
}

extension ValidatePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidatePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidatePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidatePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidatePolicyOutputResponse(findings: \(Swift.String(describing: findings)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ValidatePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidatePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct ValidatePolicyOutputResponse: Swift.Equatable {
    /// The list of findings in a policy returned by IAM Access Analyzer based on its suite of policy
    ///          checks.
    /// This member is required.
    public var findings: [AccessAnalyzerClientTypes.ValidatePolicyFinding]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        findings: [AccessAnalyzerClientTypes.ValidatePolicyFinding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ValidatePolicyOutputResponseBody: Swift.Equatable {
    public let findings: [AccessAnalyzerClientTypes.ValidatePolicyFinding]?
    public let nextToken: Swift.String?
}

extension ValidatePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.ValidatePolicyFinding?].self, forKey: .findings)
        var findingsDecoded0:[AccessAnalyzerClientTypes.ValidatePolicyFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [AccessAnalyzerClientTypes.ValidatePolicyFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(fieldList: \(Swift.String(describing: fieldList)), message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Validation exception error.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A list of fields that didn't validate.
    public var fieldList: [AccessAnalyzerClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason for the exception.
    /// This member is required.
    public var reason: AccessAnalyzerClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [AccessAnalyzerClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AccessAnalyzerClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: AccessAnalyzerClientTypes.ValidationExceptionReason?
    public let fieldList: [AccessAnalyzerClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[AccessAnalyzerClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [AccessAnalyzerClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension AccessAnalyzerClientTypes.ValidationExceptionField: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessAnalyzerClientTypes.ValidationExceptionField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationExceptionField(message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)))"}
}

extension AccessAnalyzerClientTypes {
    /// Contains information about a validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.VpcConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension AccessAnalyzerClientTypes.VpcConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcConfiguration(vpcId: \(Swift.String(describing: vpcId)))"}
}

extension AccessAnalyzerClientTypes {
    /// The proposed virtual private cloud (VPC) configuration for the Amazon S3 access point. VPC
    ///          configuration does not apply to multi-region access points. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_VpcConfiguration.html">VpcConfiguration.
    public struct VpcConfiguration: Swift.Equatable {
        ///  If this field is specified, this access point will only allow connections from the
        ///          specified VPC ID.
        /// This member is required.
        public var vpcId: Swift.String?

        public init (
            vpcId: Swift.String? = nil
        )
        {
            self.vpcId = vpcId
        }
    }

}
