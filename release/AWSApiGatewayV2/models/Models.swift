// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiGatewayV2ClientTypes.AccessLogSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationArn = "destinationArn"
        case format = "format"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Settings for logging access in a stage.
    public struct AccessLogSettings: Swift.Equatable {
        /// The ARN of the CloudWatch Logs log group to receive access logs.
        public var destinationArn: Swift.String?
        /// A single line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.
        public var format: Swift.String?

        public init (
            destinationArn: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.destinationArn = destinationArn
            self.format = format
        }
    }

}

extension ApiGatewayV2ClientTypes.Api: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiEndpoint = apiEndpoint {
            try encodeContainer.encode(apiEndpoint, forKey: .apiEndpoint)
        }
        if let apiGatewayManaged = apiGatewayManaged {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiKeySelectionExpression = apiKeySelectionExpression {
            try encodeContainer.encode(apiKeySelectionExpression, forKey: .apiKeySelectionExpression)
        }
        if let corsConfiguration = corsConfiguration {
            try encodeContainer.encode(corsConfiguration, forKey: .corsConfiguration)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disableExecuteApiEndpoint = disableExecuteApiEndpoint {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if let disableSchemaValidation = disableSchemaValidation {
            try encodeContainer.encode(disableSchemaValidation, forKey: .disableSchemaValidation)
        }
        if let importInfo = importInfo {
            var importInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .importInfo)
            for __listof__string0 in importInfo {
                try importInfoContainer.encode(__listof__string0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protocolType = protocolType {
            try encodeContainer.encode(protocolType.rawValue, forKey: .protocolType)
        }
        if let routeSelectionExpression = routeSelectionExpression {
            try encodeContainer.encode(routeSelectionExpression, forKey: .routeSelectionExpression)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let warnings = warnings {
            var warningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .warnings)
            for __listof__string0 in warnings {
                try warningsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importInfo)
        var importInfoDecoded0:[Swift.String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [Swift.String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an API.
    public struct Api: Swift.Equatable {
        /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
        public var apiEndpoint: Swift.String?
        /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
        public var apiGatewayManaged: Swift.Bool?
        /// The API ID.
        public var apiId: Swift.String?
        /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
        public var apiKeySelectionExpression: Swift.String?
        /// A CORS configuration. Supported only for HTTP APIs.
        public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
        /// The timestamp when the API was created.
        public var createdDate: ClientRuntime.Date?
        /// The description of the API.
        public var description: Swift.String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public var disableExecuteApiEndpoint: Swift.Bool?
        /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
        public var disableSchemaValidation: Swift.Bool?
        /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
        public var importInfo: [Swift.String]?
        /// The name of the API.
        /// This member is required.
        public var name: Swift.String?
        /// The API protocol.
        /// This member is required.
        public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
        /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
        /// This member is required.
        public var routeSelectionExpression: Swift.String?
        /// A collection of tags associated with the API.
        public var tags: [Swift.String:Swift.String]?
        /// A version identifier for the API.
        public var version: Swift.String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public var warnings: [Swift.String]?

        public init (
            apiEndpoint: Swift.String? = nil,
            apiGatewayManaged: Swift.Bool? = nil,
            apiId: Swift.String? = nil,
            apiKeySelectionExpression: Swift.String? = nil,
            corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            disableExecuteApiEndpoint: Swift.Bool? = nil,
            disableSchemaValidation: Swift.Bool? = nil,
            importInfo: [Swift.String]? = nil,
            name: Swift.String? = nil,
            protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
            routeSelectionExpression: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            version: Swift.String? = nil,
            warnings: [Swift.String]? = nil
        )
        {
            self.apiEndpoint = apiEndpoint
            self.apiGatewayManaged = apiGatewayManaged
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.disableSchemaValidation = disableSchemaValidation
            self.importInfo = importInfo
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }
    }

}

extension ApiGatewayV2ClientTypes.ApiMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingId = "apiMappingId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiMappingId = apiMappingId {
            try encodeContainer.encode(apiMappingId, forKey: .apiMappingId)
        }
        if let apiMappingKey = apiMappingKey {
            try encodeContainer.encode(apiMappingKey, forKey: .apiMappingKey)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingId)
        apiMappingId = apiMappingIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an API mapping.
    public struct ApiMapping: Swift.Equatable {
        /// The API identifier.
        /// This member is required.
        public var apiId: Swift.String?
        /// The API mapping identifier.
        public var apiMappingId: Swift.String?
        /// The API mapping key.
        public var apiMappingKey: Swift.String?
        /// The API stage.
        /// This member is required.
        public var stage: Swift.String?

        public init (
            apiId: Swift.String? = nil,
            apiMappingId: Swift.String? = nil,
            apiMappingKey: Swift.String? = nil,
            stage: Swift.String? = nil
        )
        {
            self.apiId = apiId
            self.apiMappingId = apiMappingId
            self.apiMappingKey = apiMappingKey
            self.stage = stage
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// The authorization type. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer. For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public enum AuthorizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsIam
        case custom
        case jwt
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationType] {
            return [
                .awsIam,
                .custom,
                .jwt,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case .custom: return "CUSTOM"
            case .jwt: return "JWT"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizationType(rawValue: rawValue) ?? AuthorizationType.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes.Authorizer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerId = "authorizerId"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerCredentialsArn = authorizerCredentialsArn {
            try encodeContainer.encode(authorizerCredentialsArn, forKey: .authorizerCredentialsArn)
        }
        if let authorizerId = authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let authorizerPayloadFormatVersion = authorizerPayloadFormatVersion {
            try encodeContainer.encode(authorizerPayloadFormatVersion, forKey: .authorizerPayloadFormatVersion)
        }
        if let authorizerResultTtlInSeconds = authorizerResultTtlInSeconds {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerType = authorizerType {
            try encodeContainer.encode(authorizerType.rawValue, forKey: .authorizerType)
        }
        if let authorizerUri = authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let enableSimpleResponses = enableSimpleResponses {
            try encodeContainer.encode(enableSimpleResponses, forKey: .enableSimpleResponses)
        }
        if let identitySource = identitySource {
            var identitySourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identitySource)
            for identitysourcelist0 in identitySource {
                try identitySourceContainer.encode(identitysourcelist0)
            }
        }
        if let identityValidationExpression = identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let jwtConfiguration = jwtConfiguration {
            try encodeContainer.encode(jwtConfiguration, forKey: .jwtConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[Swift.String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [Swift.String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an authorizer.
    public struct Authorizer: Swift.Equatable {
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
        public var authorizerCredentialsArn: Swift.String?
        /// The authorizer identifier.
        public var authorizerId: Swift.String?
        /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
        public var authorizerPayloadFormatVersion: Swift.String?
        /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
        public var authorizerResultTtlInSeconds: Swift.Int?
        /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
        public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
        /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
        public var authorizerUri: Swift.String?
        /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
        public var enableSimpleResponses: Swift.Bool?
        /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
        public var identitySource: [Swift.String]?
        /// The validation expression does not apply to the REQUEST authorizer.
        public var identityValidationExpression: Swift.String?
        /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
        public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
        /// The name of the authorizer.
        /// This member is required.
        public var name: Swift.String?

        public init (
            authorizerCredentialsArn: Swift.String? = nil,
            authorizerId: Swift.String? = nil,
            authorizerPayloadFormatVersion: Swift.String? = nil,
            authorizerResultTtlInSeconds: Swift.Int? = nil,
            authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
            authorizerUri: Swift.String? = nil,
            enableSimpleResponses: Swift.Bool? = nil,
            identitySource: [Swift.String]? = nil,
            identityValidationExpression: Swift.String? = nil,
            jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
            name: Swift.String? = nil
        )
        {
            self.authorizerCredentialsArn = authorizerCredentialsArn
            self.authorizerId = authorizerId
            self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerType = authorizerType
            self.authorizerUri = authorizerUri
            self.enableSimpleResponses = enableSimpleResponses
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.jwtConfiguration = jwtConfiguration
            self.name = name
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public enum AuthorizerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jwt
        case request
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizerType] {
            return [
                .jwt,
                .request,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jwt: return "JWT"
            case .request: return "REQUEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizerType(rawValue: rawValue) ?? AuthorizerType.sdkUnknown(rawValue)
        }
    }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is not valid, for example, the input is incomplete or incorrect. See the accompanying error message for details.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Describes the error encountered.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Describes the error encountered.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a connection type.
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internet
        case vpcLink
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .internet,
                .vpcLink,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internet: return "INTERNET"
            case .vpcLink: return "VPC_LINK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// Specifies how to handle response payload content type conversions. Supported only for WebSocket APIs.
    public enum ContentHandlingStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case convertToBinary
        case convertToText
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentHandlingStrategy] {
            return [
                .convertToBinary,
                .convertToText,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .convertToBinary: return "CONVERT_TO_BINARY"
            case .convertToText: return "CONVERT_TO_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentHandlingStrategy(rawValue: rawValue) ?? ContentHandlingStrategy.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes.Cors: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCredentials = "allowCredentials"
        case allowHeaders = "allowHeaders"
        case allowMethods = "allowMethods"
        case allowOrigins = "allowOrigins"
        case exposeHeaders = "exposeHeaders"
        case maxAge = "maxAge"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowCredentials = allowCredentials {
            try encodeContainer.encode(allowCredentials, forKey: .allowCredentials)
        }
        if let allowHeaders = allowHeaders {
            var allowHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowHeaders)
            for corsheaderlist0 in allowHeaders {
                try allowHeadersContainer.encode(corsheaderlist0)
            }
        }
        if let allowMethods = allowMethods {
            var allowMethodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowMethods)
            for corsmethodlist0 in allowMethods {
                try allowMethodsContainer.encode(corsmethodlist0)
            }
        }
        if let allowOrigins = allowOrigins {
            var allowOriginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowOrigins)
            for corsoriginlist0 in allowOrigins {
                try allowOriginsContainer.encode(corsoriginlist0)
            }
        }
        if let exposeHeaders = exposeHeaders {
            var exposeHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exposeHeaders)
            for corsheaderlist0 in exposeHeaders {
                try exposeHeadersContainer.encode(corsheaderlist0)
            }
        }
        if let maxAge = maxAge {
            try encodeContainer.encode(maxAge, forKey: .maxAge)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowCredentialsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowCredentials)
        allowCredentials = allowCredentialsDecoded
        let allowHeadersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowHeaders)
        var allowHeadersDecoded0:[Swift.String]? = nil
        if let allowHeadersContainer = allowHeadersContainer {
            allowHeadersDecoded0 = [Swift.String]()
            for string0 in allowHeadersContainer {
                if let string0 = string0 {
                    allowHeadersDecoded0?.append(string0)
                }
            }
        }
        allowHeaders = allowHeadersDecoded0
        let allowMethodsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowMethods)
        var allowMethodsDecoded0:[Swift.String]? = nil
        if let allowMethodsContainer = allowMethodsContainer {
            allowMethodsDecoded0 = [Swift.String]()
            for string0 in allowMethodsContainer {
                if let string0 = string0 {
                    allowMethodsDecoded0?.append(string0)
                }
            }
        }
        allowMethods = allowMethodsDecoded0
        let allowOriginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowOrigins)
        var allowOriginsDecoded0:[Swift.String]? = nil
        if let allowOriginsContainer = allowOriginsContainer {
            allowOriginsDecoded0 = [Swift.String]()
            for string0 in allowOriginsContainer {
                if let string0 = string0 {
                    allowOriginsDecoded0?.append(string0)
                }
            }
        }
        allowOrigins = allowOriginsDecoded0
        let exposeHeadersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exposeHeaders)
        var exposeHeadersDecoded0:[Swift.String]? = nil
        if let exposeHeadersContainer = exposeHeadersContainer {
            exposeHeadersDecoded0 = [Swift.String]()
            for string0 in exposeHeadersContainer {
                if let string0 = string0 {
                    exposeHeadersDecoded0?.append(string0)
                }
            }
        }
        exposeHeaders = exposeHeadersDecoded0
        let maxAgeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAge)
        maxAge = maxAgeDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a CORS configuration. Supported only for HTTP APIs. See [Configuring CORS](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html) for more information.
    public struct Cors: Swift.Equatable {
        /// Specifies whether credentials are included in the CORS request. Supported only for HTTP APIs.
        public var allowCredentials: Swift.Bool?
        /// Represents a collection of allowed headers. Supported only for HTTP APIs.
        public var allowHeaders: [Swift.String]?
        /// Represents a collection of allowed HTTP methods. Supported only for HTTP APIs.
        public var allowMethods: [Swift.String]?
        /// Represents a collection of allowed origins. Supported only for HTTP APIs.
        public var allowOrigins: [Swift.String]?
        /// Represents a collection of exposed headers. Supported only for HTTP APIs.
        public var exposeHeaders: [Swift.String]?
        /// The number of seconds that the browser should cache preflight request results. Supported only for HTTP APIs.
        public var maxAge: Swift.Int?

        public init (
            allowCredentials: Swift.Bool? = nil,
            allowHeaders: [Swift.String]? = nil,
            allowMethods: [Swift.String]? = nil,
            allowOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            maxAge: Swift.Int? = nil
        )
        {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }
    }

}

extension CreateApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case name = "name"
        case protocolType = "protocolType"
        case routeKey = "routeKey"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case target = "target"
        case version = "version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySelectionExpression = apiKeySelectionExpression {
            try encodeContainer.encode(apiKeySelectionExpression, forKey: .apiKeySelectionExpression)
        }
        if let corsConfiguration = corsConfiguration {
            try encodeContainer.encode(corsConfiguration, forKey: .corsConfiguration)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disableExecuteApiEndpoint = disableExecuteApiEndpoint {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if let disableSchemaValidation = disableSchemaValidation {
            try encodeContainer.encode(disableSchemaValidation, forKey: .disableSchemaValidation)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protocolType = protocolType {
            try encodeContainer.encode(protocolType.rawValue, forKey: .protocolType)
        }
        if let routeKey = routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeSelectionExpression = routeSelectionExpression {
            try encodeContainer.encode(routeSelectionExpression, forKey: .routeSelectionExpression)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension CreateApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/apis"
    }
}

/// Creates a new Api resource to represent an API.
public struct CreateApiInput: Swift.Equatable {
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs. See [Configuring CORS](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html) for more information.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null. Currently, this property is not used for HTTP integrations. Supported only for HTTP APIs.
    public var credentialsArn: Swift.String?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The name of the API.
    /// This member is required.
    public var name: Swift.String?
    /// The API protocol.
    /// This member is required.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// This property is part of quick create. If you don't specify a routeKey, a default route of $default is created. The $default route acts as a catch-all for any request made to your API, for a particular stage. The $default route key can't be modified. You can add routes after creating the API, and you can update the route keys of additional routes. Supported only for HTTP APIs.
    public var routeKey: Swift.String?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// This property is part of quick create. Quick create produces an API with an integration, a default catch-all route, and a default stage which is configured to automatically deploy changes. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. Supported only for HTTP APIs.
    public var target: Swift.String?
    /// A version identifier for the API.
    public var version: Swift.String?

    public init (
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeKey: Swift.String? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        target: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.credentialsArn = credentialsArn
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.name = name
        self.protocolType = protocolType
        self.routeKey = routeKey
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.target = target
        self.version = version
    }
}

struct CreateApiInputBody: Swift.Equatable {
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let name: Swift.String?
    let protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    let routeKey: Swift.String?
    let routeSelectionExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let target: Swift.String?
    let version: Swift.String?
}

extension CreateApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case name = "name"
        case protocolType = "protocolType"
        case routeKey = "routeKey"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case target = "target"
        case version = "version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CreateApiMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiMappingKey = apiMappingKey {
            try encodeContainer.encode(apiMappingKey, forKey: .apiMappingKey)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }
}

extension CreateApiMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings"
    }
}

/// Creates a new ApiMapping resource to represent an API mapping.
public struct CreateApiMappingInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The API stage.
    /// This member is required.
    public var stage: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        domainName: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingKey = apiMappingKey
        self.domainName = domainName
        self.stage = stage
    }
}

struct CreateApiMappingInputBody: Swift.Equatable {
    let apiId: Swift.String?
    let apiMappingKey: Swift.String?
    let stage: Swift.String?
}

extension CreateApiMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension CreateApiMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiMappingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApiMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiId = output.apiId
            self.apiMappingId = output.apiMappingId
            self.apiMappingKey = output.apiMappingKey
            self.stage = output.stage
        } else {
            self.apiId = nil
            self.apiMappingId = nil
            self.apiMappingKey = nil
            self.stage = nil
        }
    }
}

public struct CreateApiMappingOutputResponse: Swift.Equatable {
    /// The API identifier.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

struct CreateApiMappingOutputResponseBody: Swift.Equatable {
    let apiId: Swift.String?
    let apiMappingId: Swift.String?
    let apiMappingKey: Swift.String?
    let stage: Swift.String?
}

extension CreateApiMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingId = "apiMappingId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingId)
        apiMappingId = apiMappingIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension CreateApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = nil
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = nil
            self.disableSchemaValidation = nil
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct CreateApiOutputResponse: Swift.Equatable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init (
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct CreateApiOutputResponseBody: Swift.Equatable {
    let apiEndpoint: Swift.String?
    let apiGatewayManaged: Swift.Bool?
    let apiId: Swift.String?
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let importInfo: [Swift.String]?
    let name: Swift.String?
    let protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    let routeSelectionExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let version: Swift.String?
    let warnings: [Swift.String]?
}

extension CreateApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importInfo)
        var importInfoDecoded0:[Swift.String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [Swift.String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension CreateAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerCredentialsArn = authorizerCredentialsArn {
            try encodeContainer.encode(authorizerCredentialsArn, forKey: .authorizerCredentialsArn)
        }
        if let authorizerPayloadFormatVersion = authorizerPayloadFormatVersion {
            try encodeContainer.encode(authorizerPayloadFormatVersion, forKey: .authorizerPayloadFormatVersion)
        }
        if let authorizerResultTtlInSeconds = authorizerResultTtlInSeconds {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerType = authorizerType {
            try encodeContainer.encode(authorizerType.rawValue, forKey: .authorizerType)
        }
        if let authorizerUri = authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let enableSimpleResponses = enableSimpleResponses {
            try encodeContainer.encode(enableSimpleResponses, forKey: .enableSimpleResponses)
        }
        if let identitySource = identitySource {
            var identitySourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identitySource)
            for identitysourcelist0 in identitySource {
                try identitySourceContainer.encode(identitysourcelist0)
            }
        }
        if let identityValidationExpression = identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let jwtConfiguration = jwtConfiguration {
            try encodeContainer.encode(jwtConfiguration, forKey: .jwtConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers"
    }
}

/// Creates a new Authorizer resource to represent an authorizer.
public struct CreateAuthorizerInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    /// This member is required.
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    /// This member is required.
    public var identitySource: [Swift.String]?
    /// This parameter is not used.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    /// This member is required.
    public var name: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct CreateAuthorizerInputBody: Swift.Equatable {
    let authorizerCredentialsArn: Swift.String?
    let authorizerPayloadFormatVersion: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
    let authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    let authorizerUri: Swift.String?
    let enableSimpleResponses: Swift.Bool?
    let identitySource: [Swift.String]?
    let identityValidationExpression: Swift.String?
    let jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    let name: Swift.String?
}

extension CreateAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[Swift.String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [Swift.String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateAuthorizerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAuthorizerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAuthorizerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAuthorizerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorizerCredentialsArn = output.authorizerCredentialsArn
            self.authorizerId = output.authorizerId
            self.authorizerPayloadFormatVersion = output.authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerType = output.authorizerType
            self.authorizerUri = output.authorizerUri
            self.enableSimpleResponses = output.enableSimpleResponses
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.jwtConfiguration = output.jwtConfiguration
            self.name = output.name
        } else {
            self.authorizerCredentialsArn = nil
            self.authorizerId = nil
            self.authorizerPayloadFormatVersion = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerType = nil
            self.authorizerUri = nil
            self.enableSimpleResponses = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.jwtConfiguration = nil
            self.name = nil
        }
    }
}

public struct CreateAuthorizerOutputResponse: Swift.Equatable {
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init (
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct CreateAuthorizerOutputResponseBody: Swift.Equatable {
    let authorizerCredentialsArn: Swift.String?
    let authorizerId: Swift.String?
    let authorizerPayloadFormatVersion: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
    let authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    let authorizerUri: Swift.String?
    let enableSimpleResponses: Swift.Bool?
    let identitySource: [Swift.String]?
    let identityValidationExpression: Swift.String?
    let jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    let name: Swift.String?
}

extension CreateAuthorizerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerId = "authorizerId"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[Swift.String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [Swift.String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case stageName = "stageName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }
}

extension CreateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments"
    }
}

/// Creates a new Deployment resource to represent a deployment.
public struct CreateDeploymentInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The name of the Stage resource for the Deployment resource to create.
    public var stageName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.stageName = stageName
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    let description: Swift.String?
    let stageName: Swift.String?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case stageName = "stageName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
    }
}

extension CreateDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoDeployed = output.autoDeployed
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.deploymentStatus = output.deploymentStatus
            self.deploymentStatusMessage = output.deploymentStatusMessage
            self.description = output.description
        } else {
            self.autoDeployed = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.deploymentStatus = nil
            self.deploymentStatusMessage = nil
            self.description = nil
        }
    }
}

public struct CreateDeploymentOutputResponse: Swift.Equatable {
    /// Specifies whether a deployment was automatically released.
    public var autoDeployed: Swift.Bool?
    /// The date and time when the Deployment resource was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier for the deployment.
    public var deploymentId: Swift.String?
    /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
    public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    /// May contain additional feedback on the status of an API deployment.
    public var deploymentStatusMessage: Swift.String?
    /// The description for the deployment.
    public var description: Swift.String?

    public init (
        autoDeployed: Swift.Bool? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
        deploymentStatusMessage: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

struct CreateDeploymentOutputResponseBody: Swift.Equatable {
    let autoDeployed: Swift.Bool?
    let createdDate: ClientRuntime.Date?
    let deploymentId: Swift.String?
    let deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    let deploymentStatusMessage: Swift.String?
    let description: Swift.String?
}

extension CreateDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoDeployed = "autoDeployed"
        case createdDate = "createdDate"
        case deploymentId = "deploymentId"
        case deploymentStatus = "deploymentStatus"
        case deploymentStatusMessage = "deploymentStatusMessage"
        case description = "description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoDeployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeployed)
        autoDeployed = autoDeployedDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateDomainNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainNameConfigurations = domainNameConfigurations {
            var domainNameConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainNameConfigurations)
            for domainnameconfigurations0 in domainNameConfigurations {
                try domainNameConfigurationsContainer.encode(domainnameconfigurations0)
            }
        }
        if let mutualTlsAuthentication = mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/domainnames"
    }
}

/// Creates a new DomainName resource to represent a domain name.
public struct CreateDomainNameInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String:Swift.String]?

    public init (
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

struct CreateDomainNameInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    let mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDomainNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [ApiGatewayV2ClientTypes.DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainNameOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiMappingSelectionExpression = output.apiMappingSelectionExpression
            self.domainName = output.domainName
            self.domainNameConfigurations = output.domainNameConfigurations
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.tags = output.tags
        } else {
            self.apiMappingSelectionExpression = nil
            self.domainName = nil
            self.domainNameConfigurations = nil
            self.mutualTlsAuthentication = nil
            self.tags = nil
        }
    }
}

public struct CreateDomainNameOutputResponse: Swift.Equatable {
    /// The API mapping selection expression.
    public var apiMappingSelectionExpression: Swift.String?
    /// The name of the DomainName resource.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String:Swift.String]?

    public init (
        apiMappingSelectionExpression: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

struct CreateDomainNameOutputResponseBody: Swift.Equatable {
    let apiMappingSelectionExpression: Swift.String?
    let domainName: Swift.String?
    let domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    let mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDomainNameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMappingSelectionExpression = "apiMappingSelectionExpression"
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiMappingSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingSelectionExpression)
        apiMappingSelectionExpression = apiMappingSelectionExpressionDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [ApiGatewayV2ClientTypes.DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationMethod = "integrationMethod"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandlingStrategy = contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationMethod = integrationMethod {
            try encodeContainer.encode(integrationMethod, forKey: .integrationMethod)
        }
        if let integrationSubtype = integrationSubtype {
            try encodeContainer.encode(integrationSubtype, forKey: .integrationSubtype)
        }
        if let integrationType = integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let integrationUri = integrationUri {
            try encodeContainer.encode(integrationUri, forKey: .integrationUri)
        }
        if let passthroughBehavior = passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior.rawValue, forKey: .passthroughBehavior)
        }
        if let payloadFormatVersion = payloadFormatVersion {
            try encodeContainer.encode(payloadFormatVersion, forKey: .payloadFormatVersion)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, integrationparameters0) in requestParameters {
                try requestParametersContainer.encode(integrationparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestTemplates)
            for (dictKey0, templatemap0) in requestTemplates {
                try requestTemplatesContainer.encode(templatemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, responseparameters0) in responseParameters {
                try responseParametersContainer.encode(responseparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
        if let timeoutInMillis = timeoutInMillis {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
    }
}

extension CreateIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations"
    }
}

/// Creates a new Integration resource to represent an integration.
public struct CreateIntegrationInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// The description of the integration.
    public var description: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an HTTP_PROXY integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    /// This member is required.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern <action>:<header|querystring|path>.<location> where action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The template selection expression for the integration.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput?

    public init (
        apiId: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput? = nil
    )
    {
        self.apiId = apiId
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationMethod = integrationMethod
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct CreateIntegrationInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let integrationMethod: Swift.String?
    let integrationSubtype: Swift.String?
    let integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    let integrationUri: Swift.String?
    let passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    let payloadFormatVersion: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    let templateSelectionExpression: Swift.String?
    let timeoutInMillis: Swift.Int?
    let tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput?
}

extension CreateIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationMethod = "integrationMethod"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [Swift.String: Swift.String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.TlsConfigInput.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension CreateIntegrationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIntegrationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIntegrationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIntegrationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.credentialsArn = output.credentialsArn
            self.description = output.description
            self.integrationId = output.integrationId
            self.integrationMethod = output.integrationMethod
            self.integrationResponseSelectionExpression = output.integrationResponseSelectionExpression
            self.integrationSubtype = output.integrationSubtype
            self.integrationType = output.integrationType
            self.integrationUri = output.integrationUri
            self.passthroughBehavior = output.passthroughBehavior
            self.payloadFormatVersion = output.payloadFormatVersion
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.responseParameters = output.responseParameters
            self.templateSelectionExpression = output.templateSelectionExpression
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
        } else {
            self.apiGatewayManaged = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandlingStrategy = nil
            self.credentialsArn = nil
            self.description = nil
            self.integrationId = nil
            self.integrationMethod = nil
            self.integrationResponseSelectionExpression = nil
            self.integrationSubtype = nil
            self.integrationType = nil
            self.integrationUri = nil
            self.passthroughBehavior = nil
            self.payloadFormatVersion = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.responseParameters = nil
            self.templateSelectionExpression = nil
            self.timeoutInMillis = nil
            self.tlsConfig = nil
        }
    }
}

public struct CreateIntegrationOutputResponse: Swift.Equatable {
    /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
    public var apiGatewayManaged: Swift.Bool?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// Represents the description of an integration.
    public var description: Swift.String?
    /// Represents the identifier of an integration.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
    public var integrationResponseSelectionExpression: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API itegrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The template selection expression for the integration. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

    public init (
        apiGatewayManaged: Swift.Bool? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationResponseSelectionExpression: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct CreateIntegrationOutputResponseBody: Swift.Equatable {
    let apiGatewayManaged: Swift.Bool?
    let connectionId: Swift.String?
    let connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let integrationId: Swift.String?
    let integrationMethod: Swift.String?
    let integrationResponseSelectionExpression: Swift.String?
    let integrationSubtype: Swift.String?
    let integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    let integrationUri: Swift.String?
    let passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    let payloadFormatVersion: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    let templateSelectionExpression: Swift.String?
    let timeoutInMillis: Swift.Int?
    let tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?
}

extension CreateIntegrationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationId = "integrationId"
        case integrationMethod = "integrationMethod"
        case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let integrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationId)
        integrationId = integrationIdDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseSelectionExpression)
        integrationResponseSelectionExpression = integrationResponseSelectionExpressionDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [Swift.String: Swift.String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension CreateIntegrationResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandlingStrategy = contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let integrationResponseKey = integrationResponseKey {
            try encodeContainer.encode(integrationResponseKey, forKey: .integrationResponseKey)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, integrationparameters0) in responseParameters {
                try responseParametersContainer.encode(integrationparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, templatemap0) in responseTemplates {
                try responseTemplatesContainer.encode(templatemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
    }
}

extension CreateIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses"
    }
}

/// Creates a new IntegrationResponse resource to represent an integration response.
public struct CreateIntegrationResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response key.
    /// This member is required.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where {name} is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where {name} is a valid and unique response header name and {JSON-expression} is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The template selection expression for the integration response. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationId = integrationId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct CreateIntegrationResponseInputBody: Swift.Equatable {
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let integrationResponseKey: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let templateSelectionExpression: Swift.String?
}

extension CreateIntegrationResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension CreateIntegrationResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIntegrationResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIntegrationResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIntegrationResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIntegrationResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.integrationResponseId = output.integrationResponseId
            self.integrationResponseKey = output.integrationResponseKey
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.templateSelectionExpression = output.templateSelectionExpression
        } else {
            self.contentHandlingStrategy = nil
            self.integrationResponseId = nil
            self.integrationResponseKey = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.templateSelectionExpression = nil
        }
    }
}

public struct CreateIntegrationResponseOutputResponse: Swift.Equatable {
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration response ID.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The template selection expressions for the integration response.
    public var templateSelectionExpression: Swift.String?

    public init (
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct CreateIntegrationResponseOutputResponseBody: Swift.Equatable {
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let integrationResponseId: Swift.String?
    let integrationResponseKey: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let templateSelectionExpression: Swift.String?
}

extension CreateIntegrationResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseId = "integrationResponseId"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseId)
        integrationResponseId = integrationResponseIdDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension CreateModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case name = "name"
        case schema = "schema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

extension CreateModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models"
    }
}

/// Creates a new Model.
public struct CreateModelInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The name of the model. Must be alphanumeric.
    /// This member is required.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    /// This member is required.
    public var schema: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.contentType = contentType
        self.description = description
        self.name = name
        self.schema = schema
    }
}

struct CreateModelInputBody: Swift.Equatable {
    let contentType: Swift.String?
    let description: Swift.String?
    let name: Swift.String?
    let schema: Swift.String?
}

extension CreateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case name = "name"
        case schema = "schema"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension CreateModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateModelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentType = output.contentType
            self.description = output.description
            self.modelId = output.modelId
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.modelId = nil
            self.name = nil
            self.schema = nil
        }
    }
}

public struct CreateModelOutputResponse: Swift.Equatable {
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model identifier.
    public var modelId: Swift.String?
    /// The name of the model. Must be alphanumeric.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init (
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

struct CreateModelOutputResponseBody: Swift.Equatable {
    let contentType: Swift.String?
    let description: Swift.String?
    let modelId: Swift.String?
    let name: Swift.String?
    let schema: Swift.String?
}

extension CreateModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case modelId = "modelId"
        case name = "name"
        case schema = "schema"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension CreateRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyRequired = apiKeyRequired {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for authorizationscopes0 in authorizationScopes {
                try authorizationScopesContainer.encode(authorizationscopes0)
            }
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let authorizerId = authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let modelSelectionExpression = modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let operationName = operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestModels)
            for (dictKey0, routemodels0) in requestModels {
                try requestModelsContainer.encode(routemodels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, routeparameters0) in requestParameters {
                try requestParametersContainer.encode(routeparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeKey = routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeResponseSelectionExpression = routeResponseSelectionExpression {
            try encodeContainer.encode(routeResponseSelectionExpression, forKey: .routeResponseSelectionExpression)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension CreateRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes"
    }
}

/// Creates a new Route resource to represent a route.
public struct CreateRouteInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether an API key is required for the route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// The authorization scopes supported by this route.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String:Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route key for the route.
    /// This member is required.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct CreateRouteInputBody: Swift.Equatable {
    let apiKeyRequired: Swift.Bool?
    let authorizationScopes: [Swift.String]?
    let authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    let authorizerId: Swift.String?
    let modelSelectionExpression: Swift.String?
    let operationName: Swift.String?
    let requestModels: [Swift.String:Swift.String]?
    let requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeKey: Swift.String?
    let routeResponseSelectionExpression: Swift.String?
    let target: Swift.String?
}

extension CreateRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension CreateRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRouteOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRouteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.modelSelectionExpression = output.modelSelectionExpression
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.routeId = output.routeId
            self.routeKey = output.routeKey
            self.routeResponseSelectionExpression = output.routeResponseSelectionExpression
            self.target = output.target
        } else {
            self.apiGatewayManaged = nil
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.modelSelectionExpression = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.routeId = nil
            self.routeKey = nil
            self.routeResponseSelectionExpression = nil
            self.target = nil
        }
    }
}

public struct CreateRouteOutputResponse: Swift.Equatable {
    /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String:Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init (
        apiGatewayManaged: Swift.Bool? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct CreateRouteOutputResponseBody: Swift.Equatable {
    let apiGatewayManaged: Swift.Bool?
    let apiKeyRequired: Swift.Bool?
    let authorizationScopes: [Swift.String]?
    let authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    let authorizerId: Swift.String?
    let modelSelectionExpression: Swift.String?
    let operationName: Swift.String?
    let requestModels: [Swift.String:Swift.String]?
    let requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeId: Swift.String?
    let routeKey: Swift.String?
    let routeResponseSelectionExpression: Swift.String?
    let target: Swift.String?
}

extension CreateRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeId = "routeId"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension CreateRouteResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseKey = "routeResponseKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelSelectionExpression = modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseModels)
            for (dictKey0, routemodels0) in responseModels {
                try responseModelsContainer.encode(routemodels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, routeparameters0) in responseParameters {
                try responseParametersContainer.encode(routeparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeResponseKey = routeResponseKey {
            try encodeContainer.encode(routeResponseKey, forKey: .routeResponseKey)
        }
    }
}

extension CreateRouteResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses"
    }
}

/// Creates a new RouteResponse resource to represent a route response.
public struct CreateRouteResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model selection expression for the route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The response models for the route response.
    public var responseModels: [Swift.String:Swift.String]?
    /// The route response parameters.
    public var responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response key.
    /// This member is required.
    public var routeResponseKey: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeId = routeId
        self.routeResponseKey = routeResponseKey
    }
}

struct CreateRouteResponseInputBody: Swift.Equatable {
    let modelSelectionExpression: Swift.String?
    let responseModels: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeResponseKey: Swift.String?
}

extension CreateRouteResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseKey = "routeResponseKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension CreateRouteResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRouteResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRouteResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRouteResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRouteResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelSelectionExpression = output.modelSelectionExpression
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.routeResponseId = output.routeResponseId
            self.routeResponseKey = output.routeResponseKey
        } else {
            self.modelSelectionExpression = nil
            self.responseModels = nil
            self.responseParameters = nil
            self.routeResponseId = nil
            self.routeResponseKey = nil
        }
    }
}

public struct CreateRouteResponseOutputResponse: Swift.Equatable {
    /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// Represents the response models of a route response.
    public var responseModels: [Swift.String:Swift.String]?
    /// Represents the response parameters of a route response.
    public var responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// Represents the identifier of a route response.
    public var routeResponseId: Swift.String?
    /// Represents the route response key of a route response.
    public var routeResponseKey: Swift.String?

    public init (
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

struct CreateRouteResponseOutputResponseBody: Swift.Equatable {
    let modelSelectionExpression: Swift.String?
    let responseModels: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeResponseId: Swift.String?
    let routeResponseKey: Swift.String?
}

extension CreateRouteResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseId = "routeResponseId"
        case routeResponseKey = "routeResponseKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseId)
        routeResponseId = routeResponseIdDecoded
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension CreateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if let autoDeploy = autoDeploy {
            try encodeContainer.encode(autoDeploy, forKey: .autoDeploy)
        }
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let defaultRouteSettings = defaultRouteSettings {
            try encodeContainer.encode(defaultRouteSettings, forKey: .defaultRouteSettings)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routeSettings = routeSettings {
            var routeSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .routeSettings)
            for (dictKey0, routesettingsmap0) in routeSettings {
                try routeSettingsContainer.encode(routesettingsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariables)
            for (dictKey0, stagevariablesmap0) in stageVariables {
                try stageVariablesContainer.encode(stagevariablesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages"
    }
}

/// Creates a new Stage resource to represent a stage.
public struct CreateStageInput: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The deployment identifier of the API stage.
    public var deploymentId: Swift.String?
    /// The description for the API stage.
    public var description: Swift.String?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a Stage. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String:Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiId: Swift.String? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiId = apiId
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

struct CreateStageInputBody: Swift.Equatable {
    let accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    let autoDeploy: Swift.Bool?
    let clientCertificateId: Swift.String?
    let defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    let deploymentId: Swift.String?
    let description: Swift.String?
    let routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    let stageName: Swift.String?
    let stageVariables: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessLogSettings = output.accessLogSettings
            self.apiGatewayManaged = output.apiGatewayManaged
            self.autoDeploy = output.autoDeploy
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.defaultRouteSettings = output.defaultRouteSettings
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.lastDeploymentStatusMessage = output.lastDeploymentStatusMessage
            self.lastUpdatedDate = output.lastUpdatedDate
            self.routeSettings = output.routeSettings
            self.stageName = output.stageName
            self.stageVariables = output.stageVariables
            self.tags = output.tags
        } else {
            self.accessLogSettings = nil
            self.apiGatewayManaged = nil
            self.autoDeploy = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.defaultRouteSettings = nil
            self.deploymentId = nil
            self.description = nil
            self.lastDeploymentStatusMessage = nil
            self.lastUpdatedDate = nil
            self.routeSettings = nil
            self.stageName = nil
            self.stageVariables = nil
            self.tags = nil
        }
    }
}

public struct CreateStageOutputResponse: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: ClientRuntime.Date?
    /// Default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
    public var lastDeploymentStatusMessage: Swift.String?
    /// The timestamp when the stage was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String:Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        lastDeploymentStatusMessage: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

struct CreateStageOutputResponseBody: Swift.Equatable {
    let accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    let apiGatewayManaged: Swift.Bool?
    let autoDeploy: Swift.Bool?
    let clientCertificateId: Swift.String?
    let createdDate: ClientRuntime.Date?
    let defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    let deploymentId: Swift.String?
    let description: Swift.String?
    let lastDeploymentStatusMessage: Swift.String?
    let lastUpdatedDate: ClientRuntime.Date?
    let routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    let stageName: Swift.String?
    let stageVariables: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case apiGatewayManaged = "apiGatewayManaged"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case createdDate = "createdDate"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
        case lastUpdatedDate = "lastUpdatedDate"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVpcLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/vpclinks"
    }
}

/// Creates a VPC link
public struct CreateVpcLinkInput: Swift.Equatable {
    /// The name of the VPC link.
    /// This member is required.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// A list of tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateVpcLinkInputBody: Swift.Equatable {
    let name: Swift.String?
    let securityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateVpcLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVpcLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVpcLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVpcLinkOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVpcLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateVpcLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.name = output.name
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.vpcLinkId = output.vpcLinkId
            self.vpcLinkStatus = output.vpcLinkStatus
            self.vpcLinkStatusMessage = output.vpcLinkStatusMessage
            self.vpcLinkVersion = output.vpcLinkVersion
        } else {
            self.createdDate = nil
            self.name = nil
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.tags = nil
            self.vpcLinkId = nil
            self.vpcLinkStatus = nil
            self.vpcLinkStatusMessage = nil
            self.vpcLinkVersion = nil
        }
    }
}

public struct CreateVpcLinkOutputResponse: Swift.Equatable {
    /// The timestamp when the VPC link was created.
    public var createdDate: ClientRuntime.Date?
    /// The name of the VPC link.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    public var subnetIds: [Swift.String]?
    /// Tags for the VPC link.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the VPC link.
    public var vpcLinkId: Swift.String?
    /// The status of the VPC link.
    public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    /// A message summarizing the cause of the status of the VPC link.
    public var vpcLinkStatusMessage: Swift.String?
    /// The version of the VPC link.
    public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

    public init (
        createdDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcLinkId: Swift.String? = nil,
        vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
        vpcLinkStatusMessage: Swift.String? = nil,
        vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

struct CreateVpcLinkOutputResponseBody: Swift.Equatable {
    let createdDate: ClientRuntime.Date?
    let name: Swift.String?
    let securityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let vpcLinkId: Swift.String?
    let vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    let vpcLinkStatusMessage: Swift.String?
    let vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?
}

extension CreateVpcLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "createdDate"
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case vpcLinkId = "vpcLinkId"
        case vpcLinkStatus = "vpcLinkStatus"
        case vpcLinkStatusMessage = "vpcLinkStatusMessage"
        case vpcLinkVersion = "vpcLinkVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let vpcLinkStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkStatus.self, forKey: .vpcLinkStatus)
        vpcLinkStatus = vpcLinkStatusDecoded
        let vpcLinkStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkStatusMessage)
        vpcLinkStatusMessage = vpcLinkStatusMessageDecoded
        let vpcLinkVersionDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkVersion.self, forKey: .vpcLinkVersion)
        vpcLinkVersion = vpcLinkVersionDecoded
    }
}

extension DeleteAccessLogSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/accesslogsettings"
    }
}

public struct DeleteAccessLogSettingsInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

struct DeleteAccessLogSettingsInputBody: Swift.Equatable {
}

extension DeleteAccessLogSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessLogSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessLogSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessLogSettingsOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessLogSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessLogSettingsOutputResponse: Swift.Equatable {

}

extension DeleteApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

public struct DeleteApiInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteApiInputBody: Swift.Equatable {
}

extension DeleteApiInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let apiMappingId = apiMappingId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings/\(apiMappingId.urlPercentEncoding())"
    }
}

public struct DeleteApiMappingInput: Swift.Equatable {
    /// The API mapping identifier.
    /// This member is required.
    public var apiMappingId: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        apiMappingId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.apiMappingId = apiMappingId
        self.domainName = domainName
    }
}

struct DeleteApiMappingInputBody: Swift.Equatable {
}

extension DeleteApiMappingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiMappingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApiMappingOutputResponse: Swift.Equatable {

}

extension DeleteApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApiOutputResponse: Swift.Equatable {

}

extension DeleteAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

public struct DeleteAuthorizerInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The authorizer identifier.
    /// This member is required.
    public var authorizerId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        authorizerId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerId = authorizerId
    }
}

struct DeleteAuthorizerInputBody: Swift.Equatable {
}

extension DeleteAuthorizerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAuthorizerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAuthorizerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAuthorizerOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAuthorizerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAuthorizerOutputResponse: Swift.Equatable {

}

extension DeleteCorsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/cors"
    }
}

public struct DeleteCorsConfigurationInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteCorsConfigurationInputBody: Swift.Equatable {
}

extension DeleteCorsConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCorsConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCorsConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCorsConfigurationOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCorsConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCorsConfigurationOutputResponse: Swift.Equatable {

}

extension DeleteDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

public struct DeleteDeploymentInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The deployment ID.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.deploymentId = deploymentId
    }
}

struct DeleteDeploymentInputBody: Swift.Equatable {
}

extension DeleteDeploymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeploymentOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeploymentOutputResponse: Swift.Equatable {

}

extension DeleteDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())"
    }
}

public struct DeleteDomainNameInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainNameInputBody: Swift.Equatable {
}

extension DeleteDomainNameInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainNameOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDomainNameOutputResponse: Swift.Equatable {

}

extension DeleteIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())"
    }
}

public struct DeleteIntegrationInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
    }
}

struct DeleteIntegrationInputBody: Swift.Equatable {
}

extension DeleteIntegrationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIntegrationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIntegrationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIntegrationOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIntegrationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIntegrationOutputResponse: Swift.Equatable {

}

extension DeleteIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        guard let integrationResponseId = integrationResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses/\(integrationResponseId.urlPercentEncoding())"
    }
}

public struct DeleteIntegrationResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response ID.
    /// This member is required.
    public var integrationResponseId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
    }
}

struct DeleteIntegrationResponseInputBody: Swift.Equatable {
}

extension DeleteIntegrationResponseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIntegrationResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIntegrationResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIntegrationResponseOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIntegrationResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIntegrationResponseOutputResponse: Swift.Equatable {

}

extension DeleteModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let modelId = modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())"
    }
}

public struct DeleteModelInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        modelId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelId = modelId
    }
}

struct DeleteModelInputBody: Swift.Equatable {
}

extension DeleteModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteModelOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteModelOutputResponse: Swift.Equatable {

}

extension DeleteRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())"
    }
}

public struct DeleteRouteInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
    }
}

struct DeleteRouteInputBody: Swift.Equatable {
}

extension DeleteRouteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRouteOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRouteOutputResponse: Swift.Equatable {

}

extension DeleteRouteRequestParameterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        guard let requestParameterKey = requestParameterKey else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/requestparameters/\(requestParameterKey.urlPercentEncoding())"
    }
}

public struct DeleteRouteRequestParameterInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route request parameter key.
    /// This member is required.
    public var requestParameterKey: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        requestParameterKey: Swift.String? = nil,
        routeId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.requestParameterKey = requestParameterKey
        self.routeId = routeId
    }
}

struct DeleteRouteRequestParameterInputBody: Swift.Equatable {
}

extension DeleteRouteRequestParameterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteRequestParameterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteRequestParameterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRouteRequestParameterOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteRequestParameterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRouteRequestParameterOutputResponse: Swift.Equatable {

}

extension DeleteRouteResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        guard let routeResponseId = routeResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses/\(routeResponseId.urlPercentEncoding())"
    }
}

public struct DeleteRouteResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response ID.
    /// This member is required.
    public var routeResponseId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil,
        routeResponseId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
        self.routeResponseId = routeResponseId
    }
}

struct DeleteRouteResponseInputBody: Swift.Equatable {
}

extension DeleteRouteResponseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRouteResponseOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRouteResponseOutputResponse: Swift.Equatable {

}

extension DeleteRouteSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        guard let routeKey = routeKey else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/routesettings/\(routeKey.urlPercentEncoding())"
    }
}

public struct DeleteRouteSettingsInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route key.
    /// This member is required.
    public var routeKey: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeKey = routeKey
        self.stageName = stageName
    }
}

struct DeleteRouteSettingsInputBody: Swift.Equatable {
}

extension DeleteRouteSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRouteSettingsOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRouteSettingsOutputResponse: Swift.Equatable {

}

extension DeleteStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

public struct DeleteStageInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

struct DeleteStageInputBody: Swift.Equatable {
}

extension DeleteStageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStageOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStageOutputResponse: Swift.Equatable {

}

extension DeleteVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vpcLinkId = vpcLinkId else {
            return nil
        }
        return "/v2/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

public struct DeleteVpcLinkInput: Swift.Equatable {
    /// The ID of the VPC link.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init (
        vpcLinkId: Swift.String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

struct DeleteVpcLinkInputBody: Swift.Equatable {
}

extension DeleteVpcLinkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVpcLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVpcLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVpcLinkOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVpcLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVpcLinkOutputResponse: Swift.Equatable {

}

extension ApiGatewayV2ClientTypes.Deployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoDeployed = "autoDeployed"
        case createdDate = "createdDate"
        case deploymentId = "deploymentId"
        case deploymentStatus = "deploymentStatus"
        case deploymentStatusMessage = "deploymentStatusMessage"
        case description = "description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoDeployed = autoDeployed {
            try encodeContainer.encode(autoDeployed, forKey: .autoDeployed)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoDeployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeployed)
        autoDeployed = autoDeployedDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// An immutable representation of an API that can be called by users. A Deployment must be associated with a Stage for it to be callable over the internet.
    public struct Deployment: Swift.Equatable {
        /// Specifies whether a deployment was automatically released.
        public var autoDeployed: Swift.Bool?
        /// The date and time when the Deployment resource was created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier for the deployment.
        public var deploymentId: Swift.String?
        /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
        public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
        /// May contain additional feedback on the status of an API deployment.
        public var deploymentStatusMessage: Swift.String?
        /// The description for the deployment.
        public var description: Swift.String?

        public init (
            autoDeployed: Swift.Bool? = nil,
            createdDate: ClientRuntime.Date? = nil,
            deploymentId: Swift.String? = nil,
            deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.autoDeployed = autoDeployed
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents a deployment status.
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deployed
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .deployed,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes.DomainName: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMappingSelectionExpression = "apiMappingSelectionExpression"
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiMappingSelectionExpression = apiMappingSelectionExpression {
            try encodeContainer.encode(apiMappingSelectionExpression, forKey: .apiMappingSelectionExpression)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainNameConfigurations = domainNameConfigurations {
            var domainNameConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainNameConfigurations)
            for domainnameconfigurations0 in domainNameConfigurations {
                try domainNameConfigurationsContainer.encode(domainnameconfigurations0)
            }
        }
        if let mutualTlsAuthentication = mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiMappingSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingSelectionExpression)
        apiMappingSelectionExpression = apiMappingSelectionExpressionDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [ApiGatewayV2ClientTypes.DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a domain name.
    public struct DomainName: Swift.Equatable {
        /// The API mapping selection expression.
        public var apiMappingSelectionExpression: Swift.String?
        /// The name of the DomainName resource.
        /// This member is required.
        public var domainName: Swift.String?
        /// The domain name configurations.
        public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
        /// The mutual TLS authentication configuration for a custom domain name.
        public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
        /// The collection of tags associated with a domain name.
        public var tags: [Swift.String:Swift.String]?

        public init (
            apiMappingSelectionExpression: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
            mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.apiMappingSelectionExpression = apiMappingSelectionExpression
            self.domainName = domainName
            self.domainNameConfigurations = domainNameConfigurations
            self.mutualTlsAuthentication = mutualTlsAuthentication
            self.tags = tags
        }
    }

}

extension ApiGatewayV2ClientTypes.DomainNameConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayDomainName = "apiGatewayDomainName"
        case certificateArn = "certificateArn"
        case certificateName = "certificateName"
        case certificateUploadDate = "certificateUploadDate"
        case domainNameStatus = "domainNameStatus"
        case domainNameStatusMessage = "domainNameStatusMessage"
        case endpointType = "endpointType"
        case hostedZoneId = "hostedZoneId"
        case ownershipVerificationCertificateArn = "ownershipVerificationCertificateArn"
        case securityPolicy = "securityPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayDomainName = apiGatewayDomainName {
            try encodeContainer.encode(apiGatewayDomainName, forKey: .apiGatewayDomainName)
        }
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateName = certificateName {
            try encodeContainer.encode(certificateName, forKey: .certificateName)
        }
        if let certificateUploadDate = certificateUploadDate {
            try encodeContainer.encode(certificateUploadDate.timeIntervalSince1970, forKey: .certificateUploadDate)
        }
        if let domainNameStatus = domainNameStatus {
            try encodeContainer.encode(domainNameStatus.rawValue, forKey: .domainNameStatus)
        }
        if let domainNameStatusMessage = domainNameStatusMessage {
            try encodeContainer.encode(domainNameStatusMessage, forKey: .domainNameStatusMessage)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostedZoneId = hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
        if let ownershipVerificationCertificateArn = ownershipVerificationCertificateArn {
            try encodeContainer.encode(ownershipVerificationCertificateArn, forKey: .ownershipVerificationCertificateArn)
        }
        if let securityPolicy = securityPolicy {
            try encodeContainer.encode(securityPolicy.rawValue, forKey: .securityPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiGatewayDomainName)
        apiGatewayDomainName = apiGatewayDomainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateUploadDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let ownershipVerificationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownershipVerificationCertificateArn)
        ownershipVerificationCertificateArn = ownershipVerificationCertificateArnDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// The domain name configuration.
    public struct DomainNameConfiguration: Swift.Equatable {
        /// A domain name for the API.
        public var apiGatewayDomainName: Swift.String?
        /// An AWS-managed certificate that will be used by the edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.
        public var certificateArn: Swift.String?
        /// The user-friendly name of the certificate that will be used by the edge-optimized endpoint for this domain name.
        public var certificateName: Swift.String?
        /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
        public var certificateUploadDate: ClientRuntime.Date?
        /// The status of the domain name migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
        public var domainNameStatus: ApiGatewayV2ClientTypes.DomainNameStatus?
        /// An optional text message containing detailed information about status of the domain name migration.
        public var domainNameStatusMessage: Swift.String?
        /// The endpoint type.
        public var endpointType: ApiGatewayV2ClientTypes.EndpointType?
        /// The Amazon Route 53 Hosted Zone ID of the endpoint.
        public var hostedZoneId: Swift.String?
        /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn
        public var ownershipVerificationCertificateArn: Swift.String?
        /// The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are TLS_1_0 and TLS_1_2.
        public var securityPolicy: ApiGatewayV2ClientTypes.SecurityPolicy?

        public init (
            apiGatewayDomainName: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            certificateName: Swift.String? = nil,
            certificateUploadDate: ClientRuntime.Date? = nil,
            domainNameStatus: ApiGatewayV2ClientTypes.DomainNameStatus? = nil,
            domainNameStatusMessage: Swift.String? = nil,
            endpointType: ApiGatewayV2ClientTypes.EndpointType? = nil,
            hostedZoneId: Swift.String? = nil,
            ownershipVerificationCertificateArn: Swift.String? = nil,
            securityPolicy: ApiGatewayV2ClientTypes.SecurityPolicy? = nil
        )
        {
            self.apiGatewayDomainName = apiGatewayDomainName
            self.certificateArn = certificateArn
            self.certificateName = certificateName
            self.certificateUploadDate = certificateUploadDate
            self.domainNameStatus = domainNameStatus
            self.domainNameStatusMessage = domainNameStatusMessage
            self.endpointType = endpointType
            self.hostedZoneId = hostedZoneId
            self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
            self.securityPolicy = securityPolicy
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// The status of the domain name migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public enum DomainNameStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case pendingCertificateReimport
        case pendingOwnershipVerification
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainNameStatus] {
            return [
                .available,
                .pendingCertificateReimport,
                .pendingOwnershipVerification,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .pendingCertificateReimport: return "PENDING_CERTIFICATE_REIMPORT"
            case .pendingOwnershipVerification: return "PENDING_OWNERSHIP_VERIFICATION"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainNameStatus(rawValue: rawValue) ?? DomainNameStatus.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an endpoint type.
    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case edge
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .edge,
                .regional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
        }
    }
}

extension ExportApiInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let stageName = stageName {
            let stageNameQueryItem = ClientRuntime.URLQueryItem(name: "stageName".urlPercentEncoding(), value: Swift.String(stageName).urlPercentEncoding())
            items.append(stageNameQueryItem)
        }
        if let includeExtensions = includeExtensions {
            let includeExtensionsQueryItem = ClientRuntime.URLQueryItem(name: "includeExtensions".urlPercentEncoding(), value: Swift.String(includeExtensions).urlPercentEncoding())
            items.append(includeExtensionsQueryItem)
        }
        if let exportVersion = exportVersion {
            let exportVersionQueryItem = ClientRuntime.URLQueryItem(name: "exportVersion".urlPercentEncoding(), value: Swift.String(exportVersion).urlPercentEncoding())
            items.append(exportVersionQueryItem)
        }
        if let outputType = outputType {
            let outputTypeQueryItem = ClientRuntime.URLQueryItem(name: "outputType".urlPercentEncoding(), value: Swift.String(outputType).urlPercentEncoding())
            items.append(outputTypeQueryItem)
        }
        return items
    }
}

extension ExportApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let specification = specification else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/exports/\(specification.urlPercentEncoding())"
    }
}

public struct ExportApiInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The version of the API Gateway export algorithm. API Gateway uses the latest version by default. Currently, the only supported version is 1.0.
    public var exportVersion: Swift.String?
    /// Specifies whether to include [API Gateway extensions](https://docs.aws.amazon.com//apigateway/latest/developerguide/api-gateway-swagger-extensions.html) in the exported API definition. API Gateway extensions are included by default.
    public var includeExtensions: Swift.Bool?
    /// The output type of the exported definition file. Valid values are JSON and YAML.
    /// This member is required.
    public var outputType: Swift.String?
    /// The version of the API specification to use. OAS30, for OpenAPI 3.0, is the only supported value.
    /// This member is required.
    public var specification: Swift.String?
    /// The name of the API stage to export. If you don't specify this property, a representation of the latest API configuration is exported.
    public var stageName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        exportVersion: Swift.String? = nil,
        includeExtensions: Swift.Bool? = nil,
        outputType: Swift.String? = nil,
        specification: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.exportVersion = exportVersion
        self.includeExtensions = includeExtensions
        self.outputType = outputType
        self.specification = specification
        self.stageName = stageName
    }
}

struct ExportApiInputBody: Swift.Equatable {
}

extension ExportApiInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportApiOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.body = data
        } else {
            self.body = nil
        }
    }
}

public struct ExportApiOutputResponse: Swift.Equatable {
    /// Represents an exported definition of an API in a particular output format, for example, YAML. The API is serialized to the requested specification, for example, OpenAPI 3.0.
    public var body: ClientRuntime.Data?

    public init (
        body: ClientRuntime.Data? = nil
    )
    {
        self.body = body
    }
}

struct ExportApiOutputResponseBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension ExportApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension GetApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

public struct GetApiInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetApiInputBody: Swift.Equatable {
}

extension GetApiInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApiMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let apiMappingId = apiMappingId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings/\(apiMappingId.urlPercentEncoding())"
    }
}

public struct GetApiMappingInput: Swift.Equatable {
    /// The API mapping identifier.
    /// This member is required.
    public var apiMappingId: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        apiMappingId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.apiMappingId = apiMappingId
        self.domainName = domainName
    }
}

struct GetApiMappingInputBody: Swift.Equatable {
}

extension GetApiMappingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApiMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiMappingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApiMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiId = output.apiId
            self.apiMappingId = output.apiMappingId
            self.apiMappingKey = output.apiMappingKey
            self.stage = output.stage
        } else {
            self.apiId = nil
            self.apiMappingId = nil
            self.apiMappingKey = nil
            self.stage = nil
        }
    }
}

public struct GetApiMappingOutputResponse: Swift.Equatable {
    /// The API identifier.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

struct GetApiMappingOutputResponseBody: Swift.Equatable {
    let apiId: Swift.String?
    let apiMappingId: Swift.String?
    let apiMappingKey: Swift.String?
    let stage: Swift.String?
}

extension GetApiMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingId = "apiMappingId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingId)
        apiMappingId = apiMappingIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension GetApiMappingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetApiMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings"
    }
}

public struct GetApiMappingsInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetApiMappingsInputBody: Swift.Equatable {
}

extension GetApiMappingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApiMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiMappingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApiMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetApiMappingsOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.ApiMapping]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        items: [ApiGatewayV2ClientTypes.ApiMapping]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetApiMappingsOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.ApiMapping]?
    let nextToken: Swift.String?
}

extension GetApiMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.ApiMapping?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.ApiMapping]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.ApiMapping]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = nil
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = nil
            self.disableSchemaValidation = nil
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct GetApiOutputResponse: Swift.Equatable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init (
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct GetApiOutputResponseBody: Swift.Equatable {
    let apiEndpoint: Swift.String?
    let apiGatewayManaged: Swift.Bool?
    let apiId: Swift.String?
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let importInfo: [Swift.String]?
    let name: Swift.String?
    let protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    let routeSelectionExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let version: Swift.String?
    let warnings: [Swift.String]?
}

extension GetApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importInfo)
        var importInfoDecoded0:[Swift.String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [Swift.String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension GetApisInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetApisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/apis"
    }
}

public struct GetApisInput: Swift.Equatable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetApisInputBody: Swift.Equatable {
}

extension GetApisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApisOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetApisOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Api]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        items: [ApiGatewayV2ClientTypes.Api]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetApisOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Api]?
    let nextToken: Swift.String?
}

extension GetApisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Api?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Api]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Api]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

public struct GetAuthorizerInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The authorizer identifier.
    /// This member is required.
    public var authorizerId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        authorizerId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerId = authorizerId
    }
}

struct GetAuthorizerInputBody: Swift.Equatable {
}

extension GetAuthorizerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizerOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorizerCredentialsArn = output.authorizerCredentialsArn
            self.authorizerId = output.authorizerId
            self.authorizerPayloadFormatVersion = output.authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerType = output.authorizerType
            self.authorizerUri = output.authorizerUri
            self.enableSimpleResponses = output.enableSimpleResponses
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.jwtConfiguration = output.jwtConfiguration
            self.name = output.name
        } else {
            self.authorizerCredentialsArn = nil
            self.authorizerId = nil
            self.authorizerPayloadFormatVersion = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerType = nil
            self.authorizerUri = nil
            self.enableSimpleResponses = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.jwtConfiguration = nil
            self.name = nil
        }
    }
}

public struct GetAuthorizerOutputResponse: Swift.Equatable {
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init (
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct GetAuthorizerOutputResponseBody: Swift.Equatable {
    let authorizerCredentialsArn: Swift.String?
    let authorizerId: Swift.String?
    let authorizerPayloadFormatVersion: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
    let authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    let authorizerUri: Swift.String?
    let enableSimpleResponses: Swift.Bool?
    let identitySource: [Swift.String]?
    let identityValidationExpression: Swift.String?
    let jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    let name: Swift.String?
}

extension GetAuthorizerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerId = "authorizerId"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[Swift.String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [Swift.String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetAuthorizersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetAuthorizersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers"
    }
}

public struct GetAuthorizersInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetAuthorizersInputBody: Swift.Equatable {
}

extension GetAuthorizersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAuthorizersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetAuthorizersOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Authorizer]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        items: [ApiGatewayV2ClientTypes.Authorizer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetAuthorizersOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Authorizer]?
    let nextToken: Swift.String?
}

extension GetAuthorizersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Authorizer?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Authorizer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Authorizer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

public struct GetDeploymentInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The deployment ID.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.deploymentId = deploymentId
    }
}

struct GetDeploymentInputBody: Swift.Equatable {
}

extension GetDeploymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoDeployed = output.autoDeployed
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.deploymentStatus = output.deploymentStatus
            self.deploymentStatusMessage = output.deploymentStatusMessage
            self.description = output.description
        } else {
            self.autoDeployed = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.deploymentStatus = nil
            self.deploymentStatusMessage = nil
            self.description = nil
        }
    }
}

public struct GetDeploymentOutputResponse: Swift.Equatable {
    /// Specifies whether a deployment was automatically released.
    public var autoDeployed: Swift.Bool?
    /// The date and time when the Deployment resource was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier for the deployment.
    public var deploymentId: Swift.String?
    /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
    public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    /// May contain additional feedback on the status of an API deployment.
    public var deploymentStatusMessage: Swift.String?
    /// The description for the deployment.
    public var description: Swift.String?

    public init (
        autoDeployed: Swift.Bool? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
        deploymentStatusMessage: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

struct GetDeploymentOutputResponseBody: Swift.Equatable {
    let autoDeployed: Swift.Bool?
    let createdDate: ClientRuntime.Date?
    let deploymentId: Swift.String?
    let deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    let deploymentStatusMessage: Swift.String?
    let description: Swift.String?
}

extension GetDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoDeployed = "autoDeployed"
        case createdDate = "createdDate"
        case deploymentId = "deploymentId"
        case deploymentStatus = "deploymentStatus"
        case deploymentStatusMessage = "deploymentStatusMessage"
        case description = "description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoDeployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeployed)
        autoDeployed = autoDeployedDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GetDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments"
    }
}

public struct GetDeploymentsInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDeploymentsInputBody: Swift.Equatable {
}

extension GetDeploymentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetDeploymentsOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Deployment]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        items: [ApiGatewayV2ClientTypes.Deployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetDeploymentsOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Deployment]?
    let nextToken: Swift.String?
}

extension GetDeploymentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Deployment?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Deployment]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Deployment]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())"
    }
}

public struct GetDomainNameInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetDomainNameInputBody: Swift.Equatable {
}

extension GetDomainNameInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainNameOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiMappingSelectionExpression = output.apiMappingSelectionExpression
            self.domainName = output.domainName
            self.domainNameConfigurations = output.domainNameConfigurations
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.tags = output.tags
        } else {
            self.apiMappingSelectionExpression = nil
            self.domainName = nil
            self.domainNameConfigurations = nil
            self.mutualTlsAuthentication = nil
            self.tags = nil
        }
    }
}

public struct GetDomainNameOutputResponse: Swift.Equatable {
    /// The API mapping selection expression.
    public var apiMappingSelectionExpression: Swift.String?
    /// The name of the DomainName resource.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String:Swift.String]?

    public init (
        apiMappingSelectionExpression: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

struct GetDomainNameOutputResponseBody: Swift.Equatable {
    let apiMappingSelectionExpression: Swift.String?
    let domainName: Swift.String?
    let domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    let mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    let tags: [Swift.String:Swift.String]?
}

extension GetDomainNameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMappingSelectionExpression = "apiMappingSelectionExpression"
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiMappingSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingSelectionExpression)
        apiMappingSelectionExpression = apiMappingSelectionExpressionDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [ApiGatewayV2ClientTypes.DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDomainNamesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetDomainNamesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/domainnames"
    }
}

public struct GetDomainNamesInput: Swift.Equatable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDomainNamesInputBody: Swift.Equatable {
}

extension GetDomainNamesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainNamesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainNamesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainNamesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainNamesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDomainNamesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetDomainNamesOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.DomainName]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        items: [ApiGatewayV2ClientTypes.DomainName]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetDomainNamesOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.DomainName]?
    let nextToken: Swift.String?
}

extension GetDomainNamesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainName?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.DomainName]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.DomainName]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())"
    }
}

public struct GetIntegrationInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
    }
}

struct GetIntegrationInputBody: Swift.Equatable {
}

extension GetIntegrationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIntegrationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.credentialsArn = output.credentialsArn
            self.description = output.description
            self.integrationId = output.integrationId
            self.integrationMethod = output.integrationMethod
            self.integrationResponseSelectionExpression = output.integrationResponseSelectionExpression
            self.integrationSubtype = output.integrationSubtype
            self.integrationType = output.integrationType
            self.integrationUri = output.integrationUri
            self.passthroughBehavior = output.passthroughBehavior
            self.payloadFormatVersion = output.payloadFormatVersion
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.responseParameters = output.responseParameters
            self.templateSelectionExpression = output.templateSelectionExpression
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
        } else {
            self.apiGatewayManaged = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandlingStrategy = nil
            self.credentialsArn = nil
            self.description = nil
            self.integrationId = nil
            self.integrationMethod = nil
            self.integrationResponseSelectionExpression = nil
            self.integrationSubtype = nil
            self.integrationType = nil
            self.integrationUri = nil
            self.passthroughBehavior = nil
            self.payloadFormatVersion = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.responseParameters = nil
            self.templateSelectionExpression = nil
            self.timeoutInMillis = nil
            self.tlsConfig = nil
        }
    }
}

public struct GetIntegrationOutputResponse: Swift.Equatable {
    /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
    public var apiGatewayManaged: Swift.Bool?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// Represents the description of an integration.
    public var description: Swift.String?
    /// Represents the identifier of an integration.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
    public var integrationResponseSelectionExpression: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API itegrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The template selection expression for the integration. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

    public init (
        apiGatewayManaged: Swift.Bool? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationResponseSelectionExpression: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct GetIntegrationOutputResponseBody: Swift.Equatable {
    let apiGatewayManaged: Swift.Bool?
    let connectionId: Swift.String?
    let connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let integrationId: Swift.String?
    let integrationMethod: Swift.String?
    let integrationResponseSelectionExpression: Swift.String?
    let integrationSubtype: Swift.String?
    let integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    let integrationUri: Swift.String?
    let passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    let payloadFormatVersion: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    let templateSelectionExpression: Swift.String?
    let timeoutInMillis: Swift.Int?
    let tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?
}

extension GetIntegrationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationId = "integrationId"
        case integrationMethod = "integrationMethod"
        case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let integrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationId)
        integrationId = integrationIdDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseSelectionExpression)
        integrationResponseSelectionExpression = integrationResponseSelectionExpressionDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [Swift.String: Swift.String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension GetIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        guard let integrationResponseId = integrationResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses/\(integrationResponseId.urlPercentEncoding())"
    }
}

public struct GetIntegrationResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response ID.
    /// This member is required.
    public var integrationResponseId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
    }
}

struct GetIntegrationResponseInputBody: Swift.Equatable {
}

extension GetIntegrationResponseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIntegrationResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationResponseOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIntegrationResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.integrationResponseId = output.integrationResponseId
            self.integrationResponseKey = output.integrationResponseKey
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.templateSelectionExpression = output.templateSelectionExpression
        } else {
            self.contentHandlingStrategy = nil
            self.integrationResponseId = nil
            self.integrationResponseKey = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.templateSelectionExpression = nil
        }
    }
}

public struct GetIntegrationResponseOutputResponse: Swift.Equatable {
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration response ID.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The template selection expressions for the integration response.
    public var templateSelectionExpression: Swift.String?

    public init (
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct GetIntegrationResponseOutputResponseBody: Swift.Equatable {
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let integrationResponseId: Swift.String?
    let integrationResponseKey: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let templateSelectionExpression: Swift.String?
}

extension GetIntegrationResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseId = "integrationResponseId"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseId)
        integrationResponseId = integrationResponseIdDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension GetIntegrationResponsesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetIntegrationResponsesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses"
    }
}

public struct GetIntegrationResponsesInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetIntegrationResponsesInputBody: Swift.Equatable {
}

extension GetIntegrationResponsesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIntegrationResponsesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationResponsesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationResponsesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationResponsesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIntegrationResponsesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetIntegrationResponsesOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.IntegrationResponse]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        items: [ApiGatewayV2ClientTypes.IntegrationResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetIntegrationResponsesOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.IntegrationResponse]?
    let nextToken: Swift.String?
}

extension GetIntegrationResponsesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.IntegrationResponse?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.IntegrationResponse]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.IntegrationResponse]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetIntegrationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetIntegrationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations"
    }
}

public struct GetIntegrationsInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetIntegrationsInputBody: Swift.Equatable {
}

extension GetIntegrationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIntegrationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIntegrationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetIntegrationsOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Integration]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        items: [ApiGatewayV2ClientTypes.Integration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetIntegrationsOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Integration]?
    let nextToken: Swift.String?
}

extension GetIntegrationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Integration?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Integration]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Integration]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let modelId = modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())"
    }
}

public struct GetModelInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        modelId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelId = modelId
    }
}

struct GetModelInputBody: Swift.Equatable {
}

extension GetModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentType = output.contentType
            self.description = output.description
            self.modelId = output.modelId
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.modelId = nil
            self.name = nil
            self.schema = nil
        }
    }
}

public struct GetModelOutputResponse: Swift.Equatable {
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model identifier.
    public var modelId: Swift.String?
    /// The name of the model. Must be alphanumeric.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init (
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

struct GetModelOutputResponseBody: Swift.Equatable {
    let contentType: Swift.String?
    let description: Swift.String?
    let modelId: Swift.String?
    let name: Swift.String?
    let schema: Swift.String?
}

extension GetModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case modelId = "modelId"
        case name = "name"
        case schema = "schema"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension GetModelTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let modelId = modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())/template"
    }
}

public struct GetModelTemplateInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        modelId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelId = modelId
    }
}

struct GetModelTemplateInputBody: Swift.Equatable {
}

extension GetModelTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetModelTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelTemplateOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetModelTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.value = output.value
        } else {
            self.value = nil
        }
    }
}

public struct GetModelTemplateOutputResponse: Swift.Equatable {
    /// The template value.
    public var value: Swift.String?

    public init (
        value: Swift.String? = nil
    )
    {
        self.value = value
    }
}

struct GetModelTemplateOutputResponseBody: Swift.Equatable {
    let value: Swift.String?
}

extension GetModelTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "value"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension GetModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models"
    }
}

public struct GetModelsInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetModelsInputBody: Swift.Equatable {
}

extension GetModelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetModelsOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Model]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        items: [ApiGatewayV2ClientTypes.Model]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetModelsOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Model]?
    let nextToken: Swift.String?
}

extension GetModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Model?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Model]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Model]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())"
    }
}

public struct GetRouteInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
    }
}

struct GetRouteInputBody: Swift.Equatable {
}

extension GetRouteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRouteOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRouteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.modelSelectionExpression = output.modelSelectionExpression
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.routeId = output.routeId
            self.routeKey = output.routeKey
            self.routeResponseSelectionExpression = output.routeResponseSelectionExpression
            self.target = output.target
        } else {
            self.apiGatewayManaged = nil
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.modelSelectionExpression = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.routeId = nil
            self.routeKey = nil
            self.routeResponseSelectionExpression = nil
            self.target = nil
        }
    }
}

public struct GetRouteOutputResponse: Swift.Equatable {
    /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String:Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init (
        apiGatewayManaged: Swift.Bool? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct GetRouteOutputResponseBody: Swift.Equatable {
    let apiGatewayManaged: Swift.Bool?
    let apiKeyRequired: Swift.Bool?
    let authorizationScopes: [Swift.String]?
    let authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    let authorizerId: Swift.String?
    let modelSelectionExpression: Swift.String?
    let operationName: Swift.String?
    let requestModels: [Swift.String:Swift.String]?
    let requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeId: Swift.String?
    let routeKey: Swift.String?
    let routeResponseSelectionExpression: Swift.String?
    let target: Swift.String?
}

extension GetRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeId = "routeId"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension GetRouteResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        guard let routeResponseId = routeResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses/\(routeResponseId.urlPercentEncoding())"
    }
}

public struct GetRouteResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response ID.
    /// This member is required.
    public var routeResponseId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil,
        routeResponseId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
        self.routeResponseId = routeResponseId
    }
}

struct GetRouteResponseInputBody: Swift.Equatable {
}

extension GetRouteResponseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRouteResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRouteResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRouteResponseOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRouteResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRouteResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelSelectionExpression = output.modelSelectionExpression
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.routeResponseId = output.routeResponseId
            self.routeResponseKey = output.routeResponseKey
        } else {
            self.modelSelectionExpression = nil
            self.responseModels = nil
            self.responseParameters = nil
            self.routeResponseId = nil
            self.routeResponseKey = nil
        }
    }
}

public struct GetRouteResponseOutputResponse: Swift.Equatable {
    /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// Represents the response models of a route response.
    public var responseModels: [Swift.String:Swift.String]?
    /// Represents the response parameters of a route response.
    public var responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// Represents the identifier of a route response.
    public var routeResponseId: Swift.String?
    /// Represents the route response key of a route response.
    public var routeResponseKey: Swift.String?

    public init (
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

struct GetRouteResponseOutputResponseBody: Swift.Equatable {
    let modelSelectionExpression: Swift.String?
    let responseModels: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeResponseId: Swift.String?
    let routeResponseKey: Swift.String?
}

extension GetRouteResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseId = "routeResponseId"
        case routeResponseKey = "routeResponseKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseId)
        routeResponseId = routeResponseIdDecoded
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension GetRouteResponsesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetRouteResponsesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses"
    }
}

public struct GetRouteResponsesInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        routeId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.routeId = routeId
    }
}

struct GetRouteResponsesInputBody: Swift.Equatable {
}

extension GetRouteResponsesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRouteResponsesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRouteResponsesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRouteResponsesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRouteResponsesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRouteResponsesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetRouteResponsesOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.RouteResponse]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        items: [ApiGatewayV2ClientTypes.RouteResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetRouteResponsesOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.RouteResponse]?
    let nextToken: Swift.String?
}

extension GetRouteResponsesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.RouteResponse?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.RouteResponse]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.RouteResponse]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetRoutesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes"
    }
}

public struct GetRoutesInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetRoutesInputBody: Swift.Equatable {
}

extension GetRoutesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRoutesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRoutesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRoutesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoutesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRoutesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetRoutesOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Route]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        items: [ApiGatewayV2ClientTypes.Route]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetRoutesOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Route]?
    let nextToken: Swift.String?
}

extension GetRoutesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Route?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Route]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Route]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

public struct GetStageInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

struct GetStageInputBody: Swift.Equatable {
}

extension GetStageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStageOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessLogSettings = output.accessLogSettings
            self.apiGatewayManaged = output.apiGatewayManaged
            self.autoDeploy = output.autoDeploy
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.defaultRouteSettings = output.defaultRouteSettings
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.lastDeploymentStatusMessage = output.lastDeploymentStatusMessage
            self.lastUpdatedDate = output.lastUpdatedDate
            self.routeSettings = output.routeSettings
            self.stageName = output.stageName
            self.stageVariables = output.stageVariables
            self.tags = output.tags
        } else {
            self.accessLogSettings = nil
            self.apiGatewayManaged = nil
            self.autoDeploy = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.defaultRouteSettings = nil
            self.deploymentId = nil
            self.description = nil
            self.lastDeploymentStatusMessage = nil
            self.lastUpdatedDate = nil
            self.routeSettings = nil
            self.stageName = nil
            self.stageVariables = nil
            self.tags = nil
        }
    }
}

public struct GetStageOutputResponse: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: ClientRuntime.Date?
    /// Default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
    public var lastDeploymentStatusMessage: Swift.String?
    /// The timestamp when the stage was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String:Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        lastDeploymentStatusMessage: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

struct GetStageOutputResponseBody: Swift.Equatable {
    let accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    let apiGatewayManaged: Swift.Bool?
    let autoDeploy: Swift.Bool?
    let clientCertificateId: Swift.String?
    let createdDate: ClientRuntime.Date?
    let defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    let deploymentId: Swift.String?
    let description: Swift.String?
    let lastDeploymentStatusMessage: Swift.String?
    let lastUpdatedDate: ClientRuntime.Date?
    let routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    let stageName: Swift.String?
    let stageVariables: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension GetStageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case apiGatewayManaged = "apiGatewayManaged"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case createdDate = "createdDate"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
        case lastUpdatedDate = "lastUpdatedDate"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetStagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetStagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages"
    }
}

public struct GetStagesInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetStagesInputBody: Swift.Equatable {
}

extension GetStagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStagesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetStagesOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Stage]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        items: [ApiGatewayV2ClientTypes.Stage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetStagesOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Stage]?
    let nextToken: Swift.String?
}

extension GetStagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Stage?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Stage]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Stage]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v2/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct GetTagsInput: Swift.Equatable {
    /// The resource ARN for the tag.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetTagsInputBody: Swift.Equatable {
}

extension GetTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct GetTagsOutputResponse: Swift.Equatable {
    /// Represents a collection of tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetTagsOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension GetTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vpcLinkId = vpcLinkId else {
            return nil
        }
        return "/v2/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

public struct GetVpcLinkInput: Swift.Equatable {
    /// The ID of the VPC link.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init (
        vpcLinkId: Swift.String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

struct GetVpcLinkInputBody: Swift.Equatable {
}

extension GetVpcLinkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVpcLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVpcLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVpcLinkOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVpcLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVpcLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.name = output.name
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.vpcLinkId = output.vpcLinkId
            self.vpcLinkStatus = output.vpcLinkStatus
            self.vpcLinkStatusMessage = output.vpcLinkStatusMessage
            self.vpcLinkVersion = output.vpcLinkVersion
        } else {
            self.createdDate = nil
            self.name = nil
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.tags = nil
            self.vpcLinkId = nil
            self.vpcLinkStatus = nil
            self.vpcLinkStatusMessage = nil
            self.vpcLinkVersion = nil
        }
    }
}

public struct GetVpcLinkOutputResponse: Swift.Equatable {
    /// The timestamp when the VPC link was created.
    public var createdDate: ClientRuntime.Date?
    /// The name of the VPC link.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    public var subnetIds: [Swift.String]?
    /// Tags for the VPC link.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the VPC link.
    public var vpcLinkId: Swift.String?
    /// The status of the VPC link.
    public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    /// A message summarizing the cause of the status of the VPC link.
    public var vpcLinkStatusMessage: Swift.String?
    /// The version of the VPC link.
    public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

    public init (
        createdDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcLinkId: Swift.String? = nil,
        vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
        vpcLinkStatusMessage: Swift.String? = nil,
        vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

struct GetVpcLinkOutputResponseBody: Swift.Equatable {
    let createdDate: ClientRuntime.Date?
    let name: Swift.String?
    let securityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let vpcLinkId: Swift.String?
    let vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    let vpcLinkStatusMessage: Swift.String?
    let vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?
}

extension GetVpcLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "createdDate"
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case vpcLinkId = "vpcLinkId"
        case vpcLinkStatus = "vpcLinkStatus"
        case vpcLinkStatusMessage = "vpcLinkStatusMessage"
        case vpcLinkVersion = "vpcLinkVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let vpcLinkStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkStatus.self, forKey: .vpcLinkStatus)
        vpcLinkStatus = vpcLinkStatusDecoded
        let vpcLinkStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkStatusMessage)
        vpcLinkStatusMessage = vpcLinkStatusMessageDecoded
        let vpcLinkVersionDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkVersion.self, forKey: .vpcLinkVersion)
        vpcLinkVersion = vpcLinkVersionDecoded
    }
}

extension GetVpcLinksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetVpcLinksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/vpclinks"
    }
}

public struct GetVpcLinksInput: Swift.Equatable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetVpcLinksInputBody: Swift.Equatable {
}

extension GetVpcLinksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVpcLinksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVpcLinksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVpcLinksOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVpcLinksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVpcLinksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetVpcLinksOutputResponse: Swift.Equatable {
    /// A collection of VPC links.
    public var items: [ApiGatewayV2ClientTypes.VpcLink]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init (
        items: [ApiGatewayV2ClientTypes.VpcLink]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetVpcLinksOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.VpcLink]?
    let nextToken: Swift.String?
}

extension GetVpcLinksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.VpcLink?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.VpcLink]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.VpcLink]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ImportApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
    }
}

extension ImportApiInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let failOnWarnings = failOnWarnings {
            let failOnWarningsQueryItem = ClientRuntime.URLQueryItem(name: "failOnWarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        if let basepath = basepath {
            let basepathQueryItem = ClientRuntime.URLQueryItem(name: "basepath".urlPercentEncoding(), value: Swift.String(basepath).urlPercentEncoding())
            items.append(basepathQueryItem)
        }
        return items
    }
}

extension ImportApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/apis"
    }
}

///
public struct ImportApiInput: Swift.Equatable {
    /// Specifies how to interpret the base path of the API during import. Valid values are ignore, prepend, and split. The default value is ignore. To learn more, see [Set the OpenAPI basePath Property](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html). Supported only for HTTP APIs.
    public var basepath: Swift.String?
    /// The OpenAPI definition. Supported only for HTTP APIs.
    /// This member is required.
    public var body: Swift.String?
    /// Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.
    public var failOnWarnings: Swift.Bool?

    public init (
        basepath: Swift.String? = nil,
        body: Swift.String? = nil,
        failOnWarnings: Swift.Bool? = nil
    )
    {
        self.basepath = basepath
        self.body = body
        self.failOnWarnings = failOnWarnings
    }
}

struct ImportApiInputBody: Swift.Equatable {
    let body: Swift.String?
}

extension ImportApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ImportApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportApiOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = nil
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = nil
            self.disableSchemaValidation = nil
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct ImportApiOutputResponse: Swift.Equatable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init (
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct ImportApiOutputResponseBody: Swift.Equatable {
    let apiEndpoint: Swift.String?
    let apiGatewayManaged: Swift.Bool?
    let apiId: Swift.String?
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let importInfo: [Swift.String]?
    let name: Swift.String?
    let protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    let routeSelectionExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let version: Swift.String?
    let warnings: [Swift.String]?
}

extension ImportApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importInfo)
        var importInfoDecoded0:[Swift.String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [Swift.String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension ApiGatewayV2ClientTypes.Integration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationId = "integrationId"
        case integrationMethod = "integrationMethod"
        case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayManaged = apiGatewayManaged {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandlingStrategy = contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationId = integrationId {
            try encodeContainer.encode(integrationId, forKey: .integrationId)
        }
        if let integrationMethod = integrationMethod {
            try encodeContainer.encode(integrationMethod, forKey: .integrationMethod)
        }
        if let integrationResponseSelectionExpression = integrationResponseSelectionExpression {
            try encodeContainer.encode(integrationResponseSelectionExpression, forKey: .integrationResponseSelectionExpression)
        }
        if let integrationSubtype = integrationSubtype {
            try encodeContainer.encode(integrationSubtype, forKey: .integrationSubtype)
        }
        if let integrationType = integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let integrationUri = integrationUri {
            try encodeContainer.encode(integrationUri, forKey: .integrationUri)
        }
        if let passthroughBehavior = passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior.rawValue, forKey: .passthroughBehavior)
        }
        if let payloadFormatVersion = payloadFormatVersion {
            try encodeContainer.encode(payloadFormatVersion, forKey: .payloadFormatVersion)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, integrationparameters0) in requestParameters {
                try requestParametersContainer.encode(integrationparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestTemplates)
            for (dictKey0, templatemap0) in requestTemplates {
                try requestTemplatesContainer.encode(templatemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, responseparameters0) in responseParameters {
                try responseParametersContainer.encode(responseparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
        if let timeoutInMillis = timeoutInMillis {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let integrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationId)
        integrationId = integrationIdDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseSelectionExpression)
        integrationResponseSelectionExpression = integrationResponseSelectionExpressionDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [Swift.String: Swift.String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an integration.
    public struct Integration: Swift.Equatable {
        /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
        public var apiGatewayManaged: Swift.Bool?
        /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
        public var connectionId: Swift.String?
        /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
        public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
        public var credentialsArn: Swift.String?
        /// Represents the description of an integration.
        public var description: Swift.String?
        /// Represents the identifier of an integration.
        public var integrationId: Swift.String?
        /// Specifies the integration's HTTP method type.
        public var integrationMethod: Swift.String?
        /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
        public var integrationResponseSelectionExpression: Swift.String?
        /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
        public var integrationSubtype: Swift.String?
        /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
        public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
        /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
        public var integrationUri: Swift.String?
        /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
        public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
        /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
        public var payloadFormatVersion: Swift.String?
        /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API itegrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
        public var requestParameters: [Swift.String:Swift.String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
        public var requestTemplates: [Swift.String:Swift.String]?
        /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
        public var responseParameters: [Swift.String:[Swift.String:Swift.String]]?
        /// The template selection expression for the integration. Supported only for WebSocket APIs.
        public var templateSelectionExpression: Swift.String?
        /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
        public var timeoutInMillis: Swift.Int?
        /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
        public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

        public init (
            apiGatewayManaged: Swift.Bool? = nil,
            connectionId: Swift.String? = nil,
            connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
            contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
            credentialsArn: Swift.String? = nil,
            description: Swift.String? = nil,
            integrationId: Swift.String? = nil,
            integrationMethod: Swift.String? = nil,
            integrationResponseSelectionExpression: Swift.String? = nil,
            integrationSubtype: Swift.String? = nil,
            integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
            integrationUri: Swift.String? = nil,
            passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
            payloadFormatVersion: Swift.String? = nil,
            requestParameters: [Swift.String:Swift.String]? = nil,
            requestTemplates: [Swift.String:Swift.String]? = nil,
            responseParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
            templateSelectionExpression: Swift.String? = nil,
            timeoutInMillis: Swift.Int? = nil,
            tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
        )
        {
            self.apiGatewayManaged = apiGatewayManaged
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandlingStrategy = contentHandlingStrategy
            self.credentialsArn = credentialsArn
            self.description = description
            self.integrationId = integrationId
            self.integrationMethod = integrationMethod
            self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
            self.integrationSubtype = integrationSubtype
            self.integrationType = integrationType
            self.integrationUri = integrationUri
            self.passthroughBehavior = passthroughBehavior
            self.payloadFormatVersion = payloadFormatVersion
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.responseParameters = responseParameters
            self.templateSelectionExpression = templateSelectionExpression
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
        }
    }

}

extension ApiGatewayV2ClientTypes.IntegrationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseId = "integrationResponseId"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandlingStrategy = contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let integrationResponseId = integrationResponseId {
            try encodeContainer.encode(integrationResponseId, forKey: .integrationResponseId)
        }
        if let integrationResponseKey = integrationResponseKey {
            try encodeContainer.encode(integrationResponseKey, forKey: .integrationResponseKey)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, integrationparameters0) in responseParameters {
                try responseParametersContainer.encode(integrationparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, templatemap0) in responseTemplates {
                try responseTemplatesContainer.encode(templatemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseId)
        integrationResponseId = integrationResponseIdDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an integration response.
    public struct IntegrationResponse: Swift.Equatable {
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
        /// The integration response ID.
        public var integrationResponseId: Swift.String?
        /// The integration response key.
        /// This member is required.
        public var integrationResponseKey: Swift.String?
        /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
        public var responseParameters: [Swift.String:Swift.String]?
        /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public var responseTemplates: [Swift.String:Swift.String]?
        /// The template selection expressions for the integration response.
        public var templateSelectionExpression: Swift.String?

        public init (
            contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
            integrationResponseId: Swift.String? = nil,
            integrationResponseKey: Swift.String? = nil,
            responseParameters: [Swift.String:Swift.String]? = nil,
            responseTemplates: [Swift.String:Swift.String]? = nil,
            templateSelectionExpression: Swift.String? = nil
        )
        {
            self.contentHandlingStrategy = contentHandlingStrategy
            self.integrationResponseId = integrationResponseId
            self.integrationResponseKey = integrationResponseKey
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.templateSelectionExpression = templateSelectionExpression
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents an API method integration type.
    public enum IntegrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case awsProxy
        case http
        case httpProxy
        case mock
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationType] {
            return [
                .aws,
                .awsProxy,
                .http,
                .httpProxy,
                .mock,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .awsProxy: return "AWS_PROXY"
            case .http: return "HTTP"
            case .httpProxy: return "HTTP_PROXY"
            case .mock: return "MOCK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntegrationType(rawValue: rawValue) ?? IntegrationType.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes.JWTConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audience = "audience"
        case issuer = "issuer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audience = audience {
            var audienceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .audience)
            for __listof__string0 in audience {
                try audienceContainer.encode(__listof__string0)
            }
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audienceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .audience)
        var audienceDecoded0:[Swift.String]? = nil
        if let audienceContainer = audienceContainer {
            audienceDecoded0 = [Swift.String]()
            for string0 in audienceContainer {
                if let string0 = string0 {
                    audienceDecoded0?.append(string0)
                }
            }
        }
        audience = audienceDecoded0
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public struct JWTConfiguration: Swift.Equatable {
        /// A list of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list. See [RFC 7519](https://tools.ietf.org/html/rfc7519#section-4.1.3). Supported only for HTTP APIs.
        public var audience: [Swift.String]?
        /// The base domain of the identity provider that issues JSON Web Tokens. For example, an Amazon Cognito user pool has the following format: https://cognito-idp.{region}.amazonaws.com/{userPoolId} . Required for the JWT authorizer type. Supported only for HTTP APIs.
        public var issuer: Swift.String?

        public init (
            audience: [Swift.String]? = nil,
            issuer: Swift.String? = nil
        )
        {
            self.audience = audience
            self.issuer = issuer
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// The logging level.
    public enum LoggingLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case info
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .error,
                .info,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes.Model: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case modelId = "modelId"
        case name = "name"
        case schema = "schema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a data model for an API. Supported only for WebSocket APIs. See [Create Models and Mapping Templates for Request and Response Mappings](https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html).
    public struct Model: Swift.Equatable {
        /// The content-type for the model, for example, "application/json".
        public var contentType: Swift.String?
        /// The description of the model.
        public var description: Swift.String?
        /// The model identifier.
        public var modelId: Swift.String?
        /// The name of the model. Must be alphanumeric.
        /// This member is required.
        public var name: Swift.String?
        /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
        public var schema: Swift.String?

        public init (
            contentType: Swift.String? = nil,
            description: Swift.String? = nil,
            modelId: Swift.String? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.description = description
            self.modelId = modelId
            self.name = name
            self.schema = schema
        }
    }

}

extension ApiGatewayV2ClientTypes.MutualTlsAuthentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case truststoreUri = "truststoreUri"
        case truststoreVersion = "truststoreVersion"
        case truststoreWarnings = "truststoreWarnings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let truststoreUri = truststoreUri {
            try encodeContainer.encode(truststoreUri, forKey: .truststoreUri)
        }
        if let truststoreVersion = truststoreVersion {
            try encodeContainer.encode(truststoreVersion, forKey: .truststoreVersion)
        }
        if let truststoreWarnings = truststoreWarnings {
            var truststoreWarningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .truststoreWarnings)
            for __listof__string0 in truststoreWarnings {
                try truststoreWarningsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truststoreUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreUri)
        truststoreUri = truststoreUriDecoded
        let truststoreVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreVersion)
        truststoreVersion = truststoreVersionDecoded
        let truststoreWarningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .truststoreWarnings)
        var truststoreWarningsDecoded0:[Swift.String]? = nil
        if let truststoreWarningsContainer = truststoreWarningsContainer {
            truststoreWarningsDecoded0 = [Swift.String]()
            for string0 in truststoreWarningsContainer {
                if let string0 = string0 {
                    truststoreWarningsDecoded0?.append(string0)
                }
            }
        }
        truststoreWarnings = truststoreWarningsDecoded0
    }
}

extension ApiGatewayV2ClientTypes {
    public struct MutualTlsAuthentication: Swift.Equatable {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public var truststoreVersion: Swift.String?
        /// A list of warnings that API Gateway returns while processing your truststore. Invalid certificates produce warnings. Mutual TLS is still enabled, but some clients might not be able to access your API. To resolve warnings, upload a new truststore to S3, and then update you domain name to use the new version.
        public var truststoreWarnings: [Swift.String]?

        public init (
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil,
            truststoreWarnings: [Swift.String]? = nil
        )
        {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
            self.truststoreWarnings = truststoreWarnings
        }
    }

}

extension ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case truststoreUri = "truststoreUri"
        case truststoreVersion = "truststoreVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let truststoreUri = truststoreUri {
            try encodeContainer.encode(truststoreUri, forKey: .truststoreUri)
        }
        if let truststoreVersion = truststoreVersion {
            try encodeContainer.encode(truststoreVersion, forKey: .truststoreVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truststoreUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreUri)
        truststoreUri = truststoreUriDecoded
        let truststoreVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreVersion)
        truststoreVersion = truststoreVersionDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    public struct MutualTlsAuthenticationInput: Swift.Equatable {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public var truststoreVersion: Swift.String?

        public init (
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil
        )
        {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
        }
    }

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in the request was not found. See the message field for more information.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Describes the error encountered.
    public var message: Swift.String?
    /// The resource type.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case resourceType = "resourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ApiGatewayV2ClientTypes.ParameterConstraints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `required` = `required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Validation constraints imposed on parameters of a request (path, query string, headers).
    public struct ParameterConstraints: Swift.Equatable {
        /// Whether or not the parameter is required.
        public var `required`: Swift.Bool?

        public init (
            `required`: Swift.Bool? = nil
        )
        {
            self.`required` = `required`
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents passthrough behavior for an integration response. Supported only for WebSocket APIs.
    public enum PassthroughBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case never
        case whenNoMatch
        case whenNoTemplates
        case sdkUnknown(Swift.String)

        public static var allCases: [PassthroughBehavior] {
            return [
                .never,
                .whenNoMatch,
                .whenNoTemplates,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .never: return "NEVER"
            case .whenNoMatch: return "WHEN_NO_MATCH"
            case .whenNoTemplates: return "WHEN_NO_TEMPLATES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PassthroughBehavior(rawValue: rawValue) ?? PassthroughBehavior.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a protocol type.
    public enum ProtocolType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case websocket
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtocolType] {
            return [
                .http,
                .websocket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .websocket: return "WEBSOCKET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtocolType(rawValue: rawValue) ?? ProtocolType.sdkUnknown(rawValue)
        }
    }
}

extension ReimportApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
    }
}

extension ReimportApiInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let failOnWarnings = failOnWarnings {
            let failOnWarningsQueryItem = ClientRuntime.URLQueryItem(name: "failOnWarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        if let basepath = basepath {
            let basepathQueryItem = ClientRuntime.URLQueryItem(name: "basepath".urlPercentEncoding(), value: Swift.String(basepath).urlPercentEncoding())
            items.append(basepathQueryItem)
        }
        return items
    }
}

extension ReimportApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

///
public struct ReimportApiInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies how to interpret the base path of the API during import. Valid values are ignore, prepend, and split. The default value is ignore. To learn more, see [Set the OpenAPI basePath Property](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html). Supported only for HTTP APIs.
    public var basepath: Swift.String?
    /// The OpenAPI definition. Supported only for HTTP APIs.
    /// This member is required.
    public var body: Swift.String?
    /// Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.
    public var failOnWarnings: Swift.Bool?

    public init (
        apiId: Swift.String? = nil,
        basepath: Swift.String? = nil,
        body: Swift.String? = nil,
        failOnWarnings: Swift.Bool? = nil
    )
    {
        self.apiId = apiId
        self.basepath = basepath
        self.body = body
        self.failOnWarnings = failOnWarnings
    }
}

struct ReimportApiInputBody: Swift.Equatable {
    let body: Swift.String?
}

extension ReimportApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ReimportApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReimportApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReimportApiOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReimportApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReimportApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = nil
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = nil
            self.disableSchemaValidation = nil
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct ReimportApiOutputResponse: Swift.Equatable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init (
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct ReimportApiOutputResponseBody: Swift.Equatable {
    let apiEndpoint: Swift.String?
    let apiGatewayManaged: Swift.Bool?
    let apiId: Swift.String?
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let importInfo: [Swift.String]?
    let name: Swift.String?
    let protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    let routeSelectionExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let version: Swift.String?
    let warnings: [Swift.String]?
}

extension ReimportApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importInfo)
        var importInfoDecoded0:[Swift.String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [Swift.String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension ResetAuthorizersCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/cache/authorizers"
    }
}

public struct ResetAuthorizersCacheInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be $default. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

struct ResetAuthorizersCacheInputBody: Swift.Equatable {
}

extension ResetAuthorizersCacheInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResetAuthorizersCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetAuthorizersCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetAuthorizersCacheOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetAuthorizersCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResetAuthorizersCacheOutputResponse: Swift.Equatable {

}

extension ApiGatewayV2ClientTypes.Route: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeId = "routeId"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayManaged = apiGatewayManaged {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if let apiKeyRequired = apiKeyRequired {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for authorizationscopes0 in authorizationScopes {
                try authorizationScopesContainer.encode(authorizationscopes0)
            }
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let authorizerId = authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let modelSelectionExpression = modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let operationName = operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestModels)
            for (dictKey0, routemodels0) in requestModels {
                try requestModelsContainer.encode(routemodels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, routeparameters0) in requestParameters {
                try requestParametersContainer.encode(routeparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeId = routeId {
            try encodeContainer.encode(routeId, forKey: .routeId)
        }
        if let routeKey = routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeResponseSelectionExpression = routeResponseSelectionExpression {
            try encodeContainer.encode(routeResponseSelectionExpression, forKey: .routeResponseSelectionExpression)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a route.
    public struct Route: Swift.Equatable {
        /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
        public var apiGatewayManaged: Swift.Bool?
        /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
        public var apiKeyRequired: Swift.Bool?
        /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
        public var authorizationScopes: [Swift.String]?
        /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
        public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
        /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
        public var authorizerId: Swift.String?
        /// The model selection expression for the route. Supported only for WebSocket APIs.
        public var modelSelectionExpression: Swift.String?
        /// The operation name for the route.
        public var operationName: Swift.String?
        /// The request models for the route. Supported only for WebSocket APIs.
        public var requestModels: [Swift.String:Swift.String]?
        /// The request parameters for the route. Supported only for WebSocket APIs.
        public var requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
        /// The route ID.
        public var routeId: Swift.String?
        /// The route key for the route.
        /// This member is required.
        public var routeKey: Swift.String?
        /// The route response selection expression for the route. Supported only for WebSocket APIs.
        public var routeResponseSelectionExpression: Swift.String?
        /// The target for the route.
        public var target: Swift.String?

        public init (
            apiGatewayManaged: Swift.Bool? = nil,
            apiKeyRequired: Swift.Bool? = nil,
            authorizationScopes: [Swift.String]? = nil,
            authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
            authorizerId: Swift.String? = nil,
            modelSelectionExpression: Swift.String? = nil,
            operationName: Swift.String? = nil,
            requestModels: [Swift.String:Swift.String]? = nil,
            requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
            routeId: Swift.String? = nil,
            routeKey: Swift.String? = nil,
            routeResponseSelectionExpression: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.apiGatewayManaged = apiGatewayManaged
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.modelSelectionExpression = modelSelectionExpression
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.routeId = routeId
            self.routeKey = routeKey
            self.routeResponseSelectionExpression = routeResponseSelectionExpression
            self.target = target
        }
    }

}

extension ApiGatewayV2ClientTypes.RouteResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseId = "routeResponseId"
        case routeResponseKey = "routeResponseKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelSelectionExpression = modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseModels)
            for (dictKey0, routemodels0) in responseModels {
                try responseModelsContainer.encode(routemodels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, routeparameters0) in responseParameters {
                try responseParametersContainer.encode(routeparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeResponseId = routeResponseId {
            try encodeContainer.encode(routeResponseId, forKey: .routeResponseId)
        }
        if let routeResponseKey = routeResponseKey {
            try encodeContainer.encode(routeResponseKey, forKey: .routeResponseKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseId)
        routeResponseId = routeResponseIdDecoded
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a route response.
    public struct RouteResponse: Swift.Equatable {
        /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
        public var modelSelectionExpression: Swift.String?
        /// Represents the response models of a route response.
        public var responseModels: [Swift.String:Swift.String]?
        /// Represents the response parameters of a route response.
        public var responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
        /// Represents the identifier of a route response.
        public var routeResponseId: Swift.String?
        /// Represents the route response key of a route response.
        /// This member is required.
        public var routeResponseKey: Swift.String?

        public init (
            modelSelectionExpression: Swift.String? = nil,
            responseModels: [Swift.String:Swift.String]? = nil,
            responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
            routeResponseId: Swift.String? = nil,
            routeResponseKey: Swift.String? = nil
        )
        {
            self.modelSelectionExpression = modelSelectionExpression
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.routeResponseId = routeResponseId
            self.routeResponseKey = routeResponseKey
        }
    }

}

extension ApiGatewayV2ClientTypes.RouteSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTraceEnabled = "dataTraceEnabled"
        case detailedMetricsEnabled = "detailedMetricsEnabled"
        case loggingLevel = "loggingLevel"
        case throttlingBurstLimit = "throttlingBurstLimit"
        case throttlingRateLimit = "throttlingRateLimit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTraceEnabled = dataTraceEnabled {
            try encodeContainer.encode(dataTraceEnabled, forKey: .dataTraceEnabled)
        }
        if let detailedMetricsEnabled = detailedMetricsEnabled {
            try encodeContainer.encode(detailedMetricsEnabled, forKey: .detailedMetricsEnabled)
        }
        if let loggingLevel = loggingLevel {
            try encodeContainer.encode(loggingLevel.rawValue, forKey: .loggingLevel)
        }
        if let throttlingBurstLimit = throttlingBurstLimit {
            try encodeContainer.encode(throttlingBurstLimit, forKey: .throttlingBurstLimit)
        }
        if let throttlingRateLimit = throttlingRateLimit {
            try encodeContainer.encode(throttlingRateLimit, forKey: .throttlingRateLimit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTraceEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataTraceEnabled)
        dataTraceEnabled = dataTraceEnabledDecoded
        let detailedMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .detailedMetricsEnabled)
        detailedMetricsEnabled = detailedMetricsEnabledDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.LoggingLevel.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let throttlingBurstLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throttlingBurstLimit)
        throttlingBurstLimit = throttlingBurstLimitDecoded
        let throttlingRateLimitDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .throttlingRateLimit)
        throttlingRateLimit = throttlingRateLimitDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a collection of route settings.
    public struct RouteSettings: Swift.Equatable {
        /// Specifies whether (true) or not (false) data trace logging is enabled for this route. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.
        public var dataTraceEnabled: Swift.Bool?
        /// Specifies whether detailed metrics are enabled.
        public var detailedMetricsEnabled: Swift.Bool?
        /// Specifies the logging level for this route: INFO, ERROR, or OFF. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.
        public var loggingLevel: ApiGatewayV2ClientTypes.LoggingLevel?
        /// Specifies the throttling burst limit.
        public var throttlingBurstLimit: Swift.Int?
        /// Specifies the throttling rate limit.
        public var throttlingRateLimit: Swift.Double?

        public init (
            dataTraceEnabled: Swift.Bool? = nil,
            detailedMetricsEnabled: Swift.Bool? = nil,
            loggingLevel: ApiGatewayV2ClientTypes.LoggingLevel? = nil,
            throttlingBurstLimit: Swift.Int? = nil,
            throttlingRateLimit: Swift.Double? = nil
        )
        {
            self.dataTraceEnabled = dataTraceEnabled
            self.detailedMetricsEnabled = detailedMetricsEnabled
            self.loggingLevel = loggingLevel
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are TLS_1_0 and TLS_1_2.
    public enum SecurityPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tls10
        case tls12
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicy] {
            return [
                .tls10,
                .tls12,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tls10: return "TLS_1_0"
            case .tls12: return "TLS_1_2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SecurityPolicy(rawValue: rawValue) ?? SecurityPolicy.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes.Stage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case apiGatewayManaged = "apiGatewayManaged"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case createdDate = "createdDate"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
        case lastUpdatedDate = "lastUpdatedDate"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if let apiGatewayManaged = apiGatewayManaged {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if let autoDeploy = autoDeploy {
            try encodeContainer.encode(autoDeploy, forKey: .autoDeploy)
        }
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let defaultRouteSettings = defaultRouteSettings {
            try encodeContainer.encode(defaultRouteSettings, forKey: .defaultRouteSettings)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastDeploymentStatusMessage = lastDeploymentStatusMessage {
            try encodeContainer.encode(lastDeploymentStatusMessage, forKey: .lastDeploymentStatusMessage)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate.timeIntervalSince1970, forKey: .lastUpdatedDate)
        }
        if let routeSettings = routeSettings {
            var routeSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .routeSettings)
            for (dictKey0, routesettingsmap0) in routeSettings {
                try routeSettingsContainer.encode(routesettingsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariables)
            for (dictKey0, stagevariablesmap0) in stageVariables {
                try stageVariablesContainer.encode(stagevariablesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an API stage.
    public struct Stage: Swift.Equatable {
        /// Settings for logging access in this stage.
        public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
        /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
        public var apiGatewayManaged: Swift.Bool?
        /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
        public var autoDeploy: Swift.Bool?
        /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
        public var clientCertificateId: Swift.String?
        /// The timestamp when the stage was created.
        public var createdDate: ClientRuntime.Date?
        /// Default route settings for the stage.
        public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
        /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
        public var deploymentId: Swift.String?
        /// The description of the stage.
        public var description: Swift.String?
        /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
        public var lastDeploymentStatusMessage: Swift.String?
        /// The timestamp when the stage was last updated.
        public var lastUpdatedDate: ClientRuntime.Date?
        /// Route settings for the stage, by routeKey.
        public var routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
        /// The name of the stage.
        /// This member is required.
        public var stageName: Swift.String?
        /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
        public var stageVariables: [Swift.String:Swift.String]?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
            apiGatewayManaged: Swift.Bool? = nil,
            autoDeploy: Swift.Bool? = nil,
            clientCertificateId: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
            deploymentId: Swift.String? = nil,
            description: Swift.String? = nil,
            lastDeploymentStatusMessage: Swift.String? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil,
            stageName: Swift.String? = nil,
            stageVariables: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.accessLogSettings = accessLogSettings
            self.apiGatewayManaged = apiGatewayManaged
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
            self.lastUpdatedDate = lastUpdatedDate
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
            self.tags = tags
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v2/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// Creates a new Tag resource to represent a tag.
public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN for the tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ApiGatewayV2ClientTypes.TlsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverNameToVerify = "serverNameToVerify"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverNameToVerify = serverNameToVerify {
            try encodeContainer.encode(serverNameToVerify, forKey: .serverNameToVerify)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameToVerifyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverNameToVerify)
        serverNameToVerify = serverNameToVerifyDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public struct TlsConfig: Swift.Equatable {
        /// If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
        public var serverNameToVerify: Swift.String?

        public init (
            serverNameToVerify: Swift.String? = nil
        )
        {
            self.serverNameToVerify = serverNameToVerify
        }
    }

}

extension ApiGatewayV2ClientTypes.TlsConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverNameToVerify = "serverNameToVerify"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverNameToVerify = serverNameToVerify {
            try encodeContainer.encode(serverNameToVerify, forKey: .serverNameToVerify)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameToVerifyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverNameToVerify)
        serverNameToVerify = serverNameToVerifyDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public struct TlsConfigInput: Swift.Equatable {
        /// If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
        public var serverNameToVerify: Swift.String?

        public init (
            serverNameToVerify: Swift.String? = nil
        )
        {
            self.serverNameToVerify = serverNameToVerify
        }
    }

}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limitType = output.limitType
            self.message = output.message
        } else {
            self.limitType = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A limit has been exceeded. See the accompanying error message for details.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The limit type.
    public var limitType: Swift.String?
    /// Describes the error encountered.
    public var message: Swift.String?

    public init (
        limitType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.limitType = limitType
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let limitType: Swift.String?
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitType = "limitType"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v2/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN for the tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The Tag keys to delete
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case name = "name"
        case routeKey = "routeKey"
        case routeSelectionExpression = "routeSelectionExpression"
        case target = "target"
        case version = "version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySelectionExpression = apiKeySelectionExpression {
            try encodeContainer.encode(apiKeySelectionExpression, forKey: .apiKeySelectionExpression)
        }
        if let corsConfiguration = corsConfiguration {
            try encodeContainer.encode(corsConfiguration, forKey: .corsConfiguration)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disableExecuteApiEndpoint = disableExecuteApiEndpoint {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if let disableSchemaValidation = disableSchemaValidation {
            try encodeContainer.encode(disableSchemaValidation, forKey: .disableSchemaValidation)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let routeKey = routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeSelectionExpression = routeSelectionExpression {
            try encodeContainer.encode(routeSelectionExpression, forKey: .routeSelectionExpression)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension UpdateApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

/// Updates an Api.
public struct UpdateApiInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, don't specify this parameter. Currently, this property is not used for HTTP integrations. If provided, this value replaces the credentials associated with the quick create integration. Supported only for HTTP APIs.
    public var credentialsArn: Swift.String?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The name of the API.
    public var name: Swift.String?
    /// This property is part of quick create. If not specified, the route created using quick create is kept. Otherwise, this value replaces the route key of the quick create route. Additional routes may still be added after the API is updated. Supported only for HTTP APIs.
    public var routeKey: Swift.String?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// This property is part of quick create. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. The value provided updates the integration URI and integration type. You can update a quick-created target, but you can't remove it from an API. Supported only for HTTP APIs.
    public var target: Swift.String?
    /// A version identifier for the API.
    public var version: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        name: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.credentialsArn = credentialsArn
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.name = name
        self.routeKey = routeKey
        self.routeSelectionExpression = routeSelectionExpression
        self.target = target
        self.version = version
    }
}

struct UpdateApiInputBody: Swift.Equatable {
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let name: Swift.String?
    let routeKey: Swift.String?
    let routeSelectionExpression: Swift.String?
    let target: Swift.String?
    let version: Swift.String?
}

extension UpdateApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case name = "name"
        case routeKey = "routeKey"
        case routeSelectionExpression = "routeSelectionExpression"
        case target = "target"
        case version = "version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension UpdateApiMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiMappingKey = apiMappingKey {
            try encodeContainer.encode(apiMappingKey, forKey: .apiMappingKey)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }
}

extension UpdateApiMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let apiMappingId = apiMappingId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings/\(apiMappingId.urlPercentEncoding())"
    }
}

/// Updates an ApiMapping.
public struct UpdateApiMappingInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    /// This member is required.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        domainName: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.domainName = domainName
        self.stage = stage
    }
}

struct UpdateApiMappingInputBody: Swift.Equatable {
    let apiId: Swift.String?
    let apiMappingKey: Swift.String?
    let stage: Swift.String?
}

extension UpdateApiMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension UpdateApiMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiMappingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApiMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiId = output.apiId
            self.apiMappingId = output.apiMappingId
            self.apiMappingKey = output.apiMappingKey
            self.stage = output.stage
        } else {
            self.apiId = nil
            self.apiMappingId = nil
            self.apiMappingKey = nil
            self.stage = nil
        }
    }
}

public struct UpdateApiMappingOutputResponse: Swift.Equatable {
    /// The API identifier.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

struct UpdateApiMappingOutputResponseBody: Swift.Equatable {
    let apiId: Swift.String?
    let apiMappingId: Swift.String?
    let apiMappingKey: Swift.String?
    let stage: Swift.String?
}

extension UpdateApiMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingId = "apiMappingId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingId)
        apiMappingId = apiMappingIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension UpdateApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = nil
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = nil
            self.disableSchemaValidation = nil
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct UpdateApiOutputResponse: Swift.Equatable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init (
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct UpdateApiOutputResponseBody: Swift.Equatable {
    let apiEndpoint: Swift.String?
    let apiGatewayManaged: Swift.Bool?
    let apiId: Swift.String?
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let importInfo: [Swift.String]?
    let name: Swift.String?
    let protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    let routeSelectionExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let version: Swift.String?
    let warnings: [Swift.String]?
}

extension UpdateApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importInfo)
        var importInfoDecoded0:[Swift.String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [Swift.String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension UpdateAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerCredentialsArn = authorizerCredentialsArn {
            try encodeContainer.encode(authorizerCredentialsArn, forKey: .authorizerCredentialsArn)
        }
        if let authorizerPayloadFormatVersion = authorizerPayloadFormatVersion {
            try encodeContainer.encode(authorizerPayloadFormatVersion, forKey: .authorizerPayloadFormatVersion)
        }
        if let authorizerResultTtlInSeconds = authorizerResultTtlInSeconds {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerType = authorizerType {
            try encodeContainer.encode(authorizerType.rawValue, forKey: .authorizerType)
        }
        if let authorizerUri = authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let enableSimpleResponses = enableSimpleResponses {
            try encodeContainer.encode(enableSimpleResponses, forKey: .enableSimpleResponses)
        }
        if let identitySource = identitySource {
            var identitySourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identitySource)
            for identitysourcelist0 in identitySource {
                try identitySourceContainer.encode(identitysourcelist0)
            }
        }
        if let identityValidationExpression = identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let jwtConfiguration = jwtConfiguration {
            try encodeContainer.encode(jwtConfiguration, forKey: .jwtConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

/// Updates an Authorizer.
public struct UpdateAuthorizerInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// This parameter is not used.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct UpdateAuthorizerInputBody: Swift.Equatable {
    let authorizerCredentialsArn: Swift.String?
    let authorizerPayloadFormatVersion: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
    let authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    let authorizerUri: Swift.String?
    let enableSimpleResponses: Swift.Bool?
    let identitySource: [Swift.String]?
    let identityValidationExpression: Swift.String?
    let jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    let name: Swift.String?
}

extension UpdateAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[Swift.String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [Swift.String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateAuthorizerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAuthorizerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAuthorizerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAuthorizerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorizerCredentialsArn = output.authorizerCredentialsArn
            self.authorizerId = output.authorizerId
            self.authorizerPayloadFormatVersion = output.authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerType = output.authorizerType
            self.authorizerUri = output.authorizerUri
            self.enableSimpleResponses = output.enableSimpleResponses
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.jwtConfiguration = output.jwtConfiguration
            self.name = output.name
        } else {
            self.authorizerCredentialsArn = nil
            self.authorizerId = nil
            self.authorizerPayloadFormatVersion = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerType = nil
            self.authorizerUri = nil
            self.enableSimpleResponses = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.jwtConfiguration = nil
            self.name = nil
        }
    }
}

public struct UpdateAuthorizerOutputResponse: Swift.Equatable {
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init (
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct UpdateAuthorizerOutputResponseBody: Swift.Equatable {
    let authorizerCredentialsArn: Swift.String?
    let authorizerId: Swift.String?
    let authorizerPayloadFormatVersion: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
    let authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    let authorizerUri: Swift.String?
    let enableSimpleResponses: Swift.Bool?
    let identitySource: [Swift.String]?
    let identityValidationExpression: Swift.String?
    let jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    let name: Swift.String?
}

extension UpdateAuthorizerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerId = "authorizerId"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[Swift.String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [Swift.String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

/// Updates a Deployment.
public struct UpdateDeploymentInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The deployment ID.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The description for the deployment resource.
    public var description: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.deploymentId = deploymentId
        self.description = description
    }
}

struct UpdateDeploymentInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoDeployed = output.autoDeployed
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.deploymentStatus = output.deploymentStatus
            self.deploymentStatusMessage = output.deploymentStatusMessage
            self.description = output.description
        } else {
            self.autoDeployed = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.deploymentStatus = nil
            self.deploymentStatusMessage = nil
            self.description = nil
        }
    }
}

public struct UpdateDeploymentOutputResponse: Swift.Equatable {
    /// Specifies whether a deployment was automatically released.
    public var autoDeployed: Swift.Bool?
    /// The date and time when the Deployment resource was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier for the deployment.
    public var deploymentId: Swift.String?
    /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
    public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    /// May contain additional feedback on the status of an API deployment.
    public var deploymentStatusMessage: Swift.String?
    /// The description for the deployment.
    public var description: Swift.String?

    public init (
        autoDeployed: Swift.Bool? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
        deploymentStatusMessage: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

struct UpdateDeploymentOutputResponseBody: Swift.Equatable {
    let autoDeployed: Swift.Bool?
    let createdDate: ClientRuntime.Date?
    let deploymentId: Swift.String?
    let deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    let deploymentStatusMessage: Swift.String?
    let description: Swift.String?
}

extension UpdateDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoDeployed = "autoDeployed"
        case createdDate = "createdDate"
        case deploymentId = "deploymentId"
        case deploymentStatus = "deploymentStatus"
        case deploymentStatusMessage = "deploymentStatusMessage"
        case description = "description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoDeployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeployed)
        autoDeployed = autoDeployedDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDomainNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainNameConfigurations = domainNameConfigurations {
            var domainNameConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainNameConfigurations)
            for domainnameconfigurations0 in domainNameConfigurations {
                try domainNameConfigurationsContainer.encode(domainnameconfigurations0)
            }
        }
        if let mutualTlsAuthentication = mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
    }
}

extension UpdateDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())"
    }
}

/// Updates a DomainName.
public struct UpdateDomainNameInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?

    public init (
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput? = nil
    )
    {
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
    }
}

struct UpdateDomainNameInputBody: Swift.Equatable {
    let domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    let mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?
}

extension UpdateDomainNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [ApiGatewayV2ClientTypes.DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
    }
}

extension UpdateDomainNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainNameOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiMappingSelectionExpression = output.apiMappingSelectionExpression
            self.domainName = output.domainName
            self.domainNameConfigurations = output.domainNameConfigurations
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.tags = output.tags
        } else {
            self.apiMappingSelectionExpression = nil
            self.domainName = nil
            self.domainNameConfigurations = nil
            self.mutualTlsAuthentication = nil
            self.tags = nil
        }
    }
}

public struct UpdateDomainNameOutputResponse: Swift.Equatable {
    /// The API mapping selection expression.
    public var apiMappingSelectionExpression: Swift.String?
    /// The name of the DomainName resource.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String:Swift.String]?

    public init (
        apiMappingSelectionExpression: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

struct UpdateDomainNameOutputResponseBody: Swift.Equatable {
    let apiMappingSelectionExpression: Swift.String?
    let domainName: Swift.String?
    let domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    let mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateDomainNameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMappingSelectionExpression = "apiMappingSelectionExpression"
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiMappingSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingSelectionExpression)
        apiMappingSelectionExpression = apiMappingSelectionExpressionDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [ApiGatewayV2ClientTypes.DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationMethod = "integrationMethod"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandlingStrategy = contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationMethod = integrationMethod {
            try encodeContainer.encode(integrationMethod, forKey: .integrationMethod)
        }
        if let integrationSubtype = integrationSubtype {
            try encodeContainer.encode(integrationSubtype, forKey: .integrationSubtype)
        }
        if let integrationType = integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let integrationUri = integrationUri {
            try encodeContainer.encode(integrationUri, forKey: .integrationUri)
        }
        if let passthroughBehavior = passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior.rawValue, forKey: .passthroughBehavior)
        }
        if let payloadFormatVersion = payloadFormatVersion {
            try encodeContainer.encode(payloadFormatVersion, forKey: .payloadFormatVersion)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, integrationparameters0) in requestParameters {
                try requestParametersContainer.encode(integrationparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestTemplates)
            for (dictKey0, templatemap0) in requestTemplates {
                try requestTemplatesContainer.encode(templatemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, responseparameters0) in responseParameters {
                try responseParametersContainer.encode(responseparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
        if let timeoutInMillis = timeoutInMillis {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
    }
}

extension UpdateIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())"
    }
}

/// Updates an Integration.
public struct UpdateIntegrationInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// The description of the integration
    public var description: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an HTTP_PROXY integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern <action>:<header|querystring|path>.<location> where action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.).
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The template selection expression for the integration.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput?

    public init (
        apiId: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput? = nil
    )
    {
        self.apiId = apiId
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct UpdateIntegrationInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let integrationMethod: Swift.String?
    let integrationSubtype: Swift.String?
    let integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    let integrationUri: Swift.String?
    let passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    let payloadFormatVersion: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    let templateSelectionExpression: Swift.String?
    let timeoutInMillis: Swift.Int?
    let tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput?
}

extension UpdateIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationMethod = "integrationMethod"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [Swift.String: Swift.String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.TlsConfigInput.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension UpdateIntegrationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIntegrationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIntegrationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIntegrationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.credentialsArn = output.credentialsArn
            self.description = output.description
            self.integrationId = output.integrationId
            self.integrationMethod = output.integrationMethod
            self.integrationResponseSelectionExpression = output.integrationResponseSelectionExpression
            self.integrationSubtype = output.integrationSubtype
            self.integrationType = output.integrationType
            self.integrationUri = output.integrationUri
            self.passthroughBehavior = output.passthroughBehavior
            self.payloadFormatVersion = output.payloadFormatVersion
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.responseParameters = output.responseParameters
            self.templateSelectionExpression = output.templateSelectionExpression
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
        } else {
            self.apiGatewayManaged = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandlingStrategy = nil
            self.credentialsArn = nil
            self.description = nil
            self.integrationId = nil
            self.integrationMethod = nil
            self.integrationResponseSelectionExpression = nil
            self.integrationSubtype = nil
            self.integrationType = nil
            self.integrationUri = nil
            self.passthroughBehavior = nil
            self.payloadFormatVersion = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.responseParameters = nil
            self.templateSelectionExpression = nil
            self.timeoutInMillis = nil
            self.tlsConfig = nil
        }
    }
}

public struct UpdateIntegrationOutputResponse: Swift.Equatable {
    /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
    public var apiGatewayManaged: Swift.Bool?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// Represents the description of an integration.
    public var description: Swift.String?
    /// Represents the identifier of an integration.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
    public var integrationResponseSelectionExpression: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API itegrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The template selection expression for the integration. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

    public init (
        apiGatewayManaged: Swift.Bool? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationResponseSelectionExpression: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct UpdateIntegrationOutputResponseBody: Swift.Equatable {
    let apiGatewayManaged: Swift.Bool?
    let connectionId: Swift.String?
    let connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let integrationId: Swift.String?
    let integrationMethod: Swift.String?
    let integrationResponseSelectionExpression: Swift.String?
    let integrationSubtype: Swift.String?
    let integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    let integrationUri: Swift.String?
    let passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    let payloadFormatVersion: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    let templateSelectionExpression: Swift.String?
    let timeoutInMillis: Swift.Int?
    let tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?
}

extension UpdateIntegrationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationId = "integrationId"
        case integrationMethod = "integrationMethod"
        case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let integrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationId)
        integrationId = integrationIdDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseSelectionExpression)
        integrationResponseSelectionExpression = integrationResponseSelectionExpressionDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [Swift.String: Swift.String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension UpdateIntegrationResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandlingStrategy = contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let integrationResponseKey = integrationResponseKey {
            try encodeContainer.encode(integrationResponseKey, forKey: .integrationResponseKey)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, integrationparameters0) in responseParameters {
                try responseParametersContainer.encode(integrationparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, templatemap0) in responseTemplates {
                try responseTemplatesContainer.encode(templatemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
    }
}

extension UpdateIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        guard let integrationResponseId = integrationResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses/\(integrationResponseId.urlPercentEncoding())"
    }
}

/// Updates an IntegrationResponses.
public struct UpdateIntegrationResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response ID.
    /// This member is required.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name} , where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression} , where {name} is a valid and unique response header name and {JSON-expression} is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The template selection expression for the integration response. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct UpdateIntegrationResponseInputBody: Swift.Equatable {
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let integrationResponseKey: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let templateSelectionExpression: Swift.String?
}

extension UpdateIntegrationResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension UpdateIntegrationResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIntegrationResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIntegrationResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIntegrationResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateIntegrationResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.integrationResponseId = output.integrationResponseId
            self.integrationResponseKey = output.integrationResponseKey
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.templateSelectionExpression = output.templateSelectionExpression
        } else {
            self.contentHandlingStrategy = nil
            self.integrationResponseId = nil
            self.integrationResponseKey = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.templateSelectionExpression = nil
        }
    }
}

public struct UpdateIntegrationResponseOutputResponse: Swift.Equatable {
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration response ID.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The template selection expressions for the integration response.
    public var templateSelectionExpression: Swift.String?

    public init (
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct UpdateIntegrationResponseOutputResponseBody: Swift.Equatable {
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let integrationResponseId: Swift.String?
    let integrationResponseKey: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let templateSelectionExpression: Swift.String?
}

extension UpdateIntegrationResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseId = "integrationResponseId"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseId)
        integrationResponseId = integrationResponseIdDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension UpdateModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case name = "name"
        case schema = "schema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

extension UpdateModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let modelId = modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())"
    }
}

/// Updates a Model.
public struct UpdateModelInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The name of the model.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

struct UpdateModelInputBody: Swift.Equatable {
    let contentType: Swift.String?
    let description: Swift.String?
    let name: Swift.String?
    let schema: Swift.String?
}

extension UpdateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case name = "name"
        case schema = "schema"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension UpdateModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateModelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentType = output.contentType
            self.description = output.description
            self.modelId = output.modelId
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.modelId = nil
            self.name = nil
            self.schema = nil
        }
    }
}

public struct UpdateModelOutputResponse: Swift.Equatable {
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model identifier.
    public var modelId: Swift.String?
    /// The name of the model. Must be alphanumeric.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init (
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

struct UpdateModelOutputResponseBody: Swift.Equatable {
    let contentType: Swift.String?
    let description: Swift.String?
    let modelId: Swift.String?
    let name: Swift.String?
    let schema: Swift.String?
}

extension UpdateModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case modelId = "modelId"
        case name = "name"
        case schema = "schema"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension UpdateRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyRequired = apiKeyRequired {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for authorizationscopes0 in authorizationScopes {
                try authorizationScopesContainer.encode(authorizationscopes0)
            }
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let authorizerId = authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let modelSelectionExpression = modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let operationName = operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestModels)
            for (dictKey0, routemodels0) in requestModels {
                try requestModelsContainer.encode(routemodels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, routeparameters0) in requestParameters {
                try requestParametersContainer.encode(routeparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeKey = routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeResponseSelectionExpression = routeResponseSelectionExpression {
            try encodeContainer.encode(routeResponseSelectionExpression, forKey: .routeResponseSelectionExpression)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension UpdateRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())"
    }
}

/// Updates a Route.
public struct UpdateRouteInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether an API key is required for the route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// The authorization scopes supported by this route.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String:Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct UpdateRouteInputBody: Swift.Equatable {
    let apiKeyRequired: Swift.Bool?
    let authorizationScopes: [Swift.String]?
    let authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    let authorizerId: Swift.String?
    let modelSelectionExpression: Swift.String?
    let operationName: Swift.String?
    let requestModels: [Swift.String:Swift.String]?
    let requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeKey: Swift.String?
    let routeResponseSelectionExpression: Swift.String?
    let target: Swift.String?
}

extension UpdateRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension UpdateRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRouteOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRouteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.modelSelectionExpression = output.modelSelectionExpression
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.routeId = output.routeId
            self.routeKey = output.routeKey
            self.routeResponseSelectionExpression = output.routeResponseSelectionExpression
            self.target = output.target
        } else {
            self.apiGatewayManaged = nil
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.modelSelectionExpression = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.routeId = nil
            self.routeKey = nil
            self.routeResponseSelectionExpression = nil
            self.target = nil
        }
    }
}

public struct UpdateRouteOutputResponse: Swift.Equatable {
    /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String:Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init (
        apiGatewayManaged: Swift.Bool? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct UpdateRouteOutputResponseBody: Swift.Equatable {
    let apiGatewayManaged: Swift.Bool?
    let apiKeyRequired: Swift.Bool?
    let authorizationScopes: [Swift.String]?
    let authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    let authorizerId: Swift.String?
    let modelSelectionExpression: Swift.String?
    let operationName: Swift.String?
    let requestModels: [Swift.String:Swift.String]?
    let requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeId: Swift.String?
    let routeKey: Swift.String?
    let routeResponseSelectionExpression: Swift.String?
    let target: Swift.String?
}

extension UpdateRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeId = "routeId"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension UpdateRouteResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseKey = "routeResponseKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelSelectionExpression = modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseModels)
            for (dictKey0, routemodels0) in responseModels {
                try responseModelsContainer.encode(routemodels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, routeparameters0) in responseParameters {
                try responseParametersContainer.encode(routeparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeResponseKey = routeResponseKey {
            try encodeContainer.encode(routeResponseKey, forKey: .routeResponseKey)
        }
    }
}

extension UpdateRouteResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        guard let routeResponseId = routeResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses/\(routeResponseId.urlPercentEncoding())"
    }
}

/// Updates a RouteResponse.
public struct UpdateRouteResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model selection expression for the route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The response models for the route response.
    public var responseModels: [Swift.String:Swift.String]?
    /// The route response parameters.
    public var responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response ID.
    /// This member is required.
    public var routeResponseId: Swift.String?
    /// The route response key.
    public var routeResponseKey: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeId = routeId
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

struct UpdateRouteResponseInputBody: Swift.Equatable {
    let modelSelectionExpression: Swift.String?
    let responseModels: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeResponseKey: Swift.String?
}

extension UpdateRouteResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseKey = "routeResponseKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension UpdateRouteResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRouteResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRouteResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRouteResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRouteResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelSelectionExpression = output.modelSelectionExpression
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.routeResponseId = output.routeResponseId
            self.routeResponseKey = output.routeResponseKey
        } else {
            self.modelSelectionExpression = nil
            self.responseModels = nil
            self.responseParameters = nil
            self.routeResponseId = nil
            self.routeResponseKey = nil
        }
    }
}

public struct UpdateRouteResponseOutputResponse: Swift.Equatable {
    /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// Represents the response models of a route response.
    public var responseModels: [Swift.String:Swift.String]?
    /// Represents the response parameters of a route response.
    public var responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// Represents the identifier of a route response.
    public var routeResponseId: Swift.String?
    /// Represents the route response key of a route response.
    public var routeResponseKey: Swift.String?

    public init (
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

struct UpdateRouteResponseOutputResponseBody: Swift.Equatable {
    let modelSelectionExpression: Swift.String?
    let responseModels: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeResponseId: Swift.String?
    let routeResponseKey: Swift.String?
}

extension UpdateRouteResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseId = "routeResponseId"
        case routeResponseKey = "routeResponseKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseId)
        routeResponseId = routeResponseIdDecoded
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension UpdateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case routeSettings = "routeSettings"
        case stageVariables = "stageVariables"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if let autoDeploy = autoDeploy {
            try encodeContainer.encode(autoDeploy, forKey: .autoDeploy)
        }
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let defaultRouteSettings = defaultRouteSettings {
            try encodeContainer.encode(defaultRouteSettings, forKey: .defaultRouteSettings)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routeSettings = routeSettings {
            var routeSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .routeSettings)
            for (dictKey0, routesettingsmap0) in routeSettings {
                try routeSettingsContainer.encode(routesettingsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariables)
            for (dictKey0, stagevariablesmap0) in stageVariables {
                try stageVariablesContainer.encode(stagevariablesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

/// Updates a Stage.
public struct UpdateStageInput: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage.
    public var clientCertificateId: Swift.String?
    /// The default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The deployment identifier for the API stage. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description for the API stage.
    public var description: Swift.String?
    /// Route settings for the stage.
    public var routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    /// The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be $default. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a Stage. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String:Swift.String]?

    public init (
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiId: Swift.String? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiId = apiId
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
    }
}

struct UpdateStageInputBody: Swift.Equatable {
    let accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    let autoDeploy: Swift.Bool?
    let clientCertificateId: Swift.String?
    let defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    let deploymentId: Swift.String?
    let description: Swift.String?
    let routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    let stageVariables: [Swift.String:Swift.String]?
}

extension UpdateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case routeSettings = "routeSettings"
        case stageVariables = "stageVariables"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
    }
}

extension UpdateStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessLogSettings = output.accessLogSettings
            self.apiGatewayManaged = output.apiGatewayManaged
            self.autoDeploy = output.autoDeploy
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.defaultRouteSettings = output.defaultRouteSettings
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.lastDeploymentStatusMessage = output.lastDeploymentStatusMessage
            self.lastUpdatedDate = output.lastUpdatedDate
            self.routeSettings = output.routeSettings
            self.stageName = output.stageName
            self.stageVariables = output.stageVariables
            self.tags = output.tags
        } else {
            self.accessLogSettings = nil
            self.apiGatewayManaged = nil
            self.autoDeploy = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.defaultRouteSettings = nil
            self.deploymentId = nil
            self.description = nil
            self.lastDeploymentStatusMessage = nil
            self.lastUpdatedDate = nil
            self.routeSettings = nil
            self.stageName = nil
            self.stageVariables = nil
            self.tags = nil
        }
    }
}

public struct UpdateStageOutputResponse: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: ClientRuntime.Date?
    /// Default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
    public var lastDeploymentStatusMessage: Swift.String?
    /// The timestamp when the stage was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String:Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        lastDeploymentStatusMessage: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

struct UpdateStageOutputResponseBody: Swift.Equatable {
    let accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    let apiGatewayManaged: Swift.Bool?
    let autoDeploy: Swift.Bool?
    let clientCertificateId: Swift.String?
    let createdDate: ClientRuntime.Date?
    let defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    let deploymentId: Swift.String?
    let description: Swift.String?
    let lastDeploymentStatusMessage: Swift.String?
    let lastUpdatedDate: ClientRuntime.Date?
    let routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    let stageName: Swift.String?
    let stageVariables: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateStageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case apiGatewayManaged = "apiGatewayManaged"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case createdDate = "createdDate"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
        case lastUpdatedDate = "lastUpdatedDate"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateVpcLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vpcLinkId = vpcLinkId else {
            return nil
        }
        return "/v2/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

/// Updates a VPC link.
public struct UpdateVpcLinkInput: Swift.Equatable {
    /// The name of the VPC link.
    public var name: Swift.String?
    /// The ID of the VPC link.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init (
        name: Swift.String? = nil,
        vpcLinkId: Swift.String? = nil
    )
    {
        self.name = name
        self.vpcLinkId = vpcLinkId
    }
}

struct UpdateVpcLinkInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateVpcLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateVpcLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVpcLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVpcLinkOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVpcLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateVpcLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.name = output.name
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.vpcLinkId = output.vpcLinkId
            self.vpcLinkStatus = output.vpcLinkStatus
            self.vpcLinkStatusMessage = output.vpcLinkStatusMessage
            self.vpcLinkVersion = output.vpcLinkVersion
        } else {
            self.createdDate = nil
            self.name = nil
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.tags = nil
            self.vpcLinkId = nil
            self.vpcLinkStatus = nil
            self.vpcLinkStatusMessage = nil
            self.vpcLinkVersion = nil
        }
    }
}

public struct UpdateVpcLinkOutputResponse: Swift.Equatable {
    /// The timestamp when the VPC link was created.
    public var createdDate: ClientRuntime.Date?
    /// The name of the VPC link.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    public var subnetIds: [Swift.String]?
    /// Tags for the VPC link.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the VPC link.
    public var vpcLinkId: Swift.String?
    /// The status of the VPC link.
    public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    /// A message summarizing the cause of the status of the VPC link.
    public var vpcLinkStatusMessage: Swift.String?
    /// The version of the VPC link.
    public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

    public init (
        createdDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcLinkId: Swift.String? = nil,
        vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
        vpcLinkStatusMessage: Swift.String? = nil,
        vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

struct UpdateVpcLinkOutputResponseBody: Swift.Equatable {
    let createdDate: ClientRuntime.Date?
    let name: Swift.String?
    let securityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let vpcLinkId: Swift.String?
    let vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    let vpcLinkStatusMessage: Swift.String?
    let vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?
}

extension UpdateVpcLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "createdDate"
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case vpcLinkId = "vpcLinkId"
        case vpcLinkStatus = "vpcLinkStatus"
        case vpcLinkStatusMessage = "vpcLinkStatusMessage"
        case vpcLinkVersion = "vpcLinkVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let vpcLinkStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkStatus.self, forKey: .vpcLinkStatus)
        vpcLinkStatus = vpcLinkStatusDecoded
        let vpcLinkStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkStatusMessage)
        vpcLinkStatusMessage = vpcLinkStatusMessageDecoded
        let vpcLinkVersionDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkVersion.self, forKey: .vpcLinkVersion)
        vpcLinkVersion = vpcLinkVersionDecoded
    }
}

extension ApiGatewayV2ClientTypes.VpcLink: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "createdDate"
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case vpcLinkId = "vpcLinkId"
        case vpcLinkStatus = "vpcLinkStatus"
        case vpcLinkStatusMessage = "vpcLinkStatusMessage"
        case vpcLinkVersion = "vpcLinkVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcLinkId = vpcLinkId {
            try encodeContainer.encode(vpcLinkId, forKey: .vpcLinkId)
        }
        if let vpcLinkStatus = vpcLinkStatus {
            try encodeContainer.encode(vpcLinkStatus.rawValue, forKey: .vpcLinkStatus)
        }
        if let vpcLinkStatusMessage = vpcLinkStatusMessage {
            try encodeContainer.encode(vpcLinkStatusMessage, forKey: .vpcLinkStatusMessage)
        }
        if let vpcLinkVersion = vpcLinkVersion {
            try encodeContainer.encode(vpcLinkVersion.rawValue, forKey: .vpcLinkVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let vpcLinkStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkStatus.self, forKey: .vpcLinkStatus)
        vpcLinkStatus = vpcLinkStatusDecoded
        let vpcLinkStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkStatusMessage)
        vpcLinkStatusMessage = vpcLinkStatusMessageDecoded
        let vpcLinkVersionDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkVersion.self, forKey: .vpcLinkVersion)
        vpcLinkVersion = vpcLinkVersionDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a VPC link.
    public struct VpcLink: Swift.Equatable {
        /// The timestamp when the VPC link was created.
        public var createdDate: ClientRuntime.Date?
        /// The name of the VPC link.
        /// This member is required.
        public var name: Swift.String?
        /// A list of security group IDs for the VPC link.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs to include in the VPC link.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// Tags for the VPC link.
        public var tags: [Swift.String:Swift.String]?
        /// The ID of the VPC link.
        /// This member is required.
        public var vpcLinkId: Swift.String?
        /// The status of the VPC link.
        public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
        /// A message summarizing the cause of the status of the VPC link.
        public var vpcLinkStatusMessage: Swift.String?
        /// The version of the VPC link.
        public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vpcLinkId: Swift.String? = nil,
            vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
            vpcLinkStatusMessage: Swift.String? = nil,
            vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
        )
        {
            self.createdDate = createdDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcLinkId = vpcLinkId
            self.vpcLinkStatus = vpcLinkStatus
            self.vpcLinkStatusMessage = vpcLinkStatusMessage
            self.vpcLinkVersion = vpcLinkVersion
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// The status of the VPC link.
    public enum VpcLinkStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case failed
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcLinkStatus] {
            return [
                .available,
                .deleting,
                .failed,
                .inactive,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VpcLinkStatus(rawValue: rawValue) ?? VpcLinkStatus.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// The version of the VPC link.
    public enum VpcLinkVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcLinkVersion] {
            return [
                .v2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VpcLinkVersion(rawValue: rawValue) ?? VpcLinkVersion.sdkUnknown(rawValue)
        }
    }
}
