// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Backup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case backupState = "BackupState"
        case clusterId = "ClusterId"
        case copyTimestamp = "CopyTimestamp"
        case createTimestamp = "CreateTimestamp"
        case deleteTimestamp = "DeleteTimestamp"
        case neverExpires = "NeverExpires"
        case sourceBackup = "SourceBackup"
        case sourceCluster = "SourceCluster"
        case sourceRegion = "SourceRegion"
        case tagList = "TagList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let backupState = backupState {
            try encodeContainer.encode(backupState.rawValue, forKey: .backupState)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let copyTimestamp = copyTimestamp {
            try encodeContainer.encode(copyTimestamp.timeIntervalSince1970, forKey: .copyTimestamp)
        }
        if let createTimestamp = createTimestamp {
            try encodeContainer.encode(createTimestamp.timeIntervalSince1970, forKey: .createTimestamp)
        }
        if let deleteTimestamp = deleteTimestamp {
            try encodeContainer.encode(deleteTimestamp.timeIntervalSince1970, forKey: .deleteTimestamp)
        }
        if let neverExpires = neverExpires {
            try encodeContainer.encode(neverExpires, forKey: .neverExpires)
        }
        if let sourceBackup = sourceBackup {
            try encodeContainer.encode(sourceBackup, forKey: .sourceBackup)
        }
        if let sourceCluster = sourceCluster {
            try encodeContainer.encode(sourceCluster, forKey: .sourceCluster)
        }
        if let sourceRegion = sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let backupStateDecoded = try containerValues.decodeIfPresent(BackupState.self, forKey: .backupState)
        backupState = backupStateDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let createTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let copyTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .copyTimestamp)
        copyTimestamp = copyTimestampDecoded
        let neverExpiresDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .neverExpires)
        neverExpires = neverExpiresDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let sourceBackupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBackup)
        sourceBackup = sourceBackupDecoded
        let sourceClusterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCluster)
        sourceCluster = sourceClusterDecoded
        let deleteTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deleteTimestamp)
        deleteTimestamp = deleteTimestampDecoded
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension Backup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Backup(backupId: \(String(describing: backupId)), backupState: \(String(describing: backupState)), clusterId: \(String(describing: clusterId)), copyTimestamp: \(String(describing: copyTimestamp)), createTimestamp: \(String(describing: createTimestamp)), deleteTimestamp: \(String(describing: deleteTimestamp)), neverExpires: \(String(describing: neverExpires)), sourceBackup: \(String(describing: sourceBackup)), sourceCluster: \(String(describing: sourceCluster)), sourceRegion: \(String(describing: sourceRegion)), tagList: \(String(describing: tagList)))"}
}

/// <p>Contains information about a backup of an AWS CloudHSM cluster. All backup objects
///       contain the <code>BackupId</code>, <code>BackupState</code>, <code>ClusterId</code>, and
///         <code>CreateTimestamp</code> parameters. Backups that were copied into a destination region
///       additionally contain the <code>CopyTimestamp</code>, <code>SourceBackup</code>,
///         <code>SourceCluster</code>, and <code>SourceRegion</code> parameters. A backup that is
///       pending deletion will include the <code>DeleteTimestamp</code> parameter.</p>
public struct Backup: Equatable {
    /// <p>The identifier (ID) of the backup.</p>
    public let backupId: String?
    /// <p>The state of the backup.</p>
    public let backupState: BackupState?
    /// <p>The identifier (ID) of the cluster that was backed up.</p>
    public let clusterId: String?
    /// <p>The date and time when the backup was copied from a source backup.</p>
    public let copyTimestamp: Date?
    /// <p>The date and time when the backup was created.</p>
    public let createTimestamp: Date?
    /// <p>The date and time when the backup will be permanently deleted.</p>
    public let deleteTimestamp: Date?
    /// <p>Specifies whether the service should exempt a backup from the retention policy for the cluster. <code>True</code> exempts
    ///       a backup from the retention policy. <code>False</code> means the service applies the backup retention policy defined at the cluster.</p>
    public let neverExpires: Bool?
    /// <p>The identifier (ID) of the source backup from which the new backup was
    ///       copied.</p>
    public let sourceBackup: String?
    /// <p>The identifier (ID) of the cluster containing the source backup from which the new
    ///       backup was copied.</p>
    public let sourceCluster: String?
    /// <p>The AWS Region that contains the source backup from which the new backup was
    ///       copied.</p>
    public let sourceRegion: String?
    /// <p>The list of tags for the backup.</p>
    public let tagList: [Tag]?

    public init (
        backupId: String? = nil,
        backupState: BackupState? = nil,
        clusterId: String? = nil,
        copyTimestamp: Date? = nil,
        createTimestamp: Date? = nil,
        deleteTimestamp: Date? = nil,
        neverExpires: Bool? = nil,
        sourceBackup: String? = nil,
        sourceCluster: String? = nil,
        sourceRegion: String? = nil,
        tagList: [Tag]? = nil
    )
    {
        self.backupId = backupId
        self.backupState = backupState
        self.clusterId = clusterId
        self.copyTimestamp = copyTimestamp
        self.createTimestamp = createTimestamp
        self.deleteTimestamp = deleteTimestamp
        self.neverExpires = neverExpires
        self.sourceBackup = sourceBackup
        self.sourceCluster = sourceCluster
        self.sourceRegion = sourceRegion
        self.tagList = tagList
    }
}

public enum BackupPolicy {
    case `default`
    case sdkUnknown(String)
}

extension BackupPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BackupPolicy] {
        return [
            .default,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .default: return "DEFAULT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BackupPolicy(rawValue: rawValue) ?? BackupPolicy.sdkUnknown(rawValue)
    }
}

extension BackupRetentionPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(BackupRetentionType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension BackupRetentionPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupRetentionPolicy(type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>A policy that defines the number of days to retain backups.</p>
public struct BackupRetentionPolicy: Equatable {
    /// <p>The type of backup retention policy. For the <code>DAYS</code> type, the value is
    ///             the number of days to retain backups.</p>
    public let type: BackupRetentionType?
    /// <p>Use a value between 7 - 379.</p>
    public let value: String?

    public init (
        type: BackupRetentionType? = nil,
        value: String? = nil
    )
    {
        self.type = type
        self.value = value
    }
}

public enum BackupRetentionType {
    case days
    case sdkUnknown(String)
}

extension BackupRetentionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BackupRetentionType] {
        return [
            .days,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .days: return "DAYS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BackupRetentionType(rawValue: rawValue) ?? BackupRetentionType.sdkUnknown(rawValue)
    }
}

public enum BackupState {
    case createInProgress
    case deleted
    case pendingDeletion
    case ready
    case sdkUnknown(String)
}

extension BackupState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BackupState] {
        return [
            .createInProgress,
            .deleted,
            .pendingDeletion,
            .ready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .deleted: return "DELETED"
        case .pendingDeletion: return "PENDING_DELETION"
        case .ready: return "READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BackupState(rawValue: rawValue) ?? BackupState.sdkUnknown(rawValue)
    }
}

extension Certificates: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsHardwareCertificate = "AwsHardwareCertificate"
        case clusterCertificate = "ClusterCertificate"
        case clusterCsr = "ClusterCsr"
        case hsmCertificate = "HsmCertificate"
        case manufacturerHardwareCertificate = "ManufacturerHardwareCertificate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsHardwareCertificate = awsHardwareCertificate {
            try encodeContainer.encode(awsHardwareCertificate, forKey: .awsHardwareCertificate)
        }
        if let clusterCertificate = clusterCertificate {
            try encodeContainer.encode(clusterCertificate, forKey: .clusterCertificate)
        }
        if let clusterCsr = clusterCsr {
            try encodeContainer.encode(clusterCsr, forKey: .clusterCsr)
        }
        if let hsmCertificate = hsmCertificate {
            try encodeContainer.encode(hsmCertificate, forKey: .hsmCertificate)
        }
        if let manufacturerHardwareCertificate = manufacturerHardwareCertificate {
            try encodeContainer.encode(manufacturerHardwareCertificate, forKey: .manufacturerHardwareCertificate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterCsrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCsr)
        clusterCsr = clusterCsrDecoded
        let hsmCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmCertificate)
        hsmCertificate = hsmCertificateDecoded
        let awsHardwareCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsHardwareCertificate)
        awsHardwareCertificate = awsHardwareCertificateDecoded
        let manufacturerHardwareCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manufacturerHardwareCertificate)
        manufacturerHardwareCertificate = manufacturerHardwareCertificateDecoded
        let clusterCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCertificate)
        clusterCertificate = clusterCertificateDecoded
    }
}

extension Certificates: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Certificates(awsHardwareCertificate: \(String(describing: awsHardwareCertificate)), clusterCertificate: \(String(describing: clusterCertificate)), clusterCsr: \(String(describing: clusterCsr)), hsmCertificate: \(String(describing: hsmCertificate)), manufacturerHardwareCertificate: \(String(describing: manufacturerHardwareCertificate)))"}
}

/// <p>Contains one or more certificates or a certificate signing request (CSR).</p>
public struct Certificates: Equatable {
    /// <p>The HSM hardware certificate issued (signed) by AWS CloudHSM.</p>
    public let awsHardwareCertificate: String?
    /// <p>The cluster certificate issued (signed) by the issuing certificate authority (CA) of
    ///       the cluster's owner.</p>
    public let clusterCertificate: String?
    /// <p>The cluster's certificate signing request (CSR). The CSR exists only when the cluster's
    ///       state is <code>UNINITIALIZED</code>.</p>
    public let clusterCsr: String?
    /// <p>The HSM certificate issued (signed) by the HSM hardware.</p>
    public let hsmCertificate: String?
    /// <p>The HSM hardware certificate issued (signed) by the hardware manufacturer.</p>
    public let manufacturerHardwareCertificate: String?

    public init (
        awsHardwareCertificate: String? = nil,
        clusterCertificate: String? = nil,
        clusterCsr: String? = nil,
        hsmCertificate: String? = nil,
        manufacturerHardwareCertificate: String? = nil
    )
    {
        self.awsHardwareCertificate = awsHardwareCertificate
        self.clusterCertificate = clusterCertificate
        self.clusterCsr = clusterCsr
        self.hsmCertificate = hsmCertificate
        self.manufacturerHardwareCertificate = manufacturerHardwareCertificate
    }
}

extension CloudHsmAccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmAccessDeniedException(message: \(String(describing: message)))"}
}

extension CloudHsmAccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloudHsmAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the requester does not have permission to perform the
///       requested operation.</p>
public struct CloudHsmAccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudHsmAccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension CloudHsmAccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmInternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmInternalFailureException(message: \(String(describing: message)))"}
}

extension CloudHsmInternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloudHsmInternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because of an AWS CloudHSM internal failure. The request can
///       be retried.</p>
public struct CloudHsmInternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudHsmInternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension CloudHsmInternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmInvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmInvalidRequestException(message: \(String(describing: message)))"}
}

extension CloudHsmInvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloudHsmInvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it is not a valid request.</p>
public struct CloudHsmInvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudHsmInvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension CloudHsmInvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmResourceNotFoundException(message: \(String(describing: message)))"}
}

extension CloudHsmResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloudHsmResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it refers to a resource that cannot be
///       found.</p>
public struct CloudHsmResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudHsmResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension CloudHsmResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmServiceException(message: \(String(describing: message)))"}
}

extension CloudHsmServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloudHsmServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because an error occurred.</p>
public struct CloudHsmServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudHsmServiceExceptionBody: Equatable {
    public let message: String?
}

extension CloudHsmServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmTagException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmTagException(message: \(String(describing: message)))"}
}

extension CloudHsmTagException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloudHsmTagExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because of a tagging failure. Verify the tag conditions in all applicable policies, and then retry the request.</p>
public struct CloudHsmTagException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudHsmTagExceptionBody: Equatable {
    public let message: String?
}

extension CloudHsmTagExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Cluster: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupPolicy = "BackupPolicy"
        case backupRetentionPolicy = "BackupRetentionPolicy"
        case certificates = "Certificates"
        case clusterId = "ClusterId"
        case createTimestamp = "CreateTimestamp"
        case hsmType = "HsmType"
        case hsms = "Hsms"
        case preCoPassword = "PreCoPassword"
        case securityGroup = "SecurityGroup"
        case sourceBackupId = "SourceBackupId"
        case state = "State"
        case stateMessage = "StateMessage"
        case subnetMapping = "SubnetMapping"
        case tagList = "TagList"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPolicy = backupPolicy {
            try encodeContainer.encode(backupPolicy.rawValue, forKey: .backupPolicy)
        }
        if let backupRetentionPolicy = backupRetentionPolicy {
            try encodeContainer.encode(backupRetentionPolicy, forKey: .backupRetentionPolicy)
        }
        if let certificates = certificates {
            try encodeContainer.encode(certificates, forKey: .certificates)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let createTimestamp = createTimestamp {
            try encodeContainer.encode(createTimestamp.timeIntervalSince1970, forKey: .createTimestamp)
        }
        if let hsmType = hsmType {
            try encodeContainer.encode(hsmType, forKey: .hsmType)
        }
        if let hsms = hsms {
            var hsmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hsms)
            for hsms0 in hsms {
                try hsmsContainer.encode(hsms0)
            }
        }
        if let preCoPassword = preCoPassword {
            try encodeContainer.encode(preCoPassword, forKey: .preCoPassword)
        }
        if let securityGroup = securityGroup {
            try encodeContainer.encode(securityGroup, forKey: .securityGroup)
        }
        if let sourceBackupId = sourceBackupId {
            try encodeContainer.encode(sourceBackupId, forKey: .sourceBackupId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateMessage = stateMessage {
            try encodeContainer.encode(stateMessage, forKey: .stateMessage)
        }
        if let subnetMapping = subnetMapping {
            var subnetMappingContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .subnetMapping)
            for (dictKey0, externalsubnetmapping0) in subnetMapping {
                try subnetMappingContainer.encode(externalsubnetmapping0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPolicyDecoded = try containerValues.decodeIfPresent(BackupPolicy.self, forKey: .backupPolicy)
        backupPolicy = backupPolicyDecoded
        let backupRetentionPolicyDecoded = try containerValues.decodeIfPresent(BackupRetentionPolicy.self, forKey: .backupRetentionPolicy)
        backupRetentionPolicy = backupRetentionPolicyDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let createTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let hsmsContainer = try containerValues.decodeIfPresent([Hsm?].self, forKey: .hsms)
        var hsmsDecoded0:[Hsm]? = nil
        if let hsmsContainer = hsmsContainer {
            hsmsDecoded0 = [Hsm]()
            for structure0 in hsmsContainer {
                if let structure0 = structure0 {
                    hsmsDecoded0?.append(structure0)
                }
            }
        }
        hsms = hsmsDecoded0
        let hsmTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmType)
        hsmType = hsmTypeDecoded
        let preCoPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preCoPassword)
        preCoPassword = preCoPasswordDecoded
        let securityGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityGroup)
        securityGroup = securityGroupDecoded
        let sourceBackupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBackupId)
        sourceBackupId = sourceBackupIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ClusterState.self, forKey: .state)
        state = stateDecoded
        let stateMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMessage)
        stateMessage = stateMessageDecoded
        let subnetMappingContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .subnetMapping)
        var subnetMappingDecoded0: [String:String]? = nil
        if let subnetMappingContainer = subnetMappingContainer {
            subnetMappingDecoded0 = [String:String]()
            for (key0, subnetid0) in subnetMappingContainer {
                if let subnetid0 = subnetid0 {
                    subnetMappingDecoded0?[key0] = subnetid0
                }
            }
        }
        subnetMapping = subnetMappingDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let certificatesDecoded = try containerValues.decodeIfPresent(Certificates.self, forKey: .certificates)
        certificates = certificatesDecoded
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension Cluster: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Cluster(backupPolicy: \(String(describing: backupPolicy)), backupRetentionPolicy: \(String(describing: backupRetentionPolicy)), certificates: \(String(describing: certificates)), clusterId: \(String(describing: clusterId)), createTimestamp: \(String(describing: createTimestamp)), hsmType: \(String(describing: hsmType)), hsms: \(String(describing: hsms)), preCoPassword: \(String(describing: preCoPassword)), securityGroup: \(String(describing: securityGroup)), sourceBackupId: \(String(describing: sourceBackupId)), state: \(String(describing: state)), stateMessage: \(String(describing: stateMessage)), subnetMapping: \(String(describing: subnetMapping)), tagList: \(String(describing: tagList)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains information about an AWS CloudHSM cluster.</p>
public struct Cluster: Equatable {
    /// <p>The cluster's backup policy.</p>
    public let backupPolicy: BackupPolicy?
    /// <p>A policy that defines how the service retains backups.</p>
    public let backupRetentionPolicy: BackupRetentionPolicy?
    /// <p>Contains one or more certificates or a certificate signing request (CSR).</p>
    public let certificates: Certificates?
    /// <p>The cluster's identifier (ID).</p>
    public let clusterId: String?
    /// <p>The date and time when the cluster was created.</p>
    public let createTimestamp: Date?
    /// <p>The type of HSM that the cluster contains.</p>
    public let hsmType: String?
    /// <p>Contains information about the HSMs in the cluster.</p>
    public let hsms: [Hsm]?
    /// <p>The default password for the cluster's Pre-Crypto Officer (PRECO) user.</p>
    public let preCoPassword: String?
    /// <p>The identifier (ID) of the cluster's security group.</p>
    public let securityGroup: String?
    /// <p>The identifier (ID) of the backup used to create the cluster. This value exists only
    ///       when the cluster was created from a backup.</p>
    public let sourceBackupId: String?
    /// <p>The cluster's state.</p>
    public let state: ClusterState?
    /// <p>A description of the cluster's state.</p>
    public let stateMessage: String?
    /// <p>A map from availability zone to the clusterâ€™s subnet in that availability zone.</p>
    public let subnetMapping: [String:String]?
    /// <p>The list of tags for the cluster.</p>
    public let tagList: [Tag]?
    /// <p>The identifier (ID) of the virtual private cloud (VPC) that contains the
    ///       cluster.</p>
    public let vpcId: String?

    public init (
        backupPolicy: BackupPolicy? = nil,
        backupRetentionPolicy: BackupRetentionPolicy? = nil,
        certificates: Certificates? = nil,
        clusterId: String? = nil,
        createTimestamp: Date? = nil,
        hsmType: String? = nil,
        hsms: [Hsm]? = nil,
        preCoPassword: String? = nil,
        securityGroup: String? = nil,
        sourceBackupId: String? = nil,
        state: ClusterState? = nil,
        stateMessage: String? = nil,
        subnetMapping: [String:String]? = nil,
        tagList: [Tag]? = nil,
        vpcId: String? = nil
    )
    {
        self.backupPolicy = backupPolicy
        self.backupRetentionPolicy = backupRetentionPolicy
        self.certificates = certificates
        self.clusterId = clusterId
        self.createTimestamp = createTimestamp
        self.hsmType = hsmType
        self.hsms = hsms
        self.preCoPassword = preCoPassword
        self.securityGroup = securityGroup
        self.sourceBackupId = sourceBackupId
        self.state = state
        self.stateMessage = stateMessage
        self.subnetMapping = subnetMapping
        self.tagList = tagList
        self.vpcId = vpcId
    }
}

public enum ClusterState {
    case active
    case createInProgress
    case degraded
    case deleted
    case deleteInProgress
    case initialized
    case initializeInProgress
    case uninitialized
    case updateInProgress
    case sdkUnknown(String)
}

extension ClusterState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ClusterState] {
        return [
            .active,
            .createInProgress,
            .degraded,
            .deleted,
            .deleteInProgress,
            .initialized,
            .initializeInProgress,
            .uninitialized,
            .updateInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .degraded: return "DEGRADED"
        case .deleted: return "DELETED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .initialized: return "INITIALIZED"
        case .initializeInProgress: return "INITIALIZE_IN_PROGRESS"
        case .uninitialized: return "UNINITIALIZED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ClusterState(rawValue: rawValue) ?? ClusterState.sdkUnknown(rawValue)
    }
}

public struct CopyBackupToRegionInputBodyMiddleware: Middleware {
    public let id: String = "CopyBackupToRegionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyBackupToRegionInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyBackupToRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyBackupToRegionInput>
    public typealias MOutput = OperationOutput<CopyBackupToRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyBackupToRegionOutputError>
}

extension CopyBackupToRegionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyBackupToRegionInput(backupId: \(String(describing: backupId)), destinationRegion: \(String(describing: destinationRegion)), tagList: \(String(describing: tagList)))"}
}

extension CopyBackupToRegionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case destinationRegion = "DestinationRegion"
        case tagList = "TagList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let destinationRegion = destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

public struct CopyBackupToRegionInputHeadersMiddleware: Middleware {
    public let id: String = "CopyBackupToRegionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyBackupToRegionInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyBackupToRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyBackupToRegionInput>
    public typealias MOutput = OperationOutput<CopyBackupToRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyBackupToRegionOutputError>
}

public struct CopyBackupToRegionInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyBackupToRegionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyBackupToRegionInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyBackupToRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyBackupToRegionInput>
    public typealias MOutput = OperationOutput<CopyBackupToRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyBackupToRegionOutputError>
}

public struct CopyBackupToRegionInput: Equatable {
    /// <p>The ID of the backup that will be copied to the destination region. </p>
    public let backupId: String?
    /// <p>The AWS region that will contain your copied CloudHSM cluster backup.</p>
    public let destinationRegion: String?
    /// <p>Tags to apply to the destination backup during creation. If you specify tags, only these tags will be applied to the destination backup. If you do not specify tags, the service copies tags from the source backup to the destination backup.</p>
    public let tagList: [Tag]?

    public init (
        backupId: String? = nil,
        destinationRegion: String? = nil,
        tagList: [Tag]? = nil
    )
    {
        self.backupId = backupId
        self.destinationRegion = destinationRegion
        self.tagList = tagList
    }
}

struct CopyBackupToRegionInputBody: Equatable {
    public let destinationRegion: String?
    public let backupId: String?
    public let tagList: [Tag]?
}

extension CopyBackupToRegionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case destinationRegion = "DestinationRegion"
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension CopyBackupToRegionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyBackupToRegionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmTagException" : self = .cloudHsmTagException(try CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyBackupToRegionOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case cloudHsmTagException(CloudHsmTagException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyBackupToRegionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyBackupToRegionOutputResponse(destinationBackup: \(String(describing: destinationBackup)))"}
}

extension CopyBackupToRegionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyBackupToRegionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationBackup = output.destinationBackup
        } else {
            self.destinationBackup = nil
        }
    }
}

public struct CopyBackupToRegionOutputResponse: Equatable {
    /// <p>Information on the backup that will be copied to the destination region, including
    ///       CreateTimestamp, SourceBackup, SourceCluster, and Source Region. CreateTimestamp of the
    ///       destination backup will be the same as that of the source backup.</p>
    ///          <p>You will need to use the <code>sourceBackupID</code> returned in this operation to use
    ///       the <a>DescribeBackups</a> operation on the backup that will be copied to the
    ///       destination region.</p>
    public let destinationBackup: DestinationBackup?

    public init (
        destinationBackup: DestinationBackup? = nil
    )
    {
        self.destinationBackup = destinationBackup
    }
}

struct CopyBackupToRegionOutputResponseBody: Equatable {
    public let destinationBackup: DestinationBackup?
}

extension CopyBackupToRegionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationBackup = "DestinationBackup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationBackupDecoded = try containerValues.decodeIfPresent(DestinationBackup.self, forKey: .destinationBackup)
        destinationBackup = destinationBackupDecoded
    }
}

public struct CreateClusterInputBodyMiddleware: Middleware {
    public let id: String = "CreateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

extension CreateClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterInput(backupRetentionPolicy: \(String(describing: backupRetentionPolicy)), hsmType: \(String(describing: hsmType)), sourceBackupId: \(String(describing: sourceBackupId)), subnetIds: \(String(describing: subnetIds)), tagList: \(String(describing: tagList)))"}
}

extension CreateClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupRetentionPolicy = "BackupRetentionPolicy"
        case hsmType = "HsmType"
        case sourceBackupId = "SourceBackupId"
        case subnetIds = "SubnetIds"
        case tagList = "TagList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupRetentionPolicy = backupRetentionPolicy {
            try encodeContainer.encode(backupRetentionPolicy, forKey: .backupRetentionPolicy)
        }
        if let hsmType = hsmType {
            try encodeContainer.encode(hsmType, forKey: .hsmType)
        }
        if let sourceBackupId = sourceBackupId {
            try encodeContainer.encode(sourceBackupId, forKey: .sourceBackupId)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateClusterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

public struct CreateClusterInput: Equatable {
    /// <p>A policy that defines how the service retains backups.</p>
    public let backupRetentionPolicy: BackupRetentionPolicy?
    /// <p>The type of HSM to use in the cluster. Currently the only allowed value is
    ///       <code>hsm1.medium</code>.</p>
    public let hsmType: String?
    /// <p>The identifier (ID) of the cluster backup to restore. Use this value to restore the
    ///       cluster from a backup instead of creating a new cluster. To find the backup ID, use <a>DescribeBackups</a>.</p>
    public let sourceBackupId: String?
    /// <p>The identifiers (IDs) of the subnets where you are creating the cluster. You must
    ///       specify at least one subnet. If you specify multiple subnets, they must meet the following
    ///       criteria:</p>
    ///          <ul>
    ///             <li>
    ///                <p>All subnets must be in the same virtual private cloud (VPC).</p>
    ///             </li>
    ///             <li>
    ///                <p>You can specify only one subnet per Availability Zone.</p>
    ///             </li>
    ///          </ul>
    public let subnetIds: [String]?
    /// <p>Tags to apply to the CloudHSM cluster during creation.</p>
    public let tagList: [Tag]?

    public init (
        backupRetentionPolicy: BackupRetentionPolicy? = nil,
        hsmType: String? = nil,
        sourceBackupId: String? = nil,
        subnetIds: [String]? = nil,
        tagList: [Tag]? = nil
    )
    {
        self.backupRetentionPolicy = backupRetentionPolicy
        self.hsmType = hsmType
        self.sourceBackupId = sourceBackupId
        self.subnetIds = subnetIds
        self.tagList = tagList
    }
}

struct CreateClusterInputBody: Equatable {
    public let backupRetentionPolicy: BackupRetentionPolicy?
    public let hsmType: String?
    public let sourceBackupId: String?
    public let subnetIds: [String]?
    public let tagList: [Tag]?
}

extension CreateClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupRetentionPolicy = "BackupRetentionPolicy"
        case hsmType = "HsmType"
        case sourceBackupId = "SourceBackupId"
        case subnetIds = "SubnetIds"
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupRetentionPolicyDecoded = try containerValues.decodeIfPresent(BackupRetentionPolicy.self, forKey: .backupRetentionPolicy)
        backupRetentionPolicy = backupRetentionPolicyDecoded
        let hsmTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmType)
        hsmType = hsmTypeDecoded
        let sourceBackupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBackupId)
        sourceBackupId = sourceBackupIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension CreateClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmTagException" : self = .cloudHsmTagException(try CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case cloudHsmTagException(CloudHsmTagException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension CreateClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct CreateClusterOutputResponse: Equatable {
    /// <p>Information about the cluster that was created.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct CreateClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension CreateClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct CreateHsmInputBodyMiddleware: Middleware {
    public let id: String = "CreateHsmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHsmInput>
    public typealias MOutput = OperationOutput<CreateHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHsmOutputError>
}

extension CreateHsmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHsmInput(availabilityZone: \(String(describing: availabilityZone)), clusterId: \(String(describing: clusterId)), ipAddress: \(String(describing: ipAddress)))"}
}

extension CreateHsmInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case clusterId = "ClusterId"
        case ipAddress = "IpAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
    }
}

public struct CreateHsmInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHsmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHsmInput>
    public typealias MOutput = OperationOutput<CreateHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHsmOutputError>
}

public struct CreateHsmInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHsmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHsmInput>
    public typealias MOutput = OperationOutput<CreateHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHsmOutputError>
}

public struct CreateHsmInput: Equatable {
    /// <p>The Availability Zone where you are creating the HSM. To find the cluster's
    ///       Availability Zones, use <a>DescribeClusters</a>.</p>
    public let availabilityZone: String?
    /// <p>The identifier (ID) of the HSM's cluster. To find the cluster ID, use <a>DescribeClusters</a>.</p>
    public let clusterId: String?
    /// <p>The HSM's IP address. If you specify an IP address, use an available address from the
    ///       subnet that maps to the Availability Zone where you are creating the HSM. If you don't specify
    ///       an IP address, one is chosen for you from that subnet.</p>
    public let ipAddress: String?

    public init (
        availabilityZone: String? = nil,
        clusterId: String? = nil,
        ipAddress: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.clusterId = clusterId
        self.ipAddress = ipAddress
    }
}

struct CreateHsmInputBody: Equatable {
    public let clusterId: String?
    public let availabilityZone: String?
    public let ipAddress: String?
}

extension CreateHsmInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case clusterId = "ClusterId"
        case ipAddress = "IpAddress"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension CreateHsmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHsmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHsmOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHsmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHsmOutputResponse(hsm: \(String(describing: hsm)))"}
}

extension CreateHsmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHsmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hsm = output.hsm
        } else {
            self.hsm = nil
        }
    }
}

public struct CreateHsmOutputResponse: Equatable {
    /// <p>Information about the HSM that was created.</p>
    public let hsm: Hsm?

    public init (
        hsm: Hsm? = nil
    )
    {
        self.hsm = hsm
    }
}

struct CreateHsmOutputResponseBody: Equatable {
    public let hsm: Hsm?
}

extension CreateHsmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hsm = "Hsm"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmDecoded = try containerValues.decodeIfPresent(Hsm.self, forKey: .hsm)
        hsm = hsmDecoded
    }
}

public struct DeleteBackupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupOutputError>
}

extension DeleteBackupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupInput(backupId: \(String(describing: backupId)))"}
}

extension DeleteBackupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
    }
}

public struct DeleteBackupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupOutputError>
}

public struct DeleteBackupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupOutputError>
}

public struct DeleteBackupInput: Equatable {
    /// <p>The ID of the backup to be deleted. To find the ID of a backup, use the <a>DescribeBackups</a> operation.</p>
    public let backupId: String?

    public init (
        backupId: String? = nil
    )
    {
        self.backupId = backupId
    }
}

struct DeleteBackupInputBody: Equatable {
    public let backupId: String?
}

extension DeleteBackupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension DeleteBackupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupOutputResponse(backup: \(String(describing: backup)))"}
}

extension DeleteBackupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteBackupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

public struct DeleteBackupOutputResponse: Equatable {
    /// <p>Information on the <code>Backup</code> object deleted.</p>
    public let backup: Backup?

    public init (
        backup: Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct DeleteBackupOutputResponseBody: Equatable {
    public let backup: Backup?
}

extension DeleteBackupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backup = "Backup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

public struct DeleteClusterInputBodyMiddleware: Middleware {
    public let id: String = "DeleteClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterOutputError>
}

extension DeleteClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterInput(clusterId: \(String(describing: clusterId)))"}
}

extension DeleteClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
    }
}

public struct DeleteClusterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInput: Equatable {
    /// <p>The identifier (ID) of the cluster that you are deleting. To find the cluster ID, use
    ///       <a>DescribeClusters</a>.</p>
    public let clusterId: String?

    public init (
        clusterId: String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct DeleteClusterInputBody: Equatable {
    public let clusterId: String?
}

extension DeleteClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension DeleteClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmTagException" : self = .cloudHsmTagException(try CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case cloudHsmTagException(CloudHsmTagException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension DeleteClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DeleteClusterOutputResponse: Equatable {
    /// <p>Information about the cluster that was deleted.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DeleteClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension DeleteClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct DeleteHsmInputBodyMiddleware: Middleware {
    public let id: String = "DeleteHsmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHsmInput>
    public typealias MOutput = OperationOutput<DeleteHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHsmOutputError>
}

extension DeleteHsmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHsmInput(clusterId: \(String(describing: clusterId)), eniId: \(String(describing: eniId)), eniIp: \(String(describing: eniIp)), hsmId: \(String(describing: hsmId)))"}
}

extension DeleteHsmInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
        case eniId = "EniId"
        case eniIp = "EniIp"
        case hsmId = "HsmId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let eniId = eniId {
            try encodeContainer.encode(eniId, forKey: .eniId)
        }
        if let eniIp = eniIp {
            try encodeContainer.encode(eniIp, forKey: .eniIp)
        }
        if let hsmId = hsmId {
            try encodeContainer.encode(hsmId, forKey: .hsmId)
        }
    }
}

public struct DeleteHsmInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteHsmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHsmInput>
    public typealias MOutput = OperationOutput<DeleteHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHsmOutputError>
}

public struct DeleteHsmInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteHsmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHsmInput>
    public typealias MOutput = OperationOutput<DeleteHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHsmOutputError>
}

public struct DeleteHsmInput: Equatable {
    /// <p>The identifier (ID) of the cluster that contains the HSM that you are
    ///       deleting.</p>
    public let clusterId: String?
    /// <p>The identifier (ID) of the elastic network interface (ENI) of the HSM that you are
    ///       deleting.</p>
    public let eniId: String?
    /// <p>The IP address of the elastic network interface (ENI) of the HSM that you are
    ///       deleting.</p>
    public let eniIp: String?
    /// <p>The identifier (ID) of the HSM that you are deleting.</p>
    public let hsmId: String?

    public init (
        clusterId: String? = nil,
        eniId: String? = nil,
        eniIp: String? = nil,
        hsmId: String? = nil
    )
    {
        self.clusterId = clusterId
        self.eniId = eniId
        self.eniIp = eniIp
        self.hsmId = hsmId
    }
}

struct DeleteHsmInputBody: Equatable {
    public let clusterId: String?
    public let hsmId: String?
    public let eniId: String?
    public let eniIp: String?
}

extension DeleteHsmInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
        case eniId = "EniId"
        case eniIp = "EniIp"
        case hsmId = "HsmId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let hsmIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmId)
        hsmId = hsmIdDecoded
        let eniIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eniId)
        eniId = eniIdDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
    }
}

extension DeleteHsmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHsmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHsmOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHsmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHsmOutputResponse(hsmId: \(String(describing: hsmId)))"}
}

extension DeleteHsmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteHsmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hsmId = output.hsmId
        } else {
            self.hsmId = nil
        }
    }
}

public struct DeleteHsmOutputResponse: Equatable {
    /// <p>The identifier (ID) of the HSM that was deleted.</p>
    public let hsmId: String?

    public init (
        hsmId: String? = nil
    )
    {
        self.hsmId = hsmId
    }
}

struct DeleteHsmOutputResponseBody: Equatable {
    public let hsmId: String?
}

extension DeleteHsmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hsmId = "HsmId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmId)
        hsmId = hsmIdDecoded
    }
}

public struct DescribeBackupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBackupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupsOutputError>
}

extension DescribeBackupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBackupsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortAscending: \(String(describing: sortAscending)))"}
}

extension DescribeBackupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortAscending = "SortAscending"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filters)
            for (dictKey0, filters0) in filters {
                try filtersContainer.encode(filters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortAscending = sortAscending {
            try encodeContainer.encode(sortAscending, forKey: .sortAscending)
        }
    }
}

public struct DescribeBackupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBackupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupsOutputError>
}

public struct DescribeBackupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBackupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupsOutputError>
}

public struct DescribeBackupsInput: Equatable {
    /// <p>One or more filters to limit the items returned in the response.</p>
    ///          <p>Use the <code>backupIds</code> filter to return only the specified backups. Specify
    ///       backups by their backup identifier (ID).</p>
    ///          <p>Use the <code>sourceBackupIds</code> filter to return only the backups created from a
    ///       source backup. The <code>sourceBackupID</code> of a source backup is returned by the <a>CopyBackupToRegion</a> operation.</p>
    ///          <p>Use the <code>clusterIds</code> filter to return only the backups for the specified
    ///       clusters. Specify clusters by their cluster identifier (ID).</p>
    ///          <p>Use the <code>states</code> filter to return only backups that match the specified
    ///       state.</p>
    ///          <p>Use the <code>neverExpires</code> filter to return backups filtered by the value in the
    ///         <code>neverExpires</code> parameter. <code>True</code> returns all backups exempt from the
    ///       backup retention policy. <code>False</code> returns all backups with a backup retention policy
    ///       defined at the cluster.</p>
    public let filters: [String:[String]]?
    /// <p>The maximum number of backups to return in the response. When there are more backups
    ///       than the number you specify, the response contains a <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The <code>NextToken</code> value that you received in the previous response. Use this
    ///       value to get more backups.</p>
    public let nextToken: String?
    /// <p>Designates whether or not to sort the return backups by ascending chronological order
    ///       of generation.</p>
    public let sortAscending: Bool?

    public init (
        filters: [String:[String]]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortAscending: Bool? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortAscending = sortAscending
    }
}

struct DescribeBackupsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [String:[String]]?
    public let sortAscending: Bool?
}

extension DescribeBackupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortAscending = "SortAscending"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .filters)
        var filtersDecoded0: [String:[String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [String:[String]]()
            for (key0, strings0) in filtersContainer {
                var strings0Decoded0: [String]? = nil
                if let strings0 = strings0 {
                    strings0Decoded0 = [String]()
                    for string1 in strings0 {
                        if let string1 = string1 {
                            strings0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = strings0Decoded0
            }
        }
        filters = filtersDecoded0
        let sortAscendingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sortAscending)
        sortAscending = sortAscendingDecoded
    }
}

extension DescribeBackupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmTagException" : self = .cloudHsmTagException(try CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBackupsOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case cloudHsmTagException(CloudHsmTagException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBackupsOutputResponse(backups: \(String(describing: backups)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBackupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBackupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backups = output.backups
            self.nextToken = output.nextToken
        } else {
            self.backups = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBackupsOutputResponse: Equatable {
    /// <p>A list of backups.</p>
    public let backups: [Backup]?
    /// <p>An opaque string that indicates that the response contains only a subset of backups.
    ///       Use this value in a subsequent <code>DescribeBackups</code> request to get more
    ///       backups.</p>
    public let nextToken: String?

    public init (
        backups: [Backup]? = nil,
        nextToken: String? = nil
    )
    {
        self.backups = backups
        self.nextToken = nextToken
    }
}

struct DescribeBackupsOutputResponseBody: Equatable {
    public let backups: [Backup]?
    public let nextToken: String?
}

extension DescribeBackupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backups = "Backups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupsContainer = try containerValues.decodeIfPresent([Backup?].self, forKey: .backups)
        var backupsDecoded0:[Backup]? = nil
        if let backupsContainer = backupsContainer {
            backupsDecoded0 = [Backup]()
            for structure0 in backupsContainer {
                if let structure0 = structure0 {
                    backupsDecoded0?.append(structure0)
                }
            }
        }
        backups = backupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeClustersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClustersOutputError>
}

extension DescribeClustersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClustersInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeClustersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filters)
            for (dictKey0, filters0) in filters {
                try filtersContainer.encode(filters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeClustersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClustersOutputError>
}

public struct DescribeClustersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClustersOutputError>
}

public struct DescribeClustersInput: Equatable {
    /// <p>One or more filters to limit the items returned in the response.</p>
    ///          <p>Use the <code>clusterIds</code> filter to return only the specified clusters. Specify
    ///       clusters by their cluster identifier (ID).</p>
    ///          <p>Use the <code>vpcIds</code> filter to return only the clusters in the specified virtual
    ///       private clouds (VPCs). Specify VPCs by their VPC identifier (ID).</p>
    ///          <p>Use the <code>states</code> filter to return only clusters that match the specified
    ///       state.</p>
    public let filters: [String:[String]]?
    /// <p>The maximum number of clusters to return in the response. When there are more clusters
    ///       than the number you specify, the response contains a <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The <code>NextToken</code> value that you received in the previous response. Use this
    ///       value to get more clusters.</p>
    public let nextToken: String?

    public init (
        filters: [String:[String]]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeClustersInputBody: Equatable {
    public let filters: [String:[String]]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeClustersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .filters)
        var filtersDecoded0: [String:[String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [String:[String]]()
            for (key0, strings0) in filtersContainer {
                var strings0Decoded0: [String]? = nil
                if let strings0 = strings0 {
                    strings0Decoded0 = [String]()
                    for string1 in strings0 {
                        if let string1 = string1 {
                            strings0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = strings0Decoded0
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeClustersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClustersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmTagException" : self = .cloudHsmTagException(try CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClustersOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case cloudHsmTagException(CloudHsmTagException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClustersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClustersOutputResponse(clusters: \(String(describing: clusters)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeClustersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusters = output.clusters
            self.nextToken = output.nextToken
        } else {
            self.clusters = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeClustersOutputResponse: Equatable {
    /// <p>A list of clusters.</p>
    public let clusters: [Cluster]?
    /// <p>An opaque string that indicates that the response contains only a subset of clusters.
    ///       Use this value in a subsequent <code>DescribeClusters</code> request to get more
    ///       clusters.</p>
    public let nextToken: String?

    public init (
        clusters: [Cluster]? = nil,
        nextToken: String? = nil
    )
    {
        self.clusters = clusters
        self.nextToken = nextToken
    }
}

struct DescribeClustersOutputResponseBody: Equatable {
    public let clusters: [Cluster]?
    public let nextToken: String?
}

extension DescribeClustersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusters = "Clusters"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clustersContainer = try containerValues.decodeIfPresent([Cluster?].self, forKey: .clusters)
        var clustersDecoded0:[Cluster]? = nil
        if let clustersContainer = clustersContainer {
            clustersDecoded0 = [Cluster]()
            for structure0 in clustersContainer {
                if let structure0 = structure0 {
                    clustersDecoded0?.append(structure0)
                }
            }
        }
        clusters = clustersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DestinationBackup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createTimestamp = "CreateTimestamp"
        case sourceBackup = "SourceBackup"
        case sourceCluster = "SourceCluster"
        case sourceRegion = "SourceRegion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTimestamp = createTimestamp {
            try encodeContainer.encode(createTimestamp.timeIntervalSince1970, forKey: .createTimestamp)
        }
        if let sourceBackup = sourceBackup {
            try encodeContainer.encode(sourceBackup, forKey: .sourceBackup)
        }
        if let sourceCluster = sourceCluster {
            try encodeContainer.encode(sourceCluster, forKey: .sourceCluster)
        }
        if let sourceRegion = sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let sourceBackupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBackup)
        sourceBackup = sourceBackupDecoded
        let sourceClusterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCluster)
        sourceCluster = sourceClusterDecoded
    }
}

extension DestinationBackup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationBackup(createTimestamp: \(String(describing: createTimestamp)), sourceBackup: \(String(describing: sourceBackup)), sourceCluster: \(String(describing: sourceCluster)), sourceRegion: \(String(describing: sourceRegion)))"}
}

/// <p>Contains information about the backup that will be copied and created by the <a>CopyBackupToRegion</a> operation.</p>
public struct DestinationBackup: Equatable {
    /// <p>The date and time when both the source backup was created.</p>
    public let createTimestamp: Date?
    /// <p>The identifier (ID) of the source backup from which the new backup was copied.</p>
    public let sourceBackup: String?
    /// <p>The identifier (ID) of the cluster containing the source backup from which the new backup was copied.</p>
    public let sourceCluster: String?
    /// <p>The AWS region that contains the source backup from which the new backup was copied.</p>
    public let sourceRegion: String?

    public init (
        createTimestamp: Date? = nil,
        sourceBackup: String? = nil,
        sourceCluster: String? = nil,
        sourceRegion: String? = nil
    )
    {
        self.createTimestamp = createTimestamp
        self.sourceBackup = sourceBackup
        self.sourceCluster = sourceCluster
        self.sourceRegion = sourceRegion
    }
}

extension Hsm: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case clusterId = "ClusterId"
        case eniId = "EniId"
        case eniIp = "EniIp"
        case hsmId = "HsmId"
        case state = "State"
        case stateMessage = "StateMessage"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let eniId = eniId {
            try encodeContainer.encode(eniId, forKey: .eniId)
        }
        if let eniIp = eniIp {
            try encodeContainer.encode(eniIp, forKey: .eniIp)
        }
        if let hsmId = hsmId {
            try encodeContainer.encode(hsmId, forKey: .hsmId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateMessage = stateMessage {
            try encodeContainer.encode(stateMessage, forKey: .stateMessage)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let eniIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eniId)
        eniId = eniIdDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let hsmIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmId)
        hsmId = hsmIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(HsmState.self, forKey: .state)
        state = stateDecoded
        let stateMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMessage)
        stateMessage = stateMessageDecoded
    }
}

extension Hsm: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Hsm(availabilityZone: \(String(describing: availabilityZone)), clusterId: \(String(describing: clusterId)), eniId: \(String(describing: eniId)), eniIp: \(String(describing: eniIp)), hsmId: \(String(describing: hsmId)), state: \(String(describing: state)), stateMessage: \(String(describing: stateMessage)), subnetId: \(String(describing: subnetId)))"}
}

/// <p>Contains information about a hardware security module (HSM) in an AWS CloudHSM
///       cluster.</p>
public struct Hsm: Equatable {
    /// <p>The Availability Zone that contains the HSM.</p>
    public let availabilityZone: String?
    /// <p>The identifier (ID) of the cluster that contains the HSM.</p>
    public let clusterId: String?
    /// <p>The identifier (ID) of the HSM's elastic network interface (ENI).</p>
    public let eniId: String?
    /// <p>The IP address of the HSM's elastic network interface (ENI).</p>
    public let eniIp: String?
    /// <p>The HSM's identifier (ID).</p>
    public let hsmId: String?
    /// <p>The HSM's state.</p>
    public let state: HsmState?
    /// <p>A description of the HSM's state.</p>
    public let stateMessage: String?
    /// <p>The subnet that contains the HSM's elastic network interface (ENI).</p>
    public let subnetId: String?

    public init (
        availabilityZone: String? = nil,
        clusterId: String? = nil,
        eniId: String? = nil,
        eniIp: String? = nil,
        hsmId: String? = nil,
        state: HsmState? = nil,
        stateMessage: String? = nil,
        subnetId: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.clusterId = clusterId
        self.eniId = eniId
        self.eniIp = eniIp
        self.hsmId = hsmId
        self.state = state
        self.stateMessage = stateMessage
        self.subnetId = subnetId
    }
}

public enum HsmState {
    case active
    case createInProgress
    case degraded
    case deleted
    case deleteInProgress
    case sdkUnknown(String)
}

extension HsmState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HsmState] {
        return [
            .active,
            .createInProgress,
            .degraded,
            .deleted,
            .deleteInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .degraded: return "DEGRADED"
        case .deleted: return "DELETED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HsmState(rawValue: rawValue) ?? HsmState.sdkUnknown(rawValue)
    }
}

public struct InitializeClusterInputBodyMiddleware: Middleware {
    public let id: String = "InitializeClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitializeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<InitializeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitializeClusterInput>
    public typealias MOutput = OperationOutput<InitializeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitializeClusterOutputError>
}

extension InitializeClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitializeClusterInput(clusterId: \(String(describing: clusterId)), signedCert: \(String(describing: signedCert)), trustAnchor: \(String(describing: trustAnchor)))"}
}

extension InitializeClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
        case signedCert = "SignedCert"
        case trustAnchor = "TrustAnchor"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let signedCert = signedCert {
            try encodeContainer.encode(signedCert, forKey: .signedCert)
        }
        if let trustAnchor = trustAnchor {
            try encodeContainer.encode(trustAnchor, forKey: .trustAnchor)
        }
    }
}

public struct InitializeClusterInputHeadersMiddleware: Middleware {
    public let id: String = "InitializeClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitializeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<InitializeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitializeClusterInput>
    public typealias MOutput = OperationOutput<InitializeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitializeClusterOutputError>
}

public struct InitializeClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "InitializeClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitializeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<InitializeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitializeClusterInput>
    public typealias MOutput = OperationOutput<InitializeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitializeClusterOutputError>
}

public struct InitializeClusterInput: Equatable {
    /// <p>The identifier (ID) of the cluster that you are claiming. To find the cluster ID, use
    ///         <a>DescribeClusters</a>.</p>
    public let clusterId: String?
    /// <p>The cluster certificate issued (signed) by your issuing certificate authority (CA). The
    ///       certificate must be in PEM format and can contain a maximum of 5000 characters.</p>
    public let signedCert: String?
    /// <p>The issuing certificate of the issuing certificate authority (CA) that issued (signed)
    ///       the cluster certificate. You must use a self-signed certificate. The certificate used to sign the HSM CSR must be directly available, and thus must be the
    ///       root certificate. The certificate must be in PEM format and can contain a
    ///       maximum of 5000 characters.</p>
    public let trustAnchor: String?

    public init (
        clusterId: String? = nil,
        signedCert: String? = nil,
        trustAnchor: String? = nil
    )
    {
        self.clusterId = clusterId
        self.signedCert = signedCert
        self.trustAnchor = trustAnchor
    }
}

struct InitializeClusterInputBody: Equatable {
    public let clusterId: String?
    public let signedCert: String?
    public let trustAnchor: String?
}

extension InitializeClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
        case signedCert = "SignedCert"
        case trustAnchor = "TrustAnchor"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let signedCertDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signedCert)
        signedCert = signedCertDecoded
        let trustAnchorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

extension InitializeClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitializeClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitializeClusterOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitializeClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitializeClusterOutputResponse(state: \(String(describing: state)), stateMessage: \(String(describing: stateMessage)))"}
}

extension InitializeClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InitializeClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
            self.stateMessage = output.stateMessage
        } else {
            self.state = nil
            self.stateMessage = nil
        }
    }
}

public struct InitializeClusterOutputResponse: Equatable {
    /// <p>The cluster's state.</p>
    public let state: ClusterState?
    /// <p>A description of the cluster's state.</p>
    public let stateMessage: String?

    public init (
        state: ClusterState? = nil,
        stateMessage: String? = nil
    )
    {
        self.state = state
        self.stateMessage = stateMessage
    }
}

struct InitializeClusterOutputResponseBody: Equatable {
    public let state: ClusterState?
    public let stateMessage: String?
}

extension InitializeClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case state = "State"
        case stateMessage = "StateMessage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ClusterState.self, forKey: .state)
        state = stateDecoded
        let stateMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMessage)
        stateMessage = stateMessageDecoded
    }
}

public struct ListTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

extension ListTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceId: \(String(describing: resourceId)))"}
}

extension ListTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct ListTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Equatable {
    /// <p>The maximum number of tags to return in the response. When there are more tags than the
    ///       number you specify, the response contains a <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The <code>NextToken</code> value that you received in the previous response. Use this
    ///       value to get more tags.</p>
    public let nextToken: String?
    /// <p>The cluster identifier (ID) for the cluster whose tags you are getting. To find the
    ///       cluster ID, use <a>DescribeClusters</a>.</p>
    public let resourceId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct ListTagsInputBody: Equatable {
    public let resourceId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmTagException" : self = .cloudHsmTagException(try CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case cloudHsmTagException(CloudHsmTagException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsOutputResponse(nextToken: \(String(describing: nextToken)), tagList: \(String(describing: tagList)))"}
}

extension ListTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tagList = output.tagList
        } else {
            self.nextToken = nil
            self.tagList = nil
        }
    }
}

public struct ListTagsOutputResponse: Equatable {
    /// <p>An opaque string that indicates that the response contains only a subset of tags. Use
    ///       this value in a subsequent <code>ListTags</code> request to get more tags.</p>
    public let nextToken: String?
    /// <p>A list of tags.</p>
    public let tagList: [Tag]?

    public init (
        nextToken: String? = nil,
        tagList: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tagList = tagList
    }
}

struct ListTagsOutputResponseBody: Equatable {
    public let tagList: [Tag]?
    public let nextToken: String?
}

extension ListTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ModifyBackupAttributesInputBodyMiddleware: Middleware {
    public let id: String = "ModifyBackupAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyBackupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyBackupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyBackupAttributesInput>
    public typealias MOutput = OperationOutput<ModifyBackupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyBackupAttributesOutputError>
}

extension ModifyBackupAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyBackupAttributesInput(backupId: \(String(describing: backupId)), neverExpires: \(String(describing: neverExpires)))"}
}

extension ModifyBackupAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case neverExpires = "NeverExpires"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let neverExpires = neverExpires {
            try encodeContainer.encode(neverExpires, forKey: .neverExpires)
        }
    }
}

public struct ModifyBackupAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyBackupAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyBackupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyBackupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyBackupAttributesInput>
    public typealias MOutput = OperationOutput<ModifyBackupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyBackupAttributesOutputError>
}

public struct ModifyBackupAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyBackupAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyBackupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyBackupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyBackupAttributesInput>
    public typealias MOutput = OperationOutput<ModifyBackupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyBackupAttributesOutputError>
}

public struct ModifyBackupAttributesInput: Equatable {
    /// <p>The identifier (ID) of the backup to modify. To find the ID of a backup, use the <a>DescribeBackups</a> operation.</p>
    public let backupId: String?
    /// <p>Specifies whether the service should exempt a backup from the retention policy for the cluster. <code>True</code> exempts
    ///     a backup from the retention policy. <code>False</code> means the service applies the backup retention policy defined at the cluster.</p>
    public let neverExpires: Bool?

    public init (
        backupId: String? = nil,
        neverExpires: Bool? = nil
    )
    {
        self.backupId = backupId
        self.neverExpires = neverExpires
    }
}

struct ModifyBackupAttributesInputBody: Equatable {
    public let backupId: String?
    public let neverExpires: Bool?
}

extension ModifyBackupAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case neverExpires = "NeverExpires"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let neverExpiresDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .neverExpires)
        neverExpires = neverExpiresDecoded
    }
}

extension ModifyBackupAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyBackupAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyBackupAttributesOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyBackupAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyBackupAttributesOutputResponse(backup: \(String(describing: backup)))"}
}

extension ModifyBackupAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyBackupAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

public struct ModifyBackupAttributesOutputResponse: Equatable {
    /// <p>Contains information about a backup of an AWS CloudHSM cluster. All backup objects
    ///       contain the <code>BackupId</code>, <code>BackupState</code>, <code>ClusterId</code>, and
    ///         <code>CreateTimestamp</code> parameters. Backups that were copied into a destination region
    ///       additionally contain the <code>CopyTimestamp</code>, <code>SourceBackup</code>,
    ///         <code>SourceCluster</code>, and <code>SourceRegion</code> parameters. A backup that is
    ///       pending deletion will include the <code>DeleteTimestamp</code> parameter.</p>
    public let backup: Backup?

    public init (
        backup: Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct ModifyBackupAttributesOutputResponseBody: Equatable {
    public let backup: Backup?
}

extension ModifyBackupAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backup = "Backup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

public struct ModifyClusterInputBodyMiddleware: Middleware {
    public let id: String = "ModifyClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterInput>
    public typealias MOutput = OperationOutput<ModifyClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterOutputError>
}

extension ModifyClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterInput(backupRetentionPolicy: \(String(describing: backupRetentionPolicy)), clusterId: \(String(describing: clusterId)))"}
}

extension ModifyClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupRetentionPolicy = "BackupRetentionPolicy"
        case clusterId = "ClusterId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupRetentionPolicy = backupRetentionPolicy {
            try encodeContainer.encode(backupRetentionPolicy, forKey: .backupRetentionPolicy)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
    }
}

public struct ModifyClusterInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterInput>
    public typealias MOutput = OperationOutput<ModifyClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterOutputError>
}

public struct ModifyClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClusterInput>
    public typealias MOutput = OperationOutput<ModifyClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClusterOutputError>
}

public struct ModifyClusterInput: Equatable {
    /// <p>A policy that defines how the service retains backups.</p>
    public let backupRetentionPolicy: BackupRetentionPolicy?
    /// <p>The identifier (ID) of the cluster that you want to modify. To find the cluster ID, use
    ///         <a>DescribeClusters</a>.</p>
    public let clusterId: String?

    public init (
        backupRetentionPolicy: BackupRetentionPolicy? = nil,
        clusterId: String? = nil
    )
    {
        self.backupRetentionPolicy = backupRetentionPolicy
        self.clusterId = clusterId
    }
}

struct ModifyClusterInputBody: Equatable {
    public let backupRetentionPolicy: BackupRetentionPolicy?
    public let clusterId: String?
}

extension ModifyClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupRetentionPolicy = "BackupRetentionPolicy"
        case clusterId = "ClusterId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupRetentionPolicyDecoded = try containerValues.decodeIfPresent(BackupRetentionPolicy.self, forKey: .backupRetentionPolicy)
        backupRetentionPolicy = backupRetentionPolicyDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension ModifyClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClusterOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension ModifyClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ModifyClusterOutputResponse: Equatable {
    /// <p>Contains information about an AWS CloudHSM cluster.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ModifyClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension ModifyClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct RestoreBackupInputBodyMiddleware: Middleware {
    public let id: String = "RestoreBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreBackupInput>
    public typealias MOutput = OperationOutput<RestoreBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreBackupOutputError>
}

extension RestoreBackupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreBackupInput(backupId: \(String(describing: backupId)))"}
}

extension RestoreBackupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
    }
}

public struct RestoreBackupInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreBackupInput>
    public typealias MOutput = OperationOutput<RestoreBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreBackupOutputError>
}

public struct RestoreBackupInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreBackupInput>
    public typealias MOutput = OperationOutput<RestoreBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreBackupOutputError>
}

public struct RestoreBackupInput: Equatable {
    /// <p>The ID of the backup to be restored. To find the ID of a backup, use the <a>DescribeBackups</a> operation.</p>
    public let backupId: String?

    public init (
        backupId: String? = nil
    )
    {
        self.backupId = backupId
    }
}

struct RestoreBackupInputBody: Equatable {
    public let backupId: String?
}

extension RestoreBackupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension RestoreBackupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreBackupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreBackupOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreBackupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreBackupOutputResponse(backup: \(String(describing: backup)))"}
}

extension RestoreBackupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreBackupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

public struct RestoreBackupOutputResponse: Equatable {
    /// <p>Information on the <code>Backup</code> object created.</p>
    public let backup: Backup?

    public init (
        backup: Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct RestoreBackupOutputResponseBody: Equatable {
    public let backup: Backup?
}

extension RestoreBackupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backup = "Backup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Contains a tag. A tag is a key-value pair.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceId: \(String(describing: resourceId)), tagList: \(String(describing: tagList)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagList = "TagList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The cluster identifier (ID) for the cluster that you are tagging. To find the cluster
    ///       ID, use <a>DescribeClusters</a>.</p>
    public let resourceId: String?
    /// <p>A list of one or more tags.</p>
    public let tagList: [Tag]?

    public init (
        resourceId: String? = nil,
        tagList: [Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagList = tagList
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceId: String?
    public let tagList: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmTagException" : self = .cloudHsmTagException(try CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case cloudHsmTagException(CloudHsmTagException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceId: \(String(describing: resourceId)), tagKeyList: \(String(describing: tagKeyList)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkeylist0 in tagKeyList {
                try tagKeyListContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The cluster identifier (ID) for the cluster whose tags you are removing. To find the
    ///       cluster ID, use <a>DescribeClusters</a>.</p>
    public let resourceId: String?
    /// <p>A list of one or more tag keys for the tags that you are removing. Specify only the tag
    ///       keys, not the tag values.</p>
    public let tagKeyList: [String]?

    public init (
        resourceId: String? = nil,
        tagKeyList: [String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeyList = tagKeyList
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceId: String?
    public let tagKeyList: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmAccessDeniedException" : self = .cloudHsmAccessDeniedException(try CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInternalFailureException" : self = .cloudHsmInternalFailureException(try CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmInvalidRequestException" : self = .cloudHsmInvalidRequestException(try CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmResourceNotFoundException" : self = .cloudHsmResourceNotFoundException(try CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmTagException" : self = .cloudHsmTagException(try CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case cloudHsmAccessDeniedException(CloudHsmAccessDeniedException)
    case cloudHsmInternalFailureException(CloudHsmInternalFailureException)
    case cloudHsmInvalidRequestException(CloudHsmInvalidRequestException)
    case cloudHsmResourceNotFoundException(CloudHsmResourceNotFoundException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case cloudHsmTagException(CloudHsmTagException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
