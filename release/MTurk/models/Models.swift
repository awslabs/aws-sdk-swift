// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptQualificationRequestInputBodyMiddleware: Middleware {
    public let id: String = "AcceptQualificationRequestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptQualificationRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptQualificationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptQualificationRequestInput>
    public typealias MOutput = OperationOutput<AcceptQualificationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptQualificationRequestOutputError>
}

extension AcceptQualificationRequestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptQualificationRequestInput(integerValue: \(String(describing: integerValue)), qualificationRequestId: \(String(describing: qualificationRequestId)))"}
}

extension AcceptQualificationRequestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case integerValue = "IntegerValue"
        case qualificationRequestId = "QualificationRequestId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let integerValue = integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let qualificationRequestId = qualificationRequestId {
            try encodeContainer.encode(qualificationRequestId, forKey: .qualificationRequestId)
        }
    }
}

public struct AcceptQualificationRequestInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptQualificationRequestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptQualificationRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptQualificationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptQualificationRequestInput>
    public typealias MOutput = OperationOutput<AcceptQualificationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptQualificationRequestOutputError>
}

public struct AcceptQualificationRequestInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptQualificationRequestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptQualificationRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptQualificationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptQualificationRequestInput>
    public typealias MOutput = OperationOutput<AcceptQualificationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptQualificationRequestOutputError>
}

public struct AcceptQualificationRequestInput: Equatable {
    /// <p>
    ///             The value of the Qualification. You can omit this value if you are using the
    ///             presence or absence of the Qualification as the basis for a HIT requirement.
    ///         </p>
    public let integerValue: Int?
    /// <p>The ID of the Qualification request, as returned by the <code>GetQualificationRequests</code> operation.</p>
    public let qualificationRequestId: String?

    public init (
        integerValue: Int? = nil,
        qualificationRequestId: String? = nil
    )
    {
        self.integerValue = integerValue
        self.qualificationRequestId = qualificationRequestId
    }
}

struct AcceptQualificationRequestInputBody: Equatable {
    public let qualificationRequestId: String?
    public let integerValue: Int?
}

extension AcceptQualificationRequestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case integerValue = "IntegerValue"
        case qualificationRequestId = "QualificationRequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationRequestId)
        qualificationRequestId = qualificationRequestIdDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
    }
}

extension AcceptQualificationRequestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptQualificationRequestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptQualificationRequestOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptQualificationRequestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptQualificationRequestOutputResponse()"}
}

extension AcceptQualificationRequestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AcceptQualificationRequestOutputResponse: Equatable {

    public init() {}
}

struct AcceptQualificationRequestOutputResponseBody: Equatable {
}

extension AcceptQualificationRequestOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ApproveAssignmentInputBodyMiddleware: Middleware {
    public let id: String = "ApproveAssignmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApproveAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<ApproveAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApproveAssignmentInput>
    public typealias MOutput = OperationOutput<ApproveAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApproveAssignmentOutputError>
}

extension ApproveAssignmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApproveAssignmentInput(assignmentId: \(String(describing: assignmentId)), overrideRejection: \(String(describing: overrideRejection)), requesterFeedback: \(String(describing: requesterFeedback)))"}
}

extension ApproveAssignmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case overrideRejection = "OverrideRejection"
        case requesterFeedback = "RequesterFeedback"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let overrideRejection = overrideRejection {
            try encodeContainer.encode(overrideRejection, forKey: .overrideRejection)
        }
        if let requesterFeedback = requesterFeedback {
            try encodeContainer.encode(requesterFeedback, forKey: .requesterFeedback)
        }
    }
}

public struct ApproveAssignmentInputHeadersMiddleware: Middleware {
    public let id: String = "ApproveAssignmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApproveAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<ApproveAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApproveAssignmentInput>
    public typealias MOutput = OperationOutput<ApproveAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApproveAssignmentOutputError>
}

public struct ApproveAssignmentInputQueryItemMiddleware: Middleware {
    public let id: String = "ApproveAssignmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApproveAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<ApproveAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApproveAssignmentInput>
    public typealias MOutput = OperationOutput<ApproveAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApproveAssignmentOutputError>
}

public struct ApproveAssignmentInput: Equatable {
    /// <p>
    ///             The ID of the assignment. The assignment must correspond to a HIT created by the Requester.
    ///         </p>
    public let assignmentId: String?
    /// <p>
    ///             A flag indicating that an assignment should be approved even if it was previously rejected. Defaults to <code>False</code>.
    ///         </p>
    public let overrideRejection: Bool?
    /// <p>
    ///             A message for the Worker, which the Worker can see in the Status section of the web site.
    ///         </p>
    public let requesterFeedback: String?

    public init (
        assignmentId: String? = nil,
        overrideRejection: Bool? = nil,
        requesterFeedback: String? = nil
    )
    {
        self.assignmentId = assignmentId
        self.overrideRejection = overrideRejection
        self.requesterFeedback = requesterFeedback
    }
}

struct ApproveAssignmentInputBody: Equatable {
    public let assignmentId: String?
    public let requesterFeedback: String?
    public let overrideRejection: Bool?
}

extension ApproveAssignmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case overrideRejection = "OverrideRejection"
        case requesterFeedback = "RequesterFeedback"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let requesterFeedbackDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requesterFeedback)
        requesterFeedback = requesterFeedbackDecoded
        let overrideRejectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .overrideRejection)
        overrideRejection = overrideRejectionDecoded
    }
}

extension ApproveAssignmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ApproveAssignmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApproveAssignmentOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApproveAssignmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApproveAssignmentOutputResponse()"}
}

extension ApproveAssignmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ApproveAssignmentOutputResponse: Equatable {

    public init() {}
}

struct ApproveAssignmentOutputResponseBody: Equatable {
}

extension ApproveAssignmentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Assignment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptTime = "AcceptTime"
        case answer = "Answer"
        case approvalTime = "ApprovalTime"
        case assignmentId = "AssignmentId"
        case assignmentStatus = "AssignmentStatus"
        case autoApprovalTime = "AutoApprovalTime"
        case deadline = "Deadline"
        case hITId = "HITId"
        case rejectionTime = "RejectionTime"
        case requesterFeedback = "RequesterFeedback"
        case submitTime = "SubmitTime"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptTime = acceptTime {
            try encodeContainer.encode(acceptTime.timeIntervalSince1970, forKey: .acceptTime)
        }
        if let answer = answer {
            try encodeContainer.encode(answer, forKey: .answer)
        }
        if let approvalTime = approvalTime {
            try encodeContainer.encode(approvalTime.timeIntervalSince1970, forKey: .approvalTime)
        }
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let assignmentStatus = assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
        if let autoApprovalTime = autoApprovalTime {
            try encodeContainer.encode(autoApprovalTime.timeIntervalSince1970, forKey: .autoApprovalTime)
        }
        if let deadline = deadline {
            try encodeContainer.encode(deadline.timeIntervalSince1970, forKey: .deadline)
        }
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let rejectionTime = rejectionTime {
            try encodeContainer.encode(rejectionTime.timeIntervalSince1970, forKey: .rejectionTime)
        }
        if let requesterFeedback = requesterFeedback {
            try encodeContainer.encode(requesterFeedback, forKey: .requesterFeedback)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let hITIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let autoApprovalTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .autoApprovalTime)
        autoApprovalTime = autoApprovalTimeDecoded
        let acceptTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .acceptTime)
        acceptTime = acceptTimeDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let approvalTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .approvalTime)
        approvalTime = approvalTimeDecoded
        let rejectionTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .rejectionTime)
        rejectionTime = rejectionTimeDecoded
        let deadlineDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deadline)
        deadline = deadlineDecoded
        let answerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .answer)
        answer = answerDecoded
        let requesterFeedbackDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requesterFeedback)
        requesterFeedback = requesterFeedbackDecoded
    }
}

extension Assignment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Assignment(acceptTime: \(String(describing: acceptTime)), answer: \(String(describing: answer)), approvalTime: \(String(describing: approvalTime)), assignmentId: \(String(describing: assignmentId)), assignmentStatus: \(String(describing: assignmentStatus)), autoApprovalTime: \(String(describing: autoApprovalTime)), deadline: \(String(describing: deadline)), hITId: \(String(describing: hITId)), rejectionTime: \(String(describing: rejectionTime)), requesterFeedback: \(String(describing: requesterFeedback)), submitTime: \(String(describing: submitTime)), workerId: \(String(describing: workerId)))"}
}

/// <p> The Assignment data structure represents a single assignment
///             of a HIT to a Worker. The assignment tracks the Worker's efforts to
///             complete the HIT, and contains the results for later retrieval.
///         </p>
public struct Assignment: Equatable {
    /// <p> The date and time the Worker accepted the assignment.</p>
    public let acceptTime: Date?
    /// <p> The Worker's answers submitted for the HIT contained in a
    ///             QuestionFormAnswers document, if the Worker provides an answer. If
    ///             the Worker does not provide any answers, Answer may contain a
    ///             QuestionFormAnswers document, or Answer may be empty.</p>
    public let answer: String?
    /// <p> If the Worker has submitted results and the Requester has
    ///             approved the results, ApprovalTime is the date and time the Requester
    ///             approved the results. This value is omitted from the assignment if
    ///             the Requester has not yet approved the results.</p>
    public let approvalTime: Date?
    /// <p> A unique identifier for the assignment.</p>
    public let assignmentId: String?
    /// <p> The status of the assignment.</p>
    public let assignmentStatus: AssignmentStatus?
    /// <p> If results have been submitted, AutoApprovalTime is the date
    ///             and time the results of the assignment results are considered
    ///             Approved automatically if they have not already been explicitly
    ///             approved or rejected by the Requester. This value is derived from the
    ///             auto-approval delay specified by the Requester in the HIT. This value
    ///             is omitted from the assignment if the Worker has not yet submitted
    ///             results.</p>
    public let autoApprovalTime: Date?
    /// <p> The date and time of the deadline for the assignment. This
    ///             value is derived from the deadline specification for the HIT and the
    ///             date and time the Worker accepted the HIT.</p>
    public let deadline: Date?
    /// <p> The ID of the HIT.</p>
    public let hITId: String?
    /// <p> If the Worker has submitted results and the Requester has
    ///             rejected the results, RejectionTime is the date and time the
    ///             Requester rejected the results.</p>
    public let rejectionTime: Date?
    /// <p> The feedback string included with the call to the
    ///             ApproveAssignment operation or the RejectAssignment operation, if the
    ///             Requester approved or rejected the assignment and specified feedback.</p>
    public let requesterFeedback: String?
    /// <p> If the Worker has submitted results, SubmitTime is the date
    ///             and time the assignment was submitted. This value is omitted from the
    ///             assignment if the Worker has not yet submitted results.</p>
    public let submitTime: Date?
    /// <p> The ID of the Worker who accepted the HIT.</p>
    public let workerId: String?

    public init (
        acceptTime: Date? = nil,
        answer: String? = nil,
        approvalTime: Date? = nil,
        assignmentId: String? = nil,
        assignmentStatus: AssignmentStatus? = nil,
        autoApprovalTime: Date? = nil,
        deadline: Date? = nil,
        hITId: String? = nil,
        rejectionTime: Date? = nil,
        requesterFeedback: String? = nil,
        submitTime: Date? = nil,
        workerId: String? = nil
    )
    {
        self.acceptTime = acceptTime
        self.answer = answer
        self.approvalTime = approvalTime
        self.assignmentId = assignmentId
        self.assignmentStatus = assignmentStatus
        self.autoApprovalTime = autoApprovalTime
        self.deadline = deadline
        self.hITId = hITId
        self.rejectionTime = rejectionTime
        self.requesterFeedback = requesterFeedback
        self.submitTime = submitTime
        self.workerId = workerId
    }
}

public enum AssignmentStatus {
    case approved
    case rejected
    case submitted
    case sdkUnknown(String)
}

extension AssignmentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssignmentStatus] {
        return [
            .approved,
            .rejected,
            .submitted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approved: return "Approved"
        case .rejected: return "Rejected"
        case .submitted: return "Submitted"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssignmentStatus(rawValue: rawValue) ?? AssignmentStatus.sdkUnknown(rawValue)
    }
}

public struct AssociateQualificationWithWorkerInputBodyMiddleware: Middleware {
    public let id: String = "AssociateQualificationWithWorkerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateQualificationWithWorkerInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateQualificationWithWorkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateQualificationWithWorkerInput>
    public typealias MOutput = OperationOutput<AssociateQualificationWithWorkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateQualificationWithWorkerOutputError>
}

extension AssociateQualificationWithWorkerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateQualificationWithWorkerInput(integerValue: \(String(describing: integerValue)), qualificationTypeId: \(String(describing: qualificationTypeId)), sendNotification: \(String(describing: sendNotification)), workerId: \(String(describing: workerId)))"}
}

extension AssociateQualificationWithWorkerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case integerValue = "IntegerValue"
        case qualificationTypeId = "QualificationTypeId"
        case sendNotification = "SendNotification"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let integerValue = integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let sendNotification = sendNotification {
            try encodeContainer.encode(sendNotification, forKey: .sendNotification)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }
}

public struct AssociateQualificationWithWorkerInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateQualificationWithWorkerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateQualificationWithWorkerInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateQualificationWithWorkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateQualificationWithWorkerInput>
    public typealias MOutput = OperationOutput<AssociateQualificationWithWorkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateQualificationWithWorkerOutputError>
}

public struct AssociateQualificationWithWorkerInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateQualificationWithWorkerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateQualificationWithWorkerInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateQualificationWithWorkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateQualificationWithWorkerInput>
    public typealias MOutput = OperationOutput<AssociateQualificationWithWorkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateQualificationWithWorkerOutputError>
}

public struct AssociateQualificationWithWorkerInput: Equatable {
    /// <p>The value of the Qualification to assign.</p>
    public let integerValue: Int?
    /// <p>The ID of the Qualification type to use for the assigned Qualification.</p>
    public let qualificationTypeId: String?
    /// <p>
    ///             Specifies whether to send a notification email message to the Worker
    ///             saying that the qualification was assigned to the Worker.
    ///             Note: this is true by default.
    ///         </p>
    public let sendNotification: Bool?
    /// <p>
    ///             The ID of the Worker to whom the Qualification is being assigned.
    ///             Worker IDs are included with submitted HIT assignments and Qualification requests.
    ///         </p>
    public let workerId: String?

    public init (
        integerValue: Int? = nil,
        qualificationTypeId: String? = nil,
        sendNotification: Bool? = nil,
        workerId: String? = nil
    )
    {
        self.integerValue = integerValue
        self.qualificationTypeId = qualificationTypeId
        self.sendNotification = sendNotification
        self.workerId = workerId
    }
}

struct AssociateQualificationWithWorkerInputBody: Equatable {
    public let qualificationTypeId: String?
    public let workerId: String?
    public let integerValue: Int?
    public let sendNotification: Bool?
}

extension AssociateQualificationWithWorkerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case integerValue = "IntegerValue"
        case qualificationTypeId = "QualificationTypeId"
        case sendNotification = "SendNotification"
        case workerId = "WorkerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let sendNotificationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sendNotification)
        sendNotification = sendNotificationDecoded
    }
}

extension AssociateQualificationWithWorkerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateQualificationWithWorkerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateQualificationWithWorkerOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateQualificationWithWorkerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateQualificationWithWorkerOutputResponse()"}
}

extension AssociateQualificationWithWorkerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateQualificationWithWorkerOutputResponse: Equatable {

    public init() {}
}

struct AssociateQualificationWithWorkerOutputResponseBody: Equatable {
}

extension AssociateQualificationWithWorkerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension BonusPayment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case bonusAmount = "BonusAmount"
        case grantTime = "GrantTime"
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let bonusAmount = bonusAmount {
            try encodeContainer.encode(bonusAmount, forKey: .bonusAmount)
        }
        if let grantTime = grantTime {
            try encodeContainer.encode(grantTime.timeIntervalSince1970, forKey: .grantTime)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let bonusAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bonusAmount)
        bonusAmount = bonusAmountDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
        let grantTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .grantTime)
        grantTime = grantTimeDecoded
    }
}

extension BonusPayment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BonusPayment(assignmentId: \(String(describing: assignmentId)), bonusAmount: \(String(describing: bonusAmount)), grantTime: \(String(describing: grantTime)), reason: \(String(describing: reason)), workerId: \(String(describing: workerId)))"}
}

/// <p>An object representing a Bonus payment paid to a Worker.</p>
public struct BonusPayment: Equatable {
    /// <p>The ID of the assignment associated with this bonus payment.</p>
    public let assignmentId: String?
    /// <p>A string representing a currency amount.</p>
    public let bonusAmount: String?
    /// <p>The date and time of when the bonus was granted.</p>
    public let grantTime: Date?
    /// <p>The Reason text given when the bonus was granted, if any.</p>
    public let reason: String?
    /// <p>The ID of the Worker to whom the bonus was paid.</p>
    public let workerId: String?

    public init (
        assignmentId: String? = nil,
        bonusAmount: String? = nil,
        grantTime: Date? = nil,
        reason: String? = nil,
        workerId: String? = nil
    )
    {
        self.assignmentId = assignmentId
        self.bonusAmount = bonusAmount
        self.grantTime = grantTime
        self.reason = reason
        self.workerId = workerId
    }
}

public enum Comparator {
    case doesnotexist
    case equalto
    case exists
    case greaterthan
    case greaterthanorequalto
    case `in`
    case lessthan
    case lessthanorequalto
    case notequalto
    case notin
    case sdkUnknown(String)
}

extension Comparator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Comparator] {
        return [
            .doesnotexist,
            .equalto,
            .exists,
            .greaterthan,
            .greaterthanorequalto,
            .in,
            .lessthan,
            .lessthanorequalto,
            .notequalto,
            .notin,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .doesnotexist: return "DoesNotExist"
        case .equalto: return "EqualTo"
        case .exists: return "Exists"
        case .greaterthan: return "GreaterThan"
        case .greaterthanorequalto: return "GreaterThanOrEqualTo"
        case .in: return "In"
        case .lessthan: return "LessThan"
        case .lessthanorequalto: return "LessThanOrEqualTo"
        case .notequalto: return "NotEqualTo"
        case .notin: return "NotIn"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Comparator(rawValue: rawValue) ?? Comparator.sdkUnknown(rawValue)
    }
}

public struct CreateAdditionalAssignmentsForHITInputBodyMiddleware: Middleware {
    public let id: String = "CreateAdditionalAssignmentsForHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAdditionalAssignmentsForHITInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAdditionalAssignmentsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAdditionalAssignmentsForHITInput>
    public typealias MOutput = OperationOutput<CreateAdditionalAssignmentsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAdditionalAssignmentsForHITOutputError>
}

extension CreateAdditionalAssignmentsForHITInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAdditionalAssignmentsForHITInput(hITId: \(String(describing: hITId)), numberOfAdditionalAssignments: \(String(describing: numberOfAdditionalAssignments)), uniqueRequestToken: \(String(describing: uniqueRequestToken)))"}
}

extension CreateAdditionalAssignmentsForHITInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hITId = "HITId"
        case numberOfAdditionalAssignments = "NumberOfAdditionalAssignments"
        case uniqueRequestToken = "UniqueRequestToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let numberOfAdditionalAssignments = numberOfAdditionalAssignments {
            try encodeContainer.encode(numberOfAdditionalAssignments, forKey: .numberOfAdditionalAssignments)
        }
        if let uniqueRequestToken = uniqueRequestToken {
            try encodeContainer.encode(uniqueRequestToken, forKey: .uniqueRequestToken)
        }
    }
}

public struct CreateAdditionalAssignmentsForHITInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAdditionalAssignmentsForHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAdditionalAssignmentsForHITInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAdditionalAssignmentsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAdditionalAssignmentsForHITInput>
    public typealias MOutput = OperationOutput<CreateAdditionalAssignmentsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAdditionalAssignmentsForHITOutputError>
}

public struct CreateAdditionalAssignmentsForHITInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAdditionalAssignmentsForHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAdditionalAssignmentsForHITInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAdditionalAssignmentsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAdditionalAssignmentsForHITInput>
    public typealias MOutput = OperationOutput<CreateAdditionalAssignmentsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAdditionalAssignmentsForHITOutputError>
}

public struct CreateAdditionalAssignmentsForHITInput: Equatable {
    /// <p>The ID of the HIT to extend.</p>
    public let hITId: String?
    /// <p>The number of additional assignments to request for this HIT.</p>
    public let numberOfAdditionalAssignments: Int?
    /// <p>
    ///             A unique identifier for this request, which allows you to retry the call on error
    ///             without extending the HIT multiple times.
    ///             This is useful in cases such as network timeouts where it is unclear whether or not
    ///             the call succeeded on the server. If the extend HIT already exists in the system
    ///             from a previous call using the same <code>UniqueRequestToken</code>,
    ///             subsequent calls will return an error with a message containing the request ID.
    ///         </p>
    public let uniqueRequestToken: String?

    public init (
        hITId: String? = nil,
        numberOfAdditionalAssignments: Int? = nil,
        uniqueRequestToken: String? = nil
    )
    {
        self.hITId = hITId
        self.numberOfAdditionalAssignments = numberOfAdditionalAssignments
        self.uniqueRequestToken = uniqueRequestToken
    }
}

struct CreateAdditionalAssignmentsForHITInputBody: Equatable {
    public let hITId: String?
    public let numberOfAdditionalAssignments: Int?
    public let uniqueRequestToken: String?
}

extension CreateAdditionalAssignmentsForHITInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hITId = "HITId"
        case numberOfAdditionalAssignments = "NumberOfAdditionalAssignments"
        case uniqueRequestToken = "UniqueRequestToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let numberOfAdditionalAssignmentsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfAdditionalAssignments)
        numberOfAdditionalAssignments = numberOfAdditionalAssignmentsDecoded
        let uniqueRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uniqueRequestToken)
        uniqueRequestToken = uniqueRequestTokenDecoded
    }
}

extension CreateAdditionalAssignmentsForHITOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAdditionalAssignmentsForHITOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAdditionalAssignmentsForHITOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAdditionalAssignmentsForHITOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAdditionalAssignmentsForHITOutputResponse()"}
}

extension CreateAdditionalAssignmentsForHITOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateAdditionalAssignmentsForHITOutputResponse: Equatable {

    public init() {}
}

struct CreateAdditionalAssignmentsForHITOutputResponseBody: Equatable {
}

extension CreateAdditionalAssignmentsForHITOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateHITInputBodyMiddleware: Middleware {
    public let id: String = "CreateHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHITInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHITInput>
    public typealias MOutput = OperationOutput<CreateHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHITOutputError>
}

extension CreateHITInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHITInput(assignmentDurationInSeconds: \(String(describing: assignmentDurationInSeconds)), assignmentReviewPolicy: \(String(describing: assignmentReviewPolicy)), autoApprovalDelayInSeconds: \(String(describing: autoApprovalDelayInSeconds)), description: \(String(describing: description)), hITLayoutId: \(String(describing: hITLayoutId)), hITLayoutParameters: \(String(describing: hITLayoutParameters)), hITReviewPolicy: \(String(describing: hITReviewPolicy)), keywords: \(String(describing: keywords)), lifetimeInSeconds: \(String(describing: lifetimeInSeconds)), maxAssignments: \(String(describing: maxAssignments)), qualificationRequirements: \(String(describing: qualificationRequirements)), question: \(String(describing: question)), requesterAnnotation: \(String(describing: requesterAnnotation)), reward: \(String(describing: reward)), title: \(String(describing: title)), uniqueRequestToken: \(String(describing: uniqueRequestToken)))"}
}

extension CreateHITInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentDurationInSeconds = "AssignmentDurationInSeconds"
        case assignmentReviewPolicy = "AssignmentReviewPolicy"
        case autoApprovalDelayInSeconds = "AutoApprovalDelayInSeconds"
        case description = "Description"
        case hITLayoutId = "HITLayoutId"
        case hITLayoutParameters = "HITLayoutParameters"
        case hITReviewPolicy = "HITReviewPolicy"
        case keywords = "Keywords"
        case lifetimeInSeconds = "LifetimeInSeconds"
        case maxAssignments = "MaxAssignments"
        case qualificationRequirements = "QualificationRequirements"
        case question = "Question"
        case requesterAnnotation = "RequesterAnnotation"
        case reward = "Reward"
        case title = "Title"
        case uniqueRequestToken = "UniqueRequestToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentDurationInSeconds = assignmentDurationInSeconds {
            try encodeContainer.encode(assignmentDurationInSeconds, forKey: .assignmentDurationInSeconds)
        }
        if let assignmentReviewPolicy = assignmentReviewPolicy {
            try encodeContainer.encode(assignmentReviewPolicy, forKey: .assignmentReviewPolicy)
        }
        if let autoApprovalDelayInSeconds = autoApprovalDelayInSeconds {
            try encodeContainer.encode(autoApprovalDelayInSeconds, forKey: .autoApprovalDelayInSeconds)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hITLayoutId = hITLayoutId {
            try encodeContainer.encode(hITLayoutId, forKey: .hITLayoutId)
        }
        if let hITLayoutParameters = hITLayoutParameters {
            var hITLayoutParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hITLayoutParameters)
            for hitlayoutparameterlist0 in hITLayoutParameters {
                try hITLayoutParametersContainer.encode(hitlayoutparameterlist0)
            }
        }
        if let hITReviewPolicy = hITReviewPolicy {
            try encodeContainer.encode(hITReviewPolicy, forKey: .hITReviewPolicy)
        }
        if let keywords = keywords {
            try encodeContainer.encode(keywords, forKey: .keywords)
        }
        if let lifetimeInSeconds = lifetimeInSeconds {
            try encodeContainer.encode(lifetimeInSeconds, forKey: .lifetimeInSeconds)
        }
        if let maxAssignments = maxAssignments {
            try encodeContainer.encode(maxAssignments, forKey: .maxAssignments)
        }
        if let qualificationRequirements = qualificationRequirements {
            var qualificationRequirementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .qualificationRequirements)
            for qualificationrequirementlist0 in qualificationRequirements {
                try qualificationRequirementsContainer.encode(qualificationrequirementlist0)
            }
        }
        if let question = question {
            try encodeContainer.encode(question, forKey: .question)
        }
        if let requesterAnnotation = requesterAnnotation {
            try encodeContainer.encode(requesterAnnotation, forKey: .requesterAnnotation)
        }
        if let reward = reward {
            try encodeContainer.encode(reward, forKey: .reward)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let uniqueRequestToken = uniqueRequestToken {
            try encodeContainer.encode(uniqueRequestToken, forKey: .uniqueRequestToken)
        }
    }
}

public struct CreateHITInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHITInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHITInput>
    public typealias MOutput = OperationOutput<CreateHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHITOutputError>
}

public struct CreateHITInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHITInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHITInput>
    public typealias MOutput = OperationOutput<CreateHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHITOutputError>
}

public struct CreateHITInput: Equatable {
    /// <p>
    ///             The amount of time, in seconds, that a Worker has to complete the HIT after accepting it.
    ///             If a Worker does not complete the assignment within the specified duration,
    ///             the assignment is considered abandoned. If the HIT is still active
    ///             (that is, its lifetime has not elapsed), the assignment becomes available
    ///             for other users to find and accept.
    ///         </p>
    public let assignmentDurationInSeconds: Int?
    /// <p>
    ///             The Assignment-level Review Policy applies to the assignments under the HIT.
    ///             You can specify for Mechanical Turk to take various actions based on the policy.
    ///         </p>
    public let assignmentReviewPolicy: ReviewPolicy?
    /// <p>
    ///             The number of seconds after an assignment for the HIT has been submitted,
    ///             after which the assignment is considered Approved automatically
    ///             unless the Requester explicitly rejects it.
    ///         </p>
    public let autoApprovalDelayInSeconds: Int?
    /// <p>
    ///             A general description of the HIT. A description includes detailed information about the kind of task
    ///             the HIT contains. On the Amazon Mechanical Turk web site, the HIT description appears in the expanded
    ///             view of search results, and in the HIT and assignment screens. A good description gives the user enough
    ///             information to evaluate the HIT before accepting it.
    ///         </p>
    public let description: String?
    /// <p>
    ///             The HITLayoutId allows you to use a pre-existing HIT design with placeholder values
    ///             and create an additional HIT by providing those values as HITLayoutParameters.
    ///         </p>
    ///         <p>
    ///             Constraints: Either a Question parameter or a HITLayoutId parameter must be provided.
    ///         </p>
    public let hITLayoutId: String?
    /// <p>
    ///             If the HITLayoutId is provided, any placeholder values must be filled in with values
    ///             using the HITLayoutParameter structure. For more information, see HITLayout.
    ///         </p>
    public let hITLayoutParameters: [HITLayoutParameter]?
    /// <p>
    ///             The HIT-level Review Policy applies to the HIT.
    ///             You can specify for Mechanical Turk to take various actions based on the policy.
    ///         </p>
    public let hITReviewPolicy: ReviewPolicy?
    /// <p>
    ///             One or more words or phrases that describe the HIT, separated by commas.
    ///             These words are used in searches to find HITs.
    ///         </p>
    public let keywords: String?
    /// <p>
    ///             An amount of time, in seconds, after which the HIT is no longer available for users to accept.
    ///             After the lifetime of the HIT elapses, the HIT no longer appears in HIT searches,
    ///             even if not all of the assignments for the HIT have been accepted.
    ///         </p>
    public let lifetimeInSeconds: Int?
    /// <p>
    ///             The number of times the HIT can be accepted and completed before the HIT becomes unavailable.
    ///         </p>
    public let maxAssignments: Int?
    /// <p>
    ///             Conditions that a Worker's Qualifications must meet in order
    ///             to accept the HIT. A HIT can have between zero and ten
    ///             Qualification requirements. All requirements must be met in
    ///             order for a Worker to accept the HIT. Additionally, other
    ///             actions can be restricted using the <code>ActionsGuarded</code>
    ///             field on each <code>QualificationRequirement</code> structure.
    ///         </p>
    public let qualificationRequirements: [QualificationRequirement]?
    /// <p>
    ///             The data the person completing the HIT uses to produce the results.
    ///         </p>
    ///         <p>
    ///             Constraints: Must be a QuestionForm data structure, an ExternalQuestion data structure,
    ///             or an HTMLQuestion data structure. The XML question data must not be larger than
    ///             64 kilobytes (65,535 bytes) in size, including whitespace.
    ///         </p>
    ///         <p>Either a Question parameter or a HITLayoutId parameter must be provided.</p>
    public let question: String?
    /// <p>
    ///             An arbitrary data field.
    ///             The RequesterAnnotation parameter lets your application attach arbitrary data
    ///             to the HIT for tracking purposes.
    ///             For example, this parameter could be an identifier internal to the Requester's application
    ///             that corresponds with the HIT.
    ///         </p>
    ///         <p>
    ///             The RequesterAnnotation parameter for a HIT is only visible to the Requester who created the HIT.
    ///             It is not shown to the Worker, or any other Requester.
    ///         </p>
    ///         <p>
    ///             The RequesterAnnotation parameter may be different for each HIT you submit.
    ///             It does not affect how your HITs are grouped.
    ///         </p>
    public let requesterAnnotation: String?
    /// <p>
    ///             The amount of money the Requester will pay a Worker for successfully completing the HIT.
    ///         </p>
    public let reward: String?
    /// <p>
    ///             The title of the HIT. A title should be short and descriptive about the kind of task the HIT contains.
    ///             On the Amazon Mechanical Turk web site, the HIT title appears in search results,
    ///             and everywhere the HIT is mentioned.
    ///         </p>
    public let title: String?
    /// <p>
    ///             A unique identifier for this request which allows you to retry the call
    ///             on error without creating duplicate HITs.
    ///             This is useful in cases such as network timeouts where it is unclear whether or not
    ///             the call succeeded on the server.
    ///             If the HIT already exists in the system from a previous call using the same UniqueRequestToken,
    ///             subsequent calls will return a AWS.MechanicalTurk.HitAlreadyExists error
    ///             with a message containing the HITId.
    ///         </p>
    ///         <note>
    ///             <p>
    ///                 Note: It is your responsibility to ensure uniqueness of the token.
    ///                 The unique token expires after 24 hours. Subsequent calls using the same
    ///                 UniqueRequestToken made after the 24 hour limit could create duplicate HITs.
    ///             </p>
    ///         </note>
    public let uniqueRequestToken: String?

    public init (
        assignmentDurationInSeconds: Int? = nil,
        assignmentReviewPolicy: ReviewPolicy? = nil,
        autoApprovalDelayInSeconds: Int? = nil,
        description: String? = nil,
        hITLayoutId: String? = nil,
        hITLayoutParameters: [HITLayoutParameter]? = nil,
        hITReviewPolicy: ReviewPolicy? = nil,
        keywords: String? = nil,
        lifetimeInSeconds: Int? = nil,
        maxAssignments: Int? = nil,
        qualificationRequirements: [QualificationRequirement]? = nil,
        question: String? = nil,
        requesterAnnotation: String? = nil,
        reward: String? = nil,
        title: String? = nil,
        uniqueRequestToken: String? = nil
    )
    {
        self.assignmentDurationInSeconds = assignmentDurationInSeconds
        self.assignmentReviewPolicy = assignmentReviewPolicy
        self.autoApprovalDelayInSeconds = autoApprovalDelayInSeconds
        self.description = description
        self.hITLayoutId = hITLayoutId
        self.hITLayoutParameters = hITLayoutParameters
        self.hITReviewPolicy = hITReviewPolicy
        self.keywords = keywords
        self.lifetimeInSeconds = lifetimeInSeconds
        self.maxAssignments = maxAssignments
        self.qualificationRequirements = qualificationRequirements
        self.question = question
        self.requesterAnnotation = requesterAnnotation
        self.reward = reward
        self.title = title
        self.uniqueRequestToken = uniqueRequestToken
    }
}

struct CreateHITInputBody: Equatable {
    public let maxAssignments: Int?
    public let autoApprovalDelayInSeconds: Int?
    public let lifetimeInSeconds: Int?
    public let assignmentDurationInSeconds: Int?
    public let reward: String?
    public let title: String?
    public let keywords: String?
    public let description: String?
    public let question: String?
    public let requesterAnnotation: String?
    public let qualificationRequirements: [QualificationRequirement]?
    public let uniqueRequestToken: String?
    public let assignmentReviewPolicy: ReviewPolicy?
    public let hITReviewPolicy: ReviewPolicy?
    public let hITLayoutId: String?
    public let hITLayoutParameters: [HITLayoutParameter]?
}

extension CreateHITInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentDurationInSeconds = "AssignmentDurationInSeconds"
        case assignmentReviewPolicy = "AssignmentReviewPolicy"
        case autoApprovalDelayInSeconds = "AutoApprovalDelayInSeconds"
        case description = "Description"
        case hITLayoutId = "HITLayoutId"
        case hITLayoutParameters = "HITLayoutParameters"
        case hITReviewPolicy = "HITReviewPolicy"
        case keywords = "Keywords"
        case lifetimeInSeconds = "LifetimeInSeconds"
        case maxAssignments = "MaxAssignments"
        case qualificationRequirements = "QualificationRequirements"
        case question = "Question"
        case requesterAnnotation = "RequesterAnnotation"
        case reward = "Reward"
        case title = "Title"
        case uniqueRequestToken = "UniqueRequestToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxAssignmentsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxAssignments)
        maxAssignments = maxAssignmentsDecoded
        let autoApprovalDelayInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .autoApprovalDelayInSeconds)
        autoApprovalDelayInSeconds = autoApprovalDelayInSecondsDecoded
        let lifetimeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .lifetimeInSeconds)
        lifetimeInSeconds = lifetimeInSecondsDecoded
        let assignmentDurationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .assignmentDurationInSeconds)
        assignmentDurationInSeconds = assignmentDurationInSecondsDecoded
        let rewardDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reward)
        reward = rewardDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let keywordsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keywords)
        keywords = keywordsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let questionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .question)
        question = questionDecoded
        let requesterAnnotationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requesterAnnotation)
        requesterAnnotation = requesterAnnotationDecoded
        let qualificationRequirementsContainer = try containerValues.decodeIfPresent([QualificationRequirement?].self, forKey: .qualificationRequirements)
        var qualificationRequirementsDecoded0:[QualificationRequirement]? = nil
        if let qualificationRequirementsContainer = qualificationRequirementsContainer {
            qualificationRequirementsDecoded0 = [QualificationRequirement]()
            for structure0 in qualificationRequirementsContainer {
                if let structure0 = structure0 {
                    qualificationRequirementsDecoded0?.append(structure0)
                }
            }
        }
        qualificationRequirements = qualificationRequirementsDecoded0
        let uniqueRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uniqueRequestToken)
        uniqueRequestToken = uniqueRequestTokenDecoded
        let assignmentReviewPolicyDecoded = try containerValues.decodeIfPresent(ReviewPolicy.self, forKey: .assignmentReviewPolicy)
        assignmentReviewPolicy = assignmentReviewPolicyDecoded
        let hITReviewPolicyDecoded = try containerValues.decodeIfPresent(ReviewPolicy.self, forKey: .hITReviewPolicy)
        hITReviewPolicy = hITReviewPolicyDecoded
        let hITLayoutIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITLayoutId)
        hITLayoutId = hITLayoutIdDecoded
        let hITLayoutParametersContainer = try containerValues.decodeIfPresent([HITLayoutParameter?].self, forKey: .hITLayoutParameters)
        var hITLayoutParametersDecoded0:[HITLayoutParameter]? = nil
        if let hITLayoutParametersContainer = hITLayoutParametersContainer {
            hITLayoutParametersDecoded0 = [HITLayoutParameter]()
            for structure0 in hITLayoutParametersContainer {
                if let structure0 = structure0 {
                    hITLayoutParametersDecoded0?.append(structure0)
                }
            }
        }
        hITLayoutParameters = hITLayoutParametersDecoded0
    }
}

extension CreateHITOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHITOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHITOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHITOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHITOutputResponse(hIT: \(String(describing: hIT)))"}
}

extension CreateHITOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateHITOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hIT = output.hIT
        } else {
            self.hIT = nil
        }
    }
}

public struct CreateHITOutputResponse: Equatable {
    /// <p> Contains the newly created HIT data. For a description of
    ///             the HIT data structure as it appears in responses, see the HIT Data
    ///             Structure documentation.
    ///         </p>
    public let hIT: HIT?

    public init (
        hIT: HIT? = nil
    )
    {
        self.hIT = hIT
    }
}

struct CreateHITOutputResponseBody: Equatable {
    public let hIT: HIT?
}

extension CreateHITOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hIT = "HIT"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITDecoded = try containerValues.decodeIfPresent(HIT.self, forKey: .hIT)
        hIT = hITDecoded
    }
}

public struct CreateHITTypeInputBodyMiddleware: Middleware {
    public let id: String = "CreateHITTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHITTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHITTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHITTypeInput>
    public typealias MOutput = OperationOutput<CreateHITTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHITTypeOutputError>
}

extension CreateHITTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHITTypeInput(assignmentDurationInSeconds: \(String(describing: assignmentDurationInSeconds)), autoApprovalDelayInSeconds: \(String(describing: autoApprovalDelayInSeconds)), description: \(String(describing: description)), keywords: \(String(describing: keywords)), qualificationRequirements: \(String(describing: qualificationRequirements)), reward: \(String(describing: reward)), title: \(String(describing: title)))"}
}

extension CreateHITTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentDurationInSeconds = "AssignmentDurationInSeconds"
        case autoApprovalDelayInSeconds = "AutoApprovalDelayInSeconds"
        case description = "Description"
        case keywords = "Keywords"
        case qualificationRequirements = "QualificationRequirements"
        case reward = "Reward"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentDurationInSeconds = assignmentDurationInSeconds {
            try encodeContainer.encode(assignmentDurationInSeconds, forKey: .assignmentDurationInSeconds)
        }
        if let autoApprovalDelayInSeconds = autoApprovalDelayInSeconds {
            try encodeContainer.encode(autoApprovalDelayInSeconds, forKey: .autoApprovalDelayInSeconds)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keywords = keywords {
            try encodeContainer.encode(keywords, forKey: .keywords)
        }
        if let qualificationRequirements = qualificationRequirements {
            var qualificationRequirementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .qualificationRequirements)
            for qualificationrequirementlist0 in qualificationRequirements {
                try qualificationRequirementsContainer.encode(qualificationrequirementlist0)
            }
        }
        if let reward = reward {
            try encodeContainer.encode(reward, forKey: .reward)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

public struct CreateHITTypeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHITTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHITTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHITTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHITTypeInput>
    public typealias MOutput = OperationOutput<CreateHITTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHITTypeOutputError>
}

public struct CreateHITTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHITTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHITTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHITTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHITTypeInput>
    public typealias MOutput = OperationOutput<CreateHITTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHITTypeOutputError>
}

public struct CreateHITTypeInput: Equatable {
    /// <p>
    ///             The amount of time, in seconds, that a Worker has to complete the HIT after accepting it.
    ///             If a Worker does not complete the assignment within the specified duration,
    ///             the assignment is considered abandoned. If the HIT is still active
    ///             (that is, its lifetime has not elapsed), the assignment becomes available
    ///             for other users to find and accept.
    ///         </p>
    public let assignmentDurationInSeconds: Int?
    /// <p>
    ///             The number of seconds after an assignment for the HIT has been submitted,
    ///             after which the assignment is considered Approved automatically
    ///             unless the Requester explicitly rejects it.
    ///         </p>
    public let autoApprovalDelayInSeconds: Int?
    /// <p>
    ///             A general description of the HIT. A description includes detailed information about the kind of task
    ///             the HIT contains. On the Amazon Mechanical Turk web site, the HIT description appears in the expanded
    ///             view of search results, and in the HIT and assignment screens. A good description gives the user enough
    ///             information to evaluate the HIT before accepting it.
    ///         </p>
    public let description: String?
    /// <p>
    ///             One or more words or phrases that describe the HIT, separated by commas.
    ///             These words are used in searches to find HITs.
    ///         </p>
    public let keywords: String?
    /// <p>
    ///             Conditions that a Worker's Qualifications must meet in order
    ///             to accept the HIT. A HIT can have between zero and ten
    ///             Qualification requirements. All requirements must be met in
    ///             order for a Worker to accept the HIT. Additionally, other
    ///             actions can be restricted using the <code>ActionsGuarded</code>
    ///             field on each <code>QualificationRequirement</code> structure.
    ///         </p>
    public let qualificationRequirements: [QualificationRequirement]?
    /// <p>
    ///             The amount of money the Requester will pay a Worker for successfully completing the HIT.
    ///         </p>
    public let reward: String?
    /// <p>
    ///             The title of the HIT. A title should be short and descriptive about the kind of task the HIT contains.
    ///             On the Amazon Mechanical Turk web site, the HIT title appears in search results,
    ///             and everywhere the HIT is mentioned.
    ///         </p>
    public let title: String?

    public init (
        assignmentDurationInSeconds: Int? = nil,
        autoApprovalDelayInSeconds: Int? = nil,
        description: String? = nil,
        keywords: String? = nil,
        qualificationRequirements: [QualificationRequirement]? = nil,
        reward: String? = nil,
        title: String? = nil
    )
    {
        self.assignmentDurationInSeconds = assignmentDurationInSeconds
        self.autoApprovalDelayInSeconds = autoApprovalDelayInSeconds
        self.description = description
        self.keywords = keywords
        self.qualificationRequirements = qualificationRequirements
        self.reward = reward
        self.title = title
    }
}

struct CreateHITTypeInputBody: Equatable {
    public let autoApprovalDelayInSeconds: Int?
    public let assignmentDurationInSeconds: Int?
    public let reward: String?
    public let title: String?
    public let keywords: String?
    public let description: String?
    public let qualificationRequirements: [QualificationRequirement]?
}

extension CreateHITTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentDurationInSeconds = "AssignmentDurationInSeconds"
        case autoApprovalDelayInSeconds = "AutoApprovalDelayInSeconds"
        case description = "Description"
        case keywords = "Keywords"
        case qualificationRequirements = "QualificationRequirements"
        case reward = "Reward"
        case title = "Title"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoApprovalDelayInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .autoApprovalDelayInSeconds)
        autoApprovalDelayInSeconds = autoApprovalDelayInSecondsDecoded
        let assignmentDurationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .assignmentDurationInSeconds)
        assignmentDurationInSeconds = assignmentDurationInSecondsDecoded
        let rewardDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reward)
        reward = rewardDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let keywordsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keywords)
        keywords = keywordsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let qualificationRequirementsContainer = try containerValues.decodeIfPresent([QualificationRequirement?].self, forKey: .qualificationRequirements)
        var qualificationRequirementsDecoded0:[QualificationRequirement]? = nil
        if let qualificationRequirementsContainer = qualificationRequirementsContainer {
            qualificationRequirementsDecoded0 = [QualificationRequirement]()
            for structure0 in qualificationRequirementsContainer {
                if let structure0 = structure0 {
                    qualificationRequirementsDecoded0?.append(structure0)
                }
            }
        }
        qualificationRequirements = qualificationRequirementsDecoded0
    }
}

extension CreateHITTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHITTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHITTypeOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHITTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHITTypeOutputResponse(hITTypeId: \(String(describing: hITTypeId)))"}
}

extension CreateHITTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateHITTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hITTypeId = output.hITTypeId
        } else {
            self.hITTypeId = nil
        }
    }
}

public struct CreateHITTypeOutputResponse: Equatable {
    /// <p> The ID of the newly registered HIT type.</p>
    public let hITTypeId: String?

    public init (
        hITTypeId: String? = nil
    )
    {
        self.hITTypeId = hITTypeId
    }
}

struct CreateHITTypeOutputResponseBody: Equatable {
    public let hITTypeId: String?
}

extension CreateHITTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hITTypeId = "HITTypeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITTypeId)
        hITTypeId = hITTypeIdDecoded
    }
}

public struct CreateHITWithHITTypeInputBodyMiddleware: Middleware {
    public let id: String = "CreateHITWithHITTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHITWithHITTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHITWithHITTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHITWithHITTypeInput>
    public typealias MOutput = OperationOutput<CreateHITWithHITTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHITWithHITTypeOutputError>
}

extension CreateHITWithHITTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHITWithHITTypeInput(assignmentReviewPolicy: \(String(describing: assignmentReviewPolicy)), hITLayoutId: \(String(describing: hITLayoutId)), hITLayoutParameters: \(String(describing: hITLayoutParameters)), hITReviewPolicy: \(String(describing: hITReviewPolicy)), hITTypeId: \(String(describing: hITTypeId)), lifetimeInSeconds: \(String(describing: lifetimeInSeconds)), maxAssignments: \(String(describing: maxAssignments)), question: \(String(describing: question)), requesterAnnotation: \(String(describing: requesterAnnotation)), uniqueRequestToken: \(String(describing: uniqueRequestToken)))"}
}

extension CreateHITWithHITTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentReviewPolicy = "AssignmentReviewPolicy"
        case hITLayoutId = "HITLayoutId"
        case hITLayoutParameters = "HITLayoutParameters"
        case hITReviewPolicy = "HITReviewPolicy"
        case hITTypeId = "HITTypeId"
        case lifetimeInSeconds = "LifetimeInSeconds"
        case maxAssignments = "MaxAssignments"
        case question = "Question"
        case requesterAnnotation = "RequesterAnnotation"
        case uniqueRequestToken = "UniqueRequestToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentReviewPolicy = assignmentReviewPolicy {
            try encodeContainer.encode(assignmentReviewPolicy, forKey: .assignmentReviewPolicy)
        }
        if let hITLayoutId = hITLayoutId {
            try encodeContainer.encode(hITLayoutId, forKey: .hITLayoutId)
        }
        if let hITLayoutParameters = hITLayoutParameters {
            var hITLayoutParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hITLayoutParameters)
            for hitlayoutparameterlist0 in hITLayoutParameters {
                try hITLayoutParametersContainer.encode(hitlayoutparameterlist0)
            }
        }
        if let hITReviewPolicy = hITReviewPolicy {
            try encodeContainer.encode(hITReviewPolicy, forKey: .hITReviewPolicy)
        }
        if let hITTypeId = hITTypeId {
            try encodeContainer.encode(hITTypeId, forKey: .hITTypeId)
        }
        if let lifetimeInSeconds = lifetimeInSeconds {
            try encodeContainer.encode(lifetimeInSeconds, forKey: .lifetimeInSeconds)
        }
        if let maxAssignments = maxAssignments {
            try encodeContainer.encode(maxAssignments, forKey: .maxAssignments)
        }
        if let question = question {
            try encodeContainer.encode(question, forKey: .question)
        }
        if let requesterAnnotation = requesterAnnotation {
            try encodeContainer.encode(requesterAnnotation, forKey: .requesterAnnotation)
        }
        if let uniqueRequestToken = uniqueRequestToken {
            try encodeContainer.encode(uniqueRequestToken, forKey: .uniqueRequestToken)
        }
    }
}

public struct CreateHITWithHITTypeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHITWithHITTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHITWithHITTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHITWithHITTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHITWithHITTypeInput>
    public typealias MOutput = OperationOutput<CreateHITWithHITTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHITWithHITTypeOutputError>
}

public struct CreateHITWithHITTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHITWithHITTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHITWithHITTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHITWithHITTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHITWithHITTypeInput>
    public typealias MOutput = OperationOutput<CreateHITWithHITTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHITWithHITTypeOutputError>
}

public struct CreateHITWithHITTypeInput: Equatable {
    /// <p>
    ///             The Assignment-level Review Policy applies to the assignments under the HIT.
    ///             You can specify for Mechanical Turk to take various actions based on the policy.
    ///         </p>
    public let assignmentReviewPolicy: ReviewPolicy?
    /// <p>
    ///             The HITLayoutId allows you to use a pre-existing HIT design with placeholder values
    ///             and create an additional HIT by providing those values as HITLayoutParameters.
    ///         </p>
    ///         <p>
    ///             Constraints: Either a Question parameter or a HITLayoutId parameter must be provided.
    ///         </p>
    public let hITLayoutId: String?
    /// <p>
    ///             If the HITLayoutId is provided, any placeholder values must be filled in with values
    ///             using the HITLayoutParameter structure. For more information, see HITLayout.
    ///         </p>
    public let hITLayoutParameters: [HITLayoutParameter]?
    /// <p>
    ///             The HIT-level Review Policy applies to the HIT.
    ///             You can specify for Mechanical Turk to take various actions based on the policy.
    ///         </p>
    public let hITReviewPolicy: ReviewPolicy?
    /// <p>The HIT type ID you want to create this HIT with.</p>
    public let hITTypeId: String?
    /// <p>
    ///             An amount of time, in seconds, after which the HIT is no longer available for users to accept.
    ///             After the lifetime of the HIT elapses, the HIT no longer appears in HIT searches,
    ///             even if not all of the assignments for the HIT have been accepted.
    ///         </p>
    public let lifetimeInSeconds: Int?
    /// <p>
    ///             The number of times the HIT can be accepted and completed before the HIT becomes unavailable.
    ///         </p>
    public let maxAssignments: Int?
    /// <p>
    ///             The data the person completing the HIT uses to produce the results.
    ///         </p>
    ///         <p>
    ///             Constraints: Must be a QuestionForm data structure, an ExternalQuestion data structure,
    ///             or an HTMLQuestion data structure. The XML question data must not be larger than
    ///             64 kilobytes (65,535 bytes) in size, including whitespace.
    ///         </p>
    ///         <p>Either a Question parameter or a HITLayoutId parameter must be provided.</p>
    public let question: String?
    /// <p>
    ///             An arbitrary data field.
    ///             The RequesterAnnotation parameter lets your application attach arbitrary data
    ///             to the HIT for tracking purposes.
    ///             For example, this parameter could be an identifier internal to the Requester's application
    ///             that corresponds with the HIT.
    ///         </p>
    ///         <p>
    ///             The RequesterAnnotation parameter for a HIT is only visible to the Requester who created the HIT.
    ///             It is not shown to the Worker, or any other Requester.
    ///         </p>
    ///         <p>
    ///             The RequesterAnnotation parameter may be different for each HIT you submit.
    ///             It does not affect how your HITs are grouped.
    ///         </p>
    public let requesterAnnotation: String?
    /// <p>
    ///             A unique identifier for this request which allows you to retry the call
    ///             on error without creating duplicate HITs.
    ///             This is useful in cases such as network timeouts where it is unclear whether or not
    ///             the call succeeded on the server.
    ///             If the HIT already exists in the system from a previous call using the same UniqueRequestToken,
    ///             subsequent calls will return a AWS.MechanicalTurk.HitAlreadyExists error
    ///             with a message containing the HITId.
    ///         </p>
    ///         <note>
    ///             <p>
    ///                 Note: It is your responsibility to ensure uniqueness of the token.
    ///                 The unique token expires after 24 hours. Subsequent calls using the same
    ///                 UniqueRequestToken made after the 24 hour limit could create duplicate HITs.
    ///             </p>
    ///         </note>
    public let uniqueRequestToken: String?

    public init (
        assignmentReviewPolicy: ReviewPolicy? = nil,
        hITLayoutId: String? = nil,
        hITLayoutParameters: [HITLayoutParameter]? = nil,
        hITReviewPolicy: ReviewPolicy? = nil,
        hITTypeId: String? = nil,
        lifetimeInSeconds: Int? = nil,
        maxAssignments: Int? = nil,
        question: String? = nil,
        requesterAnnotation: String? = nil,
        uniqueRequestToken: String? = nil
    )
    {
        self.assignmentReviewPolicy = assignmentReviewPolicy
        self.hITLayoutId = hITLayoutId
        self.hITLayoutParameters = hITLayoutParameters
        self.hITReviewPolicy = hITReviewPolicy
        self.hITTypeId = hITTypeId
        self.lifetimeInSeconds = lifetimeInSeconds
        self.maxAssignments = maxAssignments
        self.question = question
        self.requesterAnnotation = requesterAnnotation
        self.uniqueRequestToken = uniqueRequestToken
    }
}

struct CreateHITWithHITTypeInputBody: Equatable {
    public let hITTypeId: String?
    public let maxAssignments: Int?
    public let lifetimeInSeconds: Int?
    public let question: String?
    public let requesterAnnotation: String?
    public let uniqueRequestToken: String?
    public let assignmentReviewPolicy: ReviewPolicy?
    public let hITReviewPolicy: ReviewPolicy?
    public let hITLayoutId: String?
    public let hITLayoutParameters: [HITLayoutParameter]?
}

extension CreateHITWithHITTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentReviewPolicy = "AssignmentReviewPolicy"
        case hITLayoutId = "HITLayoutId"
        case hITLayoutParameters = "HITLayoutParameters"
        case hITReviewPolicy = "HITReviewPolicy"
        case hITTypeId = "HITTypeId"
        case lifetimeInSeconds = "LifetimeInSeconds"
        case maxAssignments = "MaxAssignments"
        case question = "Question"
        case requesterAnnotation = "RequesterAnnotation"
        case uniqueRequestToken = "UniqueRequestToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITTypeId)
        hITTypeId = hITTypeIdDecoded
        let maxAssignmentsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxAssignments)
        maxAssignments = maxAssignmentsDecoded
        let lifetimeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .lifetimeInSeconds)
        lifetimeInSeconds = lifetimeInSecondsDecoded
        let questionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .question)
        question = questionDecoded
        let requesterAnnotationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requesterAnnotation)
        requesterAnnotation = requesterAnnotationDecoded
        let uniqueRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uniqueRequestToken)
        uniqueRequestToken = uniqueRequestTokenDecoded
        let assignmentReviewPolicyDecoded = try containerValues.decodeIfPresent(ReviewPolicy.self, forKey: .assignmentReviewPolicy)
        assignmentReviewPolicy = assignmentReviewPolicyDecoded
        let hITReviewPolicyDecoded = try containerValues.decodeIfPresent(ReviewPolicy.self, forKey: .hITReviewPolicy)
        hITReviewPolicy = hITReviewPolicyDecoded
        let hITLayoutIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITLayoutId)
        hITLayoutId = hITLayoutIdDecoded
        let hITLayoutParametersContainer = try containerValues.decodeIfPresent([HITLayoutParameter?].self, forKey: .hITLayoutParameters)
        var hITLayoutParametersDecoded0:[HITLayoutParameter]? = nil
        if let hITLayoutParametersContainer = hITLayoutParametersContainer {
            hITLayoutParametersDecoded0 = [HITLayoutParameter]()
            for structure0 in hITLayoutParametersContainer {
                if let structure0 = structure0 {
                    hITLayoutParametersDecoded0?.append(structure0)
                }
            }
        }
        hITLayoutParameters = hITLayoutParametersDecoded0
    }
}

extension CreateHITWithHITTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHITWithHITTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHITWithHITTypeOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHITWithHITTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHITWithHITTypeOutputResponse(hIT: \(String(describing: hIT)))"}
}

extension CreateHITWithHITTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateHITWithHITTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hIT = output.hIT
        } else {
            self.hIT = nil
        }
    }
}

public struct CreateHITWithHITTypeOutputResponse: Equatable {
    /// <p> Contains the newly created HIT data. For a description of
    ///             the HIT data structure as it appears in responses, see the HIT Data
    ///             Structure documentation.
    ///         </p>
    public let hIT: HIT?

    public init (
        hIT: HIT? = nil
    )
    {
        self.hIT = hIT
    }
}

struct CreateHITWithHITTypeOutputResponseBody: Equatable {
    public let hIT: HIT?
}

extension CreateHITWithHITTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hIT = "HIT"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITDecoded = try containerValues.decodeIfPresent(HIT.self, forKey: .hIT)
        hIT = hITDecoded
    }
}

public struct CreateQualificationTypeInputBodyMiddleware: Middleware {
    public let id: String = "CreateQualificationTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQualificationTypeInput>
    public typealias MOutput = OperationOutput<CreateQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQualificationTypeOutputError>
}

extension CreateQualificationTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateQualificationTypeInput(answerKey: \(String(describing: answerKey)), autoGranted: \(String(describing: autoGranted)), autoGrantedValue: \(String(describing: autoGrantedValue)), description: \(String(describing: description)), keywords: \(String(describing: keywords)), name: \(String(describing: name)), qualificationTypeStatus: \(String(describing: qualificationTypeStatus)), retryDelayInSeconds: \(String(describing: retryDelayInSeconds)), test: \(String(describing: test)), testDurationInSeconds: \(String(describing: testDurationInSeconds)))"}
}

extension CreateQualificationTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case answerKey = "AnswerKey"
        case autoGranted = "AutoGranted"
        case autoGrantedValue = "AutoGrantedValue"
        case description = "Description"
        case keywords = "Keywords"
        case name = "Name"
        case qualificationTypeStatus = "QualificationTypeStatus"
        case retryDelayInSeconds = "RetryDelayInSeconds"
        case test = "Test"
        case testDurationInSeconds = "TestDurationInSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answerKey = answerKey {
            try encodeContainer.encode(answerKey, forKey: .answerKey)
        }
        if let autoGranted = autoGranted {
            try encodeContainer.encode(autoGranted, forKey: .autoGranted)
        }
        if let autoGrantedValue = autoGrantedValue {
            try encodeContainer.encode(autoGrantedValue, forKey: .autoGrantedValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keywords = keywords {
            try encodeContainer.encode(keywords, forKey: .keywords)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let qualificationTypeStatus = qualificationTypeStatus {
            try encodeContainer.encode(qualificationTypeStatus.rawValue, forKey: .qualificationTypeStatus)
        }
        if let retryDelayInSeconds = retryDelayInSeconds {
            try encodeContainer.encode(retryDelayInSeconds, forKey: .retryDelayInSeconds)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
        if let testDurationInSeconds = testDurationInSeconds {
            try encodeContainer.encode(testDurationInSeconds, forKey: .testDurationInSeconds)
        }
    }
}

public struct CreateQualificationTypeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateQualificationTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQualificationTypeInput>
    public typealias MOutput = OperationOutput<CreateQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQualificationTypeOutputError>
}

public struct CreateQualificationTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateQualificationTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQualificationTypeInput>
    public typealias MOutput = OperationOutput<CreateQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQualificationTypeOutputError>
}

public struct CreateQualificationTypeInput: Equatable {
    /// <p>The answers to the Qualification test specified in the Test
    ///             parameter, in the form of an AnswerKey data structure.</p>
    ///         <p>Constraints: Must not be longer than 65535 bytes.</p>
    ///         <p>Constraints: None. If not specified, you must process
    ///             Qualification requests manually.</p>
    public let answerKey: String?
    /// <p>Specifies whether requests for the Qualification type are
    ///             granted immediately, without prompting the Worker with a
    ///             Qualification test.</p>
    ///         <p>Constraints: If the Test parameter is specified, this
    ///             parameter cannot be true.</p>
    public let autoGranted: Bool?
    /// <p>The Qualification value to use for automatically granted
    ///             Qualifications. This parameter is used only if the AutoGranted
    ///             parameter is true.</p>
    public let autoGrantedValue: Int?
    /// <p>A long description for the Qualification type. On the Amazon
    ///             Mechanical Turk website, the long description is displayed when a
    ///             Worker examines a Qualification type.</p>
    public let description: String?
    /// <p>One or more words or phrases that describe the Qualification
    ///             type, separated by commas. The keywords of a type make the type
    ///             easier to find during a search.</p>
    public let keywords: String?
    /// <p> The name you give to the Qualification type. The type name
    ///             is used to represent the Qualification to Workers, and to find the
    ///             type using a Qualification type search. It must be unique across all
    ///             of your Qualification types.</p>
    public let name: String?
    /// <p>The initial status of the Qualification type.</p>
    ///         <p>Constraints: Valid values are: Active | Inactive</p>
    public let qualificationTypeStatus: QualificationTypeStatus?
    /// <p>The number of seconds that a Worker must wait after
    ///             requesting a Qualification of the Qualification type before the
    ///             worker can retry the Qualification request.</p>
    ///         <p>Constraints: None. If not specified, retries are disabled and
    ///             Workers can request a Qualification of this type only once, even if
    ///             the Worker has not been granted the Qualification. It is not possible
    ///             to disable retries for a Qualification type after it has been created
    ///             with retries enabled. If you want to disable retries, you must delete
    ///             existing retry-enabled Qualification type and then create a new
    ///             Qualification type with retries disabled.</p>
    public let retryDelayInSeconds: Int?
    /// <p>
    ///             The questions for the Qualification test a Worker must answer
    ///             correctly to obtain a Qualification of this type. If this parameter
    ///             is specified,
    ///             <code>TestDurationInSeconds</code>
    ///             must also be specified.
    ///         </p>
    ///         <p>Constraints: Must not be longer than 65535 bytes. Must be a
    ///             QuestionForm data structure. This parameter cannot be specified if
    ///             AutoGranted is true.</p>
    ///         <p>Constraints: None. If not specified, the Worker may request
    ///             the Qualification without answering any questions.</p>
    public let test: String?
    /// <p>The number of seconds the Worker has to complete the
    ///             Qualification test, starting from the time the Worker requests the
    ///             Qualification.</p>
    public let testDurationInSeconds: Int?

    public init (
        answerKey: String? = nil,
        autoGranted: Bool? = nil,
        autoGrantedValue: Int? = nil,
        description: String? = nil,
        keywords: String? = nil,
        name: String? = nil,
        qualificationTypeStatus: QualificationTypeStatus? = nil,
        retryDelayInSeconds: Int? = nil,
        test: String? = nil,
        testDurationInSeconds: Int? = nil
    )
    {
        self.answerKey = answerKey
        self.autoGranted = autoGranted
        self.autoGrantedValue = autoGrantedValue
        self.description = description
        self.keywords = keywords
        self.name = name
        self.qualificationTypeStatus = qualificationTypeStatus
        self.retryDelayInSeconds = retryDelayInSeconds
        self.test = test
        self.testDurationInSeconds = testDurationInSeconds
    }
}

struct CreateQualificationTypeInputBody: Equatable {
    public let name: String?
    public let keywords: String?
    public let description: String?
    public let qualificationTypeStatus: QualificationTypeStatus?
    public let retryDelayInSeconds: Int?
    public let test: String?
    public let answerKey: String?
    public let testDurationInSeconds: Int?
    public let autoGranted: Bool?
    public let autoGrantedValue: Int?
}

extension CreateQualificationTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case answerKey = "AnswerKey"
        case autoGranted = "AutoGranted"
        case autoGrantedValue = "AutoGrantedValue"
        case description = "Description"
        case keywords = "Keywords"
        case name = "Name"
        case qualificationTypeStatus = "QualificationTypeStatus"
        case retryDelayInSeconds = "RetryDelayInSeconds"
        case test = "Test"
        case testDurationInSeconds = "TestDurationInSeconds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let keywordsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keywords)
        keywords = keywordsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let qualificationTypeStatusDecoded = try containerValues.decodeIfPresent(QualificationTypeStatus.self, forKey: .qualificationTypeStatus)
        qualificationTypeStatus = qualificationTypeStatusDecoded
        let retryDelayInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retryDelayInSeconds)
        retryDelayInSeconds = retryDelayInSecondsDecoded
        let testDecoded = try containerValues.decodeIfPresent(String.self, forKey: .test)
        test = testDecoded
        let answerKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .answerKey)
        answerKey = answerKeyDecoded
        let testDurationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .testDurationInSeconds)
        testDurationInSeconds = testDurationInSecondsDecoded
        let autoGrantedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoGranted)
        autoGranted = autoGrantedDecoded
        let autoGrantedValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .autoGrantedValue)
        autoGrantedValue = autoGrantedValueDecoded
    }
}

extension CreateQualificationTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateQualificationTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateQualificationTypeOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateQualificationTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateQualificationTypeOutputResponse(qualificationType: \(String(describing: qualificationType)))"}
}

extension CreateQualificationTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateQualificationTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.qualificationType = output.qualificationType
        } else {
            self.qualificationType = nil
        }
    }
}

public struct CreateQualificationTypeOutputResponse: Equatable {
    /// <p>The created Qualification type, returned as a
    ///             QualificationType data structure.</p>
    public let qualificationType: QualificationType?

    public init (
        qualificationType: QualificationType? = nil
    )
    {
        self.qualificationType = qualificationType
    }
}

struct CreateQualificationTypeOutputResponseBody: Equatable {
    public let qualificationType: QualificationType?
}

extension CreateQualificationTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case qualificationType = "QualificationType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeDecoded = try containerValues.decodeIfPresent(QualificationType.self, forKey: .qualificationType)
        qualificationType = qualificationTypeDecoded
    }
}

public struct CreateWorkerBlockInputBodyMiddleware: Middleware {
    public let id: String = "CreateWorkerBlockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkerBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkerBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkerBlockInput>
    public typealias MOutput = OperationOutput<CreateWorkerBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkerBlockOutputError>
}

extension CreateWorkerBlockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkerBlockInput(reason: \(String(describing: reason)), workerId: \(String(describing: workerId)))"}
}

extension CreateWorkerBlockInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }
}

public struct CreateWorkerBlockInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWorkerBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkerBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkerBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkerBlockInput>
    public typealias MOutput = OperationOutput<CreateWorkerBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkerBlockOutputError>
}

public struct CreateWorkerBlockInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWorkerBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkerBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkerBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkerBlockInput>
    public typealias MOutput = OperationOutput<CreateWorkerBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkerBlockOutputError>
}

public struct CreateWorkerBlockInput: Equatable {
    /// <p>A message explaining the reason for blocking the Worker. This parameter enables you to keep track of your Workers. The Worker does not see this message.</p>
    public let reason: String?
    /// <p>The ID of the Worker to block.</p>
    public let workerId: String?

    public init (
        reason: String? = nil,
        workerId: String? = nil
    )
    {
        self.reason = reason
        self.workerId = workerId
    }
}

struct CreateWorkerBlockInputBody: Equatable {
    public let workerId: String?
    public let reason: String?
}

extension CreateWorkerBlockInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CreateWorkerBlockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkerBlockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkerBlockOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkerBlockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkerBlockOutputResponse()"}
}

extension CreateWorkerBlockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateWorkerBlockOutputResponse: Equatable {

    public init() {}
}

struct CreateWorkerBlockOutputResponseBody: Equatable {
}

extension CreateWorkerBlockOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteHITInputBodyMiddleware: Middleware {
    public let id: String = "DeleteHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHITInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHITInput>
    public typealias MOutput = OperationOutput<DeleteHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHITOutputError>
}

extension DeleteHITInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHITInput(hITId: \(String(describing: hITId)))"}
}

extension DeleteHITInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hITId = "HITId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
    }
}

public struct DeleteHITInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHITInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHITInput>
    public typealias MOutput = OperationOutput<DeleteHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHITOutputError>
}

public struct DeleteHITInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHITInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHITInput>
    public typealias MOutput = OperationOutput<DeleteHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHITOutputError>
}

public struct DeleteHITInput: Equatable {
    /// <p>The ID of the HIT to be deleted.</p>
    public let hITId: String?

    public init (
        hITId: String? = nil
    )
    {
        self.hITId = hITId
    }
}

struct DeleteHITInputBody: Equatable {
    public let hITId: String?
}

extension DeleteHITInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hITId = "HITId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITId)
        hITId = hITIdDecoded
    }
}

extension DeleteHITOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHITOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHITOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHITOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHITOutputResponse()"}
}

extension DeleteHITOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHITOutputResponse: Equatable {

    public init() {}
}

struct DeleteHITOutputResponseBody: Equatable {
}

extension DeleteHITOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteQualificationTypeInputBodyMiddleware: Middleware {
    public let id: String = "DeleteQualificationTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteQualificationTypeInput>
    public typealias MOutput = OperationOutput<DeleteQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteQualificationTypeOutputError>
}

extension DeleteQualificationTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteQualificationTypeInput(qualificationTypeId: \(String(describing: qualificationTypeId)))"}
}

extension DeleteQualificationTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case qualificationTypeId = "QualificationTypeId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
    }
}

public struct DeleteQualificationTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteQualificationTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteQualificationTypeInput>
    public typealias MOutput = OperationOutput<DeleteQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteQualificationTypeOutputError>
}

public struct DeleteQualificationTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteQualificationTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteQualificationTypeInput>
    public typealias MOutput = OperationOutput<DeleteQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteQualificationTypeOutputError>
}

public struct DeleteQualificationTypeInput: Equatable {
    /// <p>The ID of the QualificationType to dispose.</p>
    public let qualificationTypeId: String?

    public init (
        qualificationTypeId: String? = nil
    )
    {
        self.qualificationTypeId = qualificationTypeId
    }
}

struct DeleteQualificationTypeInputBody: Equatable {
    public let qualificationTypeId: String?
}

extension DeleteQualificationTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case qualificationTypeId = "QualificationTypeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
    }
}

extension DeleteQualificationTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteQualificationTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteQualificationTypeOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteQualificationTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteQualificationTypeOutputResponse()"}
}

extension DeleteQualificationTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteQualificationTypeOutputResponse: Equatable {

    public init() {}
}

struct DeleteQualificationTypeOutputResponseBody: Equatable {
}

extension DeleteQualificationTypeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteWorkerBlockInputBodyMiddleware: Middleware {
    public let id: String = "DeleteWorkerBlockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkerBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkerBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkerBlockInput>
    public typealias MOutput = OperationOutput<DeleteWorkerBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkerBlockOutputError>
}

extension DeleteWorkerBlockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkerBlockInput(reason: \(String(describing: reason)), workerId: \(String(describing: workerId)))"}
}

extension DeleteWorkerBlockInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }
}

public struct DeleteWorkerBlockInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWorkerBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkerBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkerBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkerBlockInput>
    public typealias MOutput = OperationOutput<DeleteWorkerBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkerBlockOutputError>
}

public struct DeleteWorkerBlockInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWorkerBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkerBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkerBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkerBlockInput>
    public typealias MOutput = OperationOutput<DeleteWorkerBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkerBlockOutputError>
}

public struct DeleteWorkerBlockInput: Equatable {
    /// <p>A message that explains the reason for unblocking the Worker. The Worker does not see this message.</p>
    public let reason: String?
    /// <p>The ID of the Worker to unblock.</p>
    public let workerId: String?

    public init (
        reason: String? = nil,
        workerId: String? = nil
    )
    {
        self.reason = reason
        self.workerId = workerId
    }
}

struct DeleteWorkerBlockInputBody: Equatable {
    public let workerId: String?
    public let reason: String?
}

extension DeleteWorkerBlockInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DeleteWorkerBlockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkerBlockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkerBlockOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkerBlockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkerBlockOutputResponse()"}
}

extension DeleteWorkerBlockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkerBlockOutputResponse: Equatable {

    public init() {}
}

struct DeleteWorkerBlockOutputResponseBody: Equatable {
}

extension DeleteWorkerBlockOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateQualificationFromWorkerInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateQualificationFromWorkerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateQualificationFromWorkerInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateQualificationFromWorkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateQualificationFromWorkerInput>
    public typealias MOutput = OperationOutput<DisassociateQualificationFromWorkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateQualificationFromWorkerOutputError>
}

extension DisassociateQualificationFromWorkerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateQualificationFromWorkerInput(qualificationTypeId: \(String(describing: qualificationTypeId)), reason: \(String(describing: reason)), workerId: \(String(describing: workerId)))"}
}

extension DisassociateQualificationFromWorkerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case qualificationTypeId = "QualificationTypeId"
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }
}

public struct DisassociateQualificationFromWorkerInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateQualificationFromWorkerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateQualificationFromWorkerInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateQualificationFromWorkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateQualificationFromWorkerInput>
    public typealias MOutput = OperationOutput<DisassociateQualificationFromWorkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateQualificationFromWorkerOutputError>
}

public struct DisassociateQualificationFromWorkerInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateQualificationFromWorkerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateQualificationFromWorkerInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateQualificationFromWorkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateQualificationFromWorkerInput>
    public typealias MOutput = OperationOutput<DisassociateQualificationFromWorkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateQualificationFromWorkerOutputError>
}

public struct DisassociateQualificationFromWorkerInput: Equatable {
    /// <p>The ID of the Qualification type of the Qualification to be revoked.</p>
    public let qualificationTypeId: String?
    /// <p>A text message that explains why the Qualification was revoked. The user who had the Qualification sees this message.</p>
    public let reason: String?
    /// <p>The ID of the Worker who possesses the Qualification to be revoked.</p>
    public let workerId: String?

    public init (
        qualificationTypeId: String? = nil,
        reason: String? = nil,
        workerId: String? = nil
    )
    {
        self.qualificationTypeId = qualificationTypeId
        self.reason = reason
        self.workerId = workerId
    }
}

struct DisassociateQualificationFromWorkerInputBody: Equatable {
    public let workerId: String?
    public let qualificationTypeId: String?
    public let reason: String?
}

extension DisassociateQualificationFromWorkerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case qualificationTypeId = "QualificationTypeId"
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DisassociateQualificationFromWorkerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateQualificationFromWorkerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateQualificationFromWorkerOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateQualificationFromWorkerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateQualificationFromWorkerOutputResponse()"}
}

extension DisassociateQualificationFromWorkerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateQualificationFromWorkerOutputResponse: Equatable {

    public init() {}
}

struct DisassociateQualificationFromWorkerOutputResponseBody: Equatable {
}

extension DisassociateQualificationFromWorkerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum EventType {
    case assignmentabandoned
    case assignmentaccepted
    case assignmentapproved
    case assignmentrejected
    case assignmentreturned
    case assignmentsubmitted
    case hitcreated
    case hitdisposed
    case hitexpired
    case hitextended
    case hitreviewable
    case ping
    case sdkUnknown(String)
}

extension EventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventType] {
        return [
            .assignmentabandoned,
            .assignmentaccepted,
            .assignmentapproved,
            .assignmentrejected,
            .assignmentreturned,
            .assignmentsubmitted,
            .hitcreated,
            .hitdisposed,
            .hitexpired,
            .hitextended,
            .hitreviewable,
            .ping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assignmentabandoned: return "AssignmentAbandoned"
        case .assignmentaccepted: return "AssignmentAccepted"
        case .assignmentapproved: return "AssignmentApproved"
        case .assignmentrejected: return "AssignmentRejected"
        case .assignmentreturned: return "AssignmentReturned"
        case .assignmentsubmitted: return "AssignmentSubmitted"
        case .hitcreated: return "HITCreated"
        case .hitdisposed: return "HITDisposed"
        case .hitexpired: return "HITExpired"
        case .hitextended: return "HITExtended"
        case .hitreviewable: return "HITReviewable"
        case .ping: return "Ping"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
    }
}

extension GetAccountBalanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountBalanceInput()"}
}

extension GetAccountBalanceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccountBalanceInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccountBalanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountBalanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountBalanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountBalanceInput>
    public typealias MOutput = OperationOutput<GetAccountBalanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountBalanceOutputError>
}

public struct GetAccountBalanceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccountBalanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountBalanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountBalanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountBalanceInput>
    public typealias MOutput = OperationOutput<GetAccountBalanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountBalanceOutputError>
}

public struct GetAccountBalanceInput: Equatable {

    public init() {}
}

struct GetAccountBalanceInputBody: Equatable {
}

extension GetAccountBalanceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccountBalanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountBalanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountBalanceOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountBalanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountBalanceOutputResponse(availableBalance: \(String(describing: availableBalance)), onHoldBalance: \(String(describing: onHoldBalance)))"}
}

extension GetAccountBalanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccountBalanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.availableBalance = output.availableBalance
            self.onHoldBalance = output.onHoldBalance
        } else {
            self.availableBalance = nil
            self.onHoldBalance = nil
        }
    }
}

public struct GetAccountBalanceOutputResponse: Equatable {
    /// <p>A string representing a currency amount.</p>
    public let availableBalance: String?
    /// <p>A string representing a currency amount.</p>
    public let onHoldBalance: String?

    public init (
        availableBalance: String? = nil,
        onHoldBalance: String? = nil
    )
    {
        self.availableBalance = availableBalance
        self.onHoldBalance = onHoldBalance
    }
}

struct GetAccountBalanceOutputResponseBody: Equatable {
    public let availableBalance: String?
    public let onHoldBalance: String?
}

extension GetAccountBalanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availableBalance = "AvailableBalance"
        case onHoldBalance = "OnHoldBalance"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availableBalanceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availableBalance)
        availableBalance = availableBalanceDecoded
        let onHoldBalanceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .onHoldBalance)
        onHoldBalance = onHoldBalanceDecoded
    }
}

public struct GetAssignmentInputBodyMiddleware: Middleware {
    public let id: String = "GetAssignmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssignmentInput>
    public typealias MOutput = OperationOutput<GetAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssignmentOutputError>
}

extension GetAssignmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssignmentInput(assignmentId: \(String(describing: assignmentId)))"}
}

extension GetAssignmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
    }
}

public struct GetAssignmentInputHeadersMiddleware: Middleware {
    public let id: String = "GetAssignmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssignmentInput>
    public typealias MOutput = OperationOutput<GetAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssignmentOutputError>
}

public struct GetAssignmentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAssignmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssignmentInput>
    public typealias MOutput = OperationOutput<GetAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssignmentOutputError>
}

public struct GetAssignmentInput: Equatable {
    /// <p>The ID of the Assignment to be retrieved.</p>
    public let assignmentId: String?

    public init (
        assignmentId: String? = nil
    )
    {
        self.assignmentId = assignmentId
    }
}

struct GetAssignmentInputBody: Equatable {
    public let assignmentId: String?
}

extension GetAssignmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
    }
}

extension GetAssignmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssignmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssignmentOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssignmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssignmentOutputResponse(assignment: \(String(describing: assignment)), hIT: \(String(describing: hIT)))"}
}

extension GetAssignmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assignment = output.assignment
            self.hIT = output.hIT
        } else {
            self.assignment = nil
            self.hIT = nil
        }
    }
}

public struct GetAssignmentOutputResponse: Equatable {
    /// <p> The assignment. The response includes one Assignment
    ///             element.
    ///         </p>
    public let assignment: Assignment?
    /// <p> The HIT associated with this assignment. The response
    ///             includes one HIT element.</p>
    public let hIT: HIT?

    public init (
        assignment: Assignment? = nil,
        hIT: HIT? = nil
    )
    {
        self.assignment = assignment
        self.hIT = hIT
    }
}

struct GetAssignmentOutputResponseBody: Equatable {
    public let assignment: Assignment?
    public let hIT: HIT?
}

extension GetAssignmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignment = "Assignment"
        case hIT = "HIT"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentDecoded = try containerValues.decodeIfPresent(Assignment.self, forKey: .assignment)
        assignment = assignmentDecoded
        let hITDecoded = try containerValues.decodeIfPresent(HIT.self, forKey: .hIT)
        hIT = hITDecoded
    }
}

public struct GetFileUploadURLInputBodyMiddleware: Middleware {
    public let id: String = "GetFileUploadURLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFileUploadURLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFileUploadURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFileUploadURLInput>
    public typealias MOutput = OperationOutput<GetFileUploadURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFileUploadURLOutputError>
}

extension GetFileUploadURLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFileUploadURLInput(assignmentId: \(String(describing: assignmentId)), questionIdentifier: \(String(describing: questionIdentifier)))"}
}

extension GetFileUploadURLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case questionIdentifier = "QuestionIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let questionIdentifier = questionIdentifier {
            try encodeContainer.encode(questionIdentifier, forKey: .questionIdentifier)
        }
    }
}

public struct GetFileUploadURLInputHeadersMiddleware: Middleware {
    public let id: String = "GetFileUploadURLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFileUploadURLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFileUploadURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFileUploadURLInput>
    public typealias MOutput = OperationOutput<GetFileUploadURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFileUploadURLOutputError>
}

public struct GetFileUploadURLInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFileUploadURLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFileUploadURLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFileUploadURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFileUploadURLInput>
    public typealias MOutput = OperationOutput<GetFileUploadURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFileUploadURLOutputError>
}

public struct GetFileUploadURLInput: Equatable {
    /// <p>The ID of the assignment that contains the question with a
    ///             FileUploadAnswer.</p>
    public let assignmentId: String?
    /// <p>The identifier of the question with a FileUploadAnswer, as
    ///             specified in the QuestionForm of the HIT.</p>
    public let questionIdentifier: String?

    public init (
        assignmentId: String? = nil,
        questionIdentifier: String? = nil
    )
    {
        self.assignmentId = assignmentId
        self.questionIdentifier = questionIdentifier
    }
}

struct GetFileUploadURLInputBody: Equatable {
    public let assignmentId: String?
    public let questionIdentifier: String?
}

extension GetFileUploadURLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case questionIdentifier = "QuestionIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let questionIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .questionIdentifier)
        questionIdentifier = questionIdentifierDecoded
    }
}

extension GetFileUploadURLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFileUploadURLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFileUploadURLOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFileUploadURLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFileUploadURLOutputResponse(fileUploadURL: \(String(describing: fileUploadURL)))"}
}

extension GetFileUploadURLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFileUploadURLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileUploadURL = output.fileUploadURL
        } else {
            self.fileUploadURL = nil
        }
    }
}

public struct GetFileUploadURLOutputResponse: Equatable {
    /// <p> A temporary URL for the file that the Worker uploaded for
    ///             the answer.
    ///         </p>
    public let fileUploadURL: String?

    public init (
        fileUploadURL: String? = nil
    )
    {
        self.fileUploadURL = fileUploadURL
    }
}

struct GetFileUploadURLOutputResponseBody: Equatable {
    public let fileUploadURL: String?
}

extension GetFileUploadURLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileUploadURL = "FileUploadURL"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileUploadURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileUploadURL)
        fileUploadURL = fileUploadURLDecoded
    }
}

public struct GetHITInputBodyMiddleware: Middleware {
    public let id: String = "GetHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHITInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHITInput>
    public typealias MOutput = OperationOutput<GetHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHITOutputError>
}

extension GetHITInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetHITInput(hITId: \(String(describing: hITId)))"}
}

extension GetHITInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hITId = "HITId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
    }
}

public struct GetHITInputHeadersMiddleware: Middleware {
    public let id: String = "GetHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHITInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHITInput>
    public typealias MOutput = OperationOutput<GetHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHITOutputError>
}

public struct GetHITInputQueryItemMiddleware: Middleware {
    public let id: String = "GetHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHITInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHITInput>
    public typealias MOutput = OperationOutput<GetHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHITOutputError>
}

public struct GetHITInput: Equatable {
    /// <p>The ID of the HIT to be retrieved.</p>
    public let hITId: String?

    public init (
        hITId: String? = nil
    )
    {
        self.hITId = hITId
    }
}

struct GetHITInputBody: Equatable {
    public let hITId: String?
}

extension GetHITInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hITId = "HITId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITId)
        hITId = hITIdDecoded
    }
}

extension GetHITOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHITOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetHITOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHITOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetHITOutputResponse(hIT: \(String(describing: hIT)))"}
}

extension GetHITOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetHITOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hIT = output.hIT
        } else {
            self.hIT = nil
        }
    }
}

public struct GetHITOutputResponse: Equatable {
    /// <p> Contains the requested HIT data.</p>
    public let hIT: HIT?

    public init (
        hIT: HIT? = nil
    )
    {
        self.hIT = hIT
    }
}

struct GetHITOutputResponseBody: Equatable {
    public let hIT: HIT?
}

extension GetHITOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hIT = "HIT"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITDecoded = try containerValues.decodeIfPresent(HIT.self, forKey: .hIT)
        hIT = hITDecoded
    }
}

public struct GetQualificationScoreInputBodyMiddleware: Middleware {
    public let id: String = "GetQualificationScoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQualificationScoreInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQualificationScoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQualificationScoreInput>
    public typealias MOutput = OperationOutput<GetQualificationScoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQualificationScoreOutputError>
}

extension GetQualificationScoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetQualificationScoreInput(qualificationTypeId: \(String(describing: qualificationTypeId)), workerId: \(String(describing: workerId)))"}
}

extension GetQualificationScoreInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case qualificationTypeId = "QualificationTypeId"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }
}

public struct GetQualificationScoreInputHeadersMiddleware: Middleware {
    public let id: String = "GetQualificationScoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQualificationScoreInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQualificationScoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQualificationScoreInput>
    public typealias MOutput = OperationOutput<GetQualificationScoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQualificationScoreOutputError>
}

public struct GetQualificationScoreInputQueryItemMiddleware: Middleware {
    public let id: String = "GetQualificationScoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQualificationScoreInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQualificationScoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQualificationScoreInput>
    public typealias MOutput = OperationOutput<GetQualificationScoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQualificationScoreOutputError>
}

public struct GetQualificationScoreInput: Equatable {
    /// <p>The ID of the QualificationType.</p>
    public let qualificationTypeId: String?
    /// <p>The ID of the Worker whose Qualification is being updated.</p>
    public let workerId: String?

    public init (
        qualificationTypeId: String? = nil,
        workerId: String? = nil
    )
    {
        self.qualificationTypeId = qualificationTypeId
        self.workerId = workerId
    }
}

struct GetQualificationScoreInputBody: Equatable {
    public let qualificationTypeId: String?
    public let workerId: String?
}

extension GetQualificationScoreInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case qualificationTypeId = "QualificationTypeId"
        case workerId = "WorkerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerId)
        workerId = workerIdDecoded
    }
}

extension GetQualificationScoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQualificationScoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetQualificationScoreOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQualificationScoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetQualificationScoreOutputResponse(qualification: \(String(describing: qualification)))"}
}

extension GetQualificationScoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetQualificationScoreOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.qualification = output.qualification
        } else {
            self.qualification = nil
        }
    }
}

public struct GetQualificationScoreOutputResponse: Equatable {
    /// <p> The Qualification data structure of the Qualification
    ///             assigned to a user, including the Qualification type and the value
    ///             (score).
    ///         </p>
    public let qualification: Qualification?

    public init (
        qualification: Qualification? = nil
    )
    {
        self.qualification = qualification
    }
}

struct GetQualificationScoreOutputResponseBody: Equatable {
    public let qualification: Qualification?
}

extension GetQualificationScoreOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case qualification = "Qualification"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationDecoded = try containerValues.decodeIfPresent(Qualification.self, forKey: .qualification)
        qualification = qualificationDecoded
    }
}

public struct GetQualificationTypeInputBodyMiddleware: Middleware {
    public let id: String = "GetQualificationTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQualificationTypeInput>
    public typealias MOutput = OperationOutput<GetQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQualificationTypeOutputError>
}

extension GetQualificationTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetQualificationTypeInput(qualificationTypeId: \(String(describing: qualificationTypeId)))"}
}

extension GetQualificationTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case qualificationTypeId = "QualificationTypeId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
    }
}

public struct GetQualificationTypeInputHeadersMiddleware: Middleware {
    public let id: String = "GetQualificationTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQualificationTypeInput>
    public typealias MOutput = OperationOutput<GetQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQualificationTypeOutputError>
}

public struct GetQualificationTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetQualificationTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQualificationTypeInput>
    public typealias MOutput = OperationOutput<GetQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQualificationTypeOutputError>
}

public struct GetQualificationTypeInput: Equatable {
    /// <p>The ID of the QualificationType.</p>
    public let qualificationTypeId: String?

    public init (
        qualificationTypeId: String? = nil
    )
    {
        self.qualificationTypeId = qualificationTypeId
    }
}

struct GetQualificationTypeInputBody: Equatable {
    public let qualificationTypeId: String?
}

extension GetQualificationTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case qualificationTypeId = "QualificationTypeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
    }
}

extension GetQualificationTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQualificationTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetQualificationTypeOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQualificationTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetQualificationTypeOutputResponse(qualificationType: \(String(describing: qualificationType)))"}
}

extension GetQualificationTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetQualificationTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.qualificationType = output.qualificationType
        } else {
            self.qualificationType = nil
        }
    }
}

public struct GetQualificationTypeOutputResponse: Equatable {
    /// <p> The returned Qualification Type</p>
    public let qualificationType: QualificationType?

    public init (
        qualificationType: QualificationType? = nil
    )
    {
        self.qualificationType = qualificationType
    }
}

struct GetQualificationTypeOutputResponseBody: Equatable {
    public let qualificationType: QualificationType?
}

extension GetQualificationTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case qualificationType = "QualificationType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeDecoded = try containerValues.decodeIfPresent(QualificationType.self, forKey: .qualificationType)
        qualificationType = qualificationTypeDecoded
    }
}

extension HIT: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentDurationInSeconds = "AssignmentDurationInSeconds"
        case autoApprovalDelayInSeconds = "AutoApprovalDelayInSeconds"
        case creationTime = "CreationTime"
        case description = "Description"
        case expiration = "Expiration"
        case hITGroupId = "HITGroupId"
        case hITId = "HITId"
        case hITLayoutId = "HITLayoutId"
        case hITReviewStatus = "HITReviewStatus"
        case hITStatus = "HITStatus"
        case hITTypeId = "HITTypeId"
        case keywords = "Keywords"
        case maxAssignments = "MaxAssignments"
        case numberOfAssignmentsAvailable = "NumberOfAssignmentsAvailable"
        case numberOfAssignmentsCompleted = "NumberOfAssignmentsCompleted"
        case numberOfAssignmentsPending = "NumberOfAssignmentsPending"
        case qualificationRequirements = "QualificationRequirements"
        case question = "Question"
        case requesterAnnotation = "RequesterAnnotation"
        case reward = "Reward"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentDurationInSeconds = assignmentDurationInSeconds {
            try encodeContainer.encode(assignmentDurationInSeconds, forKey: .assignmentDurationInSeconds)
        }
        if let autoApprovalDelayInSeconds = autoApprovalDelayInSeconds {
            try encodeContainer.encode(autoApprovalDelayInSeconds, forKey: .autoApprovalDelayInSeconds)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expiration = expiration {
            try encodeContainer.encode(expiration.timeIntervalSince1970, forKey: .expiration)
        }
        if let hITGroupId = hITGroupId {
            try encodeContainer.encode(hITGroupId, forKey: .hITGroupId)
        }
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let hITLayoutId = hITLayoutId {
            try encodeContainer.encode(hITLayoutId, forKey: .hITLayoutId)
        }
        if let hITReviewStatus = hITReviewStatus {
            try encodeContainer.encode(hITReviewStatus.rawValue, forKey: .hITReviewStatus)
        }
        if let hITStatus = hITStatus {
            try encodeContainer.encode(hITStatus.rawValue, forKey: .hITStatus)
        }
        if let hITTypeId = hITTypeId {
            try encodeContainer.encode(hITTypeId, forKey: .hITTypeId)
        }
        if let keywords = keywords {
            try encodeContainer.encode(keywords, forKey: .keywords)
        }
        if let maxAssignments = maxAssignments {
            try encodeContainer.encode(maxAssignments, forKey: .maxAssignments)
        }
        if let numberOfAssignmentsAvailable = numberOfAssignmentsAvailable {
            try encodeContainer.encode(numberOfAssignmentsAvailable, forKey: .numberOfAssignmentsAvailable)
        }
        if let numberOfAssignmentsCompleted = numberOfAssignmentsCompleted {
            try encodeContainer.encode(numberOfAssignmentsCompleted, forKey: .numberOfAssignmentsCompleted)
        }
        if let numberOfAssignmentsPending = numberOfAssignmentsPending {
            try encodeContainer.encode(numberOfAssignmentsPending, forKey: .numberOfAssignmentsPending)
        }
        if let qualificationRequirements = qualificationRequirements {
            var qualificationRequirementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .qualificationRequirements)
            for qualificationrequirementlist0 in qualificationRequirements {
                try qualificationRequirementsContainer.encode(qualificationrequirementlist0)
            }
        }
        if let question = question {
            try encodeContainer.encode(question, forKey: .question)
        }
        if let requesterAnnotation = requesterAnnotation {
            try encodeContainer.encode(requesterAnnotation, forKey: .requesterAnnotation)
        }
        if let reward = reward {
            try encodeContainer.encode(reward, forKey: .reward)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let hITTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITTypeId)
        hITTypeId = hITTypeIdDecoded
        let hITGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITGroupId)
        hITGroupId = hITGroupIdDecoded
        let hITLayoutIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITLayoutId)
        hITLayoutId = hITLayoutIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let questionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .question)
        question = questionDecoded
        let keywordsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keywords)
        keywords = keywordsDecoded
        let hITStatusDecoded = try containerValues.decodeIfPresent(HITStatus.self, forKey: .hITStatus)
        hITStatus = hITStatusDecoded
        let maxAssignmentsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxAssignments)
        maxAssignments = maxAssignmentsDecoded
        let rewardDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reward)
        reward = rewardDecoded
        let autoApprovalDelayInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .autoApprovalDelayInSeconds)
        autoApprovalDelayInSeconds = autoApprovalDelayInSecondsDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiration)
        expiration = expirationDecoded
        let assignmentDurationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .assignmentDurationInSeconds)
        assignmentDurationInSeconds = assignmentDurationInSecondsDecoded
        let requesterAnnotationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requesterAnnotation)
        requesterAnnotation = requesterAnnotationDecoded
        let qualificationRequirementsContainer = try containerValues.decodeIfPresent([QualificationRequirement?].self, forKey: .qualificationRequirements)
        var qualificationRequirementsDecoded0:[QualificationRequirement]? = nil
        if let qualificationRequirementsContainer = qualificationRequirementsContainer {
            qualificationRequirementsDecoded0 = [QualificationRequirement]()
            for structure0 in qualificationRequirementsContainer {
                if let structure0 = structure0 {
                    qualificationRequirementsDecoded0?.append(structure0)
                }
            }
        }
        qualificationRequirements = qualificationRequirementsDecoded0
        let hITReviewStatusDecoded = try containerValues.decodeIfPresent(HITReviewStatus.self, forKey: .hITReviewStatus)
        hITReviewStatus = hITReviewStatusDecoded
        let numberOfAssignmentsPendingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfAssignmentsPending)
        numberOfAssignmentsPending = numberOfAssignmentsPendingDecoded
        let numberOfAssignmentsAvailableDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfAssignmentsAvailable)
        numberOfAssignmentsAvailable = numberOfAssignmentsAvailableDecoded
        let numberOfAssignmentsCompletedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfAssignmentsCompleted)
        numberOfAssignmentsCompleted = numberOfAssignmentsCompletedDecoded
    }
}

extension HIT: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HIT(assignmentDurationInSeconds: \(String(describing: assignmentDurationInSeconds)), autoApprovalDelayInSeconds: \(String(describing: autoApprovalDelayInSeconds)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), expiration: \(String(describing: expiration)), hITGroupId: \(String(describing: hITGroupId)), hITId: \(String(describing: hITId)), hITLayoutId: \(String(describing: hITLayoutId)), hITReviewStatus: \(String(describing: hITReviewStatus)), hITStatus: \(String(describing: hITStatus)), hITTypeId: \(String(describing: hITTypeId)), keywords: \(String(describing: keywords)), maxAssignments: \(String(describing: maxAssignments)), numberOfAssignmentsAvailable: \(String(describing: numberOfAssignmentsAvailable)), numberOfAssignmentsCompleted: \(String(describing: numberOfAssignmentsCompleted)), numberOfAssignmentsPending: \(String(describing: numberOfAssignmentsPending)), qualificationRequirements: \(String(describing: qualificationRequirements)), question: \(String(describing: question)), requesterAnnotation: \(String(describing: requesterAnnotation)), reward: \(String(describing: reward)), title: \(String(describing: title)))"}
}

/// <p> The HIT data structure represents a single HIT, including
///             all the information necessary for a Worker to accept and complete the
///             HIT.</p>
public struct HIT: Equatable {
    /// <p> The length of time, in seconds, that a Worker has to
    ///             complete the HIT after accepting it.</p>
    public let assignmentDurationInSeconds: Int?
    /// <p>The amount of time, in seconds, after the Worker submits an
    ///             assignment for the HIT that the results are automatically approved by
    ///             Amazon Mechanical Turk. This is the amount of time the Requester has
    ///             to reject an assignment submitted by a Worker before the assignment
    ///             is auto-approved and the Worker is paid.
    ///         </p>
    public let autoApprovalDelayInSeconds: Int?
    /// <p> The date and time the HIT was created.</p>
    public let creationTime: Date?
    /// <p> A general description of the HIT.</p>
    public let description: String?
    /// <p>The date and time the HIT expires.</p>
    public let expiration: Date?
    /// <p> The ID of the HIT Group of this HIT.</p>
    public let hITGroupId: String?
    /// <p> A unique identifier for the HIT.</p>
    public let hITId: String?
    /// <p> The ID of the HIT Layout of this HIT.</p>
    public let hITLayoutId: String?
    /// <p> Indicates the review status of the HIT. Valid Values are
    ///             NotReviewed | MarkedForReview | ReviewedAppropriate |
    ///             ReviewedInappropriate.</p>
    public let hITReviewStatus: HITReviewStatus?
    /// <p>The status of the HIT and its assignments. Valid Values are
    ///             Assignable | Unassignable | Reviewable | Reviewing | Disposed.
    ///         </p>
    public let hITStatus: HITStatus?
    /// <p>The ID of the HIT type of this HIT</p>
    public let hITTypeId: String?
    /// <p> One or more words or phrases that describe the HIT,
    ///             separated by commas. Search terms similar to the keywords of a HIT
    ///             are more likely to have the HIT in the search results.</p>
    public let keywords: String?
    /// <p>The number of times the HIT can be accepted and completed
    ///             before the HIT becomes unavailable.
    ///         </p>
    public let maxAssignments: Int?
    /// <p> The number of assignments for this HIT that are available
    ///             for Workers to accept.</p>
    public let numberOfAssignmentsAvailable: Int?
    /// <p> The number of assignments for this HIT that have been
    ///             approved or rejected.</p>
    public let numberOfAssignmentsCompleted: Int?
    /// <p> The number of assignments for this HIT that are being
    ///             previewed or have been accepted by Workers, but have not yet been
    ///             submitted, returned, or abandoned.</p>
    public let numberOfAssignmentsPending: Int?
    /// <p>
    ///             Conditions that a Worker's Qualifications must meet in order
    ///             to accept the HIT. A HIT can have between zero and ten
    ///             Qualification requirements. All requirements must be met in
    ///             order for a Worker to accept the HIT. Additionally, other
    ///             actions can be restricted using the <code>ActionsGuarded</code>
    ///             field on each <code>QualificationRequirement</code> structure.
    ///         </p>
    public let qualificationRequirements: [QualificationRequirement]?
    /// <p> The data the Worker completing the HIT uses produce the
    ///             results. This is either either a QuestionForm, HTMLQuestion or an
    ///             ExternalQuestion data structure.</p>
    public let question: String?
    /// <p> An arbitrary data field the Requester who created the HIT
    ///             can use. This field is visible only to the creator of the HIT.</p>
    public let requesterAnnotation: String?
    /// <p>A string representing a currency amount.</p>
    public let reward: String?
    /// <p> The title of the HIT.</p>
    public let title: String?

    public init (
        assignmentDurationInSeconds: Int? = nil,
        autoApprovalDelayInSeconds: Int? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        expiration: Date? = nil,
        hITGroupId: String? = nil,
        hITId: String? = nil,
        hITLayoutId: String? = nil,
        hITReviewStatus: HITReviewStatus? = nil,
        hITStatus: HITStatus? = nil,
        hITTypeId: String? = nil,
        keywords: String? = nil,
        maxAssignments: Int? = nil,
        numberOfAssignmentsAvailable: Int? = nil,
        numberOfAssignmentsCompleted: Int? = nil,
        numberOfAssignmentsPending: Int? = nil,
        qualificationRequirements: [QualificationRequirement]? = nil,
        question: String? = nil,
        requesterAnnotation: String? = nil,
        reward: String? = nil,
        title: String? = nil
    )
    {
        self.assignmentDurationInSeconds = assignmentDurationInSeconds
        self.autoApprovalDelayInSeconds = autoApprovalDelayInSeconds
        self.creationTime = creationTime
        self.description = description
        self.expiration = expiration
        self.hITGroupId = hITGroupId
        self.hITId = hITId
        self.hITLayoutId = hITLayoutId
        self.hITReviewStatus = hITReviewStatus
        self.hITStatus = hITStatus
        self.hITTypeId = hITTypeId
        self.keywords = keywords
        self.maxAssignments = maxAssignments
        self.numberOfAssignmentsAvailable = numberOfAssignmentsAvailable
        self.numberOfAssignmentsCompleted = numberOfAssignmentsCompleted
        self.numberOfAssignmentsPending = numberOfAssignmentsPending
        self.qualificationRequirements = qualificationRequirements
        self.question = question
        self.requesterAnnotation = requesterAnnotation
        self.reward = reward
        self.title = title
    }
}

public enum HITAccessActions {
    case accept
    case discoverpreviewandaccept
    case previewandaccept
    case sdkUnknown(String)
}

extension HITAccessActions : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HITAccessActions] {
        return [
            .accept,
            .discoverpreviewandaccept,
            .previewandaccept,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accept: return "Accept"
        case .discoverpreviewandaccept: return "DiscoverPreviewAndAccept"
        case .previewandaccept: return "PreviewAndAccept"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HITAccessActions(rawValue: rawValue) ?? HITAccessActions.sdkUnknown(rawValue)
    }
}

extension HITLayoutParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension HITLayoutParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HITLayoutParameter(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p> The HITLayoutParameter data structure defines parameter
///             values used with a HITLayout. A HITLayout is a reusable Amazon
///             Mechanical Turk project template used to provide Human Intelligence
///             Task (HIT) question data for CreateHIT.
///         </p>
public struct HITLayoutParameter: Equatable {
    /// <p> The name of the parameter in the HITLayout.
    ///         </p>
    public let name: String?
    /// <p>The value substituted for the parameter referenced in the
    ///             HITLayout.
    ///         </p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum HITReviewStatus {
    case markedforreview
    case notreviewed
    case reviewedappropriate
    case reviewedinappropriate
    case sdkUnknown(String)
}

extension HITReviewStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HITReviewStatus] {
        return [
            .markedforreview,
            .notreviewed,
            .reviewedappropriate,
            .reviewedinappropriate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .markedforreview: return "MarkedForReview"
        case .notreviewed: return "NotReviewed"
        case .reviewedappropriate: return "ReviewedAppropriate"
        case .reviewedinappropriate: return "ReviewedInappropriate"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HITReviewStatus(rawValue: rawValue) ?? HITReviewStatus.sdkUnknown(rawValue)
    }
}

public enum HITStatus {
    case assignable
    case disposed
    case reviewable
    case reviewing
    case unassignable
    case sdkUnknown(String)
}

extension HITStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HITStatus] {
        return [
            .assignable,
            .disposed,
            .reviewable,
            .reviewing,
            .unassignable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assignable: return "Assignable"
        case .disposed: return "Disposed"
        case .reviewable: return "Reviewable"
        case .reviewing: return "Reviewing"
        case .unassignable: return "Unassignable"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HITStatus(rawValue: rawValue) ?? HITStatus.sdkUnknown(rawValue)
    }
}

public struct ListAssignmentsForHITInputBodyMiddleware: Middleware {
    public let id: String = "ListAssignmentsForHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssignmentsForHITInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssignmentsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssignmentsForHITInput>
    public typealias MOutput = OperationOutput<ListAssignmentsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssignmentsForHITOutputError>
}

extension ListAssignmentsForHITInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssignmentsForHITInput(assignmentStatuses: \(String(describing: assignmentStatuses)), hITId: \(String(describing: hITId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssignmentsForHITInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentStatuses = "AssignmentStatuses"
        case hITId = "HITId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentStatuses = assignmentStatuses {
            var assignmentStatusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assignmentStatuses)
            for assignmentstatuslist0 in assignmentStatuses {
                try assignmentStatusesContainer.encode(assignmentstatuslist0.rawValue)
            }
        }
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssignmentsForHITInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssignmentsForHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssignmentsForHITInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssignmentsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssignmentsForHITInput>
    public typealias MOutput = OperationOutput<ListAssignmentsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssignmentsForHITOutputError>
}

public struct ListAssignmentsForHITInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssignmentsForHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssignmentsForHITInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssignmentsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssignmentsForHITInput>
    public typealias MOutput = OperationOutput<ListAssignmentsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssignmentsForHITOutputError>
}

public struct ListAssignmentsForHITInput: Equatable {
    /// <p>The status of the assignments to return: Submitted | Approved
    ///             | Rejected</p>
    public let assignmentStatuses: [AssignmentStatus]?
    /// <p>The ID of the HIT.</p>
    public let hITId: String?
    public let maxResults: Int?
    /// <p>Pagination token</p>
    public let nextToken: String?

    public init (
        assignmentStatuses: [AssignmentStatus]? = nil,
        hITId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.assignmentStatuses = assignmentStatuses
        self.hITId = hITId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssignmentsForHITInputBody: Equatable {
    public let hITId: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let assignmentStatuses: [AssignmentStatus]?
}

extension ListAssignmentsForHITInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentStatuses = "AssignmentStatuses"
        case hITId = "HITId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let assignmentStatusesContainer = try containerValues.decodeIfPresent([AssignmentStatus?].self, forKey: .assignmentStatuses)
        var assignmentStatusesDecoded0:[AssignmentStatus]? = nil
        if let assignmentStatusesContainer = assignmentStatusesContainer {
            assignmentStatusesDecoded0 = [AssignmentStatus]()
            for string0 in assignmentStatusesContainer {
                if let string0 = string0 {
                    assignmentStatusesDecoded0?.append(string0)
                }
            }
        }
        assignmentStatuses = assignmentStatusesDecoded0
    }
}

extension ListAssignmentsForHITOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssignmentsForHITOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssignmentsForHITOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssignmentsForHITOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssignmentsForHITOutputResponse(assignments: \(String(describing: assignments)), nextToken: \(String(describing: nextToken)), numResults: \(String(describing: numResults)))"}
}

extension ListAssignmentsForHITOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssignmentsForHITOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assignments = output.assignments
            self.nextToken = output.nextToken
            self.numResults = output.numResults
        } else {
            self.assignments = nil
            self.nextToken = nil
            self.numResults = nil
        }
    }
}

public struct ListAssignmentsForHITOutputResponse: Equatable {
    /// <p> The collection of Assignment data structures returned by
    ///             this call.</p>
    public let assignments: [Assignment]?
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///         </p>
    public let nextToken: String?
    /// <p> The number of assignments on the page in the filtered
    ///             results list, equivalent to the number of assignments returned by
    ///             this call.</p>
    public let numResults: Int?

    public init (
        assignments: [Assignment]? = nil,
        nextToken: String? = nil,
        numResults: Int? = nil
    )
    {
        self.assignments = assignments
        self.nextToken = nextToken
        self.numResults = numResults
    }
}

struct ListAssignmentsForHITOutputResponseBody: Equatable {
    public let nextToken: String?
    public let numResults: Int?
    public let assignments: [Assignment]?
}

extension ListAssignmentsForHITOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignments = "Assignments"
        case nextToken = "NextToken"
        case numResults = "NumResults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let assignmentsContainer = try containerValues.decodeIfPresent([Assignment?].self, forKey: .assignments)
        var assignmentsDecoded0:[Assignment]? = nil
        if let assignmentsContainer = assignmentsContainer {
            assignmentsDecoded0 = [Assignment]()
            for structure0 in assignmentsContainer {
                if let structure0 = structure0 {
                    assignmentsDecoded0?.append(structure0)
                }
            }
        }
        assignments = assignmentsDecoded0
    }
}

public struct ListBonusPaymentsInputBodyMiddleware: Middleware {
    public let id: String = "ListBonusPaymentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBonusPaymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBonusPaymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBonusPaymentsInput>
    public typealias MOutput = OperationOutput<ListBonusPaymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBonusPaymentsOutputError>
}

extension ListBonusPaymentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBonusPaymentsInput(assignmentId: \(String(describing: assignmentId)), hITId: \(String(describing: hITId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBonusPaymentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case hITId = "HITId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListBonusPaymentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBonusPaymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBonusPaymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBonusPaymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBonusPaymentsInput>
    public typealias MOutput = OperationOutput<ListBonusPaymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBonusPaymentsOutputError>
}

public struct ListBonusPaymentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBonusPaymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBonusPaymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBonusPaymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBonusPaymentsInput>
    public typealias MOutput = OperationOutput<ListBonusPaymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBonusPaymentsOutputError>
}

public struct ListBonusPaymentsInput: Equatable {
    /// <p>The ID of the assignment associated with the bonus payments
    ///             to retrieve. If specified, only bonus payments for the given
    ///             assignment are returned. Either the HITId parameter or the
    ///             AssignmentId parameter must be specified</p>
    public let assignmentId: String?
    /// <p>The ID of the HIT associated with the bonus payments to
    ///             retrieve. If not specified, all bonus payments for all assignments
    ///             for the given HIT are returned. Either the HITId parameter or the
    ///             AssignmentId parameter must be specified</p>
    public let hITId: String?
    public let maxResults: Int?
    /// <p>Pagination token</p>
    public let nextToken: String?

    public init (
        assignmentId: String? = nil,
        hITId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.assignmentId = assignmentId
        self.hITId = hITId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBonusPaymentsInputBody: Equatable {
    public let hITId: String?
    public let assignmentId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListBonusPaymentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case hITId = "HITId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListBonusPaymentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBonusPaymentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBonusPaymentsOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBonusPaymentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBonusPaymentsOutputResponse(bonusPayments: \(String(describing: bonusPayments)), nextToken: \(String(describing: nextToken)), numResults: \(String(describing: numResults)))"}
}

extension ListBonusPaymentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBonusPaymentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bonusPayments = output.bonusPayments
            self.nextToken = output.nextToken
            self.numResults = output.numResults
        } else {
            self.bonusPayments = nil
            self.nextToken = nil
            self.numResults = nil
        }
    }
}

public struct ListBonusPaymentsOutputResponse: Equatable {
    /// <p>A successful request to the ListBonusPayments operation
    ///             returns a list of BonusPayment objects.
    ///         </p>
    public let bonusPayments: [BonusPayment]?
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///         </p>
    public let nextToken: String?
    /// <p>The number of bonus payments on this page in the filtered
    ///             results list, equivalent to the number of bonus payments being
    ///             returned by this call.
    ///         </p>
    public let numResults: Int?

    public init (
        bonusPayments: [BonusPayment]? = nil,
        nextToken: String? = nil,
        numResults: Int? = nil
    )
    {
        self.bonusPayments = bonusPayments
        self.nextToken = nextToken
        self.numResults = numResults
    }
}

struct ListBonusPaymentsOutputResponseBody: Equatable {
    public let numResults: Int?
    public let nextToken: String?
    public let bonusPayments: [BonusPayment]?
}

extension ListBonusPaymentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bonusPayments = "BonusPayments"
        case nextToken = "NextToken"
        case numResults = "NumResults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let bonusPaymentsContainer = try containerValues.decodeIfPresent([BonusPayment?].self, forKey: .bonusPayments)
        var bonusPaymentsDecoded0:[BonusPayment]? = nil
        if let bonusPaymentsContainer = bonusPaymentsContainer {
            bonusPaymentsDecoded0 = [BonusPayment]()
            for structure0 in bonusPaymentsContainer {
                if let structure0 = structure0 {
                    bonusPaymentsDecoded0?.append(structure0)
                }
            }
        }
        bonusPayments = bonusPaymentsDecoded0
    }
}

public struct ListHITsForQualificationTypeInputBodyMiddleware: Middleware {
    public let id: String = "ListHITsForQualificationTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHITsForQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHITsForQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHITsForQualificationTypeInput>
    public typealias MOutput = OperationOutput<ListHITsForQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHITsForQualificationTypeOutputError>
}

extension ListHITsForQualificationTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHITsForQualificationTypeInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), qualificationTypeId: \(String(describing: qualificationTypeId)))"}
}

extension ListHITsForQualificationTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case qualificationTypeId = "QualificationTypeId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
    }
}

public struct ListHITsForQualificationTypeInputHeadersMiddleware: Middleware {
    public let id: String = "ListHITsForQualificationTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHITsForQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHITsForQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHITsForQualificationTypeInput>
    public typealias MOutput = OperationOutput<ListHITsForQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHITsForQualificationTypeOutputError>
}

public struct ListHITsForQualificationTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "ListHITsForQualificationTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHITsForQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHITsForQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHITsForQualificationTypeInput>
    public typealias MOutput = OperationOutput<ListHITsForQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHITsForQualificationTypeOutputError>
}

public struct ListHITsForQualificationTypeInput: Equatable {
    /// <p>
    ///             Limit the number of results returned.
    ///         </p>
    public let maxResults: Int?
    /// <p>Pagination Token</p>
    public let nextToken: String?
    /// <p>
    ///             The ID of the Qualification type to use when querying HITs.
    ///         </p>
    public let qualificationTypeId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        qualificationTypeId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.qualificationTypeId = qualificationTypeId
    }
}

struct ListHITsForQualificationTypeInputBody: Equatable {
    public let qualificationTypeId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListHITsForQualificationTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case qualificationTypeId = "QualificationTypeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListHITsForQualificationTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHITsForQualificationTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHITsForQualificationTypeOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHITsForQualificationTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHITsForQualificationTypeOutputResponse(hITs: \(String(describing: hITs)), nextToken: \(String(describing: nextToken)), numResults: \(String(describing: numResults)))"}
}

extension ListHITsForQualificationTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListHITsForQualificationTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hITs = output.hITs
            self.nextToken = output.nextToken
            self.numResults = output.numResults
        } else {
            self.hITs = nil
            self.nextToken = nil
            self.numResults = nil
        }
    }
}

public struct ListHITsForQualificationTypeOutputResponse: Equatable {
    /// <p> The list of HIT elements returned by the query.</p>
    public let hITs: [HIT]?
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///         </p>
    public let nextToken: String?
    /// <p> The number of HITs on this page in the filtered results
    ///             list, equivalent to the number of HITs being returned by this call.	</p>
    public let numResults: Int?

    public init (
        hITs: [HIT]? = nil,
        nextToken: String? = nil,
        numResults: Int? = nil
    )
    {
        self.hITs = hITs
        self.nextToken = nextToken
        self.numResults = numResults
    }
}

struct ListHITsForQualificationTypeOutputResponseBody: Equatable {
    public let nextToken: String?
    public let numResults: Int?
    public let hITs: [HIT]?
}

extension ListHITsForQualificationTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hITs = "HITs"
        case nextToken = "NextToken"
        case numResults = "NumResults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let hITsContainer = try containerValues.decodeIfPresent([HIT?].self, forKey: .hITs)
        var hITsDecoded0:[HIT]? = nil
        if let hITsContainer = hITsContainer {
            hITsDecoded0 = [HIT]()
            for structure0 in hITsContainer {
                if let structure0 = structure0 {
                    hITsDecoded0?.append(structure0)
                }
            }
        }
        hITs = hITsDecoded0
    }
}

public struct ListHITsInputBodyMiddleware: Middleware {
    public let id: String = "ListHITsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHITsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHITsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHITsInput>
    public typealias MOutput = OperationOutput<ListHITsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHITsOutputError>
}

extension ListHITsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHITsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListHITsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListHITsInputHeadersMiddleware: Middleware {
    public let id: String = "ListHITsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHITsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHITsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHITsInput>
    public typealias MOutput = OperationOutput<ListHITsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHITsOutputError>
}

public struct ListHITsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListHITsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHITsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHITsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHITsInput>
    public typealias MOutput = OperationOutput<ListHITsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHITsOutputError>
}

public struct ListHITsInput: Equatable {
    public let maxResults: Int?
    /// <p>Pagination token</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHITsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListHITsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListHITsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHITsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHITsOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHITsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHITsOutputResponse(hITs: \(String(describing: hITs)), nextToken: \(String(describing: nextToken)), numResults: \(String(describing: numResults)))"}
}

extension ListHITsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListHITsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hITs = output.hITs
            self.nextToken = output.nextToken
            self.numResults = output.numResults
        } else {
            self.hITs = nil
            self.nextToken = nil
            self.numResults = nil
        }
    }
}

public struct ListHITsOutputResponse: Equatable {
    /// <p> The list of HIT elements returned by the query.</p>
    public let hITs: [HIT]?
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///         </p>
    public let nextToken: String?
    /// <p>The number of HITs on this page in the filtered results list,
    ///             equivalent to the number of HITs being returned by this call.</p>
    public let numResults: Int?

    public init (
        hITs: [HIT]? = nil,
        nextToken: String? = nil,
        numResults: Int? = nil
    )
    {
        self.hITs = hITs
        self.nextToken = nextToken
        self.numResults = numResults
    }
}

struct ListHITsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let numResults: Int?
    public let hITs: [HIT]?
}

extension ListHITsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hITs = "HITs"
        case nextToken = "NextToken"
        case numResults = "NumResults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let hITsContainer = try containerValues.decodeIfPresent([HIT?].self, forKey: .hITs)
        var hITsDecoded0:[HIT]? = nil
        if let hITsContainer = hITsContainer {
            hITsDecoded0 = [HIT]()
            for structure0 in hITsContainer {
                if let structure0 = structure0 {
                    hITsDecoded0?.append(structure0)
                }
            }
        }
        hITs = hITsDecoded0
    }
}

public struct ListQualificationRequestsInputBodyMiddleware: Middleware {
    public let id: String = "ListQualificationRequestsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQualificationRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQualificationRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQualificationRequestsInput>
    public typealias MOutput = OperationOutput<ListQualificationRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQualificationRequestsOutputError>
}

extension ListQualificationRequestsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQualificationRequestsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), qualificationTypeId: \(String(describing: qualificationTypeId)))"}
}

extension ListQualificationRequestsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case qualificationTypeId = "QualificationTypeId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
    }
}

public struct ListQualificationRequestsInputHeadersMiddleware: Middleware {
    public let id: String = "ListQualificationRequestsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQualificationRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQualificationRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQualificationRequestsInput>
    public typealias MOutput = OperationOutput<ListQualificationRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQualificationRequestsOutputError>
}

public struct ListQualificationRequestsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListQualificationRequestsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQualificationRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQualificationRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQualificationRequestsInput>
    public typealias MOutput = OperationOutput<ListQualificationRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQualificationRequestsOutputError>
}

public struct ListQualificationRequestsInput: Equatable {
    /// <p> The maximum number of results to return in a single call.
    ///         </p>
    public let maxResults: Int?
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///         </p>
    public let nextToken: String?
    /// <p>The ID of the QualificationType.</p>
    public let qualificationTypeId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        qualificationTypeId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.qualificationTypeId = qualificationTypeId
    }
}

struct ListQualificationRequestsInputBody: Equatable {
    public let qualificationTypeId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListQualificationRequestsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case qualificationTypeId = "QualificationTypeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListQualificationRequestsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQualificationRequestsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQualificationRequestsOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQualificationRequestsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQualificationRequestsOutputResponse(nextToken: \(String(describing: nextToken)), numResults: \(String(describing: numResults)), qualificationRequests: \(String(describing: qualificationRequests)))"}
}

extension ListQualificationRequestsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListQualificationRequestsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.numResults = output.numResults
            self.qualificationRequests = output.qualificationRequests
        } else {
            self.nextToken = nil
            self.numResults = nil
            self.qualificationRequests = nil
        }
    }
}

public struct ListQualificationRequestsOutputResponse: Equatable {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///         </p>
    public let nextToken: String?
    /// <p>The number of Qualification requests on this page in the filtered results list,
    ///             equivalent to the number of Qualification requests being returned by this call.</p>
    public let numResults: Int?
    /// <p>The Qualification request. The response includes one
    ///             QualificationRequest element
    ///             for each Qualification request returned
    ///             by the query.</p>
    public let qualificationRequests: [QualificationRequest]?

    public init (
        nextToken: String? = nil,
        numResults: Int? = nil,
        qualificationRequests: [QualificationRequest]? = nil
    )
    {
        self.nextToken = nextToken
        self.numResults = numResults
        self.qualificationRequests = qualificationRequests
    }
}

struct ListQualificationRequestsOutputResponseBody: Equatable {
    public let numResults: Int?
    public let nextToken: String?
    public let qualificationRequests: [QualificationRequest]?
}

extension ListQualificationRequestsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case numResults = "NumResults"
        case qualificationRequests = "QualificationRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let qualificationRequestsContainer = try containerValues.decodeIfPresent([QualificationRequest?].self, forKey: .qualificationRequests)
        var qualificationRequestsDecoded0:[QualificationRequest]? = nil
        if let qualificationRequestsContainer = qualificationRequestsContainer {
            qualificationRequestsDecoded0 = [QualificationRequest]()
            for structure0 in qualificationRequestsContainer {
                if let structure0 = structure0 {
                    qualificationRequestsDecoded0?.append(structure0)
                }
            }
        }
        qualificationRequests = qualificationRequestsDecoded0
    }
}

public struct ListQualificationTypesInputBodyMiddleware: Middleware {
    public let id: String = "ListQualificationTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQualificationTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQualificationTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQualificationTypesInput>
    public typealias MOutput = OperationOutput<ListQualificationTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQualificationTypesOutputError>
}

extension ListQualificationTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQualificationTypesInput(maxResults: \(String(describing: maxResults)), mustBeOwnedByCaller: \(String(describing: mustBeOwnedByCaller)), mustBeRequestable: \(String(describing: mustBeRequestable)), nextToken: \(String(describing: nextToken)), query: \(String(describing: query)))"}
}

extension ListQualificationTypesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case mustBeOwnedByCaller = "MustBeOwnedByCaller"
        case mustBeRequestable = "MustBeRequestable"
        case nextToken = "NextToken"
        case query = "Query"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let mustBeOwnedByCaller = mustBeOwnedByCaller {
            try encodeContainer.encode(mustBeOwnedByCaller, forKey: .mustBeOwnedByCaller)
        }
        if let mustBeRequestable = mustBeRequestable {
            try encodeContainer.encode(mustBeRequestable, forKey: .mustBeRequestable)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let query = query {
            try encodeContainer.encode(query, forKey: .query)
        }
    }
}

public struct ListQualificationTypesInputHeadersMiddleware: Middleware {
    public let id: String = "ListQualificationTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQualificationTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQualificationTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQualificationTypesInput>
    public typealias MOutput = OperationOutput<ListQualificationTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQualificationTypesOutputError>
}

public struct ListQualificationTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListQualificationTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQualificationTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQualificationTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQualificationTypesInput>
    public typealias MOutput = OperationOutput<ListQualificationTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQualificationTypesOutputError>
}

public struct ListQualificationTypesInput: Equatable {
    /// <p> The maximum number of results to return in a single call.
    ///         </p>
    public let maxResults: Int?
    /// <p> Specifies that only Qualification types that the Requester
    ///             created are returned. If false, the operation returns all
    ///             Qualification types.
    ///         </p>
    public let mustBeOwnedByCaller: Bool?
    /// <p>Specifies that only Qualification types that a user can
    ///             request through the Amazon Mechanical Turk web site, such as by
    ///             taking a Qualification test, are returned as results of the search.
    ///             Some Qualification types, such as those assigned automatically by the
    ///             system, cannot be requested directly by users. If false, all
    ///             Qualification types, including those managed by the system, are
    ///             considered. Valid values are True | False.
    ///         </p>
    public let mustBeRequestable: Bool?
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///         </p>
    public let nextToken: String?
    /// <p> A text query against all of the searchable attributes of
    ///             Qualification types.
    ///         </p>
    public let query: String?

    public init (
        maxResults: Int? = nil,
        mustBeOwnedByCaller: Bool? = nil,
        mustBeRequestable: Bool? = nil,
        nextToken: String? = nil,
        query: String? = nil
    )
    {
        self.maxResults = maxResults
        self.mustBeOwnedByCaller = mustBeOwnedByCaller
        self.mustBeRequestable = mustBeRequestable
        self.nextToken = nextToken
        self.query = query
    }
}

struct ListQualificationTypesInputBody: Equatable {
    public let query: String?
    public let mustBeRequestable: Bool?
    public let mustBeOwnedByCaller: Bool?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListQualificationTypesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case mustBeOwnedByCaller = "MustBeOwnedByCaller"
        case mustBeRequestable = "MustBeRequestable"
        case nextToken = "NextToken"
        case query = "Query"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .query)
        query = queryDecoded
        let mustBeRequestableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .mustBeRequestable)
        mustBeRequestable = mustBeRequestableDecoded
        let mustBeOwnedByCallerDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .mustBeOwnedByCaller)
        mustBeOwnedByCaller = mustBeOwnedByCallerDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListQualificationTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQualificationTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQualificationTypesOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQualificationTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQualificationTypesOutputResponse(nextToken: \(String(describing: nextToken)), numResults: \(String(describing: numResults)), qualificationTypes: \(String(describing: qualificationTypes)))"}
}

extension ListQualificationTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListQualificationTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.numResults = output.numResults
            self.qualificationTypes = output.qualificationTypes
        } else {
            self.nextToken = nil
            self.numResults = nil
            self.qualificationTypes = nil
        }
    }
}

public struct ListQualificationTypesOutputResponse: Equatable {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///         </p>
    public let nextToken: String?
    /// <p> The number of Qualification types on this page in the
    ///             filtered results list, equivalent to the number of types this
    ///             operation returns.
    ///         </p>
    public let numResults: Int?
    /// <p> The list of QualificationType elements returned by the
    ///             query.
    ///         </p>
    public let qualificationTypes: [QualificationType]?

    public init (
        nextToken: String? = nil,
        numResults: Int? = nil,
        qualificationTypes: [QualificationType]? = nil
    )
    {
        self.nextToken = nextToken
        self.numResults = numResults
        self.qualificationTypes = qualificationTypes
    }
}

struct ListQualificationTypesOutputResponseBody: Equatable {
    public let numResults: Int?
    public let nextToken: String?
    public let qualificationTypes: [QualificationType]?
}

extension ListQualificationTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case numResults = "NumResults"
        case qualificationTypes = "QualificationTypes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let qualificationTypesContainer = try containerValues.decodeIfPresent([QualificationType?].self, forKey: .qualificationTypes)
        var qualificationTypesDecoded0:[QualificationType]? = nil
        if let qualificationTypesContainer = qualificationTypesContainer {
            qualificationTypesDecoded0 = [QualificationType]()
            for structure0 in qualificationTypesContainer {
                if let structure0 = structure0 {
                    qualificationTypesDecoded0?.append(structure0)
                }
            }
        }
        qualificationTypes = qualificationTypesDecoded0
    }
}

public struct ListReviewPolicyResultsForHITInputBodyMiddleware: Middleware {
    public let id: String = "ListReviewPolicyResultsForHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReviewPolicyResultsForHITInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReviewPolicyResultsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReviewPolicyResultsForHITInput>
    public typealias MOutput = OperationOutput<ListReviewPolicyResultsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReviewPolicyResultsForHITOutputError>
}

extension ListReviewPolicyResultsForHITInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReviewPolicyResultsForHITInput(hITId: \(String(describing: hITId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), policyLevels: \(String(describing: policyLevels)), retrieveActions: \(String(describing: retrieveActions)), retrieveResults: \(String(describing: retrieveResults)))"}
}

extension ListReviewPolicyResultsForHITInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hITId = "HITId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyLevels = "PolicyLevels"
        case retrieveActions = "RetrieveActions"
        case retrieveResults = "RetrieveResults"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyLevels = policyLevels {
            var policyLevelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyLevels)
            for reviewpolicylevellist0 in policyLevels {
                try policyLevelsContainer.encode(reviewpolicylevellist0.rawValue)
            }
        }
        if let retrieveActions = retrieveActions {
            try encodeContainer.encode(retrieveActions, forKey: .retrieveActions)
        }
        if let retrieveResults = retrieveResults {
            try encodeContainer.encode(retrieveResults, forKey: .retrieveResults)
        }
    }
}

public struct ListReviewPolicyResultsForHITInputHeadersMiddleware: Middleware {
    public let id: String = "ListReviewPolicyResultsForHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReviewPolicyResultsForHITInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReviewPolicyResultsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReviewPolicyResultsForHITInput>
    public typealias MOutput = OperationOutput<ListReviewPolicyResultsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReviewPolicyResultsForHITOutputError>
}

public struct ListReviewPolicyResultsForHITInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReviewPolicyResultsForHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReviewPolicyResultsForHITInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReviewPolicyResultsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReviewPolicyResultsForHITInput>
    public typealias MOutput = OperationOutput<ListReviewPolicyResultsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReviewPolicyResultsForHITOutputError>
}

public struct ListReviewPolicyResultsForHITInput: Equatable {
    /// <p>The unique identifier of the HIT to retrieve review results for.</p>
    public let hITId: String?
    /// <p>Limit the number of results returned.</p>
    public let maxResults: Int?
    /// <p>Pagination token</p>
    public let nextToken: String?
    /// <p>
    ///             The Policy Level(s) to retrieve review results for - HIT or Assignment.
    ///             If omitted, the default behavior is to retrieve all data for both policy levels.
    ///             For a list of all the described policies, see Review Policies.
    ///         </p>
    public let policyLevels: [ReviewPolicyLevel]?
    /// <p>
    ///             Specify if the operation should retrieve a list of the actions taken executing
    ///             the Review Policies and their outcomes.
    ///         </p>
    public let retrieveActions: Bool?
    /// <p>
    ///             Specify if the operation should retrieve a list of the results computed by the Review Policies.
    ///         </p>
    public let retrieveResults: Bool?

    public init (
        hITId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        policyLevels: [ReviewPolicyLevel]? = nil,
        retrieveActions: Bool? = nil,
        retrieveResults: Bool? = nil
    )
    {
        self.hITId = hITId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyLevels = policyLevels
        self.retrieveActions = retrieveActions
        self.retrieveResults = retrieveResults
    }
}

struct ListReviewPolicyResultsForHITInputBody: Equatable {
    public let hITId: String?
    public let policyLevels: [ReviewPolicyLevel]?
    public let retrieveActions: Bool?
    public let retrieveResults: Bool?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListReviewPolicyResultsForHITInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hITId = "HITId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyLevels = "PolicyLevels"
        case retrieveActions = "RetrieveActions"
        case retrieveResults = "RetrieveResults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let policyLevelsContainer = try containerValues.decodeIfPresent([ReviewPolicyLevel?].self, forKey: .policyLevels)
        var policyLevelsDecoded0:[ReviewPolicyLevel]? = nil
        if let policyLevelsContainer = policyLevelsContainer {
            policyLevelsDecoded0 = [ReviewPolicyLevel]()
            for string0 in policyLevelsContainer {
                if let string0 = string0 {
                    policyLevelsDecoded0?.append(string0)
                }
            }
        }
        policyLevels = policyLevelsDecoded0
        let retrieveActionsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .retrieveActions)
        retrieveActions = retrieveActionsDecoded
        let retrieveResultsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .retrieveResults)
        retrieveResults = retrieveResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReviewPolicyResultsForHITOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReviewPolicyResultsForHITOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReviewPolicyResultsForHITOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReviewPolicyResultsForHITOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReviewPolicyResultsForHITOutputResponse(assignmentReviewPolicy: \(String(describing: assignmentReviewPolicy)), assignmentReviewReport: \(String(describing: assignmentReviewReport)), hITId: \(String(describing: hITId)), hITReviewPolicy: \(String(describing: hITReviewPolicy)), hITReviewReport: \(String(describing: hITReviewReport)), nextToken: \(String(describing: nextToken)))"}
}

extension ListReviewPolicyResultsForHITOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReviewPolicyResultsForHITOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assignmentReviewPolicy = output.assignmentReviewPolicy
            self.assignmentReviewReport = output.assignmentReviewReport
            self.hITId = output.hITId
            self.hITReviewPolicy = output.hITReviewPolicy
            self.hITReviewReport = output.hITReviewReport
            self.nextToken = output.nextToken
        } else {
            self.assignmentReviewPolicy = nil
            self.assignmentReviewReport = nil
            self.hITId = nil
            self.hITReviewPolicy = nil
            self.hITReviewReport = nil
            self.nextToken = nil
        }
    }
}

public struct ListReviewPolicyResultsForHITOutputResponse: Equatable {
    /// <p> The name of the Assignment-level Review Policy. This
    ///             contains only the PolicyName element.
    ///         </p>
    public let assignmentReviewPolicy: ReviewPolicy?
    /// <p> Contains both ReviewResult and ReviewAction elements for an
    ///             Assignment.
    ///         </p>
    public let assignmentReviewReport: ReviewReport?
    /// <p>The HITId of the HIT for which results have been returned.</p>
    public let hITId: String?
    /// <p>The name of the HIT-level Review Policy. This contains only
    ///             the PolicyName element.</p>
    public let hITReviewPolicy: ReviewPolicy?
    /// <p>Contains both ReviewResult and ReviewAction elements for a particular HIT.
    ///         </p>
    public let hITReviewReport: ReviewReport?
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///         </p>
    public let nextToken: String?

    public init (
        assignmentReviewPolicy: ReviewPolicy? = nil,
        assignmentReviewReport: ReviewReport? = nil,
        hITId: String? = nil,
        hITReviewPolicy: ReviewPolicy? = nil,
        hITReviewReport: ReviewReport? = nil,
        nextToken: String? = nil
    )
    {
        self.assignmentReviewPolicy = assignmentReviewPolicy
        self.assignmentReviewReport = assignmentReviewReport
        self.hITId = hITId
        self.hITReviewPolicy = hITReviewPolicy
        self.hITReviewReport = hITReviewReport
        self.nextToken = nextToken
    }
}

struct ListReviewPolicyResultsForHITOutputResponseBody: Equatable {
    public let hITId: String?
    public let assignmentReviewPolicy: ReviewPolicy?
    public let hITReviewPolicy: ReviewPolicy?
    public let assignmentReviewReport: ReviewReport?
    public let hITReviewReport: ReviewReport?
    public let nextToken: String?
}

extension ListReviewPolicyResultsForHITOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentReviewPolicy = "AssignmentReviewPolicy"
        case assignmentReviewReport = "AssignmentReviewReport"
        case hITId = "HITId"
        case hITReviewPolicy = "HITReviewPolicy"
        case hITReviewReport = "HITReviewReport"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let assignmentReviewPolicyDecoded = try containerValues.decodeIfPresent(ReviewPolicy.self, forKey: .assignmentReviewPolicy)
        assignmentReviewPolicy = assignmentReviewPolicyDecoded
        let hITReviewPolicyDecoded = try containerValues.decodeIfPresent(ReviewPolicy.self, forKey: .hITReviewPolicy)
        hITReviewPolicy = hITReviewPolicyDecoded
        let assignmentReviewReportDecoded = try containerValues.decodeIfPresent(ReviewReport.self, forKey: .assignmentReviewReport)
        assignmentReviewReport = assignmentReviewReportDecoded
        let hITReviewReportDecoded = try containerValues.decodeIfPresent(ReviewReport.self, forKey: .hITReviewReport)
        hITReviewReport = hITReviewReportDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListReviewableHITsInputBodyMiddleware: Middleware {
    public let id: String = "ListReviewableHITsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReviewableHITsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReviewableHITsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReviewableHITsInput>
    public typealias MOutput = OperationOutput<ListReviewableHITsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReviewableHITsOutputError>
}

extension ListReviewableHITsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReviewableHITsInput(hITTypeId: \(String(describing: hITTypeId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), status: \(String(describing: status)))"}
}

extension ListReviewableHITsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hITTypeId = "HITTypeId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITTypeId = hITTypeId {
            try encodeContainer.encode(hITTypeId, forKey: .hITTypeId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListReviewableHITsInputHeadersMiddleware: Middleware {
    public let id: String = "ListReviewableHITsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReviewableHITsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReviewableHITsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReviewableHITsInput>
    public typealias MOutput = OperationOutput<ListReviewableHITsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReviewableHITsOutputError>
}

public struct ListReviewableHITsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReviewableHITsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReviewableHITsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReviewableHITsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReviewableHITsInput>
    public typealias MOutput = OperationOutput<ListReviewableHITsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReviewableHITsOutputError>
}

public struct ListReviewableHITsInput: Equatable {
    /// <p>
    ///             The ID of the HIT type of the HITs to consider for the query.
    ///             If not specified, all HITs for the Reviewer are considered
    ///         </p>
    public let hITTypeId: String?
    /// <p>
    ///             Limit the number of results returned.
    ///         </p>
    public let maxResults: Int?
    /// <p>Pagination Token</p>
    public let nextToken: String?
    /// <p>
    ///             Can be either <code>Reviewable</code> or <code>Reviewing</code>.
    ///             Reviewable is the default value.
    ///         </p>
    public let status: ReviewableHITStatus?

    public init (
        hITTypeId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: ReviewableHITStatus? = nil
    )
    {
        self.hITTypeId = hITTypeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListReviewableHITsInputBody: Equatable {
    public let hITTypeId: String?
    public let status: ReviewableHITStatus?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListReviewableHITsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hITTypeId = "HITTypeId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITTypeId)
        hITTypeId = hITTypeIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ReviewableHITStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReviewableHITsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReviewableHITsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReviewableHITsOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReviewableHITsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReviewableHITsOutputResponse(hITs: \(String(describing: hITs)), nextToken: \(String(describing: nextToken)), numResults: \(String(describing: numResults)))"}
}

extension ListReviewableHITsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReviewableHITsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hITs = output.hITs
            self.nextToken = output.nextToken
            self.numResults = output.numResults
        } else {
            self.hITs = nil
            self.nextToken = nil
            self.numResults = nil
        }
    }
}

public struct ListReviewableHITsOutputResponse: Equatable {
    /// <p> The list of HIT elements returned by the query.</p>
    public let hITs: [HIT]?
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///         </p>
    public let nextToken: String?
    /// <p> The number of HITs on this page in the filtered results
    ///             list, equivalent to the number of HITs being returned by this call.
    ///         </p>
    public let numResults: Int?

    public init (
        hITs: [HIT]? = nil,
        nextToken: String? = nil,
        numResults: Int? = nil
    )
    {
        self.hITs = hITs
        self.nextToken = nextToken
        self.numResults = numResults
    }
}

struct ListReviewableHITsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let numResults: Int?
    public let hITs: [HIT]?
}

extension ListReviewableHITsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hITs = "HITs"
        case nextToken = "NextToken"
        case numResults = "NumResults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let hITsContainer = try containerValues.decodeIfPresent([HIT?].self, forKey: .hITs)
        var hITsDecoded0:[HIT]? = nil
        if let hITsContainer = hITsContainer {
            hITsDecoded0 = [HIT]()
            for structure0 in hITsContainer {
                if let structure0 = structure0 {
                    hITsDecoded0?.append(structure0)
                }
            }
        }
        hITs = hITsDecoded0
    }
}

public struct ListWorkerBlocksInputBodyMiddleware: Middleware {
    public let id: String = "ListWorkerBlocksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkerBlocksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkerBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkerBlocksInput>
    public typealias MOutput = OperationOutput<ListWorkerBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkerBlocksOutputError>
}

extension ListWorkerBlocksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkerBlocksInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWorkerBlocksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWorkerBlocksInputHeadersMiddleware: Middleware {
    public let id: String = "ListWorkerBlocksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkerBlocksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkerBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkerBlocksInput>
    public typealias MOutput = OperationOutput<ListWorkerBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkerBlocksOutputError>
}

public struct ListWorkerBlocksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWorkerBlocksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkerBlocksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkerBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkerBlocksInput>
    public typealias MOutput = OperationOutput<ListWorkerBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkerBlocksOutputError>
}

public struct ListWorkerBlocksInput: Equatable {
    public let maxResults: Int?
    /// <p>Pagination token</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkerBlocksInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListWorkerBlocksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkerBlocksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkerBlocksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkerBlocksOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkerBlocksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkerBlocksOutputResponse(nextToken: \(String(describing: nextToken)), numResults: \(String(describing: numResults)), workerBlocks: \(String(describing: workerBlocks)))"}
}

extension ListWorkerBlocksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWorkerBlocksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.numResults = output.numResults
            self.workerBlocks = output.workerBlocks
        } else {
            self.nextToken = nil
            self.numResults = nil
            self.workerBlocks = nil
        }
    }
}

public struct ListWorkerBlocksOutputResponse: Equatable {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///         </p>
    public let nextToken: String?
    /// <p> The number of assignments on the page in the filtered
    ///             results list, equivalent to the number of assignments returned by
    ///             this call.</p>
    public let numResults: Int?
    /// <p> The list of WorkerBlocks, containing the collection of
    ///             Worker IDs and reasons for blocking.</p>
    public let workerBlocks: [WorkerBlock]?

    public init (
        nextToken: String? = nil,
        numResults: Int? = nil,
        workerBlocks: [WorkerBlock]? = nil
    )
    {
        self.nextToken = nextToken
        self.numResults = numResults
        self.workerBlocks = workerBlocks
    }
}

struct ListWorkerBlocksOutputResponseBody: Equatable {
    public let nextToken: String?
    public let numResults: Int?
    public let workerBlocks: [WorkerBlock]?
}

extension ListWorkerBlocksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case numResults = "NumResults"
        case workerBlocks = "WorkerBlocks"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let workerBlocksContainer = try containerValues.decodeIfPresent([WorkerBlock?].self, forKey: .workerBlocks)
        var workerBlocksDecoded0:[WorkerBlock]? = nil
        if let workerBlocksContainer = workerBlocksContainer {
            workerBlocksDecoded0 = [WorkerBlock]()
            for structure0 in workerBlocksContainer {
                if let structure0 = structure0 {
                    workerBlocksDecoded0?.append(structure0)
                }
            }
        }
        workerBlocks = workerBlocksDecoded0
    }
}

public struct ListWorkersWithQualificationTypeInputBodyMiddleware: Middleware {
    public let id: String = "ListWorkersWithQualificationTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkersWithQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkersWithQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkersWithQualificationTypeInput>
    public typealias MOutput = OperationOutput<ListWorkersWithQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkersWithQualificationTypeOutputError>
}

extension ListWorkersWithQualificationTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkersWithQualificationTypeInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), qualificationTypeId: \(String(describing: qualificationTypeId)), status: \(String(describing: status)))"}
}

extension ListWorkersWithQualificationTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case qualificationTypeId = "QualificationTypeId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListWorkersWithQualificationTypeInputHeadersMiddleware: Middleware {
    public let id: String = "ListWorkersWithQualificationTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkersWithQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkersWithQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkersWithQualificationTypeInput>
    public typealias MOutput = OperationOutput<ListWorkersWithQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkersWithQualificationTypeOutputError>
}

public struct ListWorkersWithQualificationTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWorkersWithQualificationTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkersWithQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkersWithQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkersWithQualificationTypeInput>
    public typealias MOutput = OperationOutput<ListWorkersWithQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkersWithQualificationTypeOutputError>
}

public struct ListWorkersWithQualificationTypeInput: Equatable {
    /// <p>
    ///             Limit the number of results returned.
    ///         </p>
    public let maxResults: Int?
    /// <p>Pagination Token</p>
    public let nextToken: String?
    /// <p>The ID of the Qualification type of the Qualifications to
    ///             return.</p>
    public let qualificationTypeId: String?
    /// <p>
    ///             The status of the Qualifications to return.
    ///             Can be <code>Granted | Revoked</code>.
    ///         </p>
    public let status: QualificationStatus?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        qualificationTypeId: String? = nil,
        status: QualificationStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.qualificationTypeId = qualificationTypeId
        self.status = status
    }
}

struct ListWorkersWithQualificationTypeInputBody: Equatable {
    public let qualificationTypeId: String?
    public let status: QualificationStatus?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListWorkersWithQualificationTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case qualificationTypeId = "QualificationTypeId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QualificationStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkersWithQualificationTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkersWithQualificationTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkersWithQualificationTypeOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkersWithQualificationTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkersWithQualificationTypeOutputResponse(nextToken: \(String(describing: nextToken)), numResults: \(String(describing: numResults)), qualifications: \(String(describing: qualifications)))"}
}

extension ListWorkersWithQualificationTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWorkersWithQualificationTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.numResults = output.numResults
            self.qualifications = output.qualifications
        } else {
            self.nextToken = nil
            self.numResults = nil
            self.qualifications = nil
        }
    }
}

public struct ListWorkersWithQualificationTypeOutputResponse: Equatable {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///         </p>
    public let nextToken: String?
    /// <p> The number of Qualifications on this page in the filtered
    ///             results list, equivalent to the number of Qualifications being
    ///             returned by this call.</p>
    public let numResults: Int?
    /// <p> The list of Qualification elements returned by this call.
    ///         </p>
    public let qualifications: [Qualification]?

    public init (
        nextToken: String? = nil,
        numResults: Int? = nil,
        qualifications: [Qualification]? = nil
    )
    {
        self.nextToken = nextToken
        self.numResults = numResults
        self.qualifications = qualifications
    }
}

struct ListWorkersWithQualificationTypeOutputResponseBody: Equatable {
    public let nextToken: String?
    public let numResults: Int?
    public let qualifications: [Qualification]?
}

extension ListWorkersWithQualificationTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case numResults = "NumResults"
        case qualifications = "Qualifications"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let qualificationsContainer = try containerValues.decodeIfPresent([Qualification?].self, forKey: .qualifications)
        var qualificationsDecoded0:[Qualification]? = nil
        if let qualificationsContainer = qualificationsContainer {
            qualificationsDecoded0 = [Qualification]()
            for structure0 in qualificationsContainer {
                if let structure0 = structure0 {
                    qualificationsDecoded0?.append(structure0)
                }
            }
        }
        qualifications = qualificationsDecoded0
    }
}

extension Locale: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case country = "Country"
        case subdivision = "Subdivision"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let subdivision = subdivision {
            try encodeContainer.encode(subdivision, forKey: .subdivision)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .country)
        country = countryDecoded
        let subdivisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subdivision)
        subdivision = subdivisionDecoded
    }
}

extension Locale: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Locale(country: \(String(describing: country)), subdivision: \(String(describing: subdivision)))"}
}

/// <p>The Locale data structure represents a geographical region or location.</p>
public struct Locale: Equatable {
    /// <p> The country of the locale. Must be a valid ISO 3166 country
    ///             code. For example, the code US refers to the United States of
    ///             America.
    ///         </p>
    public let country: String?
    /// <p>The state or subdivision of the locale. A valid ISO 3166-2
    ///             subdivision code. For example, the code WA refers to the state of
    ///             Washington.</p>
    public let subdivision: String?

    public init (
        country: String? = nil,
        subdivision: String? = nil
    )
    {
        self.country = country
        self.subdivision = subdivision
    }
}

extension NotificationSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case eventTypes = "EventTypes"
        case transport = "Transport"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let eventTypes = eventTypes {
            var eventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypes)
            for eventtypelist0 in eventTypes {
                try eventTypesContainer.encode(eventtypelist0.rawValue)
            }
        }
        if let transport = transport {
            try encodeContainer.encode(transport.rawValue, forKey: .transport)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destination)
        destination = destinationDecoded
        let transportDecoded = try containerValues.decodeIfPresent(NotificationTransport.self, forKey: .transport)
        transport = transportDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let eventTypesContainer = try containerValues.decodeIfPresent([EventType?].self, forKey: .eventTypes)
        var eventTypesDecoded0:[EventType]? = nil
        if let eventTypesContainer = eventTypesContainer {
            eventTypesDecoded0 = [EventType]()
            for string0 in eventTypesContainer {
                if let string0 = string0 {
                    eventTypesDecoded0?.append(string0)
                }
            }
        }
        eventTypes = eventTypesDecoded0
    }
}

extension NotificationSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationSpecification(destination: \(String(describing: destination)), eventTypes: \(String(describing: eventTypes)), transport: \(String(describing: transport)), version: \(String(describing: version)))"}
}

/// <p>The NotificationSpecification data structure describes a HIT
///             event notification for a HIT type.</p>
public struct NotificationSpecification: Equatable {
    /// <p>
    ///             The target for notification messages. The Destination’s format is determined by the specified Transport:
    ///         </p>
    ///         <ul>
    ///             <li>
    ///                 <p>When Transport is Email, the Destination is your email address.</p>
    ///             </li>
    ///             <li>
    ///                 <p>When Transport is SQS, the Destination is your queue URL.</p>
    ///             </li>
    ///             <li>
    ///                 <p>When Transport is SNS, the Destination is the ARN of your topic.</p>
    ///             </li>
    ///          </ul>
    public let destination: String?
    /// <p> The list of events that should cause notifications to be
    ///             sent. Valid Values: AssignmentAccepted | AssignmentAbandoned |
    ///             AssignmentReturned | AssignmentSubmitted | AssignmentRejected |
    ///             AssignmentApproved | HITCreated | HITExtended | HITDisposed |
    ///             HITReviewable | HITExpired | Ping. The Ping event is only valid for
    ///             the SendTestEventNotification operation.
    ///         </p>
    public let eventTypes: [EventType]?
    /// <p> The method Amazon Mechanical Turk uses to send the
    ///             notification. Valid Values: Email | SQS | SNS.
    ///         </p>
    public let transport: NotificationTransport?
    /// <p>The version of the Notification API to use. Valid value is
    ///             2006-05-05.</p>
    public let version: String?

    public init (
        destination: String? = nil,
        eventTypes: [EventType]? = nil,
        transport: NotificationTransport? = nil,
        version: String? = nil
    )
    {
        self.destination = destination
        self.eventTypes = eventTypes
        self.transport = transport
        self.version = version
    }
}

public enum NotificationTransport {
    case email
    case sns
    case sqs
    case sdkUnknown(String)
}

extension NotificationTransport : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NotificationTransport] {
        return [
            .email,
            .sns,
            .sqs,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .email: return "Email"
        case .sns: return "SNS"
        case .sqs: return "SQS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NotificationTransport(rawValue: rawValue) ?? NotificationTransport.sdkUnknown(rawValue)
    }
}

public enum NotifyWorkersFailureCode {
    case hardfailure
    case softfailure
    case sdkUnknown(String)
}

extension NotifyWorkersFailureCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NotifyWorkersFailureCode] {
        return [
            .hardfailure,
            .softfailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hardfailure: return "HardFailure"
        case .softfailure: return "SoftFailure"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NotifyWorkersFailureCode(rawValue: rawValue) ?? NotifyWorkersFailureCode.sdkUnknown(rawValue)
    }
}

extension NotifyWorkersFailureStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case notifyWorkersFailureCode = "NotifyWorkersFailureCode"
        case notifyWorkersFailureMessage = "NotifyWorkersFailureMessage"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notifyWorkersFailureCode = notifyWorkersFailureCode {
            try encodeContainer.encode(notifyWorkersFailureCode.rawValue, forKey: .notifyWorkersFailureCode)
        }
        if let notifyWorkersFailureMessage = notifyWorkersFailureMessage {
            try encodeContainer.encode(notifyWorkersFailureMessage, forKey: .notifyWorkersFailureMessage)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notifyWorkersFailureCodeDecoded = try containerValues.decodeIfPresent(NotifyWorkersFailureCode.self, forKey: .notifyWorkersFailureCode)
        notifyWorkersFailureCode = notifyWorkersFailureCodeDecoded
        let notifyWorkersFailureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notifyWorkersFailureMessage)
        notifyWorkersFailureMessage = notifyWorkersFailureMessageDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerId)
        workerId = workerIdDecoded
    }
}

extension NotifyWorkersFailureStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyWorkersFailureStatus(notifyWorkersFailureCode: \(String(describing: notifyWorkersFailureCode)), notifyWorkersFailureMessage: \(String(describing: notifyWorkersFailureMessage)), workerId: \(String(describing: workerId)))"}
}

/// <p> When MTurk encounters an issue with notifying the Workers
///             you specified, it returns back this object with failure details.
///         </p>
public struct NotifyWorkersFailureStatus: Equatable {
    /// <p> Encoded value for the failure type.
    ///         </p>
    public let notifyWorkersFailureCode: NotifyWorkersFailureCode?
    /// <p> A message detailing the reason the Worker could not be
    ///             notified.
    ///         </p>
    public let notifyWorkersFailureMessage: String?
    /// <p> The ID of the Worker.</p>
    public let workerId: String?

    public init (
        notifyWorkersFailureCode: NotifyWorkersFailureCode? = nil,
        notifyWorkersFailureMessage: String? = nil,
        workerId: String? = nil
    )
    {
        self.notifyWorkersFailureCode = notifyWorkersFailureCode
        self.notifyWorkersFailureMessage = notifyWorkersFailureMessage
        self.workerId = workerId
    }
}

public struct NotifyWorkersInputBodyMiddleware: Middleware {
    public let id: String = "NotifyWorkersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyWorkersInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyWorkersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyWorkersInput>
    public typealias MOutput = OperationOutput<NotifyWorkersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyWorkersOutputError>
}

extension NotifyWorkersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyWorkersInput(messageText: \(String(describing: messageText)), subject: \(String(describing: subject)), workerIds: \(String(describing: workerIds)))"}
}

extension NotifyWorkersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messageText = "MessageText"
        case subject = "Subject"
        case workerIds = "WorkerIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageText = messageText {
            try encodeContainer.encode(messageText, forKey: .messageText)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let workerIds = workerIds {
            var workerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workerIds)
            for customeridlist0 in workerIds {
                try workerIdsContainer.encode(customeridlist0)
            }
        }
    }
}

public struct NotifyWorkersInputHeadersMiddleware: Middleware {
    public let id: String = "NotifyWorkersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyWorkersInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyWorkersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyWorkersInput>
    public typealias MOutput = OperationOutput<NotifyWorkersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyWorkersOutputError>
}

public struct NotifyWorkersInputQueryItemMiddleware: Middleware {
    public let id: String = "NotifyWorkersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyWorkersInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyWorkersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyWorkersInput>
    public typealias MOutput = OperationOutput<NotifyWorkersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyWorkersOutputError>
}

public struct NotifyWorkersInput: Equatable {
    /// <p>The text of the email message to send. Can include up to
    ///             4,096 characters</p>
    public let messageText: String?
    /// <p>The subject line of the email message to send. Can include up
    ///             to 200 characters.</p>
    public let subject: String?
    /// <p>A list of Worker IDs you wish to notify. You
    ///             can notify upto
    ///             100 Workers at a time.</p>
    public let workerIds: [String]?

    public init (
        messageText: String? = nil,
        subject: String? = nil,
        workerIds: [String]? = nil
    )
    {
        self.messageText = messageText
        self.subject = subject
        self.workerIds = workerIds
    }
}

struct NotifyWorkersInputBody: Equatable {
    public let subject: String?
    public let messageText: String?
    public let workerIds: [String]?
}

extension NotifyWorkersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageText = "MessageText"
        case subject = "Subject"
        case workerIds = "WorkerIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let messageTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageText)
        messageText = messageTextDecoded
        let workerIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .workerIds)
        var workerIdsDecoded0:[String]? = nil
        if let workerIdsContainer = workerIdsContainer {
            workerIdsDecoded0 = [String]()
            for string0 in workerIdsContainer {
                if let string0 = string0 {
                    workerIdsDecoded0?.append(string0)
                }
            }
        }
        workerIds = workerIdsDecoded0
    }
}

extension NotifyWorkersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyWorkersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum NotifyWorkersOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyWorkersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyWorkersOutputResponse(notifyWorkersFailureStatuses: \(String(describing: notifyWorkersFailureStatuses)))"}
}

extension NotifyWorkersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotifyWorkersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.notifyWorkersFailureStatuses = output.notifyWorkersFailureStatuses
        } else {
            self.notifyWorkersFailureStatuses = nil
        }
    }
}

public struct NotifyWorkersOutputResponse: Equatable {
    /// <p> When MTurk sends notifications to the list of Workers, it
    ///             returns back any failures it encounters in this list of
    ///             NotifyWorkersFailureStatus objects.
    ///         </p>
    public let notifyWorkersFailureStatuses: [NotifyWorkersFailureStatus]?

    public init (
        notifyWorkersFailureStatuses: [NotifyWorkersFailureStatus]? = nil
    )
    {
        self.notifyWorkersFailureStatuses = notifyWorkersFailureStatuses
    }
}

struct NotifyWorkersOutputResponseBody: Equatable {
    public let notifyWorkersFailureStatuses: [NotifyWorkersFailureStatus]?
}

extension NotifyWorkersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case notifyWorkersFailureStatuses = "NotifyWorkersFailureStatuses"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notifyWorkersFailureStatusesContainer = try containerValues.decodeIfPresent([NotifyWorkersFailureStatus?].self, forKey: .notifyWorkersFailureStatuses)
        var notifyWorkersFailureStatusesDecoded0:[NotifyWorkersFailureStatus]? = nil
        if let notifyWorkersFailureStatusesContainer = notifyWorkersFailureStatusesContainer {
            notifyWorkersFailureStatusesDecoded0 = [NotifyWorkersFailureStatus]()
            for structure0 in notifyWorkersFailureStatusesContainer {
                if let structure0 = structure0 {
                    notifyWorkersFailureStatusesDecoded0?.append(structure0)
                }
            }
        }
        notifyWorkersFailureStatuses = notifyWorkersFailureStatusesDecoded0
    }
}

extension ParameterMapEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for stringlist0 in values {
                try valuesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ParameterMapEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterMapEntry(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p> This data structure is the data type for the AnswerKey
///             parameter of the ScoreMyKnownAnswers/2011-09-01 Review Policy.
///         </p>
public struct ParameterMapEntry: Equatable {
    /// <p> The QuestionID from the HIT that is used to identify which
    ///             question requires Mechanical Turk to score as part of the
    ///             ScoreMyKnownAnswers/2011-09-01 Review Policy.
    ///         </p>
    public let key: String?
    /// <p> The list of answers to the question specified in the
    ///             MapEntry Key element. The Worker must match all values in order for
    ///             the answer to be scored correctly.
    ///         </p>
    public let values: [String]?

    public init (
        key: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

extension PolicyParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case mapEntries = "MapEntries"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let mapEntries = mapEntries {
            var mapEntriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mapEntries)
            for parametermapentrylist0 in mapEntries {
                try mapEntriesContainer.encode(parametermapentrylist0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for stringlist0 in values {
                try valuesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let mapEntriesContainer = try containerValues.decodeIfPresent([ParameterMapEntry?].self, forKey: .mapEntries)
        var mapEntriesDecoded0:[ParameterMapEntry]? = nil
        if let mapEntriesContainer = mapEntriesContainer {
            mapEntriesDecoded0 = [ParameterMapEntry]()
            for structure0 in mapEntriesContainer {
                if let structure0 = structure0 {
                    mapEntriesDecoded0?.append(structure0)
                }
            }
        }
        mapEntries = mapEntriesDecoded0
    }
}

extension PolicyParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyParameter(key: \(String(describing: key)), mapEntries: \(String(describing: mapEntries)), values: \(String(describing: values)))"}
}

/// <p> Name of the parameter from the Review policy.
///         </p>
public struct PolicyParameter: Equatable {
    /// <p> Name of the parameter from the list of Review Polices.
    ///         </p>
    public let key: String?
    /// <p> List of ParameterMapEntry objects.
    ///         </p>
    public let mapEntries: [ParameterMapEntry]?
    /// <p> The list of values of the Parameter</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        mapEntries: [ParameterMapEntry]? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.mapEntries = mapEntries
        self.values = values
    }
}

extension Qualification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantTime = "GrantTime"
        case integerValue = "IntegerValue"
        case localeValue = "LocaleValue"
        case qualificationTypeId = "QualificationTypeId"
        case status = "Status"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantTime = grantTime {
            try encodeContainer.encode(grantTime.timeIntervalSince1970, forKey: .grantTime)
        }
        if let integerValue = integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let localeValue = localeValue {
            try encodeContainer.encode(localeValue, forKey: .localeValue)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let grantTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .grantTime)
        grantTime = grantTimeDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let localeValueDecoded = try containerValues.decodeIfPresent(Locale.self, forKey: .localeValue)
        localeValue = localeValueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QualificationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Qualification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Qualification(grantTime: \(String(describing: grantTime)), integerValue: \(String(describing: integerValue)), localeValue: \(String(describing: localeValue)), qualificationTypeId: \(String(describing: qualificationTypeId)), status: \(String(describing: status)), workerId: \(String(describing: workerId)))"}
}

/// <p>The Qualification data structure represents a Qualification
///             assigned to a user, including the Qualification type and the value
///             (score).</p>
public struct Qualification: Equatable {
    /// <p> The date and time the Qualification was granted to the
    ///             Worker. If the Worker's Qualification was revoked, and then
    ///             re-granted based on a new Qualification request, GrantTime is the
    ///             date and time of the last call to the AcceptQualificationRequest
    ///             operation.</p>
    public let grantTime: Date?
    /// <p> The value (score) of the Qualification, if the Qualification
    ///             has an integer value.</p>
    public let integerValue: Int?
    /// <p>The Locale data structure represents a geographical region or location.</p>
    public let localeValue: Locale?
    /// <p> The ID of the Qualification type for the Qualification.</p>
    public let qualificationTypeId: String?
    /// <p> The status of the Qualification. Valid values are Granted |
    ///             Revoked.</p>
    public let status: QualificationStatus?
    /// <p> The ID of the Worker who possesses the Qualification.
    ///         </p>
    public let workerId: String?

    public init (
        grantTime: Date? = nil,
        integerValue: Int? = nil,
        localeValue: Locale? = nil,
        qualificationTypeId: String? = nil,
        status: QualificationStatus? = nil,
        workerId: String? = nil
    )
    {
        self.grantTime = grantTime
        self.integerValue = integerValue
        self.localeValue = localeValue
        self.qualificationTypeId = qualificationTypeId
        self.status = status
        self.workerId = workerId
    }
}

extension QualificationRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case answer = "Answer"
        case qualificationRequestId = "QualificationRequestId"
        case qualificationTypeId = "QualificationTypeId"
        case submitTime = "SubmitTime"
        case test = "Test"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answer = answer {
            try encodeContainer.encode(answer, forKey: .answer)
        }
        if let qualificationRequestId = qualificationRequestId {
            try encodeContainer.encode(qualificationRequestId, forKey: .qualificationRequestId)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationRequestId)
        qualificationRequestId = qualificationRequestIdDecoded
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let testDecoded = try containerValues.decodeIfPresent(String.self, forKey: .test)
        test = testDecoded
        let answerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .answer)
        answer = answerDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
    }
}

extension QualificationRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QualificationRequest(answer: \(String(describing: answer)), qualificationRequestId: \(String(describing: qualificationRequestId)), qualificationTypeId: \(String(describing: qualificationTypeId)), submitTime: \(String(describing: submitTime)), test: \(String(describing: test)), workerId: \(String(describing: workerId)))"}
}

/// <p> The QualificationRequest data structure represents a request
///             a Worker has made for a Qualification.
///         </p>
public struct QualificationRequest: Equatable {
    /// <p> The Worker's answers for the Qualification type's test
    ///             contained in a QuestionFormAnswers document, if the type has a test
    ///             and the Worker has submitted answers. If the Worker does not provide
    ///             any answers, Answer may be empty.
    ///         </p>
    public let answer: String?
    /// <p>The ID of the Qualification request, a unique identifier
    ///             generated when the request was submitted.
    ///
    ///         </p>
    public let qualificationRequestId: String?
    /// <p> The ID of the Qualification type the Worker is requesting,
    ///             as returned by the CreateQualificationType operation.
    ///         </p>
    public let qualificationTypeId: String?
    /// <p>The date and time the Qualification request had a status of
    ///             Submitted. This is either the time the Worker submitted answers for a
    ///             Qualification test, or the time the Worker requested the
    ///             Qualification if the Qualification type does not have a test.
    ///         </p>
    public let submitTime: Date?
    /// <p> The contents of the Qualification test that was presented to
    ///             the Worker, if the type has a test and the Worker has submitted
    ///             answers. This value is identical to the QuestionForm associated with
    ///             the Qualification type at the time the Worker requests the
    ///             Qualification.</p>
    public let test: String?
    /// <p> The ID of the Worker requesting the Qualification.</p>
    public let workerId: String?

    public init (
        answer: String? = nil,
        qualificationRequestId: String? = nil,
        qualificationTypeId: String? = nil,
        submitTime: Date? = nil,
        test: String? = nil,
        workerId: String? = nil
    )
    {
        self.answer = answer
        self.qualificationRequestId = qualificationRequestId
        self.qualificationTypeId = qualificationTypeId
        self.submitTime = submitTime
        self.test = test
        self.workerId = workerId
    }
}

extension QualificationRequirement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionsGuarded = "ActionsGuarded"
        case comparator = "Comparator"
        case integerValues = "IntegerValues"
        case localeValues = "LocaleValues"
        case qualificationTypeId = "QualificationTypeId"
        case requiredToPreview = "RequiredToPreview"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionsGuarded = actionsGuarded {
            try encodeContainer.encode(actionsGuarded.rawValue, forKey: .actionsGuarded)
        }
        if let comparator = comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let integerValues = integerValues {
            var integerValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerValues)
            for integerlist0 in integerValues {
                try integerValuesContainer.encode(integerlist0)
            }
        }
        if let localeValues = localeValues {
            var localeValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .localeValues)
            for localelist0 in localeValues {
                try localeValuesContainer.encode(localelist0)
            }
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let requiredToPreview = requiredToPreview {
            try encodeContainer.encode(requiredToPreview, forKey: .requiredToPreview)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let comparatorDecoded = try containerValues.decodeIfPresent(Comparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let integerValuesContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .integerValues)
        var integerValuesDecoded0:[Int]? = nil
        if let integerValuesContainer = integerValuesContainer {
            integerValuesDecoded0 = [Int]()
            for integer0 in integerValuesContainer {
                if let integer0 = integer0 {
                    integerValuesDecoded0?.append(integer0)
                }
            }
        }
        integerValues = integerValuesDecoded0
        let localeValuesContainer = try containerValues.decodeIfPresent([Locale?].self, forKey: .localeValues)
        var localeValuesDecoded0:[Locale]? = nil
        if let localeValuesContainer = localeValuesContainer {
            localeValuesDecoded0 = [Locale]()
            for structure0 in localeValuesContainer {
                if let structure0 = structure0 {
                    localeValuesDecoded0?.append(structure0)
                }
            }
        }
        localeValues = localeValuesDecoded0
        let requiredToPreviewDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .requiredToPreview)
        requiredToPreview = requiredToPreviewDecoded
        let actionsGuardedDecoded = try containerValues.decodeIfPresent(HITAccessActions.self, forKey: .actionsGuarded)
        actionsGuarded = actionsGuardedDecoded
    }
}

extension QualificationRequirement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QualificationRequirement(actionsGuarded: \(String(describing: actionsGuarded)), comparator: \(String(describing: comparator)), integerValues: \(String(describing: integerValues)), localeValues: \(String(describing: localeValues)), qualificationTypeId: \(String(describing: qualificationTypeId)), requiredToPreview: \(String(describing: requiredToPreview)))"}
}

/// <p>
///             The QualificationRequirement data structure describes a Qualification that a Worker must have
///             before the Worker is allowed to accept a HIT.
///             A requirement may optionally state that a Worker must have the Qualification in order to preview the HIT, or
///             see the HIT in search results.
///         </p>
public struct QualificationRequirement: Equatable {
    /// <p> Setting this attribute prevents Workers whose Qualifications do not meet
    ///             this QualificationRequirement from taking the specified action. Valid arguments include
    ///             "Accept" (Worker cannot accept the HIT, but can preview the HIT and see it in their search results),
    ///             "PreviewAndAccept" (Worker cannot accept or preview the HIT, but can see the HIT in their search results),
    ///             and "DiscoverPreviewAndAccept" (Worker cannot accept, preview, or see the HIT in their search results). It's possible for you to create a HIT with multiple
    ///             QualificationRequirements (which can have different values for the ActionGuarded attribute). In this case,
    ///             the Worker is only permitted to perform an action when they have met all QualificationRequirements guarding
    ///             the action. The actions in the order of least restrictive to most restrictive are Discover, Preview and Accept.
    ///             For example, if a Worker meets all QualificationRequirements that are set to DiscoverPreviewAndAccept, but do
    ///             not meet all requirements that are set with PreviewAndAccept, then the Worker will be able to Discover, i.e. see the
    ///             HIT in their search result, but will not be able to Preview or Accept the HIT. ActionsGuarded should not be used in combination with the
    ///             <code>RequiredToPreview</code> field.
    ///         </p>
    public let actionsGuarded: HITAccessActions?
    /// <p>The kind of comparison to make against a Qualification's
    ///             value. You can compare a Qualification's value to an IntegerValue to
    ///             see if it is LessThan, LessThanOrEqualTo, GreaterThan,
    ///             GreaterThanOrEqualTo, EqualTo, or NotEqualTo the IntegerValue. You
    ///             can compare it to a LocaleValue to see if it is EqualTo, or
    ///             NotEqualTo the LocaleValue. You can check to see if the value is In
    ///             or NotIn a set of IntegerValue
    ///             or LocaleValue values. Lastly, a
    ///             Qualification requirement can also
    ///             test if a Qualification Exists or
    ///             DoesNotExist in the user's profile,
    ///             regardless of its value.
    ///         </p>
    public let comparator: Comparator?
    /// <p> The integer value to compare against the Qualification's
    ///             value. IntegerValue must not be present if Comparator is Exists or
    ///             DoesNotExist. IntegerValue can only be used if the Qualification type
    ///             has an integer value; it cannot be used with the Worker_Locale
    ///             QualificationType ID. When performing a set comparison by using the
    ///             In or the NotIn comparator, you can use up to 15 IntegerValue
    ///             elements in a QualificationRequirement data structure.
    ///         </p>
    public let integerValues: [Int]?
    /// <p> The locale value to compare against the Qualification's
    ///             value. The local value must be a valid ISO 3166 country code or
    ///             supports ISO 3166-2 subdivisions. LocaleValue can only be used with a
    ///             Worker_Locale QualificationType ID. LocaleValue can only be used with
    ///             the EqualTo, NotEqualTo, In, and NotIn comparators. You must only use
    ///             a single LocaleValue element when using the EqualTo or NotEqualTo
    ///             comparators. When performing a set comparison by using the In or the
    ///             NotIn comparator, you can use up to 30 LocaleValue elements in a
    ///             QualificationRequirement data structure.
    ///         </p>
    public let localeValues: [Locale]?
    /// <p> The ID of the Qualification type for the requirement.</p>
    public let qualificationTypeId: String?
    /// <p> DEPRECATED: Use the <code>ActionsGuarded</code> field instead.
    ///             If RequiredToPreview is true, the question data for the HIT will not be shown
    ///             when a Worker whose Qualifications do not meet this requirement tries
    ///             to preview the HIT. That is, a Worker's Qualifications must meet all
    ///             of the requirements for which RequiredToPreview is true in order to
    ///             preview the HIT. If a Worker meets all of the requirements where
    ///             RequiredToPreview is true (or if there are no such requirements), but
    ///             does not meet all of the requirements for the HIT, the Worker will be
    ///             allowed to preview the HIT's question data, but will not be allowed
    ///             to accept and complete the HIT. The default is false. This should not
    ///             be used in combination with the <code>ActionsGuarded</code> field.
    ///         </p>
    @available(*, deprecated)
    public let requiredToPreview: Bool?

    public init (
        actionsGuarded: HITAccessActions? = nil,
        comparator: Comparator? = nil,
        integerValues: [Int]? = nil,
        localeValues: [Locale]? = nil,
        qualificationTypeId: String? = nil,
        requiredToPreview: Bool? = nil
    )
    {
        self.actionsGuarded = actionsGuarded
        self.comparator = comparator
        self.integerValues = integerValues
        self.localeValues = localeValues
        self.qualificationTypeId = qualificationTypeId
        self.requiredToPreview = requiredToPreview
    }
}

public enum QualificationStatus {
    case granted
    case revoked
    case sdkUnknown(String)
}

extension QualificationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QualificationStatus] {
        return [
            .granted,
            .revoked,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .granted: return "Granted"
        case .revoked: return "Revoked"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QualificationStatus(rawValue: rawValue) ?? QualificationStatus.sdkUnknown(rawValue)
    }
}

extension QualificationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case answerKey = "AnswerKey"
        case autoGranted = "AutoGranted"
        case autoGrantedValue = "AutoGrantedValue"
        case creationTime = "CreationTime"
        case description = "Description"
        case isRequestable = "IsRequestable"
        case keywords = "Keywords"
        case name = "Name"
        case qualificationTypeId = "QualificationTypeId"
        case qualificationTypeStatus = "QualificationTypeStatus"
        case retryDelayInSeconds = "RetryDelayInSeconds"
        case test = "Test"
        case testDurationInSeconds = "TestDurationInSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answerKey = answerKey {
            try encodeContainer.encode(answerKey, forKey: .answerKey)
        }
        if let autoGranted = autoGranted {
            try encodeContainer.encode(autoGranted, forKey: .autoGranted)
        }
        if let autoGrantedValue = autoGrantedValue {
            try encodeContainer.encode(autoGrantedValue, forKey: .autoGrantedValue)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let isRequestable = isRequestable {
            try encodeContainer.encode(isRequestable, forKey: .isRequestable)
        }
        if let keywords = keywords {
            try encodeContainer.encode(keywords, forKey: .keywords)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let qualificationTypeStatus = qualificationTypeStatus {
            try encodeContainer.encode(qualificationTypeStatus.rawValue, forKey: .qualificationTypeStatus)
        }
        if let retryDelayInSeconds = retryDelayInSeconds {
            try encodeContainer.encode(retryDelayInSeconds, forKey: .retryDelayInSeconds)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
        if let testDurationInSeconds = testDurationInSeconds {
            try encodeContainer.encode(testDurationInSeconds, forKey: .testDurationInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let keywordsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keywords)
        keywords = keywordsDecoded
        let qualificationTypeStatusDecoded = try containerValues.decodeIfPresent(QualificationTypeStatus.self, forKey: .qualificationTypeStatus)
        qualificationTypeStatus = qualificationTypeStatusDecoded
        let testDecoded = try containerValues.decodeIfPresent(String.self, forKey: .test)
        test = testDecoded
        let testDurationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .testDurationInSeconds)
        testDurationInSeconds = testDurationInSecondsDecoded
        let answerKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .answerKey)
        answerKey = answerKeyDecoded
        let retryDelayInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retryDelayInSeconds)
        retryDelayInSeconds = retryDelayInSecondsDecoded
        let isRequestableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isRequestable)
        isRequestable = isRequestableDecoded
        let autoGrantedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoGranted)
        autoGranted = autoGrantedDecoded
        let autoGrantedValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .autoGrantedValue)
        autoGrantedValue = autoGrantedValueDecoded
    }
}

extension QualificationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QualificationType(answerKey: \(String(describing: answerKey)), autoGranted: \(String(describing: autoGranted)), autoGrantedValue: \(String(describing: autoGrantedValue)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), isRequestable: \(String(describing: isRequestable)), keywords: \(String(describing: keywords)), name: \(String(describing: name)), qualificationTypeId: \(String(describing: qualificationTypeId)), qualificationTypeStatus: \(String(describing: qualificationTypeStatus)), retryDelayInSeconds: \(String(describing: retryDelayInSeconds)), test: \(String(describing: test)), testDurationInSeconds: \(String(describing: testDurationInSeconds)))"}
}

/// <p> The QualificationType data structure represents a
///             Qualification type, a description of a property of a Worker that must
///             match the requirements of a HIT for the Worker to be able to accept
///             the HIT. The type also describes how a Worker can obtain a
///             Qualification of that type, such as through a Qualification test.
///         </p>
public struct QualificationType: Equatable {
    /// <p>The answers to the Qualification test specified in the Test
    ///             parameter.</p>
    public let answerKey: String?
    /// <p>Specifies that requests for the Qualification type are
    ///             granted immediately, without prompting the Worker with a
    ///             Qualification test. Valid values are True | False.</p>
    public let autoGranted: Bool?
    /// <p> The Qualification integer value to use for automatically
    ///             granted Qualifications, if AutoGranted is true. This is 1 by default.
    ///         </p>
    public let autoGrantedValue: Int?
    /// <p> The date and time the Qualification type was created.
    ///         </p>
    public let creationTime: Date?
    /// <p> A long description for the Qualification type.
    ///         </p>
    public let description: String?
    /// <p> Specifies whether the Qualification type is one that a user
    ///             can request through the Amazon Mechanical Turk web site, such as by
    ///             taking a Qualification test. This value is False for Qualifications
    ///             assigned automatically by the system. Valid values are True | False.
    ///         </p>
    public let isRequestable: Bool?
    /// <p> One or more words or phrases that describe theQualification
    ///             type, separated by commas. The Keywords make the type easier to find
    ///             using a search.
    ///         </p>
    public let keywords: String?
    /// <p> The name of the Qualification type. The type name is used to
    ///             identify the type, and to find the type using a Qualification type
    ///             search.
    ///         </p>
    public let name: String?
    /// <p> A unique identifier for the Qualification type. A
    ///             Qualification type is given a Qualification type ID when you call the
    ///             CreateQualificationType operation.
    ///         </p>
    public let qualificationTypeId: String?
    /// <p> The status of the Qualification type. A Qualification type's
    ///             status determines if users can apply to receive a Qualification of
    ///             this type, and if HITs can be created with requirements based on this
    ///             type. Valid values are Active | Inactive.
    ///         </p>
    public let qualificationTypeStatus: QualificationTypeStatus?
    /// <p> The amount of time, in seconds, Workers must wait after
    ///             taking the Qualification test before they can take it again. Workers
    ///             can take a Qualification test multiple times if they were not granted
    ///             the Qualification from a previous attempt, or if the test offers a
    ///             gradient score and they want a better score. If not specified,
    ///             retries are disabled and Workers can request a Qualification only
    ///             once.
    ///         </p>
    public let retryDelayInSeconds: Int?
    /// <p> The questions for a Qualification test associated with this
    ///             Qualification type that a user can take to obtain a Qualification of
    ///             this type. This parameter must be specified if AnswerKey is present.
    ///             A Qualification type cannot have both a specified Test parameter and
    ///             an AutoGranted value of true.
    ///         </p>
    public let test: String?
    /// <p> The amount of time, in seconds, given to a Worker to
    ///             complete the Qualification test, beginning from the time the Worker
    ///             requests the Qualification.
    ///         </p>
    public let testDurationInSeconds: Int?

    public init (
        answerKey: String? = nil,
        autoGranted: Bool? = nil,
        autoGrantedValue: Int? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        isRequestable: Bool? = nil,
        keywords: String? = nil,
        name: String? = nil,
        qualificationTypeId: String? = nil,
        qualificationTypeStatus: QualificationTypeStatus? = nil,
        retryDelayInSeconds: Int? = nil,
        test: String? = nil,
        testDurationInSeconds: Int? = nil
    )
    {
        self.answerKey = answerKey
        self.autoGranted = autoGranted
        self.autoGrantedValue = autoGrantedValue
        self.creationTime = creationTime
        self.description = description
        self.isRequestable = isRequestable
        self.keywords = keywords
        self.name = name
        self.qualificationTypeId = qualificationTypeId
        self.qualificationTypeStatus = qualificationTypeStatus
        self.retryDelayInSeconds = retryDelayInSeconds
        self.test = test
        self.testDurationInSeconds = testDurationInSeconds
    }
}

public enum QualificationTypeStatus {
    case active
    case inactive
    case sdkUnknown(String)
}

extension QualificationTypeStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QualificationTypeStatus] {
        return [
            .active,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .inactive: return "Inactive"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QualificationTypeStatus(rawValue: rawValue) ?? QualificationTypeStatus.sdkUnknown(rawValue)
    }
}

public struct RejectAssignmentInputBodyMiddleware: Middleware {
    public let id: String = "RejectAssignmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectAssignmentInput>
    public typealias MOutput = OperationOutput<RejectAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectAssignmentOutputError>
}

extension RejectAssignmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectAssignmentInput(assignmentId: \(String(describing: assignmentId)), requesterFeedback: \(String(describing: requesterFeedback)))"}
}

extension RejectAssignmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case requesterFeedback = "RequesterFeedback"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let requesterFeedback = requesterFeedback {
            try encodeContainer.encode(requesterFeedback, forKey: .requesterFeedback)
        }
    }
}

public struct RejectAssignmentInputHeadersMiddleware: Middleware {
    public let id: String = "RejectAssignmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectAssignmentInput>
    public typealias MOutput = OperationOutput<RejectAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectAssignmentOutputError>
}

public struct RejectAssignmentInputQueryItemMiddleware: Middleware {
    public let id: String = "RejectAssignmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectAssignmentInput>
    public typealias MOutput = OperationOutput<RejectAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectAssignmentOutputError>
}

public struct RejectAssignmentInput: Equatable {
    /// <p>
    ///             The ID of the assignment. The assignment must correspond to a HIT created by the Requester.
    ///         </p>
    public let assignmentId: String?
    /// <p>
    ///             A message for the Worker, which the Worker can see in the Status section of the web site.
    ///         </p>
    public let requesterFeedback: String?

    public init (
        assignmentId: String? = nil,
        requesterFeedback: String? = nil
    )
    {
        self.assignmentId = assignmentId
        self.requesterFeedback = requesterFeedback
    }
}

struct RejectAssignmentInputBody: Equatable {
    public let assignmentId: String?
    public let requesterFeedback: String?
}

extension RejectAssignmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case requesterFeedback = "RequesterFeedback"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let requesterFeedbackDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requesterFeedback)
        requesterFeedback = requesterFeedbackDecoded
    }
}

extension RejectAssignmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectAssignmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectAssignmentOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectAssignmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectAssignmentOutputResponse()"}
}

extension RejectAssignmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RejectAssignmentOutputResponse: Equatable {

    public init() {}
}

struct RejectAssignmentOutputResponseBody: Equatable {
}

extension RejectAssignmentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RejectQualificationRequestInputBodyMiddleware: Middleware {
    public let id: String = "RejectQualificationRequestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectQualificationRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectQualificationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectQualificationRequestInput>
    public typealias MOutput = OperationOutput<RejectQualificationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectQualificationRequestOutputError>
}

extension RejectQualificationRequestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectQualificationRequestInput(qualificationRequestId: \(String(describing: qualificationRequestId)), reason: \(String(describing: reason)))"}
}

extension RejectQualificationRequestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case qualificationRequestId = "QualificationRequestId"
        case reason = "Reason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let qualificationRequestId = qualificationRequestId {
            try encodeContainer.encode(qualificationRequestId, forKey: .qualificationRequestId)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

public struct RejectQualificationRequestInputHeadersMiddleware: Middleware {
    public let id: String = "RejectQualificationRequestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectQualificationRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectQualificationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectQualificationRequestInput>
    public typealias MOutput = OperationOutput<RejectQualificationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectQualificationRequestOutputError>
}

public struct RejectQualificationRequestInputQueryItemMiddleware: Middleware {
    public let id: String = "RejectQualificationRequestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectQualificationRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectQualificationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectQualificationRequestInput>
    public typealias MOutput = OperationOutput<RejectQualificationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectQualificationRequestOutputError>
}

public struct RejectQualificationRequestInput: Equatable {
    /// <p>
    ///             The ID of the Qualification request, as returned by the
    ///             <code>ListQualificationRequests</code>
    ///             operation.
    ///         </p>
    public let qualificationRequestId: String?
    /// <p>A text message explaining why the request was rejected, to be
    ///             shown to the Worker who made the request.</p>
    public let reason: String?

    public init (
        qualificationRequestId: String? = nil,
        reason: String? = nil
    )
    {
        self.qualificationRequestId = qualificationRequestId
        self.reason = reason
    }
}

struct RejectQualificationRequestInputBody: Equatable {
    public let qualificationRequestId: String?
    public let reason: String?
}

extension RejectQualificationRequestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case qualificationRequestId = "QualificationRequestId"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationRequestId)
        qualificationRequestId = qualificationRequestIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RejectQualificationRequestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectQualificationRequestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectQualificationRequestOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectQualificationRequestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectQualificationRequestOutputResponse()"}
}

extension RejectQualificationRequestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RejectQualificationRequestOutputResponse: Equatable {

    public init() {}
}

struct RejectQualificationRequestOutputResponseBody: Equatable {
}

extension RejectQualificationRequestOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RequestError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestError(message: \(String(describing: message)), turkErrorCode: \(String(describing: turkErrorCode)))"}
}

extension RequestError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.turkErrorCode = output.turkErrorCode
        } else {
            self.message = nil
            self.turkErrorCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request is invalid.</p>
public struct RequestError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var turkErrorCode: String?

    public init (
        message: String? = nil,
        turkErrorCode: String? = nil
    )
    {
        self.message = message
        self.turkErrorCode = turkErrorCode
    }
}

struct RequestErrorBody: Equatable {
    public let message: String?
    public let turkErrorCode: String?
}

extension RequestErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case turkErrorCode = "TurkErrorCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let turkErrorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .turkErrorCode)
        turkErrorCode = turkErrorCodeDecoded
    }
}

extension ReviewActionDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionId = "ActionId"
        case actionName = "ActionName"
        case completeTime = "CompleteTime"
        case errorCode = "ErrorCode"
        case result = "Result"
        case status = "Status"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let completeTime = completeTime {
            try encodeContainer.encode(completeTime.timeIntervalSince1970, forKey: .completeTime)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let result = result {
            try encodeContainer.encode(result, forKey: .result)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ReviewActionStatus.self, forKey: .status)
        status = statusDecoded
        let completeTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completeTime)
        completeTime = completeTimeDecoded
        let resultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .result)
        result = resultDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension ReviewActionDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReviewActionDetail(actionId: \(String(describing: actionId)), actionName: \(String(describing: actionName)), completeTime: \(String(describing: completeTime)), errorCode: \(String(describing: errorCode)), result: \(String(describing: result)), status: \(String(describing: status)), targetId: \(String(describing: targetId)), targetType: \(String(describing: targetType)))"}
}

/// <p> Both the AssignmentReviewReport and the HITReviewReport
///             elements contains the ReviewActionDetail data structure. This
///             structure is returned multiple times for each action specified in the
///             Review Policy.
///         </p>
public struct ReviewActionDetail: Equatable {
    /// <p>The unique identifier for the action.</p>
    public let actionId: String?
    /// <p> The nature of the action itself. The Review Policy is
    ///             responsible for examining the HIT and Assignments, emitting results,
    ///             and deciding which other actions will be necessary. </p>
    public let actionName: String?
    /// <p> The date when the action was completed.</p>
    public let completeTime: Date?
    /// <p> Present only when the Results have a FAILED Status.</p>
    public let errorCode: String?
    /// <p> A description of the outcome of the review.</p>
    public let result: String?
    /// <p> The current disposition of the action: INTENDED, SUCCEEDED,
    ///             FAILED, or CANCELLED.
    ///         </p>
    public let status: ReviewActionStatus?
    /// <p> The specific HITId or AssignmentID targeted by the action.</p>
    public let targetId: String?
    /// <p> The type of object in TargetId.</p>
    public let targetType: String?

    public init (
        actionId: String? = nil,
        actionName: String? = nil,
        completeTime: Date? = nil,
        errorCode: String? = nil,
        result: String? = nil,
        status: ReviewActionStatus? = nil,
        targetId: String? = nil,
        targetType: String? = nil
    )
    {
        self.actionId = actionId
        self.actionName = actionName
        self.completeTime = completeTime
        self.errorCode = errorCode
        self.result = result
        self.status = status
        self.targetId = targetId
        self.targetType = targetType
    }
}

public enum ReviewActionStatus {
    case cancelled
    case failed
    case intended
    case succeeded
    case sdkUnknown(String)
}

extension ReviewActionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReviewActionStatus] {
        return [
            .cancelled,
            .failed,
            .intended,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "Cancelled"
        case .failed: return "Failed"
        case .intended: return "Intended"
        case .succeeded: return "Succeeded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReviewActionStatus(rawValue: rawValue) ?? ReviewActionStatus.sdkUnknown(rawValue)
    }
}

extension ReviewPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameters = "Parameters"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for policyparameterlist0 in parameters {
                try parametersContainer.encode(policyparameterlist0)
            }
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let parametersContainer = try containerValues.decodeIfPresent([PolicyParameter?].self, forKey: .parameters)
        var parametersDecoded0:[PolicyParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [PolicyParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension ReviewPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReviewPolicy(parameters: \(String(describing: parameters)), policyName: \(String(describing: policyName)))"}
}

/// <p> HIT Review Policy data structures represent HIT review
///             policies, which you specify when you create a HIT.
///         </p>
public struct ReviewPolicy: Equatable {
    /// <p>Name of the parameter from the Review policy.</p>
    public let parameters: [PolicyParameter]?
    /// <p> Name of a Review Policy: SimplePlurality/2011-09-01 or
    ///             ScoreMyKnownAnswers/2011-09-01
    ///         </p>
    public let policyName: String?

    public init (
        parameters: [PolicyParameter]? = nil,
        policyName: String? = nil
    )
    {
        self.parameters = parameters
        self.policyName = policyName
    }
}

public enum ReviewPolicyLevel {
    case assignment
    case hit
    case sdkUnknown(String)
}

extension ReviewPolicyLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReviewPolicyLevel] {
        return [
            .assignment,
            .hit,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assignment: return "Assignment"
        case .hit: return "HIT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReviewPolicyLevel(rawValue: rawValue) ?? ReviewPolicyLevel.sdkUnknown(rawValue)
    }
}

extension ReviewReport: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reviewActions = "ReviewActions"
        case reviewResults = "ReviewResults"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reviewActions = reviewActions {
            var reviewActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reviewActions)
            for reviewactiondetaillist0 in reviewActions {
                try reviewActionsContainer.encode(reviewactiondetaillist0)
            }
        }
        if let reviewResults = reviewResults {
            var reviewResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reviewResults)
            for reviewresultdetaillist0 in reviewResults {
                try reviewResultsContainer.encode(reviewresultdetaillist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reviewResultsContainer = try containerValues.decodeIfPresent([ReviewResultDetail?].self, forKey: .reviewResults)
        var reviewResultsDecoded0:[ReviewResultDetail]? = nil
        if let reviewResultsContainer = reviewResultsContainer {
            reviewResultsDecoded0 = [ReviewResultDetail]()
            for structure0 in reviewResultsContainer {
                if let structure0 = structure0 {
                    reviewResultsDecoded0?.append(structure0)
                }
            }
        }
        reviewResults = reviewResultsDecoded0
        let reviewActionsContainer = try containerValues.decodeIfPresent([ReviewActionDetail?].self, forKey: .reviewActions)
        var reviewActionsDecoded0:[ReviewActionDetail]? = nil
        if let reviewActionsContainer = reviewActionsContainer {
            reviewActionsDecoded0 = [ReviewActionDetail]()
            for structure0 in reviewActionsContainer {
                if let structure0 = structure0 {
                    reviewActionsDecoded0?.append(structure0)
                }
            }
        }
        reviewActions = reviewActionsDecoded0
    }
}

extension ReviewReport: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReviewReport(reviewActions: \(String(describing: reviewActions)), reviewResults: \(String(describing: reviewResults)))"}
}

/// <p> Contains both ReviewResult and ReviewAction elements for a
///             particular HIT.
///         </p>
public struct ReviewReport: Equatable {
    /// <p> A list of ReviewAction objects for each action specified in
    ///             the Review Policy.
    ///         </p>
    public let reviewActions: [ReviewActionDetail]?
    /// <p> A list of ReviewResults objects for each action specified in
    ///             the Review Policy.
    ///         </p>
    public let reviewResults: [ReviewResultDetail]?

    public init (
        reviewActions: [ReviewActionDetail]? = nil,
        reviewResults: [ReviewResultDetail]? = nil
    )
    {
        self.reviewActions = reviewActions
        self.reviewResults = reviewResults
    }
}

extension ReviewResultDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionId = "ActionId"
        case key = "Key"
        case questionId = "QuestionId"
        case subjectId = "SubjectId"
        case subjectType = "SubjectType"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let subjectId = subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
        if let subjectType = subjectType {
            try encodeContainer.encode(subjectType, forKey: .subjectType)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let subjectTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subjectType)
        subjectType = subjectTypeDecoded
        let questionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ReviewResultDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReviewResultDetail(actionId: \(String(describing: actionId)), key: \(String(describing: key)), questionId: \(String(describing: questionId)), subjectId: \(String(describing: subjectId)), subjectType: \(String(describing: subjectType)), value: \(String(describing: value)))"}
}

/// <p> This data structure is returned multiple times for each
///             result specified in the Review Policy.
///         </p>
public struct ReviewResultDetail: Equatable {
    /// <p> A unique identifier of the Review action result.
    ///         </p>
    public let actionId: String?
    /// <p> Key identifies the particular piece of reviewed information.
    ///         </p>
    public let key: String?
    /// <p> Specifies the QuestionId the result is describing. Depending
    ///             on whether the TargetType is a HIT or Assignment this results could
    ///             specify multiple values. If TargetType is HIT and QuestionId is
    ///             absent, then the result describes results of the HIT, including the
    ///             HIT agreement score. If ObjectType is Assignment and QuestionId is
    ///             absent, then the result describes the Worker's performance on the
    ///             HIT.
    ///         </p>
    public let questionId: String?
    /// <p>The HITID or AssignmentId about which this result was taken.
    ///             Note that HIT-level Review Policies will often emit results about
    ///             both the HIT itself and its Assignments, while Assignment-level
    ///             review policies generally only emit results about the Assignment
    ///             itself.
    ///         </p>
    public let subjectId: String?
    /// <p> The type of the object from the SubjectId field.</p>
    public let subjectType: String?
    /// <p> The values of Key provided by the review policies you have
    ///             selected.
    ///         </p>
    public let value: String?

    public init (
        actionId: String? = nil,
        key: String? = nil,
        questionId: String? = nil,
        subjectId: String? = nil,
        subjectType: String? = nil,
        value: String? = nil
    )
    {
        self.actionId = actionId
        self.key = key
        self.questionId = questionId
        self.subjectId = subjectId
        self.subjectType = subjectType
        self.value = value
    }
}

public enum ReviewableHITStatus {
    case reviewable
    case reviewing
    case sdkUnknown(String)
}

extension ReviewableHITStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReviewableHITStatus] {
        return [
            .reviewable,
            .reviewing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .reviewable: return "Reviewable"
        case .reviewing: return "Reviewing"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReviewableHITStatus(rawValue: rawValue) ?? ReviewableHITStatus.sdkUnknown(rawValue)
    }
}

public struct SendBonusInputBodyMiddleware: Middleware {
    public let id: String = "SendBonusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendBonusInput>,
                  next: H) -> Swift.Result<OperationOutput<SendBonusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendBonusInput>
    public typealias MOutput = OperationOutput<SendBonusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendBonusOutputError>
}

extension SendBonusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendBonusInput(assignmentId: \(String(describing: assignmentId)), bonusAmount: \(String(describing: bonusAmount)), reason: \(String(describing: reason)), uniqueRequestToken: \(String(describing: uniqueRequestToken)), workerId: \(String(describing: workerId)))"}
}

extension SendBonusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case bonusAmount = "BonusAmount"
        case reason = "Reason"
        case uniqueRequestToken = "UniqueRequestToken"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let bonusAmount = bonusAmount {
            try encodeContainer.encode(bonusAmount, forKey: .bonusAmount)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let uniqueRequestToken = uniqueRequestToken {
            try encodeContainer.encode(uniqueRequestToken, forKey: .uniqueRequestToken)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }
}

public struct SendBonusInputHeadersMiddleware: Middleware {
    public let id: String = "SendBonusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendBonusInput>,
                  next: H) -> Swift.Result<OperationOutput<SendBonusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendBonusInput>
    public typealias MOutput = OperationOutput<SendBonusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendBonusOutputError>
}

public struct SendBonusInputQueryItemMiddleware: Middleware {
    public let id: String = "SendBonusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendBonusInput>,
                  next: H) -> Swift.Result<OperationOutput<SendBonusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendBonusInput>
    public typealias MOutput = OperationOutput<SendBonusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendBonusOutputError>
}

public struct SendBonusInput: Equatable {
    /// <p>The ID of the assignment for which this bonus is paid.</p>
    public let assignmentId: String?
    /// <p>
    ///             The Bonus amount is a US Dollar amount specified using a string (for example, "5" represents $5.00 USD and
    ///             "101.42" represents $101.42 USD). Do not include currency symbols or currency codes.
    ///         </p>
    public let bonusAmount: String?
    /// <p>A message that explains the reason for the bonus payment. The
    ///             Worker receiving the bonus can see this message.</p>
    public let reason: String?
    /// <p>A unique identifier for this request, which allows you to
    ///             retry the call on error without granting multiple bonuses. This is
    ///             useful in cases such as network timeouts where it is unclear whether
    ///             or not the call succeeded on the server. If the bonus already exists
    ///             in the system from a previous call using the same UniqueRequestToken,
    ///             subsequent calls will return an error with a message containing the
    ///             request ID.</p>
    public let uniqueRequestToken: String?
    /// <p>The ID of the Worker being paid the bonus.</p>
    public let workerId: String?

    public init (
        assignmentId: String? = nil,
        bonusAmount: String? = nil,
        reason: String? = nil,
        uniqueRequestToken: String? = nil,
        workerId: String? = nil
    )
    {
        self.assignmentId = assignmentId
        self.bonusAmount = bonusAmount
        self.reason = reason
        self.uniqueRequestToken = uniqueRequestToken
        self.workerId = workerId
    }
}

struct SendBonusInputBody: Equatable {
    public let workerId: String?
    public let bonusAmount: String?
    public let assignmentId: String?
    public let reason: String?
    public let uniqueRequestToken: String?
}

extension SendBonusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case bonusAmount = "BonusAmount"
        case reason = "Reason"
        case uniqueRequestToken = "UniqueRequestToken"
        case workerId = "WorkerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let bonusAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bonusAmount)
        bonusAmount = bonusAmountDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
        let uniqueRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uniqueRequestToken)
        uniqueRequestToken = uniqueRequestTokenDecoded
    }
}

extension SendBonusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendBonusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendBonusOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendBonusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendBonusOutputResponse()"}
}

extension SendBonusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SendBonusOutputResponse: Equatable {

    public init() {}
}

struct SendBonusOutputResponseBody: Equatable {
}

extension SendBonusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SendTestEventNotificationInputBodyMiddleware: Middleware {
    public let id: String = "SendTestEventNotificationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTestEventNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTestEventNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTestEventNotificationInput>
    public typealias MOutput = OperationOutput<SendTestEventNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTestEventNotificationOutputError>
}

extension SendTestEventNotificationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendTestEventNotificationInput(notification: \(String(describing: notification)), testEventType: \(String(describing: testEventType)))"}
}

extension SendTestEventNotificationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case notification = "Notification"
        case testEventType = "TestEventType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let testEventType = testEventType {
            try encodeContainer.encode(testEventType.rawValue, forKey: .testEventType)
        }
    }
}

public struct SendTestEventNotificationInputHeadersMiddleware: Middleware {
    public let id: String = "SendTestEventNotificationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTestEventNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTestEventNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTestEventNotificationInput>
    public typealias MOutput = OperationOutput<SendTestEventNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTestEventNotificationOutputError>
}

public struct SendTestEventNotificationInputQueryItemMiddleware: Middleware {
    public let id: String = "SendTestEventNotificationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTestEventNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTestEventNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTestEventNotificationInput>
    public typealias MOutput = OperationOutput<SendTestEventNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTestEventNotificationOutputError>
}

public struct SendTestEventNotificationInput: Equatable {
    /// <p>
    ///             The notification specification to test. This value is identical to the value
    ///             you would provide to the UpdateNotificationSettings operation when you establish
    ///             the notification specification for a HIT type.
    ///         </p>
    public let notification: NotificationSpecification?
    /// <p>
    ///             The event to simulate to test the notification specification.
    ///             This event is included in the test message even if the notification specification
    ///             does not include the event type.
    ///             The notification specification does not filter out the test event.
    ///         </p>
    public let testEventType: EventType?

    public init (
        notification: NotificationSpecification? = nil,
        testEventType: EventType? = nil
    )
    {
        self.notification = notification
        self.testEventType = testEventType
    }
}

struct SendTestEventNotificationInputBody: Equatable {
    public let notification: NotificationSpecification?
    public let testEventType: EventType?
}

extension SendTestEventNotificationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case notification = "Notification"
        case testEventType = "TestEventType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationDecoded = try containerValues.decodeIfPresent(NotificationSpecification.self, forKey: .notification)
        notification = notificationDecoded
        let testEventTypeDecoded = try containerValues.decodeIfPresent(EventType.self, forKey: .testEventType)
        testEventType = testEventTypeDecoded
    }
}

extension SendTestEventNotificationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendTestEventNotificationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendTestEventNotificationOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendTestEventNotificationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendTestEventNotificationOutputResponse()"}
}

extension SendTestEventNotificationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SendTestEventNotificationOutputResponse: Equatable {

    public init() {}
}

struct SendTestEventNotificationOutputResponseBody: Equatable {
}

extension SendTestEventNotificationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ServiceFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceFault(message: \(String(describing: message)), turkErrorCode: \(String(describing: turkErrorCode)))"}
}

extension ServiceFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.turkErrorCode = output.turkErrorCode
        } else {
            self.message = nil
            self.turkErrorCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Mechanical Turk is temporarily unable to process your request. Try your call again.</p>
public struct ServiceFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var turkErrorCode: String?

    public init (
        message: String? = nil,
        turkErrorCode: String? = nil
    )
    {
        self.message = message
        self.turkErrorCode = turkErrorCode
    }
}

struct ServiceFaultBody: Equatable {
    public let message: String?
    public let turkErrorCode: String?
}

extension ServiceFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case turkErrorCode = "TurkErrorCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let turkErrorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .turkErrorCode)
        turkErrorCode = turkErrorCodeDecoded
    }
}

public struct UpdateExpirationForHITInputBodyMiddleware: Middleware {
    public let id: String = "UpdateExpirationForHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateExpirationForHITInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateExpirationForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateExpirationForHITInput>
    public typealias MOutput = OperationOutput<UpdateExpirationForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateExpirationForHITOutputError>
}

extension UpdateExpirationForHITInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateExpirationForHITInput(expireAt: \(String(describing: expireAt)), hITId: \(String(describing: hITId)))"}
}

extension UpdateExpirationForHITInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expireAt = "ExpireAt"
        case hITId = "HITId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expireAt = expireAt {
            try encodeContainer.encode(expireAt.timeIntervalSince1970, forKey: .expireAt)
        }
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
    }
}

public struct UpdateExpirationForHITInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateExpirationForHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateExpirationForHITInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateExpirationForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateExpirationForHITInput>
    public typealias MOutput = OperationOutput<UpdateExpirationForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateExpirationForHITOutputError>
}

public struct UpdateExpirationForHITInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateExpirationForHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateExpirationForHITInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateExpirationForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateExpirationForHITInput>
    public typealias MOutput = OperationOutput<UpdateExpirationForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateExpirationForHITOutputError>
}

public struct UpdateExpirationForHITInput: Equatable {
    /// <p>
    ///             The date and time at which you want the HIT to expire
    ///         </p>
    public let expireAt: Date?
    /// <p>
    ///             The HIT to update.
    ///         </p>
    public let hITId: String?

    public init (
        expireAt: Date? = nil,
        hITId: String? = nil
    )
    {
        self.expireAt = expireAt
        self.hITId = hITId
    }
}

struct UpdateExpirationForHITInputBody: Equatable {
    public let hITId: String?
    public let expireAt: Date?
}

extension UpdateExpirationForHITInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expireAt = "ExpireAt"
        case hITId = "HITId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let expireAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expireAt)
        expireAt = expireAtDecoded
    }
}

extension UpdateExpirationForHITOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateExpirationForHITOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateExpirationForHITOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateExpirationForHITOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateExpirationForHITOutputResponse()"}
}

extension UpdateExpirationForHITOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateExpirationForHITOutputResponse: Equatable {

    public init() {}
}

struct UpdateExpirationForHITOutputResponseBody: Equatable {
}

extension UpdateExpirationForHITOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateHITReviewStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdateHITReviewStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateHITReviewStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateHITReviewStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateHITReviewStatusInput>
    public typealias MOutput = OperationOutput<UpdateHITReviewStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateHITReviewStatusOutputError>
}

extension UpdateHITReviewStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateHITReviewStatusInput(hITId: \(String(describing: hITId)), revert: \(String(describing: revert)))"}
}

extension UpdateHITReviewStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hITId = "HITId"
        case revert = "Revert"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let revert = revert {
            try encodeContainer.encode(revert, forKey: .revert)
        }
    }
}

public struct UpdateHITReviewStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateHITReviewStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateHITReviewStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateHITReviewStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateHITReviewStatusInput>
    public typealias MOutput = OperationOutput<UpdateHITReviewStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateHITReviewStatusOutputError>
}

public struct UpdateHITReviewStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateHITReviewStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateHITReviewStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateHITReviewStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateHITReviewStatusInput>
    public typealias MOutput = OperationOutput<UpdateHITReviewStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateHITReviewStatusOutputError>
}

public struct UpdateHITReviewStatusInput: Equatable {
    /// <p>
    ///             The ID of the HIT to update.
    ///         </p>
    public let hITId: String?
    /// <p>
    ///             Specifies how to update the HIT status. Default is <code>False</code>.
    ///         </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     Setting this to false will only transition a HIT from <code>Reviewable</code> to <code>Reviewing</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     Setting this to true will only transition a HIT from <code>Reviewing</code> to <code>Reviewable</code>
    ///                 </p>
    ///             </li>
    ///          </ul>
    public let revert: Bool?

    public init (
        hITId: String? = nil,
        revert: Bool? = nil
    )
    {
        self.hITId = hITId
        self.revert = revert
    }
}

struct UpdateHITReviewStatusInputBody: Equatable {
    public let hITId: String?
    public let revert: Bool?
}

extension UpdateHITReviewStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hITId = "HITId"
        case revert = "Revert"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let revertDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .revert)
        revert = revertDecoded
    }
}

extension UpdateHITReviewStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateHITReviewStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateHITReviewStatusOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateHITReviewStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateHITReviewStatusOutputResponse()"}
}

extension UpdateHITReviewStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateHITReviewStatusOutputResponse: Equatable {

    public init() {}
}

struct UpdateHITReviewStatusOutputResponseBody: Equatable {
}

extension UpdateHITReviewStatusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateHITTypeOfHITInputBodyMiddleware: Middleware {
    public let id: String = "UpdateHITTypeOfHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateHITTypeOfHITInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateHITTypeOfHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateHITTypeOfHITInput>
    public typealias MOutput = OperationOutput<UpdateHITTypeOfHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateHITTypeOfHITOutputError>
}

extension UpdateHITTypeOfHITInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateHITTypeOfHITInput(hITId: \(String(describing: hITId)), hITTypeId: \(String(describing: hITTypeId)))"}
}

extension UpdateHITTypeOfHITInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hITId = "HITId"
        case hITTypeId = "HITTypeId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let hITTypeId = hITTypeId {
            try encodeContainer.encode(hITTypeId, forKey: .hITTypeId)
        }
    }
}

public struct UpdateHITTypeOfHITInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateHITTypeOfHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateHITTypeOfHITInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateHITTypeOfHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateHITTypeOfHITInput>
    public typealias MOutput = OperationOutput<UpdateHITTypeOfHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateHITTypeOfHITOutputError>
}

public struct UpdateHITTypeOfHITInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateHITTypeOfHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateHITTypeOfHITInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateHITTypeOfHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateHITTypeOfHITInput>
    public typealias MOutput = OperationOutput<UpdateHITTypeOfHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateHITTypeOfHITOutputError>
}

public struct UpdateHITTypeOfHITInput: Equatable {
    /// <p>The HIT to update.</p>
    public let hITId: String?
    /// <p>The ID of the new HIT type.</p>
    public let hITTypeId: String?

    public init (
        hITId: String? = nil,
        hITTypeId: String? = nil
    )
    {
        self.hITId = hITId
        self.hITTypeId = hITTypeId
    }
}

struct UpdateHITTypeOfHITInputBody: Equatable {
    public let hITId: String?
    public let hITTypeId: String?
}

extension UpdateHITTypeOfHITInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hITId = "HITId"
        case hITTypeId = "HITTypeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let hITTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITTypeId)
        hITTypeId = hITTypeIdDecoded
    }
}

extension UpdateHITTypeOfHITOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateHITTypeOfHITOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateHITTypeOfHITOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateHITTypeOfHITOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateHITTypeOfHITOutputResponse()"}
}

extension UpdateHITTypeOfHITOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateHITTypeOfHITOutputResponse: Equatable {

    public init() {}
}

struct UpdateHITTypeOfHITOutputResponseBody: Equatable {
}

extension UpdateHITTypeOfHITOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateNotificationSettingsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateNotificationSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNotificationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNotificationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNotificationSettingsInput>
    public typealias MOutput = OperationOutput<UpdateNotificationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNotificationSettingsOutputError>
}

extension UpdateNotificationSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNotificationSettingsInput(active: \(String(describing: active)), hITTypeId: \(String(describing: hITTypeId)), notification: \(String(describing: notification)))"}
}

extension UpdateNotificationSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case active = "Active"
        case hITTypeId = "HITTypeId"
        case notification = "Notification"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let hITTypeId = hITTypeId {
            try encodeContainer.encode(hITTypeId, forKey: .hITTypeId)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
    }
}

public struct UpdateNotificationSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateNotificationSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNotificationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNotificationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNotificationSettingsInput>
    public typealias MOutput = OperationOutput<UpdateNotificationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNotificationSettingsOutputError>
}

public struct UpdateNotificationSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateNotificationSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNotificationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNotificationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNotificationSettingsInput>
    public typealias MOutput = OperationOutput<UpdateNotificationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNotificationSettingsOutputError>
}

public struct UpdateNotificationSettingsInput: Equatable {
    /// <p>
    ///             Specifies whether notifications are sent for HITs of this HIT type,
    ///             according to the notification specification.
    ///             You must specify either the Notification parameter or the Active parameter
    ///             for the call to UpdateNotificationSettings to succeed.
    ///         </p>
    public let active: Bool?
    /// <p>
    ///             The ID of the HIT type whose notification specification is being updated.
    ///         </p>
    public let hITTypeId: String?
    /// <p>
    ///             The notification specification for the HIT type.
    ///         </p>
    public let notification: NotificationSpecification?

    public init (
        active: Bool? = nil,
        hITTypeId: String? = nil,
        notification: NotificationSpecification? = nil
    )
    {
        self.active = active
        self.hITTypeId = hITTypeId
        self.notification = notification
    }
}

struct UpdateNotificationSettingsInputBody: Equatable {
    public let hITTypeId: String?
    public let notification: NotificationSpecification?
    public let active: Bool?
}

extension UpdateNotificationSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case active = "Active"
        case hITTypeId = "HITTypeId"
        case notification = "Notification"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hITTypeId)
        hITTypeId = hITTypeIdDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(NotificationSpecification.self, forKey: .notification)
        notification = notificationDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .active)
        active = activeDecoded
    }
}

extension UpdateNotificationSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNotificationSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNotificationSettingsOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNotificationSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNotificationSettingsOutputResponse()"}
}

extension UpdateNotificationSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNotificationSettingsOutputResponse: Equatable {

    public init() {}
}

struct UpdateNotificationSettingsOutputResponseBody: Equatable {
}

extension UpdateNotificationSettingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateQualificationTypeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateQualificationTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQualificationTypeInput>
    public typealias MOutput = OperationOutput<UpdateQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQualificationTypeOutputError>
}

extension UpdateQualificationTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQualificationTypeInput(answerKey: \(String(describing: answerKey)), autoGranted: \(String(describing: autoGranted)), autoGrantedValue: \(String(describing: autoGrantedValue)), description: \(String(describing: description)), qualificationTypeId: \(String(describing: qualificationTypeId)), qualificationTypeStatus: \(String(describing: qualificationTypeStatus)), retryDelayInSeconds: \(String(describing: retryDelayInSeconds)), test: \(String(describing: test)), testDurationInSeconds: \(String(describing: testDurationInSeconds)))"}
}

extension UpdateQualificationTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case answerKey = "AnswerKey"
        case autoGranted = "AutoGranted"
        case autoGrantedValue = "AutoGrantedValue"
        case description = "Description"
        case qualificationTypeId = "QualificationTypeId"
        case qualificationTypeStatus = "QualificationTypeStatus"
        case retryDelayInSeconds = "RetryDelayInSeconds"
        case test = "Test"
        case testDurationInSeconds = "TestDurationInSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answerKey = answerKey {
            try encodeContainer.encode(answerKey, forKey: .answerKey)
        }
        if let autoGranted = autoGranted {
            try encodeContainer.encode(autoGranted, forKey: .autoGranted)
        }
        if let autoGrantedValue = autoGrantedValue {
            try encodeContainer.encode(autoGrantedValue, forKey: .autoGrantedValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let qualificationTypeStatus = qualificationTypeStatus {
            try encodeContainer.encode(qualificationTypeStatus.rawValue, forKey: .qualificationTypeStatus)
        }
        if let retryDelayInSeconds = retryDelayInSeconds {
            try encodeContainer.encode(retryDelayInSeconds, forKey: .retryDelayInSeconds)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
        if let testDurationInSeconds = testDurationInSeconds {
            try encodeContainer.encode(testDurationInSeconds, forKey: .testDurationInSeconds)
        }
    }
}

public struct UpdateQualificationTypeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateQualificationTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQualificationTypeInput>
    public typealias MOutput = OperationOutput<UpdateQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQualificationTypeOutputError>
}

public struct UpdateQualificationTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateQualificationTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQualificationTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQualificationTypeInput>
    public typealias MOutput = OperationOutput<UpdateQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQualificationTypeOutputError>
}

public struct UpdateQualificationTypeInput: Equatable {
    /// <p>The answers to the Qualification test specified in the Test parameter, in the form of an AnswerKey data structure.</p>
    public let answerKey: String?
    /// <p>Specifies whether requests for the Qualification type are granted immediately, without prompting the Worker with a Qualification test.</p>
    ///         <p>Constraints: If the Test parameter is specified, this parameter cannot be true.</p>
    public let autoGranted: Bool?
    /// <p>The Qualification value to use for automatically granted Qualifications. This parameter is used only if the AutoGranted parameter is true.</p>
    public let autoGrantedValue: Int?
    /// <p>The new description of the Qualification type.</p>
    public let description: String?
    /// <p>The ID of the Qualification type to update.</p>
    public let qualificationTypeId: String?
    /// <p>The new status of the Qualification type - Active | Inactive</p>
    public let qualificationTypeStatus: QualificationTypeStatus?
    /// <p>The amount of time, in seconds, that Workers must wait
    ///             after requesting a Qualification of the specified Qualification type
    ///             before they can retry the Qualification request. It is not possible to
    ///             disable retries for a Qualification type after it has been created with
    ///             retries enabled. If you want to disable retries, you must dispose of
    ///             the existing retry-enabled Qualification type using
    ///             DisposeQualificationType and then create a new Qualification type with
    ///             retries disabled using CreateQualificationType.</p>
    public let retryDelayInSeconds: Int?
    /// <p>The questions for the Qualification test a Worker must answer correctly to obtain a Qualification of this type. If this parameter is specified, <code>TestDurationInSeconds</code> must also be specified.</p>
    ///         <p>Constraints: Must not be longer than 65535 bytes. Must be a QuestionForm data structure. This parameter cannot be specified if AutoGranted is true.</p>
    ///         <p>Constraints: None. If not specified, the Worker may request the Qualification without answering any questions.</p>
    public let test: String?
    /// <p>The number of seconds the Worker has to complete the Qualification test, starting from the time the Worker requests the Qualification.</p>
    public let testDurationInSeconds: Int?

    public init (
        answerKey: String? = nil,
        autoGranted: Bool? = nil,
        autoGrantedValue: Int? = nil,
        description: String? = nil,
        qualificationTypeId: String? = nil,
        qualificationTypeStatus: QualificationTypeStatus? = nil,
        retryDelayInSeconds: Int? = nil,
        test: String? = nil,
        testDurationInSeconds: Int? = nil
    )
    {
        self.answerKey = answerKey
        self.autoGranted = autoGranted
        self.autoGrantedValue = autoGrantedValue
        self.description = description
        self.qualificationTypeId = qualificationTypeId
        self.qualificationTypeStatus = qualificationTypeStatus
        self.retryDelayInSeconds = retryDelayInSeconds
        self.test = test
        self.testDurationInSeconds = testDurationInSeconds
    }
}

struct UpdateQualificationTypeInputBody: Equatable {
    public let qualificationTypeId: String?
    public let description: String?
    public let qualificationTypeStatus: QualificationTypeStatus?
    public let test: String?
    public let answerKey: String?
    public let testDurationInSeconds: Int?
    public let retryDelayInSeconds: Int?
    public let autoGranted: Bool?
    public let autoGrantedValue: Int?
}

extension UpdateQualificationTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case answerKey = "AnswerKey"
        case autoGranted = "AutoGranted"
        case autoGrantedValue = "AutoGrantedValue"
        case description = "Description"
        case qualificationTypeId = "QualificationTypeId"
        case qualificationTypeStatus = "QualificationTypeStatus"
        case retryDelayInSeconds = "RetryDelayInSeconds"
        case test = "Test"
        case testDurationInSeconds = "TestDurationInSeconds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let qualificationTypeStatusDecoded = try containerValues.decodeIfPresent(QualificationTypeStatus.self, forKey: .qualificationTypeStatus)
        qualificationTypeStatus = qualificationTypeStatusDecoded
        let testDecoded = try containerValues.decodeIfPresent(String.self, forKey: .test)
        test = testDecoded
        let answerKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .answerKey)
        answerKey = answerKeyDecoded
        let testDurationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .testDurationInSeconds)
        testDurationInSeconds = testDurationInSecondsDecoded
        let retryDelayInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retryDelayInSeconds)
        retryDelayInSeconds = retryDelayInSecondsDecoded
        let autoGrantedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoGranted)
        autoGranted = autoGrantedDecoded
        let autoGrantedValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .autoGrantedValue)
        autoGrantedValue = autoGrantedValueDecoded
    }
}

extension UpdateQualificationTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQualificationTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQualificationTypeOutputError: Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQualificationTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQualificationTypeOutputResponse(qualificationType: \(String(describing: qualificationType)))"}
}

extension UpdateQualificationTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateQualificationTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.qualificationType = output.qualificationType
        } else {
            self.qualificationType = nil
        }
    }
}

public struct UpdateQualificationTypeOutputResponse: Equatable {
    /// <p> Contains a QualificationType data structure.</p>
    public let qualificationType: QualificationType?

    public init (
        qualificationType: QualificationType? = nil
    )
    {
        self.qualificationType = qualificationType
    }
}

struct UpdateQualificationTypeOutputResponseBody: Equatable {
    public let qualificationType: QualificationType?
}

extension UpdateQualificationTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case qualificationType = "QualificationType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeDecoded = try containerValues.decodeIfPresent(QualificationType.self, forKey: .qualificationType)
        qualificationType = qualificationTypeDecoded
    }
}

extension WorkerBlock: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WorkerBlock: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkerBlock(reason: \(String(describing: reason)), workerId: \(String(describing: workerId)))"}
}

/// <p> The WorkerBlock data structure represents a Worker who has
///             been blocked. It has two elements: the WorkerId and the Reason for
///             the block.
///         </p>
public struct WorkerBlock: Equatable {
    /// <p> A message explaining the reason the Worker was blocked.
    ///         </p>
    public let reason: String?
    /// <p> The ID of the Worker who accepted the HIT.</p>
    public let workerId: String?

    public init (
        reason: String? = nil,
        workerId: String? = nil
    )
    {
        self.reason = reason
        self.workerId = workerId
    }
}
