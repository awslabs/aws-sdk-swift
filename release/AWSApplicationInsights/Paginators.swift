// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListApplicationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListApplicationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListApplicationsOutputResponse`
extension ApplicationInsightsClient {
    public func listApplicationsPaginated(input: ListApplicationsInput) -> ClientRuntime.PaginatorSequence<ListApplicationsInput, ListApplicationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListApplicationsInput, ListApplicationsOutputResponse>(input: input, inputKey: \ListApplicationsInput.nextToken, outputKey: \ListApplicationsOutputResponse.nextToken, paginationFunction: self.listApplications(input:))
    }
}

extension ListApplicationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApplicationsInput {
        return ListApplicationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListComponentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListComponentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListComponentsOutputResponse`
extension ApplicationInsightsClient {
    public func listComponentsPaginated(input: ListComponentsInput) -> ClientRuntime.PaginatorSequence<ListComponentsInput, ListComponentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListComponentsInput, ListComponentsOutputResponse>(input: input, inputKey: \ListComponentsInput.nextToken, outputKey: \ListComponentsOutputResponse.nextToken, paginationFunction: self.listComponents(input:))
    }
}

extension ListComponentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComponentsInput {
        return ListComponentsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceGroupName: self.resourceGroupName
        )}
}

/// Paginate over `[ListConfigurationHistoryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListConfigurationHistoryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListConfigurationHistoryOutputResponse`
extension ApplicationInsightsClient {
    public func listConfigurationHistoryPaginated(input: ListConfigurationHistoryInput) -> ClientRuntime.PaginatorSequence<ListConfigurationHistoryInput, ListConfigurationHistoryOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListConfigurationHistoryInput, ListConfigurationHistoryOutputResponse>(input: input, inputKey: \ListConfigurationHistoryInput.nextToken, outputKey: \ListConfigurationHistoryOutputResponse.nextToken, paginationFunction: self.listConfigurationHistory(input:))
    }
}

extension ListConfigurationHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListConfigurationHistoryInput {
        return ListConfigurationHistoryInput(
            endTime: self.endTime,
            eventStatus: self.eventStatus,
            maxResults: self.maxResults,
            nextToken: token,
            resourceGroupName: self.resourceGroupName,
            startTime: self.startTime
        )}
}

/// Paginate over `[ListLogPatternsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListLogPatternsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListLogPatternsOutputResponse`
extension ApplicationInsightsClient {
    public func listLogPatternsPaginated(input: ListLogPatternsInput) -> ClientRuntime.PaginatorSequence<ListLogPatternsInput, ListLogPatternsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLogPatternsInput, ListLogPatternsOutputResponse>(input: input, inputKey: \ListLogPatternsInput.nextToken, outputKey: \ListLogPatternsOutputResponse.nextToken, paginationFunction: self.listLogPatterns(input:))
    }
}

extension ListLogPatternsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLogPatternsInput {
        return ListLogPatternsInput(
            maxResults: self.maxResults,
            nextToken: token,
            patternSetName: self.patternSetName,
            resourceGroupName: self.resourceGroupName
        )}
}

/// Paginate over `[ListLogPatternSetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListLogPatternSetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListLogPatternSetsOutputResponse`
extension ApplicationInsightsClient {
    public func listLogPatternSetsPaginated(input: ListLogPatternSetsInput) -> ClientRuntime.PaginatorSequence<ListLogPatternSetsInput, ListLogPatternSetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLogPatternSetsInput, ListLogPatternSetsOutputResponse>(input: input, inputKey: \ListLogPatternSetsInput.nextToken, outputKey: \ListLogPatternSetsOutputResponse.nextToken, paginationFunction: self.listLogPatternSets(input:))
    }
}

extension ListLogPatternSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLogPatternSetsInput {
        return ListLogPatternSetsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceGroupName: self.resourceGroupName
        )}
}

/// Paginate over `[ListProblemsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListProblemsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListProblemsOutputResponse`
extension ApplicationInsightsClient {
    public func listProblemsPaginated(input: ListProblemsInput) -> ClientRuntime.PaginatorSequence<ListProblemsInput, ListProblemsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListProblemsInput, ListProblemsOutputResponse>(input: input, inputKey: \ListProblemsInput.nextToken, outputKey: \ListProblemsOutputResponse.nextToken, paginationFunction: self.listProblems(input:))
    }
}

extension ListProblemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProblemsInput {
        return ListProblemsInput(
            componentName: self.componentName,
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            resourceGroupName: self.resourceGroupName,
            startTime: self.startTime
        )}
}
