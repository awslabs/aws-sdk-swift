// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[DescribeAggregateComplianceByConfigRulesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAggregateComplianceByConfigRulesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAggregateComplianceByConfigRulesOutputResponse`
extension ConfigClient {
    public func describeAggregateComplianceByConfigRulesPaginated(input: DescribeAggregateComplianceByConfigRulesInput) -> ClientRuntime.PaginatorSequence<DescribeAggregateComplianceByConfigRulesInput, DescribeAggregateComplianceByConfigRulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAggregateComplianceByConfigRulesInput, DescribeAggregateComplianceByConfigRulesOutputResponse>(input: input, inputKey: \DescribeAggregateComplianceByConfigRulesInput.nextToken, outputKey: \DescribeAggregateComplianceByConfigRulesOutputResponse.nextToken, paginationFunction: self.describeAggregateComplianceByConfigRules(input:))
    }
}

extension DescribeAggregateComplianceByConfigRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAggregateComplianceByConfigRulesInput {
        return DescribeAggregateComplianceByConfigRulesInput(
            configurationAggregatorName: self.configurationAggregatorName,
            filters: self.filters,
            limit: self.limit,
            nextToken: token
        )}
}

/// Paginate over `[DescribeAggregateComplianceByConformancePacksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAggregateComplianceByConformancePacksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAggregateComplianceByConformancePacksOutputResponse`
extension ConfigClient {
    public func describeAggregateComplianceByConformancePacksPaginated(input: DescribeAggregateComplianceByConformancePacksInput) -> ClientRuntime.PaginatorSequence<DescribeAggregateComplianceByConformancePacksInput, DescribeAggregateComplianceByConformancePacksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAggregateComplianceByConformancePacksInput, DescribeAggregateComplianceByConformancePacksOutputResponse>(input: input, inputKey: \DescribeAggregateComplianceByConformancePacksInput.nextToken, outputKey: \DescribeAggregateComplianceByConformancePacksOutputResponse.nextToken, paginationFunction: self.describeAggregateComplianceByConformancePacks(input:))
    }
}

extension DescribeAggregateComplianceByConformancePacksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAggregateComplianceByConformancePacksInput {
        return DescribeAggregateComplianceByConformancePacksInput(
            configurationAggregatorName: self.configurationAggregatorName,
            filters: self.filters,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAggregateComplianceByConformancePacksPaginated`
/// to access the nested member `[ConfigClientTypes.AggregateComplianceByConformancePack]`
/// - Returns: `[ConfigClientTypes.AggregateComplianceByConformancePack]`
extension PaginatorSequence where Input == DescribeAggregateComplianceByConformancePacksInput, Output == DescribeAggregateComplianceByConformancePacksOutputResponse {
    public func aggregateComplianceByConformancePacks() async throws -> [ConfigClientTypes.AggregateComplianceByConformancePack] {
        return try await self.asyncCompactMap { item in item.aggregateComplianceByConformancePacks }
    }
}

/// Paginate over `[DescribeAggregationAuthorizationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAggregationAuthorizationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAggregationAuthorizationsOutputResponse`
extension ConfigClient {
    public func describeAggregationAuthorizationsPaginated(input: DescribeAggregationAuthorizationsInput) -> ClientRuntime.PaginatorSequence<DescribeAggregationAuthorizationsInput, DescribeAggregationAuthorizationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAggregationAuthorizationsInput, DescribeAggregationAuthorizationsOutputResponse>(input: input, inputKey: \DescribeAggregationAuthorizationsInput.nextToken, outputKey: \DescribeAggregationAuthorizationsOutputResponse.nextToken, paginationFunction: self.describeAggregationAuthorizations(input:))
    }
}

extension DescribeAggregationAuthorizationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAggregationAuthorizationsInput {
        return DescribeAggregationAuthorizationsInput(
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAggregationAuthorizationsPaginated`
/// to access the nested member `[ConfigClientTypes.AggregationAuthorization]`
/// - Returns: `[ConfigClientTypes.AggregationAuthorization]`
extension PaginatorSequence where Input == DescribeAggregationAuthorizationsInput, Output == DescribeAggregationAuthorizationsOutputResponse {
    public func aggregationAuthorizations() async throws -> [ConfigClientTypes.AggregationAuthorization] {
        return try await self.asyncCompactMap { item in item.aggregationAuthorizations }
    }
}

/// Paginate over `[DescribeComplianceByConfigRuleOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeComplianceByConfigRuleInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeComplianceByConfigRuleOutputResponse`
extension ConfigClient {
    public func describeComplianceByConfigRulePaginated(input: DescribeComplianceByConfigRuleInput) -> ClientRuntime.PaginatorSequence<DescribeComplianceByConfigRuleInput, DescribeComplianceByConfigRuleOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeComplianceByConfigRuleInput, DescribeComplianceByConfigRuleOutputResponse>(input: input, inputKey: \DescribeComplianceByConfigRuleInput.nextToken, outputKey: \DescribeComplianceByConfigRuleOutputResponse.nextToken, paginationFunction: self.describeComplianceByConfigRule(input:))
    }
}

extension DescribeComplianceByConfigRuleInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeComplianceByConfigRuleInput {
        return DescribeComplianceByConfigRuleInput(
            complianceTypes: self.complianceTypes,
            configRuleNames: self.configRuleNames,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeComplianceByConfigRulePaginated`
/// to access the nested member `[ConfigClientTypes.ComplianceByConfigRule]`
/// - Returns: `[ConfigClientTypes.ComplianceByConfigRule]`
extension PaginatorSequence where Input == DescribeComplianceByConfigRuleInput, Output == DescribeComplianceByConfigRuleOutputResponse {
    public func complianceByConfigRules() async throws -> [ConfigClientTypes.ComplianceByConfigRule] {
        return try await self.asyncCompactMap { item in item.complianceByConfigRules }
    }
}

/// Paginate over `[DescribeComplianceByResourceOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeComplianceByResourceInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeComplianceByResourceOutputResponse`
extension ConfigClient {
    public func describeComplianceByResourcePaginated(input: DescribeComplianceByResourceInput) -> ClientRuntime.PaginatorSequence<DescribeComplianceByResourceInput, DescribeComplianceByResourceOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeComplianceByResourceInput, DescribeComplianceByResourceOutputResponse>(input: input, inputKey: \DescribeComplianceByResourceInput.nextToken, outputKey: \DescribeComplianceByResourceOutputResponse.nextToken, paginationFunction: self.describeComplianceByResource(input:))
    }
}

extension DescribeComplianceByResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeComplianceByResourceInput {
        return DescribeComplianceByResourceInput(
            complianceTypes: self.complianceTypes,
            limit: self.limit,
            nextToken: token,
            resourceId: self.resourceId,
            resourceType: self.resourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeComplianceByResourcePaginated`
/// to access the nested member `[ConfigClientTypes.ComplianceByResource]`
/// - Returns: `[ConfigClientTypes.ComplianceByResource]`
extension PaginatorSequence where Input == DescribeComplianceByResourceInput, Output == DescribeComplianceByResourceOutputResponse {
    public func complianceByResources() async throws -> [ConfigClientTypes.ComplianceByResource] {
        return try await self.asyncCompactMap { item in item.complianceByResources }
    }
}

/// Paginate over `[DescribeConfigRuleEvaluationStatusOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeConfigRuleEvaluationStatusInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeConfigRuleEvaluationStatusOutputResponse`
extension ConfigClient {
    public func describeConfigRuleEvaluationStatusPaginated(input: DescribeConfigRuleEvaluationStatusInput) -> ClientRuntime.PaginatorSequence<DescribeConfigRuleEvaluationStatusInput, DescribeConfigRuleEvaluationStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeConfigRuleEvaluationStatusInput, DescribeConfigRuleEvaluationStatusOutputResponse>(input: input, inputKey: \DescribeConfigRuleEvaluationStatusInput.nextToken, outputKey: \DescribeConfigRuleEvaluationStatusOutputResponse.nextToken, paginationFunction: self.describeConfigRuleEvaluationStatus(input:))
    }
}

extension DescribeConfigRuleEvaluationStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeConfigRuleEvaluationStatusInput {
        return DescribeConfigRuleEvaluationStatusInput(
            configRuleNames: self.configRuleNames,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeConfigRuleEvaluationStatusPaginated`
/// to access the nested member `[ConfigClientTypes.ConfigRuleEvaluationStatus]`
/// - Returns: `[ConfigClientTypes.ConfigRuleEvaluationStatus]`
extension PaginatorSequence where Input == DescribeConfigRuleEvaluationStatusInput, Output == DescribeConfigRuleEvaluationStatusOutputResponse {
    public func configRulesEvaluationStatus() async throws -> [ConfigClientTypes.ConfigRuleEvaluationStatus] {
        return try await self.asyncCompactMap { item in item.configRulesEvaluationStatus }
    }
}

/// Paginate over `[DescribeConfigRulesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeConfigRulesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeConfigRulesOutputResponse`
extension ConfigClient {
    public func describeConfigRulesPaginated(input: DescribeConfigRulesInput) -> ClientRuntime.PaginatorSequence<DescribeConfigRulesInput, DescribeConfigRulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeConfigRulesInput, DescribeConfigRulesOutputResponse>(input: input, inputKey: \DescribeConfigRulesInput.nextToken, outputKey: \DescribeConfigRulesOutputResponse.nextToken, paginationFunction: self.describeConfigRules(input:))
    }
}

extension DescribeConfigRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeConfigRulesInput {
        return DescribeConfigRulesInput(
            configRuleNames: self.configRuleNames,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeConfigRulesPaginated`
/// to access the nested member `[ConfigClientTypes.ConfigRule]`
/// - Returns: `[ConfigClientTypes.ConfigRule]`
extension PaginatorSequence where Input == DescribeConfigRulesInput, Output == DescribeConfigRulesOutputResponse {
    public func configRules() async throws -> [ConfigClientTypes.ConfigRule] {
        return try await self.asyncCompactMap { item in item.configRules }
    }
}

/// Paginate over `[DescribeConfigurationAggregatorsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeConfigurationAggregatorsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeConfigurationAggregatorsOutputResponse`
extension ConfigClient {
    public func describeConfigurationAggregatorsPaginated(input: DescribeConfigurationAggregatorsInput) -> ClientRuntime.PaginatorSequence<DescribeConfigurationAggregatorsInput, DescribeConfigurationAggregatorsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeConfigurationAggregatorsInput, DescribeConfigurationAggregatorsOutputResponse>(input: input, inputKey: \DescribeConfigurationAggregatorsInput.nextToken, outputKey: \DescribeConfigurationAggregatorsOutputResponse.nextToken, paginationFunction: self.describeConfigurationAggregators(input:))
    }
}

extension DescribeConfigurationAggregatorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeConfigurationAggregatorsInput {
        return DescribeConfigurationAggregatorsInput(
            configurationAggregatorNames: self.configurationAggregatorNames,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeConfigurationAggregatorsPaginated`
/// to access the nested member `[ConfigClientTypes.ConfigurationAggregator]`
/// - Returns: `[ConfigClientTypes.ConfigurationAggregator]`
extension PaginatorSequence where Input == DescribeConfigurationAggregatorsInput, Output == DescribeConfigurationAggregatorsOutputResponse {
    public func configurationAggregators() async throws -> [ConfigClientTypes.ConfigurationAggregator] {
        return try await self.asyncCompactMap { item in item.configurationAggregators }
    }
}

/// Paginate over `[DescribeConfigurationAggregatorSourcesStatusOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeConfigurationAggregatorSourcesStatusInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeConfigurationAggregatorSourcesStatusOutputResponse`
extension ConfigClient {
    public func describeConfigurationAggregatorSourcesStatusPaginated(input: DescribeConfigurationAggregatorSourcesStatusInput) -> ClientRuntime.PaginatorSequence<DescribeConfigurationAggregatorSourcesStatusInput, DescribeConfigurationAggregatorSourcesStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeConfigurationAggregatorSourcesStatusInput, DescribeConfigurationAggregatorSourcesStatusOutputResponse>(input: input, inputKey: \DescribeConfigurationAggregatorSourcesStatusInput.nextToken, outputKey: \DescribeConfigurationAggregatorSourcesStatusOutputResponse.nextToken, paginationFunction: self.describeConfigurationAggregatorSourcesStatus(input:))
    }
}

extension DescribeConfigurationAggregatorSourcesStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeConfigurationAggregatorSourcesStatusInput {
        return DescribeConfigurationAggregatorSourcesStatusInput(
            configurationAggregatorName: self.configurationAggregatorName,
            limit: self.limit,
            nextToken: token,
            updateStatus: self.updateStatus
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeConfigurationAggregatorSourcesStatusPaginated`
/// to access the nested member `[ConfigClientTypes.AggregatedSourceStatus]`
/// - Returns: `[ConfigClientTypes.AggregatedSourceStatus]`
extension PaginatorSequence where Input == DescribeConfigurationAggregatorSourcesStatusInput, Output == DescribeConfigurationAggregatorSourcesStatusOutputResponse {
    public func aggregatedSourceStatusList() async throws -> [ConfigClientTypes.AggregatedSourceStatus] {
        return try await self.asyncCompactMap { item in item.aggregatedSourceStatusList }
    }
}

/// Paginate over `[DescribeConformancePackComplianceOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeConformancePackComplianceInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeConformancePackComplianceOutputResponse`
extension ConfigClient {
    public func describeConformancePackCompliancePaginated(input: DescribeConformancePackComplianceInput) -> ClientRuntime.PaginatorSequence<DescribeConformancePackComplianceInput, DescribeConformancePackComplianceOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeConformancePackComplianceInput, DescribeConformancePackComplianceOutputResponse>(input: input, inputKey: \DescribeConformancePackComplianceInput.nextToken, outputKey: \DescribeConformancePackComplianceOutputResponse.nextToken, paginationFunction: self.describeConformancePackCompliance(input:))
    }
}

extension DescribeConformancePackComplianceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeConformancePackComplianceInput {
        return DescribeConformancePackComplianceInput(
            conformancePackName: self.conformancePackName,
            filters: self.filters,
            limit: self.limit,
            nextToken: token
        )}
}

/// Paginate over `[DescribeConformancePacksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeConformancePacksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeConformancePacksOutputResponse`
extension ConfigClient {
    public func describeConformancePacksPaginated(input: DescribeConformancePacksInput) -> ClientRuntime.PaginatorSequence<DescribeConformancePacksInput, DescribeConformancePacksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeConformancePacksInput, DescribeConformancePacksOutputResponse>(input: input, inputKey: \DescribeConformancePacksInput.nextToken, outputKey: \DescribeConformancePacksOutputResponse.nextToken, paginationFunction: self.describeConformancePacks(input:))
    }
}

extension DescribeConformancePacksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeConformancePacksInput {
        return DescribeConformancePacksInput(
            conformancePackNames: self.conformancePackNames,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeConformancePacksPaginated`
/// to access the nested member `[ConfigClientTypes.ConformancePackDetail]`
/// - Returns: `[ConfigClientTypes.ConformancePackDetail]`
extension PaginatorSequence where Input == DescribeConformancePacksInput, Output == DescribeConformancePacksOutputResponse {
    public func conformancePackDetails() async throws -> [ConfigClientTypes.ConformancePackDetail] {
        return try await self.asyncCompactMap { item in item.conformancePackDetails }
    }
}

/// Paginate over `[DescribeConformancePackStatusOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeConformancePackStatusInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeConformancePackStatusOutputResponse`
extension ConfigClient {
    public func describeConformancePackStatusPaginated(input: DescribeConformancePackStatusInput) -> ClientRuntime.PaginatorSequence<DescribeConformancePackStatusInput, DescribeConformancePackStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeConformancePackStatusInput, DescribeConformancePackStatusOutputResponse>(input: input, inputKey: \DescribeConformancePackStatusInput.nextToken, outputKey: \DescribeConformancePackStatusOutputResponse.nextToken, paginationFunction: self.describeConformancePackStatus(input:))
    }
}

extension DescribeConformancePackStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeConformancePackStatusInput {
        return DescribeConformancePackStatusInput(
            conformancePackNames: self.conformancePackNames,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeConformancePackStatusPaginated`
/// to access the nested member `[ConfigClientTypes.ConformancePackStatusDetail]`
/// - Returns: `[ConfigClientTypes.ConformancePackStatusDetail]`
extension PaginatorSequence where Input == DescribeConformancePackStatusInput, Output == DescribeConformancePackStatusOutputResponse {
    public func conformancePackStatusDetails() async throws -> [ConfigClientTypes.ConformancePackStatusDetail] {
        return try await self.asyncCompactMap { item in item.conformancePackStatusDetails }
    }
}

/// Paginate over `[DescribeOrganizationConfigRulesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeOrganizationConfigRulesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeOrganizationConfigRulesOutputResponse`
extension ConfigClient {
    public func describeOrganizationConfigRulesPaginated(input: DescribeOrganizationConfigRulesInput) -> ClientRuntime.PaginatorSequence<DescribeOrganizationConfigRulesInput, DescribeOrganizationConfigRulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeOrganizationConfigRulesInput, DescribeOrganizationConfigRulesOutputResponse>(input: input, inputKey: \DescribeOrganizationConfigRulesInput.nextToken, outputKey: \DescribeOrganizationConfigRulesOutputResponse.nextToken, paginationFunction: self.describeOrganizationConfigRules(input:))
    }
}

extension DescribeOrganizationConfigRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOrganizationConfigRulesInput {
        return DescribeOrganizationConfigRulesInput(
            limit: self.limit,
            nextToken: token,
            organizationConfigRuleNames: self.organizationConfigRuleNames
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeOrganizationConfigRulesPaginated`
/// to access the nested member `[ConfigClientTypes.OrganizationConfigRule]`
/// - Returns: `[ConfigClientTypes.OrganizationConfigRule]`
extension PaginatorSequence where Input == DescribeOrganizationConfigRulesInput, Output == DescribeOrganizationConfigRulesOutputResponse {
    public func organizationConfigRules() async throws -> [ConfigClientTypes.OrganizationConfigRule] {
        return try await self.asyncCompactMap { item in item.organizationConfigRules }
    }
}

/// Paginate over `[DescribeOrganizationConfigRuleStatusesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeOrganizationConfigRuleStatusesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeOrganizationConfigRuleStatusesOutputResponse`
extension ConfigClient {
    public func describeOrganizationConfigRuleStatusesPaginated(input: DescribeOrganizationConfigRuleStatusesInput) -> ClientRuntime.PaginatorSequence<DescribeOrganizationConfigRuleStatusesInput, DescribeOrganizationConfigRuleStatusesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeOrganizationConfigRuleStatusesInput, DescribeOrganizationConfigRuleStatusesOutputResponse>(input: input, inputKey: \DescribeOrganizationConfigRuleStatusesInput.nextToken, outputKey: \DescribeOrganizationConfigRuleStatusesOutputResponse.nextToken, paginationFunction: self.describeOrganizationConfigRuleStatuses(input:))
    }
}

extension DescribeOrganizationConfigRuleStatusesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOrganizationConfigRuleStatusesInput {
        return DescribeOrganizationConfigRuleStatusesInput(
            limit: self.limit,
            nextToken: token,
            organizationConfigRuleNames: self.organizationConfigRuleNames
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeOrganizationConfigRuleStatusesPaginated`
/// to access the nested member `[ConfigClientTypes.OrganizationConfigRuleStatus]`
/// - Returns: `[ConfigClientTypes.OrganizationConfigRuleStatus]`
extension PaginatorSequence where Input == DescribeOrganizationConfigRuleStatusesInput, Output == DescribeOrganizationConfigRuleStatusesOutputResponse {
    public func organizationConfigRuleStatuses() async throws -> [ConfigClientTypes.OrganizationConfigRuleStatus] {
        return try await self.asyncCompactMap { item in item.organizationConfigRuleStatuses }
    }
}

/// Paginate over `[DescribeOrganizationConformancePacksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeOrganizationConformancePacksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeOrganizationConformancePacksOutputResponse`
extension ConfigClient {
    public func describeOrganizationConformancePacksPaginated(input: DescribeOrganizationConformancePacksInput) -> ClientRuntime.PaginatorSequence<DescribeOrganizationConformancePacksInput, DescribeOrganizationConformancePacksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeOrganizationConformancePacksInput, DescribeOrganizationConformancePacksOutputResponse>(input: input, inputKey: \DescribeOrganizationConformancePacksInput.nextToken, outputKey: \DescribeOrganizationConformancePacksOutputResponse.nextToken, paginationFunction: self.describeOrganizationConformancePacks(input:))
    }
}

extension DescribeOrganizationConformancePacksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOrganizationConformancePacksInput {
        return DescribeOrganizationConformancePacksInput(
            limit: self.limit,
            nextToken: token,
            organizationConformancePackNames: self.organizationConformancePackNames
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeOrganizationConformancePacksPaginated`
/// to access the nested member `[ConfigClientTypes.OrganizationConformancePack]`
/// - Returns: `[ConfigClientTypes.OrganizationConformancePack]`
extension PaginatorSequence where Input == DescribeOrganizationConformancePacksInput, Output == DescribeOrganizationConformancePacksOutputResponse {
    public func organizationConformancePacks() async throws -> [ConfigClientTypes.OrganizationConformancePack] {
        return try await self.asyncCompactMap { item in item.organizationConformancePacks }
    }
}

/// Paginate over `[DescribeOrganizationConformancePackStatusesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeOrganizationConformancePackStatusesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeOrganizationConformancePackStatusesOutputResponse`
extension ConfigClient {
    public func describeOrganizationConformancePackStatusesPaginated(input: DescribeOrganizationConformancePackStatusesInput) -> ClientRuntime.PaginatorSequence<DescribeOrganizationConformancePackStatusesInput, DescribeOrganizationConformancePackStatusesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeOrganizationConformancePackStatusesInput, DescribeOrganizationConformancePackStatusesOutputResponse>(input: input, inputKey: \DescribeOrganizationConformancePackStatusesInput.nextToken, outputKey: \DescribeOrganizationConformancePackStatusesOutputResponse.nextToken, paginationFunction: self.describeOrganizationConformancePackStatuses(input:))
    }
}

extension DescribeOrganizationConformancePackStatusesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOrganizationConformancePackStatusesInput {
        return DescribeOrganizationConformancePackStatusesInput(
            limit: self.limit,
            nextToken: token,
            organizationConformancePackNames: self.organizationConformancePackNames
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeOrganizationConformancePackStatusesPaginated`
/// to access the nested member `[ConfigClientTypes.OrganizationConformancePackStatus]`
/// - Returns: `[ConfigClientTypes.OrganizationConformancePackStatus]`
extension PaginatorSequence where Input == DescribeOrganizationConformancePackStatusesInput, Output == DescribeOrganizationConformancePackStatusesOutputResponse {
    public func organizationConformancePackStatuses() async throws -> [ConfigClientTypes.OrganizationConformancePackStatus] {
        return try await self.asyncCompactMap { item in item.organizationConformancePackStatuses }
    }
}

/// Paginate over `[DescribePendingAggregationRequestsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribePendingAggregationRequestsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribePendingAggregationRequestsOutputResponse`
extension ConfigClient {
    public func describePendingAggregationRequestsPaginated(input: DescribePendingAggregationRequestsInput) -> ClientRuntime.PaginatorSequence<DescribePendingAggregationRequestsInput, DescribePendingAggregationRequestsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribePendingAggregationRequestsInput, DescribePendingAggregationRequestsOutputResponse>(input: input, inputKey: \DescribePendingAggregationRequestsInput.nextToken, outputKey: \DescribePendingAggregationRequestsOutputResponse.nextToken, paginationFunction: self.describePendingAggregationRequests(input:))
    }
}

extension DescribePendingAggregationRequestsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePendingAggregationRequestsInput {
        return DescribePendingAggregationRequestsInput(
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describePendingAggregationRequestsPaginated`
/// to access the nested member `[ConfigClientTypes.PendingAggregationRequest]`
/// - Returns: `[ConfigClientTypes.PendingAggregationRequest]`
extension PaginatorSequence where Input == DescribePendingAggregationRequestsInput, Output == DescribePendingAggregationRequestsOutputResponse {
    public func pendingAggregationRequests() async throws -> [ConfigClientTypes.PendingAggregationRequest] {
        return try await self.asyncCompactMap { item in item.pendingAggregationRequests }
    }
}

/// Paginate over `[DescribeRemediationExceptionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeRemediationExceptionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeRemediationExceptionsOutputResponse`
extension ConfigClient {
    public func describeRemediationExceptionsPaginated(input: DescribeRemediationExceptionsInput) -> ClientRuntime.PaginatorSequence<DescribeRemediationExceptionsInput, DescribeRemediationExceptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeRemediationExceptionsInput, DescribeRemediationExceptionsOutputResponse>(input: input, inputKey: \DescribeRemediationExceptionsInput.nextToken, outputKey: \DescribeRemediationExceptionsOutputResponse.nextToken, paginationFunction: self.describeRemediationExceptions(input:))
    }
}

extension DescribeRemediationExceptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRemediationExceptionsInput {
        return DescribeRemediationExceptionsInput(
            configRuleName: self.configRuleName,
            limit: self.limit,
            nextToken: token,
            resourceKeys: self.resourceKeys
        )}
}

/// Paginate over `[DescribeRemediationExecutionStatusOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeRemediationExecutionStatusInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeRemediationExecutionStatusOutputResponse`
extension ConfigClient {
    public func describeRemediationExecutionStatusPaginated(input: DescribeRemediationExecutionStatusInput) -> ClientRuntime.PaginatorSequence<DescribeRemediationExecutionStatusInput, DescribeRemediationExecutionStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeRemediationExecutionStatusInput, DescribeRemediationExecutionStatusOutputResponse>(input: input, inputKey: \DescribeRemediationExecutionStatusInput.nextToken, outputKey: \DescribeRemediationExecutionStatusOutputResponse.nextToken, paginationFunction: self.describeRemediationExecutionStatus(input:))
    }
}

extension DescribeRemediationExecutionStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRemediationExecutionStatusInput {
        return DescribeRemediationExecutionStatusInput(
            configRuleName: self.configRuleName,
            limit: self.limit,
            nextToken: token,
            resourceKeys: self.resourceKeys
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeRemediationExecutionStatusPaginated`
/// to access the nested member `[ConfigClientTypes.RemediationExecutionStatus]`
/// - Returns: `[ConfigClientTypes.RemediationExecutionStatus]`
extension PaginatorSequence where Input == DescribeRemediationExecutionStatusInput, Output == DescribeRemediationExecutionStatusOutputResponse {
    public func remediationExecutionStatuses() async throws -> [ConfigClientTypes.RemediationExecutionStatus] {
        return try await self.asyncCompactMap { item in item.remediationExecutionStatuses }
    }
}

/// Paginate over `[DescribeRetentionConfigurationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeRetentionConfigurationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeRetentionConfigurationsOutputResponse`
extension ConfigClient {
    public func describeRetentionConfigurationsPaginated(input: DescribeRetentionConfigurationsInput) -> ClientRuntime.PaginatorSequence<DescribeRetentionConfigurationsInput, DescribeRetentionConfigurationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeRetentionConfigurationsInput, DescribeRetentionConfigurationsOutputResponse>(input: input, inputKey: \DescribeRetentionConfigurationsInput.nextToken, outputKey: \DescribeRetentionConfigurationsOutputResponse.nextToken, paginationFunction: self.describeRetentionConfigurations(input:))
    }
}

extension DescribeRetentionConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRetentionConfigurationsInput {
        return DescribeRetentionConfigurationsInput(
            nextToken: token,
            retentionConfigurationNames: self.retentionConfigurationNames
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeRetentionConfigurationsPaginated`
/// to access the nested member `[ConfigClientTypes.RetentionConfiguration]`
/// - Returns: `[ConfigClientTypes.RetentionConfiguration]`
extension PaginatorSequence where Input == DescribeRetentionConfigurationsInput, Output == DescribeRetentionConfigurationsOutputResponse {
    public func retentionConfigurations() async throws -> [ConfigClientTypes.RetentionConfiguration] {
        return try await self.asyncCompactMap { item in item.retentionConfigurations }
    }
}

/// Paginate over `[GetAggregateComplianceDetailsByConfigRuleOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetAggregateComplianceDetailsByConfigRuleInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetAggregateComplianceDetailsByConfigRuleOutputResponse`
extension ConfigClient {
    public func getAggregateComplianceDetailsByConfigRulePaginated(input: GetAggregateComplianceDetailsByConfigRuleInput) -> ClientRuntime.PaginatorSequence<GetAggregateComplianceDetailsByConfigRuleInput, GetAggregateComplianceDetailsByConfigRuleOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetAggregateComplianceDetailsByConfigRuleInput, GetAggregateComplianceDetailsByConfigRuleOutputResponse>(input: input, inputKey: \GetAggregateComplianceDetailsByConfigRuleInput.nextToken, outputKey: \GetAggregateComplianceDetailsByConfigRuleOutputResponse.nextToken, paginationFunction: self.getAggregateComplianceDetailsByConfigRule(input:))
    }
}

extension GetAggregateComplianceDetailsByConfigRuleInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetAggregateComplianceDetailsByConfigRuleInput {
        return GetAggregateComplianceDetailsByConfigRuleInput(
            accountId: self.accountId,
            awsRegion: self.awsRegion,
            complianceType: self.complianceType,
            configRuleName: self.configRuleName,
            configurationAggregatorName: self.configurationAggregatorName,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getAggregateComplianceDetailsByConfigRulePaginated`
/// to access the nested member `[ConfigClientTypes.AggregateEvaluationResult]`
/// - Returns: `[ConfigClientTypes.AggregateEvaluationResult]`
extension PaginatorSequence where Input == GetAggregateComplianceDetailsByConfigRuleInput, Output == GetAggregateComplianceDetailsByConfigRuleOutputResponse {
    public func aggregateEvaluationResults() async throws -> [ConfigClientTypes.AggregateEvaluationResult] {
        return try await self.asyncCompactMap { item in item.aggregateEvaluationResults }
    }
}

/// Paginate over `[GetAggregateConfigRuleComplianceSummaryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetAggregateConfigRuleComplianceSummaryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetAggregateConfigRuleComplianceSummaryOutputResponse`
extension ConfigClient {
    public func getAggregateConfigRuleComplianceSummaryPaginated(input: GetAggregateConfigRuleComplianceSummaryInput) -> ClientRuntime.PaginatorSequence<GetAggregateConfigRuleComplianceSummaryInput, GetAggregateConfigRuleComplianceSummaryOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetAggregateConfigRuleComplianceSummaryInput, GetAggregateConfigRuleComplianceSummaryOutputResponse>(input: input, inputKey: \GetAggregateConfigRuleComplianceSummaryInput.nextToken, outputKey: \GetAggregateConfigRuleComplianceSummaryOutputResponse.nextToken, paginationFunction: self.getAggregateConfigRuleComplianceSummary(input:))
    }
}

extension GetAggregateConfigRuleComplianceSummaryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetAggregateConfigRuleComplianceSummaryInput {
        return GetAggregateConfigRuleComplianceSummaryInput(
            configurationAggregatorName: self.configurationAggregatorName,
            filters: self.filters,
            groupByKey: self.groupByKey,
            limit: self.limit,
            nextToken: token
        )}
}

/// Paginate over `[GetAggregateConformancePackComplianceSummaryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetAggregateConformancePackComplianceSummaryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetAggregateConformancePackComplianceSummaryOutputResponse`
extension ConfigClient {
    public func getAggregateConformancePackComplianceSummaryPaginated(input: GetAggregateConformancePackComplianceSummaryInput) -> ClientRuntime.PaginatorSequence<GetAggregateConformancePackComplianceSummaryInput, GetAggregateConformancePackComplianceSummaryOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetAggregateConformancePackComplianceSummaryInput, GetAggregateConformancePackComplianceSummaryOutputResponse>(input: input, inputKey: \GetAggregateConformancePackComplianceSummaryInput.nextToken, outputKey: \GetAggregateConformancePackComplianceSummaryOutputResponse.nextToken, paginationFunction: self.getAggregateConformancePackComplianceSummary(input:))
    }
}

extension GetAggregateConformancePackComplianceSummaryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetAggregateConformancePackComplianceSummaryInput {
        return GetAggregateConformancePackComplianceSummaryInput(
            configurationAggregatorName: self.configurationAggregatorName,
            filters: self.filters,
            groupByKey: self.groupByKey,
            limit: self.limit,
            nextToken: token
        )}
}

/// Paginate over `[GetAggregateDiscoveredResourceCountsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetAggregateDiscoveredResourceCountsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetAggregateDiscoveredResourceCountsOutputResponse`
extension ConfigClient {
    public func getAggregateDiscoveredResourceCountsPaginated(input: GetAggregateDiscoveredResourceCountsInput) -> ClientRuntime.PaginatorSequence<GetAggregateDiscoveredResourceCountsInput, GetAggregateDiscoveredResourceCountsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetAggregateDiscoveredResourceCountsInput, GetAggregateDiscoveredResourceCountsOutputResponse>(input: input, inputKey: \GetAggregateDiscoveredResourceCountsInput.nextToken, outputKey: \GetAggregateDiscoveredResourceCountsOutputResponse.nextToken, paginationFunction: self.getAggregateDiscoveredResourceCounts(input:))
    }
}

extension GetAggregateDiscoveredResourceCountsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetAggregateDiscoveredResourceCountsInput {
        return GetAggregateDiscoveredResourceCountsInput(
            configurationAggregatorName: self.configurationAggregatorName,
            filters: self.filters,
            groupByKey: self.groupByKey,
            limit: self.limit,
            nextToken: token
        )}
}

/// Paginate over `[GetComplianceDetailsByConfigRuleOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetComplianceDetailsByConfigRuleInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetComplianceDetailsByConfigRuleOutputResponse`
extension ConfigClient {
    public func getComplianceDetailsByConfigRulePaginated(input: GetComplianceDetailsByConfigRuleInput) -> ClientRuntime.PaginatorSequence<GetComplianceDetailsByConfigRuleInput, GetComplianceDetailsByConfigRuleOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetComplianceDetailsByConfigRuleInput, GetComplianceDetailsByConfigRuleOutputResponse>(input: input, inputKey: \GetComplianceDetailsByConfigRuleInput.nextToken, outputKey: \GetComplianceDetailsByConfigRuleOutputResponse.nextToken, paginationFunction: self.getComplianceDetailsByConfigRule(input:))
    }
}

extension GetComplianceDetailsByConfigRuleInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetComplianceDetailsByConfigRuleInput {
        return GetComplianceDetailsByConfigRuleInput(
            complianceTypes: self.complianceTypes,
            configRuleName: self.configRuleName,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getComplianceDetailsByConfigRulePaginated`
/// to access the nested member `[ConfigClientTypes.EvaluationResult]`
/// - Returns: `[ConfigClientTypes.EvaluationResult]`
extension PaginatorSequence where Input == GetComplianceDetailsByConfigRuleInput, Output == GetComplianceDetailsByConfigRuleOutputResponse {
    public func evaluationResults() async throws -> [ConfigClientTypes.EvaluationResult] {
        return try await self.asyncCompactMap { item in item.evaluationResults }
    }
}

/// Paginate over `[GetComplianceDetailsByResourceOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetComplianceDetailsByResourceInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetComplianceDetailsByResourceOutputResponse`
extension ConfigClient {
    public func getComplianceDetailsByResourcePaginated(input: GetComplianceDetailsByResourceInput) -> ClientRuntime.PaginatorSequence<GetComplianceDetailsByResourceInput, GetComplianceDetailsByResourceOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetComplianceDetailsByResourceInput, GetComplianceDetailsByResourceOutputResponse>(input: input, inputKey: \GetComplianceDetailsByResourceInput.nextToken, outputKey: \GetComplianceDetailsByResourceOutputResponse.nextToken, paginationFunction: self.getComplianceDetailsByResource(input:))
    }
}

extension GetComplianceDetailsByResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetComplianceDetailsByResourceInput {
        return GetComplianceDetailsByResourceInput(
            complianceTypes: self.complianceTypes,
            nextToken: token,
            resourceId: self.resourceId,
            resourceType: self.resourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getComplianceDetailsByResourcePaginated`
/// to access the nested member `[ConfigClientTypes.EvaluationResult]`
/// - Returns: `[ConfigClientTypes.EvaluationResult]`
extension PaginatorSequence where Input == GetComplianceDetailsByResourceInput, Output == GetComplianceDetailsByResourceOutputResponse {
    public func evaluationResults() async throws -> [ConfigClientTypes.EvaluationResult] {
        return try await self.asyncCompactMap { item in item.evaluationResults }
    }
}

/// Paginate over `[GetConformancePackComplianceDetailsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetConformancePackComplianceDetailsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetConformancePackComplianceDetailsOutputResponse`
extension ConfigClient {
    public func getConformancePackComplianceDetailsPaginated(input: GetConformancePackComplianceDetailsInput) -> ClientRuntime.PaginatorSequence<GetConformancePackComplianceDetailsInput, GetConformancePackComplianceDetailsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetConformancePackComplianceDetailsInput, GetConformancePackComplianceDetailsOutputResponse>(input: input, inputKey: \GetConformancePackComplianceDetailsInput.nextToken, outputKey: \GetConformancePackComplianceDetailsOutputResponse.nextToken, paginationFunction: self.getConformancePackComplianceDetails(input:))
    }
}

extension GetConformancePackComplianceDetailsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetConformancePackComplianceDetailsInput {
        return GetConformancePackComplianceDetailsInput(
            conformancePackName: self.conformancePackName,
            filters: self.filters,
            limit: self.limit,
            nextToken: token
        )}
}

/// Paginate over `[GetConformancePackComplianceSummaryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetConformancePackComplianceSummaryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetConformancePackComplianceSummaryOutputResponse`
extension ConfigClient {
    public func getConformancePackComplianceSummaryPaginated(input: GetConformancePackComplianceSummaryInput) -> ClientRuntime.PaginatorSequence<GetConformancePackComplianceSummaryInput, GetConformancePackComplianceSummaryOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetConformancePackComplianceSummaryInput, GetConformancePackComplianceSummaryOutputResponse>(input: input, inputKey: \GetConformancePackComplianceSummaryInput.nextToken, outputKey: \GetConformancePackComplianceSummaryOutputResponse.nextToken, paginationFunction: self.getConformancePackComplianceSummary(input:))
    }
}

extension GetConformancePackComplianceSummaryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetConformancePackComplianceSummaryInput {
        return GetConformancePackComplianceSummaryInput(
            conformancePackNames: self.conformancePackNames,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getConformancePackComplianceSummaryPaginated`
/// to access the nested member `[ConfigClientTypes.ConformancePackComplianceSummary]`
/// - Returns: `[ConfigClientTypes.ConformancePackComplianceSummary]`
extension PaginatorSequence where Input == GetConformancePackComplianceSummaryInput, Output == GetConformancePackComplianceSummaryOutputResponse {
    public func conformancePackComplianceSummaryList() async throws -> [ConfigClientTypes.ConformancePackComplianceSummary] {
        return try await self.asyncCompactMap { item in item.conformancePackComplianceSummaryList }
    }
}

/// Paginate over `[GetDiscoveredResourceCountsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetDiscoveredResourceCountsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetDiscoveredResourceCountsOutputResponse`
extension ConfigClient {
    public func getDiscoveredResourceCountsPaginated(input: GetDiscoveredResourceCountsInput) -> ClientRuntime.PaginatorSequence<GetDiscoveredResourceCountsInput, GetDiscoveredResourceCountsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetDiscoveredResourceCountsInput, GetDiscoveredResourceCountsOutputResponse>(input: input, inputKey: \GetDiscoveredResourceCountsInput.nextToken, outputKey: \GetDiscoveredResourceCountsOutputResponse.nextToken, paginationFunction: self.getDiscoveredResourceCounts(input:))
    }
}

extension GetDiscoveredResourceCountsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDiscoveredResourceCountsInput {
        return GetDiscoveredResourceCountsInput(
            limit: self.limit,
            nextToken: token,
            resourceTypes: self.resourceTypes
        )}
}

/// Paginate over `[GetOrganizationConfigRuleDetailedStatusOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetOrganizationConfigRuleDetailedStatusInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetOrganizationConfigRuleDetailedStatusOutputResponse`
extension ConfigClient {
    public func getOrganizationConfigRuleDetailedStatusPaginated(input: GetOrganizationConfigRuleDetailedStatusInput) -> ClientRuntime.PaginatorSequence<GetOrganizationConfigRuleDetailedStatusInput, GetOrganizationConfigRuleDetailedStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetOrganizationConfigRuleDetailedStatusInput, GetOrganizationConfigRuleDetailedStatusOutputResponse>(input: input, inputKey: \GetOrganizationConfigRuleDetailedStatusInput.nextToken, outputKey: \GetOrganizationConfigRuleDetailedStatusOutputResponse.nextToken, paginationFunction: self.getOrganizationConfigRuleDetailedStatus(input:))
    }
}

extension GetOrganizationConfigRuleDetailedStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetOrganizationConfigRuleDetailedStatusInput {
        return GetOrganizationConfigRuleDetailedStatusInput(
            filters: self.filters,
            limit: self.limit,
            nextToken: token,
            organizationConfigRuleName: self.organizationConfigRuleName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getOrganizationConfigRuleDetailedStatusPaginated`
/// to access the nested member `[ConfigClientTypes.MemberAccountStatus]`
/// - Returns: `[ConfigClientTypes.MemberAccountStatus]`
extension PaginatorSequence where Input == GetOrganizationConfigRuleDetailedStatusInput, Output == GetOrganizationConfigRuleDetailedStatusOutputResponse {
    public func organizationConfigRuleDetailedStatus() async throws -> [ConfigClientTypes.MemberAccountStatus] {
        return try await self.asyncCompactMap { item in item.organizationConfigRuleDetailedStatus }
    }
}

/// Paginate over `[GetOrganizationConformancePackDetailedStatusOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetOrganizationConformancePackDetailedStatusInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetOrganizationConformancePackDetailedStatusOutputResponse`
extension ConfigClient {
    public func getOrganizationConformancePackDetailedStatusPaginated(input: GetOrganizationConformancePackDetailedStatusInput) -> ClientRuntime.PaginatorSequence<GetOrganizationConformancePackDetailedStatusInput, GetOrganizationConformancePackDetailedStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetOrganizationConformancePackDetailedStatusInput, GetOrganizationConformancePackDetailedStatusOutputResponse>(input: input, inputKey: \GetOrganizationConformancePackDetailedStatusInput.nextToken, outputKey: \GetOrganizationConformancePackDetailedStatusOutputResponse.nextToken, paginationFunction: self.getOrganizationConformancePackDetailedStatus(input:))
    }
}

extension GetOrganizationConformancePackDetailedStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetOrganizationConformancePackDetailedStatusInput {
        return GetOrganizationConformancePackDetailedStatusInput(
            filters: self.filters,
            limit: self.limit,
            nextToken: token,
            organizationConformancePackName: self.organizationConformancePackName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getOrganizationConformancePackDetailedStatusPaginated`
/// to access the nested member `[ConfigClientTypes.OrganizationConformancePackDetailedStatus]`
/// - Returns: `[ConfigClientTypes.OrganizationConformancePackDetailedStatus]`
extension PaginatorSequence where Input == GetOrganizationConformancePackDetailedStatusInput, Output == GetOrganizationConformancePackDetailedStatusOutputResponse {
    public func organizationConformancePackDetailedStatuses() async throws -> [ConfigClientTypes.OrganizationConformancePackDetailedStatus] {
        return try await self.asyncCompactMap { item in item.organizationConformancePackDetailedStatuses }
    }
}

/// Paginate over `[GetResourceConfigHistoryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetResourceConfigHistoryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetResourceConfigHistoryOutputResponse`
extension ConfigClient {
    public func getResourceConfigHistoryPaginated(input: GetResourceConfigHistoryInput) -> ClientRuntime.PaginatorSequence<GetResourceConfigHistoryInput, GetResourceConfigHistoryOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetResourceConfigHistoryInput, GetResourceConfigHistoryOutputResponse>(input: input, inputKey: \GetResourceConfigHistoryInput.nextToken, outputKey: \GetResourceConfigHistoryOutputResponse.nextToken, paginationFunction: self.getResourceConfigHistory(input:))
    }
}

extension GetResourceConfigHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetResourceConfigHistoryInput {
        return GetResourceConfigHistoryInput(
            chronologicalOrder: self.chronologicalOrder,
            earlierTime: self.earlierTime,
            laterTime: self.laterTime,
            limit: self.limit,
            nextToken: token,
            resourceId: self.resourceId,
            resourceType: self.resourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getResourceConfigHistoryPaginated`
/// to access the nested member `[ConfigClientTypes.ConfigurationItem]`
/// - Returns: `[ConfigClientTypes.ConfigurationItem]`
extension PaginatorSequence where Input == GetResourceConfigHistoryInput, Output == GetResourceConfigHistoryOutputResponse {
    public func configurationItems() async throws -> [ConfigClientTypes.ConfigurationItem] {
        return try await self.asyncCompactMap { item in item.configurationItems }
    }
}

/// Paginate over `[ListAggregateDiscoveredResourcesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAggregateDiscoveredResourcesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAggregateDiscoveredResourcesOutputResponse`
extension ConfigClient {
    public func listAggregateDiscoveredResourcesPaginated(input: ListAggregateDiscoveredResourcesInput) -> ClientRuntime.PaginatorSequence<ListAggregateDiscoveredResourcesInput, ListAggregateDiscoveredResourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAggregateDiscoveredResourcesInput, ListAggregateDiscoveredResourcesOutputResponse>(input: input, inputKey: \ListAggregateDiscoveredResourcesInput.nextToken, outputKey: \ListAggregateDiscoveredResourcesOutputResponse.nextToken, paginationFunction: self.listAggregateDiscoveredResources(input:))
    }
}

extension ListAggregateDiscoveredResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAggregateDiscoveredResourcesInput {
        return ListAggregateDiscoveredResourcesInput(
            configurationAggregatorName: self.configurationAggregatorName,
            filters: self.filters,
            limit: self.limit,
            nextToken: token,
            resourceType: self.resourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAggregateDiscoveredResourcesPaginated`
/// to access the nested member `[ConfigClientTypes.AggregateResourceIdentifier]`
/// - Returns: `[ConfigClientTypes.AggregateResourceIdentifier]`
extension PaginatorSequence where Input == ListAggregateDiscoveredResourcesInput, Output == ListAggregateDiscoveredResourcesOutputResponse {
    public func resourceIdentifiers() async throws -> [ConfigClientTypes.AggregateResourceIdentifier] {
        return try await self.asyncCompactMap { item in item.resourceIdentifiers }
    }
}

/// Paginate over `[ListConformancePackComplianceScoresOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListConformancePackComplianceScoresInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListConformancePackComplianceScoresOutputResponse`
extension ConfigClient {
    public func listConformancePackComplianceScoresPaginated(input: ListConformancePackComplianceScoresInput) -> ClientRuntime.PaginatorSequence<ListConformancePackComplianceScoresInput, ListConformancePackComplianceScoresOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListConformancePackComplianceScoresInput, ListConformancePackComplianceScoresOutputResponse>(input: input, inputKey: \ListConformancePackComplianceScoresInput.nextToken, outputKey: \ListConformancePackComplianceScoresOutputResponse.nextToken, paginationFunction: self.listConformancePackComplianceScores(input:))
    }
}

extension ListConformancePackComplianceScoresInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListConformancePackComplianceScoresInput {
        return ListConformancePackComplianceScoresInput(
            filters: self.filters,
            limit: self.limit,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// Paginate over `[ListDiscoveredResourcesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDiscoveredResourcesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDiscoveredResourcesOutputResponse`
extension ConfigClient {
    public func listDiscoveredResourcesPaginated(input: ListDiscoveredResourcesInput) -> ClientRuntime.PaginatorSequence<ListDiscoveredResourcesInput, ListDiscoveredResourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDiscoveredResourcesInput, ListDiscoveredResourcesOutputResponse>(input: input, inputKey: \ListDiscoveredResourcesInput.nextToken, outputKey: \ListDiscoveredResourcesOutputResponse.nextToken, paginationFunction: self.listDiscoveredResources(input:))
    }
}

extension ListDiscoveredResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDiscoveredResourcesInput {
        return ListDiscoveredResourcesInput(
            includeDeletedResources: self.includeDeletedResources,
            limit: self.limit,
            nextToken: token,
            resourceIds: self.resourceIds,
            resourceName: self.resourceName,
            resourceType: self.resourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDiscoveredResourcesPaginated`
/// to access the nested member `[ConfigClientTypes.ResourceIdentifier]`
/// - Returns: `[ConfigClientTypes.ResourceIdentifier]`
extension PaginatorSequence where Input == ListDiscoveredResourcesInput, Output == ListDiscoveredResourcesOutputResponse {
    public func resourceIdentifiers() async throws -> [ConfigClientTypes.ResourceIdentifier] {
        return try await self.asyncCompactMap { item in item.resourceIdentifiers }
    }
}

/// Paginate over `[ListStoredQueriesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListStoredQueriesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListStoredQueriesOutputResponse`
extension ConfigClient {
    public func listStoredQueriesPaginated(input: ListStoredQueriesInput) -> ClientRuntime.PaginatorSequence<ListStoredQueriesInput, ListStoredQueriesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListStoredQueriesInput, ListStoredQueriesOutputResponse>(input: input, inputKey: \ListStoredQueriesInput.nextToken, outputKey: \ListStoredQueriesOutputResponse.nextToken, paginationFunction: self.listStoredQueries(input:))
    }
}

extension ListStoredQueriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStoredQueriesInput {
        return ListStoredQueriesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListTagsForResourceOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTagsForResourceInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTagsForResourceOutputResponse`
extension ConfigClient {
    public func listTagsForResourcePaginated(input: ListTagsForResourceInput) -> ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse>(input: input, inputKey: \ListTagsForResourceInput.nextToken, outputKey: \ListTagsForResourceOutputResponse.nextToken, paginationFunction: self.listTagsForResource(input:))
    }
}

extension ListTagsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsForResourceInput {
        return ListTagsForResourceInput(
            limit: self.limit,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTagsForResourcePaginated`
/// to access the nested member `[ConfigClientTypes.Tag]`
/// - Returns: `[ConfigClientTypes.Tag]`
extension PaginatorSequence where Input == ListTagsForResourceInput, Output == ListTagsForResourceOutputResponse {
    public func tags() async throws -> [ConfigClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}

/// Paginate over `[SelectAggregateResourceConfigOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SelectAggregateResourceConfigInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SelectAggregateResourceConfigOutputResponse`
extension ConfigClient {
    public func selectAggregateResourceConfigPaginated(input: SelectAggregateResourceConfigInput) -> ClientRuntime.PaginatorSequence<SelectAggregateResourceConfigInput, SelectAggregateResourceConfigOutputResponse> {
        return ClientRuntime.PaginatorSequence<SelectAggregateResourceConfigInput, SelectAggregateResourceConfigOutputResponse>(input: input, inputKey: \SelectAggregateResourceConfigInput.nextToken, outputKey: \SelectAggregateResourceConfigOutputResponse.nextToken, paginationFunction: self.selectAggregateResourceConfig(input:))
    }
}

extension SelectAggregateResourceConfigInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SelectAggregateResourceConfigInput {
        return SelectAggregateResourceConfigInput(
            configurationAggregatorName: self.configurationAggregatorName,
            expression: self.expression,
            limit: self.limit,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `selectAggregateResourceConfigPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == SelectAggregateResourceConfigInput, Output == SelectAggregateResourceConfigOutputResponse {
    public func results() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.results }
    }
}

/// Paginate over `[SelectResourceConfigOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SelectResourceConfigInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SelectResourceConfigOutputResponse`
extension ConfigClient {
    public func selectResourceConfigPaginated(input: SelectResourceConfigInput) -> ClientRuntime.PaginatorSequence<SelectResourceConfigInput, SelectResourceConfigOutputResponse> {
        return ClientRuntime.PaginatorSequence<SelectResourceConfigInput, SelectResourceConfigOutputResponse>(input: input, inputKey: \SelectResourceConfigInput.nextToken, outputKey: \SelectResourceConfigOutputResponse.nextToken, paginationFunction: self.selectResourceConfig(input:))
    }
}

extension SelectResourceConfigInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SelectResourceConfigInput {
        return SelectResourceConfigInput(
            expression: self.expression,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `selectResourceConfigPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == SelectResourceConfigInput, Output == SelectResourceConfigOutputResponse {
    public func results() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.results }
    }
}
