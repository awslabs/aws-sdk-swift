// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension KeySigningKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate = "CreatedDate"
        case dNSKEYRecord = "DNSKEYRecord"
        case dSRecord = "DSRecord"
        case digestAlgorithmMnemonic = "DigestAlgorithmMnemonic"
        case digestAlgorithmType = "DigestAlgorithmType"
        case digestValue = "DigestValue"
        case flag = "Flag"
        case keyTag = "KeyTag"
        case kmsArn = "KmsArn"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case publicKey = "PublicKey"
        case signingAlgorithmMnemonic = "SigningAlgorithmMnemonic"
        case signingAlgorithmType = "SigningAlgorithmType"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("https://route53.amazonaws.com/doc/2013-04-01/", forKey: Key("xmlns"))
        }
        if let createdDate = createdDate {
            try container.encode(TimestampWrapper(createdDate, format: .dateTime), forKey: Key("createdDate"))
        }
        if let dNSKEYRecord = dNSKEYRecord {
            try container.encode(dNSKEYRecord, forKey: Key("dNSKEYRecord"))
        }
        if let dSRecord = dSRecord {
            try container.encode(dSRecord, forKey: Key("dSRecord"))
        }
        if let digestAlgorithmMnemonic = digestAlgorithmMnemonic {
            try container.encode(digestAlgorithmMnemonic, forKey: Key("digestAlgorithmMnemonic"))
        }
        if digestAlgorithmType != 0 {
            try container.encode(digestAlgorithmType, forKey: Key("digestAlgorithmType"))
        }
        if let digestValue = digestValue {
            try container.encode(digestValue, forKey: Key("digestValue"))
        }
        if flag != 0 {
            try container.encode(flag, forKey: Key("flag"))
        }
        if keyTag != 0 {
            try container.encode(keyTag, forKey: Key("keyTag"))
        }
        if let kmsArn = kmsArn {
            try container.encode(kmsArn, forKey: Key("kmsArn"))
        }
        if let lastModifiedDate = lastModifiedDate {
            try container.encode(TimestampWrapper(lastModifiedDate, format: .dateTime), forKey: Key("lastModifiedDate"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
        if let publicKey = publicKey {
            try container.encode(publicKey, forKey: Key("publicKey"))
        }
        if let signingAlgorithmMnemonic = signingAlgorithmMnemonic {
            try container.encode(signingAlgorithmMnemonic, forKey: Key("signingAlgorithmMnemonic"))
        }
        if signingAlgorithmType != 0 {
            try container.encode(signingAlgorithmType, forKey: Key("signingAlgorithmType"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
        if let statusMessage = statusMessage {
            try container.encode(statusMessage, forKey: Key("statusMessage"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let flagDecoded = try containerValues.decode(Int.self, forKey: .flag)
        flag = flagDecoded
        let signingAlgorithmMnemonicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingAlgorithmMnemonic)
        signingAlgorithmMnemonic = signingAlgorithmMnemonicDecoded
        let signingAlgorithmTypeDecoded = try containerValues.decode(Int.self, forKey: .signingAlgorithmType)
        signingAlgorithmType = signingAlgorithmTypeDecoded
        let digestAlgorithmMnemonicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .digestAlgorithmMnemonic)
        digestAlgorithmMnemonic = digestAlgorithmMnemonicDecoded
        let digestAlgorithmTypeDecoded = try containerValues.decode(Int.self, forKey: .digestAlgorithmType)
        digestAlgorithmType = digestAlgorithmTypeDecoded
        let keyTagDecoded = try containerValues.decode(Int.self, forKey: .keyTag)
        keyTag = keyTagDecoded
        let digestValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .digestValue)
        digestValue = digestValueDecoded
        let publicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
        let dSRecordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dSRecord)
        dSRecord = dSRecordDecoded
        let dNSKEYRecordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dNSKEYRecord)
        dNSKEYRecord = dNSKEYRecordDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        var createdDateBuffer:Date? = nil
        if let createdDateDecoded = createdDateDecoded {
            createdDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdDateDecoded, format: .dateTime)
        }
        createdDate = createdDateBuffer
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        var lastModifiedDateBuffer:Date? = nil
        if let lastModifiedDateDecoded = lastModifiedDateDecoded {
            lastModifiedDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedDateDecoded, format: .dateTime)
        }
        lastModifiedDate = lastModifiedDateBuffer
    }
}
