// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct UpdateHealthCheckInputBody: Equatable {
    public let healthCheckVersion: Int?
    public let iPAddress: String?
    public let port: Int?
    public let resourcePath: String?
    public let fullyQualifiedDomainName: String?
    public let searchString: String?
    public let failureThreshold: Int?
    public let inverted: Bool?
    public let disabled: Bool?
    public let healthThreshold: Int?
    public let childHealthChecks: [String]?
    public let enableSNI: Bool?
    public let regions: [HealthCheckRegion]?
    public let alarmIdentifier: AlarmIdentifier?
    public let insufficientDataHealthStatus: InsufficientDataHealthStatus?
    public let resetElements: [ResettableElementName]?
}

extension UpdateHealthCheckInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarmIdentifier = "AlarmIdentifier"
        case childHealthChecks = "ChildHealthChecks"
        case disabled = "Disabled"
        case enableSNI = "EnableSNI"
        case failureThreshold = "FailureThreshold"
        case fullyQualifiedDomainName = "FullyQualifiedDomainName"
        case healthCheckVersion = "HealthCheckVersion"
        case healthThreshold = "HealthThreshold"
        case iPAddress = "IPAddress"
        case insufficientDataHealthStatus = "InsufficientDataHealthStatus"
        case inverted = "Inverted"
        case port = "Port"
        case regions = "Regions"
        case resetElements = "ResetElements"
        case resourcePath = "ResourcePath"
        case searchString = "SearchString"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthCheckVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthCheckVersion)
        healthCheckVersion = healthCheckVersionDecoded
        let iPAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iPAddress)
        iPAddress = iPAddressDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let resourcePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourcePath)
        resourcePath = resourcePathDecoded
        let fullyQualifiedDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fullyQualifiedDomainName)
        fullyQualifiedDomainName = fullyQualifiedDomainNameDecoded
        let searchStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .searchString)
        searchString = searchStringDecoded
        let failureThresholdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failureThreshold)
        failureThreshold = failureThresholdDecoded
        let invertedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .inverted)
        inverted = invertedDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let healthThresholdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthThreshold)
        healthThreshold = healthThresholdDecoded
        if containerValues.contains(.childHealthChecks) {
            struct KeyVal0{struct ChildHealthCheck{}}
            let childHealthChecksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ChildHealthCheck>.CodingKeys.self, forKey: .childHealthChecks)
            if let childHealthChecksWrappedContainer = childHealthChecksWrappedContainer {
                let childHealthChecksContainer = try childHealthChecksWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var childHealthChecksBuffer:[String]? = nil
                if let childHealthChecksContainer = childHealthChecksContainer {
                    childHealthChecksBuffer = [String]()
                    for stringContainer0 in childHealthChecksContainer {
                        childHealthChecksBuffer?.append(stringContainer0)
                    }
                }
                childHealthChecks = childHealthChecksBuffer
            } else {
                childHealthChecks = []
            }
        } else {
            childHealthChecks = nil
        }
        let enableSNIDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableSNI)
        enableSNI = enableSNIDecoded
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([HealthCheckRegion].self, forKey: .member)
                var regionsBuffer:[HealthCheckRegion]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [HealthCheckRegion]()
                    for stringContainer0 in regionsContainer {
                        regionsBuffer?.append(stringContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
        let alarmIdentifierDecoded = try containerValues.decodeIfPresent(AlarmIdentifier.self, forKey: .alarmIdentifier)
        alarmIdentifier = alarmIdentifierDecoded
        let insufficientDataHealthStatusDecoded = try containerValues.decodeIfPresent(InsufficientDataHealthStatus.self, forKey: .insufficientDataHealthStatus)
        insufficientDataHealthStatus = insufficientDataHealthStatusDecoded
        if containerValues.contains(.resetElements) {
            struct KeyVal0{struct ResettableElementName{}}
            let resetElementsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ResettableElementName>.CodingKeys.self, forKey: .resetElements)
            if let resetElementsWrappedContainer = resetElementsWrappedContainer {
                let resetElementsContainer = try resetElementsWrappedContainer.decodeIfPresent([ResettableElementName].self, forKey: .member)
                var resetElementsBuffer:[ResettableElementName]? = nil
                if let resetElementsContainer = resetElementsContainer {
                    resetElementsBuffer = [ResettableElementName]()
                    for stringContainer0 in resetElementsContainer {
                        resetElementsBuffer?.append(stringContainer0)
                    }
                }
                resetElements = resetElementsBuffer
            } else {
                resetElements = []
            }
        } else {
            resetElements = nil
        }
    }
}
