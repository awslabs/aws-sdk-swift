// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class Route53Client {
    let client: SdkHttpClient
    let config: Route53ClientConfiguration
    let serviceName = "Route 53"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: Route53ClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = XMLEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = XMLDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class Route53ClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> Route53ClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try Route53ClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension Route53Client: Route53ClientProtocol {
    /// <p>Activates a key-signing key (KSK) so that it can be used for signing by DNSSEC. This operation changes the
    /// 			KSK status to <code>ACTIVE</code>.</p>
    public func activateKeySigningKey(input: ActivateKeySigningKeyInput, completion: @escaping (SdkResult<ActivateKeySigningKeyOutput, ActivateKeySigningKeyOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/keysigningkey/\(hostedZoneId)/\(name)/activate"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "activateKeySigningKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ActivateKeySigningKeyInput, ActivateKeySigningKeyOutput, ActivateKeySigningKeyOutputError>(id: "activateKeySigningKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ActivateKeySigningKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ActivateKeySigningKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ActivateKeySigningKeyInput, ActivateKeySigningKeyOutput, ActivateKeySigningKeyOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associates an Amazon VPC with a private hosted zone. </p>
    /// 		       <important>
    ///             <p>To perform the association, the VPC and the private hosted zone must already exist.
    /// 			You can't convert a public hosted zone into a private hosted zone.</p>
    ///          </important>
    /// 		       <note>
    ///             <p>If you want to associate a VPC that was created by using one AWS account with a private hosted zone that was created
    /// 			by using a different account, the AWS account that created the private hosted zone must first submit a
    /// 			<code>CreateVPCAssociationAuthorization</code> request. Then the account that created the VPC must submit an
    /// 			<code>AssociateVPCWithHostedZone</code> request.</p>
    ///          </note>
    public func associateVPCWithHostedZone(input: AssociateVPCWithHostedZoneInput, completion: @escaping (SdkResult<AssociateVPCWithHostedZoneOutput, AssociateVPCWithHostedZoneOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(hostedZoneId)/associatevpc"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateVPCWithHostedZone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateVPCWithHostedZoneInput, AssociateVPCWithHostedZoneOutput, AssociateVPCWithHostedZoneOutputError>(id: "associateVPCWithHostedZone")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateVPCWithHostedZoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateVPCWithHostedZoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateVPCWithHostedZoneInput, AssociateVPCWithHostedZoneOutput, AssociateVPCWithHostedZoneOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateVPCWithHostedZoneInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates, changes, or deletes a resource record set, which contains authoritative DNS information for a specified
    /// 			domain name or subdomain name. For example, you can use <code>ChangeResourceRecordSets</code> to create a resource record set that
    /// 			routes traffic for test.example.com to a web server that has an IP address of 192.0.2.44.</p>
    /// 		
    /// 		       <p>
    ///             <b>Deleting Resource Record Sets</b>
    ///          </p>
    /// 		       <p>To delete a resource record set, you must specify all the same values that you specified when you created it.</p>
    ///
    /// 		       <p>
    ///             <b>Change Batches and Transactional Changes</b>
    ///          </p>
    /// 		       <p>The request body must include a document with a <code>ChangeResourceRecordSetsRequest</code> element.
    /// 			The request body contains a list of change items, known as a change batch. Change batches are considered transactional changes.
    /// 			Route 53 validates the changes in the request and then either makes all or none of the changes in the change batch request.
    /// 			This ensures that DNS routing isn't adversely affected by partial changes to the resource record sets in a hosted zone. </p>
    /// 		       <p>For example, suppose a change batch request contains two changes: it deletes the <code>CNAME</code> resource record set for www.example.com and
    /// 			creates an alias resource record set for www.example.com. If validation for both records succeeds, Route 53 deletes the first resource record set and
    /// 			creates the second resource record set in a single operation. If validation for either the <code>DELETE</code> or the <code>CREATE</code> action fails,
    /// 			then the request is canceled, and the original <code>CNAME</code> record continues to exist.</p>
    /// 		       <note>
    /// 			         <p>If you try to delete the same resource record set more than once in a single change batch, Route 53 returns an <code>InvalidChangeBatch</code> error.</p>
    /// 		       </note>
    /// 		
    /// 		       <p>
    ///             <b>Traffic Flow</b>
    ///          </p>
    /// 		       <p>To create resource record sets for complex routing configurations, use either the traffic flow visual editor in the
    /// 			Route 53 console or the API actions for traffic policies and traffic policy instances. Save the configuration as a traffic policy,
    /// 			then associate the traffic policy with one or more domain names (such as example.com) or subdomain names (such as www.example.com),
    /// 			in the same hosted zone or in multiple hosted zones. You can roll back the updates if the new configuration isn't performing
    /// 			as expected. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/traffic-flow.html">Using Traffic Flow to Route DNS Traffic</a>
    /// 			in the <i>Amazon Route 53 Developer Guide</i>.</p>
    /// 		
    /// 		       <p>
    ///             <b>Create, Delete, and Upsert</b>
    ///          </p>
    /// 		       <p>Use <code>ChangeResourceRecordsSetsRequest</code> to perform the following actions:</p>
    /// 			      <ul>
    ///             <li>
    /// 					          <p>
    ///                   <code>CREATE</code>: Creates a resource record set that has the specified values.</p>
    /// 				        </li>
    ///             <li>
    /// 					          <p>
    ///                   <code>DELETE</code>: Deletes an existing resource record set that has the specified values.</p>
    /// 				        </li>
    ///             <li>
    /// 					          <p>
    ///                   <code>UPSERT</code>: If a resource record set does not already exist, AWS creates it.
    /// 						If a resource set does exist, Route 53 updates it with the values in the request. </p>
    /// 				        </li>
    ///          </ul>
    /// 		
    /// 		       <p>
    ///             <b>Syntaxes for Creating, Updating, and Deleting Resource Record Sets</b>
    ///          </p>
    /// 		       <p>The syntax for a request depends on the type of resource record set that you want to create, delete, or update, such as
    /// 			weighted, alias, or failover. The XML elements in your request must appear in the order listed in the syntax. </p>
    ///
    /// 		
    /// 		       <p>For an example for each type of resource record set, see "Examples."</p>
    /// 		
    /// 		
    /// 		       <p>Don't refer to the syntax in the "Parameter Syntax" section, which includes all of the elements for every kind of
    /// 			resource record set that you can create, delete, or update by using <code>ChangeResourceRecordSets</code>. </p>
    /// 		
    /// 		       <p>
    ///             <b>Change Propagation to Route 53 DNS Servers</b>
    ///          </p>
    /// 		       <p>When you submit a <code>ChangeResourceRecordSets</code> request, Route 53 propagates your changes to all of the
    /// 			Route 53 authoritative DNS servers. While your changes are propagating, <code>GetChange</code> returns a status of
    /// 			<code>PENDING</code>. When propagation is complete, <code>GetChange</code> returns a status of <code>INSYNC</code>.
    /// 			Changes generally propagate to all Route 53 name servers within 60 seconds. For more information, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetChange.html">GetChange</a>.</p>
    ///
    /// 		       <p>
    ///             <b>Limits on ChangeResourceRecordSets Requests</b>
    ///          </p>
    /// 		       <p>For information about the limits on a <code>ChangeResourceRecordSets</code> request, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the
    /// 			<i>Amazon Route 53 Developer Guide</i>.</p>
    public func changeResourceRecordSets(input: ChangeResourceRecordSetsInput, completion: @escaping (SdkResult<ChangeResourceRecordSetsOutput, ChangeResourceRecordSetsOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(hostedZoneId)/rrset"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "changeResourceRecordSets")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ChangeResourceRecordSetsInput, ChangeResourceRecordSetsOutput, ChangeResourceRecordSetsOutputError>(id: "changeResourceRecordSets")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ChangeResourceRecordSetsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ChangeResourceRecordSetsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ChangeResourceRecordSetsInput, ChangeResourceRecordSetsOutput, ChangeResourceRecordSetsOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: ChangeResourceRecordSetsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds, edits, or deletes tags for a health check or a hosted zone.</p>
    /// 		       <p>For information about using tags for cost allocation, see
    /// 			<a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags</a>
    /// 			in the <i>AWS Billing and Cost Management User Guide</i>.</p>
    public func changeTagsForResource(input: ChangeTagsForResourceInput, completion: @escaping (SdkResult<ChangeTagsForResourceOutput, ChangeTagsForResourceOutputError>) -> Void)
    {
        guard let resourceType = input.resourceType else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceType unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/tags/\(resourceType.rawValue)/\(resourceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "changeTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ChangeTagsForResourceInput, ChangeTagsForResourceOutput, ChangeTagsForResourceOutputError>(id: "changeTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ChangeTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ChangeTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ChangeTagsForResourceInput, ChangeTagsForResourceOutput, ChangeTagsForResourceOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: ChangeTagsForResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new health check.</p>
    /// 		       <p>For information about adding health checks to resource record sets, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ResourceRecordSet.html#Route53-Type-ResourceRecordSet-HealthCheckId">HealthCheckId</a>
    /// 			in
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ChangeResourceRecordSets.html">ChangeResourceRecordSets</a>. </p>
    /// 		
    /// 		       <p>
    ///             <b>ELB Load Balancers</b>
    ///          </p>
    /// 		       <p>If you're registering EC2 instances with an Elastic Load Balancing (ELB) load balancer, do not create Amazon Route 53 health checks for the
    /// 			EC2 instances. When you register an EC2 instance with a load balancer, you configure settings for an ELB health check, which performs a
    /// 			similar function to a Route 53 health check.</p>
    /// 		
    /// 		       <p>
    ///             <b>Private Hosted Zones</b>
    ///          </p>
    /// 		       <p>You can associate health checks with failover resource record sets in a private hosted zone. Note the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Route 53 health checkers are outside the VPC. To check the health of an endpoint within a VPC by IP address, you must
    /// 					assign a public IP address to the instance in the VPC.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>You can configure a health checker to check the health of an external resource that the instance relies on, such as a
    /// 					database server.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>You can create a CloudWatch metric, associate an alarm with the metric, and then create a health check that is based on the
    /// 					state of the alarm. For example, you might create a CloudWatch metric that checks the status of the Amazon EC2 <code>StatusCheckFailed</code> metric,
    /// 					add an alarm to the metric, and then create a health check that is based on the state of the alarm. For information about creating
    /// 					CloudWatch metrics and alarms by using the CloudWatch console, see the
    /// 					<a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
    /// 			         </li>
    ///          </ul>
    public func createHealthCheck(input: CreateHealthCheckInput, completion: @escaping (SdkResult<CreateHealthCheckOutput, CreateHealthCheckOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/healthcheck"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createHealthCheck")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateHealthCheckInput, CreateHealthCheckOutput, CreateHealthCheckOutputError>(id: "createHealthCheck")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateHealthCheckInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateHealthCheckInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateHealthCheckInput, CreateHealthCheckOutput, CreateHealthCheckOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateHealthCheckInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new public or private hosted zone. You create records in a public hosted zone to define how you want to route traffic
    /// 			on the internet for a domain, such as example.com, and its subdomains (apex.example.com, acme.example.com). You create records in a
    /// 			private hosted zone to define how you want to route traffic for a domain and its subdomains within one or more
    /// 			Amazon Virtual Private Clouds (Amazon VPCs). </p>
    /// 		       <important>
    /// 			         <p>You can't convert a public hosted zone to a private hosted zone or vice versa. Instead, you must create a new hosted zone
    /// 				with the same name and create new resource record sets.</p>
    /// 		       </important>
    /// 		       <p>For more information about charges for hosted zones, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
    /// 		       <p>Note the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>You can't create a hosted zone for a top-level domain (TLD) such as .com.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>For public hosted zones, Route 53 automatically creates a default SOA record and four NS records for the zone.
    /// 					For more information about SOA and NS records, see
    /// 					<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/SOA-NSrecords.html">NS and SOA Records that Route 53 Creates for a Hosted Zone</a> in the
    /// 					<i>Amazon Route 53 Developer Guide</i>.</p>
    /// 				           <p>If you want to use the same name servers for multiple public hosted zones, you can optionally associate a reusable delegation set
    /// 					with the hosted zone. See the <code>DelegationSetId</code> element.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>If your domain is registered with a registrar other than Route 53, you must update the name servers with your registrar to make
    /// 					Route 53 the DNS service for the domain. For more information, see
    /// 					<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/MigratingDNS.html">Migrating DNS Service for an Existing Domain to Amazon Route 53</a> in the
    /// 					<i>Amazon Route 53 Developer Guide</i>. </p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>When you submit a <code>CreateHostedZone</code> request, the initial status of the hosted zone is <code>PENDING</code>.
    /// 			For public hosted zones, this means that the NS and SOA records are not yet available on all Route 53 DNS servers. When the
    /// 			NS and SOA records are available, the status of the zone changes to <code>INSYNC</code>.</p>
    /// 		       <p>The <code>CreateHostedZone</code> request requires the caller to have an <code>ec2:DescribeVpcs</code> permission.</p>
    public func createHostedZone(input: CreateHostedZoneInput, completion: @escaping (SdkResult<CreateHostedZoneOutput, CreateHostedZoneOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/hostedzone"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createHostedZone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateHostedZoneInput, CreateHostedZoneOutput, CreateHostedZoneOutputError>(id: "createHostedZone")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateHostedZoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateHostedZoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateHostedZoneInput, CreateHostedZoneOutput, CreateHostedZoneOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateHostedZoneInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new key-signing key (KSK) associated with a hosted zone. You can only have two KSKs per hosted zone.</p>
    public func createKeySigningKey(input: CreateKeySigningKeyInput, completion: @escaping (SdkResult<CreateKeySigningKeyOutput, CreateKeySigningKeyOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/keysigningkey"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createKeySigningKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateKeySigningKeyInput, CreateKeySigningKeyOutput, CreateKeySigningKeyOutputError>(id: "createKeySigningKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateKeySigningKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateKeySigningKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateKeySigningKeyInput, CreateKeySigningKeyOutput, CreateKeySigningKeyOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateKeySigningKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a configuration for DNS query logging. After you create a query logging configuration, Amazon Route 53 begins to publish
    /// 			log data to an Amazon CloudWatch Logs log group.</p>
    /// 		       <p>DNS query logs contain information about the queries that Route 53 receives for a specified public hosted zone, such as the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Route 53 edge location that responded to the DNS query</p>
    ///             </li>
    ///             <li>
    ///                <p>Domain or subdomain that was requested</p>
    ///             </li>
    ///             <li>
    ///                <p>DNS record type, such as A or AAAA</p>
    ///             </li>
    ///             <li>
    ///                <p>DNS response code, such as <code>NoError</code> or <code>ServFail</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    /// 		
    /// 		       <dl>
    ///             <dt>Log Group and Resource Policy</dt>
    ///             <dd>
    ///                <p>Before you create a query logging configuration, perform the following operations.</p>
    /// 					          <note>
    ///                   <p>If you create a query logging configuration using the Route 53 console, Route 53 performs these operations automatically.</p>
    ///                </note>
    /// 					          <ol>
    ///                   <li>
    ///                      <p>Create a CloudWatch Logs log group, and make note of the ARN, which you specify when you create a
    /// 							query logging configuration. Note the following:</p>
    /// 							              <ul>
    ///                         <li>
    ///                            <p>You must create the log group in the us-east-1 region.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>You must use the same AWS account to create the log group and the hosted zone that you want to
    /// 									configure query logging for.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>When you create log groups for query logging, we recommend that you use a consistent prefix, for example:</p>
    /// 									                  <p>
    ///                               <code>/aws/route53/<i>hosted zone name</i>
    ///                               </code>
    ///                            </p>
    /// 									                  <p>In the next step, you'll create a resource policy, which controls access to one or more log groups and the associated
    /// 										AWS resources, such as Route 53 hosted zones. There's a limit on the number of resource policies that you can create, so
    /// 										we recommend that you use a consistent prefix so you can use the same resource policy for all the log groups that you create
    /// 										for query logging.</p>
    /// 								                </li>
    ///                      </ul>
    /// 						            </li>
    ///                   <li>
    ///                      <p>Create a CloudWatch Logs resource policy, and give it the permissions that Route 53 needs to create log streams and to
    /// 							send query logs to log streams. For the value of <code>Resource</code>, specify the ARN for the log group that you created
    /// 							in the previous step. To use the same resource policy for all the CloudWatch Logs log groups that you created for query logging configurations,
    /// 							replace the hosted zone name with <code>*</code>, for example:</p>
    /// 							              <p>
    ///                         <code>arn:aws:logs:us-east-1:123412341234:log-group:/aws/route53/*</code>
    ///                      </p>
    /// 							              <note>
    ///                         <p>You can't use the CloudWatch console to create or edit a resource policy. You must use the CloudWatch API, one of the AWS SDKs,
    /// 								or the AWS CLI.</p>
    ///                      </note>
    /// 						            </li>
    ///                </ol>
    /// 				        </dd>
    ///             <dt>Log Streams and Edge Locations</dt>
    ///             <dd>
    ///                <p>When Route 53 finishes creating the configuration for DNS query logging, it does the following:</p>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>Creates a log stream for an edge location the first time that the edge location responds to DNS queries for the
    /// 							specified hosted zone. That log stream is used to log all queries that Route 53 responds to for that edge location.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Begins to send query logs to the applicable log stream.</p>
    ///                   </li>
    ///                </ul>
    /// 					          <p>The name of each log stream is in the following format:</p>
    /// 					          <p>
    ///                   <code>
    ///                      <i>hosted zone ID</i>/<i>edge location code</i>
    ///                   </code>
    ///                </p>
    /// 					          <p>The edge location code is a three-letter code and an arbitrarily assigned number, for example, DFW3. The three-letter code
    /// 						typically corresponds with the International Air Transport Association airport code for an airport near the edge location.
    /// 						(These abbreviations might change in the future.) For a list of edge locations, see "The Route 53 Global Network" on the
    /// 						<a href="http://aws.amazon.com/route53/details/">Route 53 Product Details</a> page.</p>
    /// 				        </dd>
    ///             <dt>Queries That Are Logged</dt>
    ///             <dd>
    ///                <p>Query logs contain only the queries that DNS resolvers forward to Route 53. If a DNS resolver has already cached
    /// 					the response to a query (such as the IP address for a load balancer for example.com), the resolver will continue to return
    /// 					the cached response. It doesn't forward another query to Route 53 until the TTL for the corresponding resource record set expires.
    /// 					Depending on how many DNS queries are submitted for a resource record set, and depending on the TTL for that resource record set,
    /// 					query logs might contain information about only one query out of every several thousand queries that are submitted to DNS.
    /// 					For more information about how DNS works, see
    /// 					<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/welcome-dns-service.html">Routing Internet Traffic to Your Website or Web Application</a>
    /// 					in the <i>Amazon Route 53 Developer Guide</i>.</p>
    /// 				        </dd>
    ///             <dt>Log File Format</dt>
    ///             <dd>
    ///                <p>For a list of the values in each query log and the format of each value, see
    /// 					<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html">Logging DNS Queries</a> in the
    /// 					<i>Amazon Route 53 Developer Guide</i>.</p>
    /// 				        </dd>
    ///             <dt>Pricing</dt>
    ///             <dd>
    ///                <p>For information about charges for query logs, see
    /// 					<a href="http://aws.amazon.com/cloudwatch/pricing/">Amazon CloudWatch Pricing</a>.</p>
    ///             </dd>
    ///             <dt>How to Stop Logging</dt>
    ///             <dd>
    ///                <p>If you want Route 53 to stop sending query logs to CloudWatch Logs, delete the query logging configuration. For more information, see
    /// 					<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_DeleteQueryLoggingConfig.html">DeleteQueryLoggingConfig</a>.</p>
    /// 				        </dd>
    ///          </dl>
    public func createQueryLoggingConfig(input: CreateQueryLoggingConfigInput, completion: @escaping (SdkResult<CreateQueryLoggingConfigOutput, CreateQueryLoggingConfigOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/queryloggingconfig"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createQueryLoggingConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateQueryLoggingConfigInput, CreateQueryLoggingConfigOutput, CreateQueryLoggingConfigOutputError>(id: "createQueryLoggingConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateQueryLoggingConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateQueryLoggingConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateQueryLoggingConfigInput, CreateQueryLoggingConfigOutput, CreateQueryLoggingConfigOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateQueryLoggingConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a delegation set (a group of four name servers) that can be reused by multiple hosted zones that were created by
    /// 			the same AWS account. </p>
    /// 		       <p>You can also create a reusable delegation set that uses the four name servers that are associated
    /// 			with an existing hosted zone. Specify the hosted zone ID in the <code>CreateReusableDelegationSet</code> request.</p>
    /// 		       <note>
    /// 			         <p>You can't associate a reusable delegation set with a private hosted zone.</p>
    /// 		       </note>
    /// 		       <p>For information about using a reusable delegation set to configure white label name servers, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/white-label-name-servers.html">Configuring White Label Name Servers</a>.</p>
    /// 		
    /// 		       <p>The process for migrating existing hosted zones to use a reusable delegation set is comparable to the process for
    /// 			configuring white label name servers. You need to perform the following steps:</p>
    /// 		       <ol>
    ///             <li>
    ///                <p>Create a reusable delegation set.</p>
    ///             </li>
    ///             <li>
    ///                <p>Recreate hosted zones, and reduce the TTL to 60 seconds or less.</p>
    ///             </li>
    ///             <li>
    ///                <p>Recreate resource record sets in the new hosted zones.</p>
    ///             </li>
    ///             <li>
    ///                <p>Change the registrar's name servers to use the name servers for the new hosted zones.</p>
    ///             </li>
    ///             <li>
    ///                <p>Monitor traffic for the website or application.</p>
    ///             </li>
    ///             <li>
    ///                <p>Change TTLs back to their original values.</p>
    ///             </li>
    ///          </ol>
    /// 		
    /// 		       <p>If you want to migrate existing hosted zones to use a reusable delegation set, the existing hosted zones can't use
    /// 			any of the name servers that are assigned to the reusable delegation set. If one or more hosted zones do use one or more
    /// 			name servers that are assigned to the reusable delegation set, you can do one of the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>For small numbers of hosted zones—up to a few hundred—it's relatively easy to create
    /// 				reusable delegation sets until you get one that has four name servers that don't overlap with any of the name servers
    /// 				in your hosted zones.</p>
    ///             </li>
    ///             <li>
    ///                <p>For larger numbers of hosted zones, the easiest solution is to use more than one reusable delegation set.</p>
    ///             </li>
    ///             <li>
    ///                <p>For larger numbers of hosted zones, you can also migrate hosted zones that have overlapping name servers
    /// 				to hosted zones that don't have overlapping name servers, then migrate the hosted zones again to use the
    /// 				reusable delegation set.</p>
    ///             </li>
    ///          </ul>
    public func createReusableDelegationSet(input: CreateReusableDelegationSetInput, completion: @escaping (SdkResult<CreateReusableDelegationSetOutput, CreateReusableDelegationSetOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/delegationset"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createReusableDelegationSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateReusableDelegationSetInput, CreateReusableDelegationSetOutput, CreateReusableDelegationSetOutputError>(id: "createReusableDelegationSet")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateReusableDelegationSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateReusableDelegationSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateReusableDelegationSetInput, CreateReusableDelegationSetOutput, CreateReusableDelegationSetOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateReusableDelegationSetInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a traffic policy, which you use to create multiple DNS resource record sets for one domain name (such as example.com) or
    /// 			one subdomain name (such as www.example.com).</p>
    public func createTrafficPolicy(input: CreateTrafficPolicyInput, completion: @escaping (SdkResult<CreateTrafficPolicyOutput, CreateTrafficPolicyOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/trafficpolicy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTrafficPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTrafficPolicyInput, CreateTrafficPolicyOutput, CreateTrafficPolicyOutputError>(id: "createTrafficPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTrafficPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTrafficPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTrafficPolicyInput, CreateTrafficPolicyOutput, CreateTrafficPolicyOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTrafficPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates resource record sets in a specified hosted zone based on the settings in a specified traffic policy version.
    /// 			In addition, <code>CreateTrafficPolicyInstance</code> associates the resource record sets with a specified domain name (such as example.com) or
    /// 			subdomain name (such as www.example.com). Amazon Route 53 responds to DNS queries for the domain or subdomain name by using the resource record sets
    /// 			that <code>CreateTrafficPolicyInstance</code> created.</p>
    public func createTrafficPolicyInstance(input: CreateTrafficPolicyInstanceInput, completion: @escaping (SdkResult<CreateTrafficPolicyInstanceOutput, CreateTrafficPolicyInstanceOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/trafficpolicyinstance"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTrafficPolicyInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTrafficPolicyInstanceInput, CreateTrafficPolicyInstanceOutput, CreateTrafficPolicyInstanceOutputError>(id: "createTrafficPolicyInstance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTrafficPolicyInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTrafficPolicyInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTrafficPolicyInstanceInput, CreateTrafficPolicyInstanceOutput, CreateTrafficPolicyInstanceOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTrafficPolicyInstanceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new version of an existing traffic policy. When you create a new version of a traffic policy, you specify the ID of the
    /// 			traffic policy that you want to update and a JSON-formatted document that describes the new version. You use traffic policies to create
    /// 			multiple DNS resource record sets for one domain name (such as example.com) or one subdomain name (such as www.example.com). You can
    /// 			create a maximum of 1000 versions of a traffic policy. If you reach the limit and need to create another version, you'll need to start a new
    /// 			traffic policy.</p>
    public func createTrafficPolicyVersion(input: CreateTrafficPolicyVersionInput, completion: @escaping (SdkResult<CreateTrafficPolicyVersionOutput, CreateTrafficPolicyVersionOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/trafficpolicy/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTrafficPolicyVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTrafficPolicyVersionInput, CreateTrafficPolicyVersionOutput, CreateTrafficPolicyVersionOutputError>(id: "createTrafficPolicyVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTrafficPolicyVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTrafficPolicyVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTrafficPolicyVersionInput, CreateTrafficPolicyVersionOutput, CreateTrafficPolicyVersionOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTrafficPolicyVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Authorizes the AWS account that created a specified VPC to submit an <code>AssociateVPCWithHostedZone</code>
    /// 			request to associate the VPC with a specified hosted zone that was created by a different account.
    /// 			To submit a <code>CreateVPCAssociationAuthorization</code> request, you must use the account that created the
    /// 			hosted zone. After you authorize the association, use the account that created the VPC to submit an
    /// 			<code>AssociateVPCWithHostedZone</code> request.</p>
    /// 		       <note>
    ///             <p>If you want to associate multiple VPCs that you created by using one account with a hosted zone
    /// 			that you created by using a different account, you must submit one authorization request for each VPC.</p>
    ///          </note>
    public func createVPCAssociationAuthorization(input: CreateVPCAssociationAuthorizationInput, completion: @escaping (SdkResult<CreateVPCAssociationAuthorizationOutput, CreateVPCAssociationAuthorizationOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(hostedZoneId)/authorizevpcassociation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createVPCAssociationAuthorization")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateVPCAssociationAuthorizationInput, CreateVPCAssociationAuthorizationOutput, CreateVPCAssociationAuthorizationOutputError>(id: "createVPCAssociationAuthorization")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateVPCAssociationAuthorizationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateVPCAssociationAuthorizationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateVPCAssociationAuthorizationInput, CreateVPCAssociationAuthorizationOutput, CreateVPCAssociationAuthorizationOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateVPCAssociationAuthorizationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deactivates a key-signing key (KSK) so that it will not be used for signing by DNSSEC. This operation changes the
    /// 			KSK status to <code>INACTIVE</code>.</p>
    public func deactivateKeySigningKey(input: DeactivateKeySigningKeyInput, completion: @escaping (SdkResult<DeactivateKeySigningKeyOutput, DeactivateKeySigningKeyOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/keysigningkey/\(hostedZoneId)/\(name)/deactivate"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deactivateKeySigningKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeactivateKeySigningKeyInput, DeactivateKeySigningKeyOutput, DeactivateKeySigningKeyOutputError>(id: "deactivateKeySigningKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeactivateKeySigningKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeactivateKeySigningKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeactivateKeySigningKeyInput, DeactivateKeySigningKeyOutput, DeactivateKeySigningKeyOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a health check.</p>
    /// 		       <important>
    /// 			         <p>Amazon Route 53 does not prevent you from deleting a health check even if the health check is associated with one or more
    /// 				resource record sets. If you delete a health check and you don't update the associated resource record sets, the future status
    /// 				of the health check can't be predicted and may change. This will affect the routing of DNS queries for your DNS failover
    /// 				configuration. For more information, see
    /// 				<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/health-checks-creating-deleting.html#health-checks-deleting.html">Replacing and Deleting Health Checks</a>
    /// 				in the <i>Amazon Route 53 Developer Guide</i>.</p>
    /// 		       </important>
    /// 		
    /// 		       <p>If you're using AWS Cloud Map and you configured Cloud Map to create a Route 53 health check when you register an instance,
    /// 			you can't use the Route 53 <code>DeleteHealthCheck</code> command to delete the health check. The health check is deleted
    /// 			automatically when you deregister the instance; there can be a delay of several hours before the health check is deleted
    /// 			from Route 53. </p>
    public func deleteHealthCheck(input: DeleteHealthCheckInput, completion: @escaping (SdkResult<DeleteHealthCheckOutput, DeleteHealthCheckOutputError>) -> Void)
    {
        guard let healthCheckId = input.healthCheckId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component healthCheckId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/healthcheck/\(healthCheckId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteHealthCheck")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteHealthCheckInput, DeleteHealthCheckOutput, DeleteHealthCheckOutputError>(id: "deleteHealthCheck")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteHealthCheckInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteHealthCheckInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteHealthCheckInput, DeleteHealthCheckOutput, DeleteHealthCheckOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a hosted zone.</p>
    /// 		
    /// 		       <p>If the hosted zone was created by another service, such as AWS Cloud Map, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DeleteHostedZone.html#delete-public-hosted-zone-created-by-another-service">Deleting
    /// 			Public Hosted Zones That Were Created by Another Service</a> in the <i>Amazon Route 53 Developer Guide</i> for information about how to delete it.
    /// 			(The process is the same for public and private hosted zones that were created by another service.)</p>
    /// 		
    /// 		       <p>If you want to keep your domain registration but you want to stop routing internet traffic to your website or web application,
    /// 			we recommend that you delete resource record sets in the hosted zone instead of deleting the hosted zone.</p>
    /// 		
    /// 		       <important>
    /// 			         <p>If you delete a hosted zone, you can't undelete it. You must create a new hosted zone and update the name servers for your
    /// 				domain registration, which can require up to 48 hours to take effect. (If you delegated responsibility for a subdomain to a hosted zone
    /// 				and you delete the child hosted zone, you must update the name servers in the parent hosted zone.) In addition, if you delete a hosted zone,
    /// 				someone could hijack the domain and route traffic to their own resources using your domain name.</p>
    /// 		       </important>
    /// 		
    /// 		       <p>If you want to avoid the monthly charge for the hosted zone, you can transfer DNS service for the domain to a free DNS service.
    /// 			When you transfer DNS service, you have to update the name servers for the domain registration. If the domain is registered with Route 53,
    /// 			see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_UpdateDomainNameservers.html">UpdateDomainNameservers</a>
    /// 			for information about how to replace Route 53 name servers with name servers for the new DNS service. If the domain is registered with
    /// 			another registrar, use the method provided by the registrar to update name servers for the domain registration. For more information,
    /// 			perform an internet search on "free DNS service."</p>
    ///
    /// 		       <p>You can delete a hosted zone only if it contains only the default SOA record and NS resource record sets.
    /// 			If the hosted zone contains other resource record sets, you must delete them before you can delete the hosted zone.
    /// 			If you try to delete a hosted zone that contains other resource record sets, the request fails, and Route 53 returns a
    /// 			<code>HostedZoneNotEmpty</code> error. For information about deleting records from your hosted zone, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ChangeResourceRecordSets.html">ChangeResourceRecordSets</a>.</p>
    /// 		       <p>To verify that the hosted zone has been deleted, do one of the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Use the <code>GetHostedZone</code> action to request information about the hosted zone.</p>
    ///             </li>
    ///             <li>
    ///                <p>Use the <code>ListHostedZones</code> action to get a list of the hosted zones associated with the current
    /// 				AWS account.</p>
    ///             </li>
    ///          </ul>
    public func deleteHostedZone(input: DeleteHostedZoneInput, completion: @escaping (SdkResult<DeleteHostedZoneOutput, DeleteHostedZoneOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteHostedZone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteHostedZoneInput, DeleteHostedZoneOutput, DeleteHostedZoneOutputError>(id: "deleteHostedZone")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteHostedZoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteHostedZoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteHostedZoneInput, DeleteHostedZoneOutput, DeleteHostedZoneOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a key-signing key (KSK). Before you can delete a KSK, you must deactivate it. The KSK must be
    /// 		deactivated before you can delete it regardless of whether the hosted zone is enabled for DNSSEC signing.</p>
    public func deleteKeySigningKey(input: DeleteKeySigningKeyInput, completion: @escaping (SdkResult<DeleteKeySigningKeyOutput, DeleteKeySigningKeyOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/keysigningkey/\(hostedZoneId)/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteKeySigningKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteKeySigningKeyInput, DeleteKeySigningKeyOutput, DeleteKeySigningKeyOutputError>(id: "deleteKeySigningKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteKeySigningKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteKeySigningKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteKeySigningKeyInput, DeleteKeySigningKeyOutput, DeleteKeySigningKeyOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a configuration for DNS query logging. If you delete a configuration, Amazon Route 53 stops sending query logs to CloudWatch Logs.
    /// 			Route 53 doesn't delete any logs that are already in CloudWatch Logs.</p>
    /// 		
    /// 		       <p>For more information about DNS query logs, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateQueryLoggingConfig.html">CreateQueryLoggingConfig</a>.</p>
    public func deleteQueryLoggingConfig(input: DeleteQueryLoggingConfigInput, completion: @escaping (SdkResult<DeleteQueryLoggingConfigOutput, DeleteQueryLoggingConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/queryloggingconfig/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteQueryLoggingConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteQueryLoggingConfigInput, DeleteQueryLoggingConfigOutput, DeleteQueryLoggingConfigOutputError>(id: "deleteQueryLoggingConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteQueryLoggingConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteQueryLoggingConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteQueryLoggingConfigInput, DeleteQueryLoggingConfigOutput, DeleteQueryLoggingConfigOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a reusable delegation set.</p>
    /// 		       <important>
    /// 			         <p>You can delete a reusable delegation set only if it isn't associated with any hosted zones.</p>
    /// 		       </important>
    /// 		       <p>To verify that the reusable delegation set is not associated with any hosted zones, submit a
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetReusableDelegationSet.html">GetReusableDelegationSet</a>
    /// 			request and specify the ID of the reusable delegation set that you want to delete.</p>
    public func deleteReusableDelegationSet(input: DeleteReusableDelegationSetInput, completion: @escaping (SdkResult<DeleteReusableDelegationSetOutput, DeleteReusableDelegationSetOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/delegationset/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteReusableDelegationSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteReusableDelegationSetInput, DeleteReusableDelegationSetOutput, DeleteReusableDelegationSetOutputError>(id: "deleteReusableDelegationSet")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteReusableDelegationSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteReusableDelegationSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteReusableDelegationSetInput, DeleteReusableDelegationSetOutput, DeleteReusableDelegationSetOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a traffic policy.</p>
    /// 		       <p>When you delete a traffic policy, Route 53 sets a flag on the policy to indicate that it has been deleted. However, Route 53 never fully deletes
    /// 			the traffic policy. Note the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Deleted traffic policies aren't listed if you run <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListTrafficPolicies.html">ListTrafficPolicies</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>	There's no way to get a list of deleted policies.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you retain the ID of the policy, you can get information about the policy, including the traffic policy document, by running
    /// 				<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetTrafficPolicy.html">GetTrafficPolicy</a>.</p>
    ///             </li>
    ///          </ul>
    public func deleteTrafficPolicy(input: DeleteTrafficPolicyInput, completion: @escaping (SdkResult<DeleteTrafficPolicyOutput, DeleteTrafficPolicyOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        guard let version = input.version else {
            completion(.failure(.client(ClientError.serializationFailed("uri component version unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/trafficpolicy/\(id)/\(version)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTrafficPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteTrafficPolicyInput, DeleteTrafficPolicyOutput, DeleteTrafficPolicyOutputError>(id: "deleteTrafficPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteTrafficPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteTrafficPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteTrafficPolicyInput, DeleteTrafficPolicyOutput, DeleteTrafficPolicyOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a traffic policy instance and all of the resource record sets that Amazon Route 53 created when you created the instance.</p>
    /// 		       <note>
    /// 			         <p>In the Route 53 console, traffic policy instances are known as policy records.</p>
    /// 		       </note>
    public func deleteTrafficPolicyInstance(input: DeleteTrafficPolicyInstanceInput, completion: @escaping (SdkResult<DeleteTrafficPolicyInstanceOutput, DeleteTrafficPolicyInstanceOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/trafficpolicyinstance/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTrafficPolicyInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteTrafficPolicyInstanceInput, DeleteTrafficPolicyInstanceOutput, DeleteTrafficPolicyInstanceOutputError>(id: "deleteTrafficPolicyInstance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteTrafficPolicyInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteTrafficPolicyInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteTrafficPolicyInstanceInput, DeleteTrafficPolicyInstanceOutput, DeleteTrafficPolicyInstanceOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes authorization to submit an <code>AssociateVPCWithHostedZone</code> request to associate a specified VPC
    /// 			with a hosted zone that was created by a different account. You must use the account that created the hosted zone
    /// 			to submit a <code>DeleteVPCAssociationAuthorization</code> request.</p>
    /// 		       <important>
    /// 			         <p>Sending this request only prevents the AWS account that created the VPC from associating the VPC
    /// 				with the Amazon Route 53 hosted zone in the future. If the VPC is already associated with the hosted zone,
    /// 				<code>DeleteVPCAssociationAuthorization</code> won't disassociate the VPC from the hosted zone.
    /// 				If you want to delete an existing association, use <code>DisassociateVPCFromHostedZone</code>.</p>
    /// 		       </important>
    public func deleteVPCAssociationAuthorization(input: DeleteVPCAssociationAuthorizationInput, completion: @escaping (SdkResult<DeleteVPCAssociationAuthorizationOutput, DeleteVPCAssociationAuthorizationOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(hostedZoneId)/deauthorizevpcassociation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVPCAssociationAuthorization")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteVPCAssociationAuthorizationInput, DeleteVPCAssociationAuthorizationOutput, DeleteVPCAssociationAuthorizationOutputError>(id: "deleteVPCAssociationAuthorization")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteVPCAssociationAuthorizationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteVPCAssociationAuthorizationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteVPCAssociationAuthorizationInput, DeleteVPCAssociationAuthorizationOutput, DeleteVPCAssociationAuthorizationOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteVPCAssociationAuthorizationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disables DNSSEC signing in a specific hosted zone. This action does not deactivate any key-signing keys (KSKs)
    /// 		that are active in the hosted zone.</p>
    public func disableHostedZoneDNSSEC(input: DisableHostedZoneDNSSECInput, completion: @escaping (SdkResult<DisableHostedZoneDNSSECOutput, DisableHostedZoneDNSSECOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(hostedZoneId)/disable-dnssec"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disableHostedZoneDNSSEC")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisableHostedZoneDNSSECInput, DisableHostedZoneDNSSECOutput, DisableHostedZoneDNSSECOutputError>(id: "disableHostedZoneDNSSEC")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisableHostedZoneDNSSECInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisableHostedZoneDNSSECInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisableHostedZoneDNSSECInput, DisableHostedZoneDNSSECOutput, DisableHostedZoneDNSSECOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disassociates an Amazon Virtual Private Cloud (Amazon VPC) from an Amazon Route 53 private hosted zone. Note the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>You can't disassociate the last Amazon VPC from a private hosted zone.</p>
    ///             </li>
    ///             <li>
    ///                <p>You can't convert a private hosted zone into a public hosted zone.</p>
    ///             </li>
    ///             <li>
    ///                <p>You can submit a <code>DisassociateVPCFromHostedZone</code> request using either the account
    /// 				that created the hosted zone or the account that created the Amazon VPC.</p>
    ///             </li>
    ///             <li>
    ///                <p>Some services, such as AWS Cloud Map and Amazon Elastic File System (Amazon EFS) automatically create hosted zones and associate
    /// 				VPCs with the hosted zones. A service can create a hosted zone using your account or using its own account.
    /// 				You can disassociate a VPC from a hosted zone only if the service created the hosted zone using your account.</p>
    /// 				           <p>When you run <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListHostedZonesByVPC.html">DisassociateVPCFromHostedZone</a>,
    /// 					if the hosted zone has a value for <code>OwningAccount</code>, you can use <code>DisassociateVPCFromHostedZone</code>.
    /// 					If the hosted zone has a value for <code>OwningService</code>, you can't use <code>DisassociateVPCFromHostedZone</code>.</p>
    /// 			         </li>
    ///          </ul>
    public func disassociateVPCFromHostedZone(input: DisassociateVPCFromHostedZoneInput, completion: @escaping (SdkResult<DisassociateVPCFromHostedZoneOutput, DisassociateVPCFromHostedZoneOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(hostedZoneId)/disassociatevpc"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateVPCFromHostedZone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateVPCFromHostedZoneInput, DisassociateVPCFromHostedZoneOutput, DisassociateVPCFromHostedZoneOutputError>(id: "disassociateVPCFromHostedZone")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateVPCFromHostedZoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateVPCFromHostedZoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateVPCFromHostedZoneInput, DisassociateVPCFromHostedZoneOutput, DisassociateVPCFromHostedZoneOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: DisassociateVPCFromHostedZoneInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Enables DNSSEC signing in a specific hosted zone.</p>
    public func enableHostedZoneDNSSEC(input: EnableHostedZoneDNSSECInput, completion: @escaping (SdkResult<EnableHostedZoneDNSSECOutput, EnableHostedZoneDNSSECOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(hostedZoneId)/enable-dnssec"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "enableHostedZoneDNSSEC")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<EnableHostedZoneDNSSECInput, EnableHostedZoneDNSSECOutput, EnableHostedZoneDNSSECOutputError>(id: "enableHostedZoneDNSSEC")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: EnableHostedZoneDNSSECInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: EnableHostedZoneDNSSECInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<EnableHostedZoneDNSSECInput, EnableHostedZoneDNSSECOutput, EnableHostedZoneDNSSECOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the specified limit for the current account, for example, the maximum number of health checks that you
    /// 			can create using the account.</p>
    /// 		       <p>For the default limit, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a>
    /// 			in the <i>Amazon Route 53 Developer Guide</i>. To request a higher limit,
    /// 			<a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-route53">open a case</a>.</p>
    /// 		       <note>
    ///             <p>You can also view account limits in AWS Trusted Advisor. Sign in to the AWS Management Console and open the Trusted Advisor console at
    /// 			<a href="https://console.aws.amazon.com/trustedadvisor">https://console.aws.amazon.com/trustedadvisor/</a>. Then choose
    /// 			<b>Service limits</b> in the navigation pane.</p>
    /// 		       </note>
    public func getAccountLimit(input: GetAccountLimitInput, completion: @escaping (SdkResult<GetAccountLimitOutput, GetAccountLimitOutputError>) -> Void)
    {
        guard let type = input.type else {
            completion(.failure(.client(ClientError.serializationFailed("uri component type unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/accountlimit/\(type.rawValue)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAccountLimit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAccountLimitInput, GetAccountLimitOutput, GetAccountLimitOutputError>(id: "getAccountLimit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAccountLimitInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAccountLimitInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAccountLimitInput, GetAccountLimitOutput, GetAccountLimitOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the current status of a change batch request. The status is one of the
    /// 			following values:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>PENDING</code> indicates that the changes in this request have not propagated to all Amazon Route 53 DNS servers.
    /// 					This is the initial status of all change batch requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>INSYNC</code> indicates that the changes have propagated to all Route 53 DNS servers. </p>
    /// 			         </li>
    ///          </ul>
    public func getChange(input: GetChangeInput, completion: @escaping (SdkResult<GetChangeOutput, GetChangeOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/change/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getChange")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetChangeInput, GetChangeOutput, GetChangeOutputError>(id: "getChange")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetChangeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetChangeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetChangeInput, GetChangeOutput, GetChangeOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Route 53 does not perform authorization for this API because it retrieves information that is already available to the public.</p>
    /// 	        <important>
    /// 			         <p>
    ///                <code>GetCheckerIpRanges</code> still works, but we recommend that you download
    /// 			ip-ranges.json, which includes IP address ranges for all AWS services. For more information, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/route-53-ip-addresses.html">IP Address Ranges of Amazon Route 53 Servers</a>
    /// 			in the <i>Amazon Route 53 Developer Guide</i>.</p>
    /// 		       </important>
    public func getCheckerIpRanges(input: GetCheckerIpRangesInput, completion: @escaping (SdkResult<GetCheckerIpRangesOutput, GetCheckerIpRangesOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/checkeripranges"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCheckerIpRanges")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCheckerIpRangesInput, GetCheckerIpRangesOutput, GetCheckerIpRangesOutputError>(id: "getCheckerIpRanges")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCheckerIpRangesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCheckerIpRangesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCheckerIpRangesInput, GetCheckerIpRangesOutput, GetCheckerIpRangesOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about DNSSEC for a specific hosted zone, including the key-signing keys (KSKs) in the hosted zone.</p>
    public func getDNSSEC(input: GetDNSSECInput, completion: @escaping (SdkResult<GetDNSSECOutput, GetDNSSECOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(hostedZoneId)/dnssec"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDNSSEC")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDNSSECInput, GetDNSSECOutput, GetDNSSECOutputError>(id: "getDNSSEC")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDNSSECInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDNSSECInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDNSSECInput, GetDNSSECOutput, GetDNSSECOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about whether a specified geographic location is supported for Amazon Route 53 geolocation
    /// 			resource record sets.</p>
    /// 	        <p>Route 53 does not perform authorization for this API because it retrieves information that is already available to the public.</p>
    /// 		
    /// 		       <p>Use the following syntax to determine whether a continent is supported for geolocation:</p>
    /// 		       <p>
    ///             <code>GET /2013-04-01/geolocation?continentcode=<i>two-letter abbreviation for a continent</i>
    ///             </code>
    ///          </p>
    /// 		
    /// 		       <p>Use the following syntax to determine whether a country is supported for geolocation:</p>
    /// 		       <p>
    ///             <code>GET /2013-04-01/geolocation?countrycode=<i>two-character country code</i>
    ///             </code>
    ///          </p>
    /// 		
    /// 		       <p>Use the following syntax to determine whether a subdivision of a country is supported for geolocation:</p>
    /// 		       <p>
    ///             <code>GET /2013-04-01/geolocation?countrycode=<i>two-character country code</i>&subdivisioncode=<i>subdivision code</i>
    ///             </code>
    ///          </p>
    public func getGeoLocation(input: GetGeoLocationInput, completion: @escaping (SdkResult<GetGeoLocationOutput, GetGeoLocationOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/geolocation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getGeoLocation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetGeoLocationInput, GetGeoLocationOutput, GetGeoLocationOutputError>(id: "getGeoLocation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetGeoLocationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetGeoLocationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetGeoLocationInput, GetGeoLocationOutput, GetGeoLocationOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a specified health check.</p>
    public func getHealthCheck(input: GetHealthCheckInput, completion: @escaping (SdkResult<GetHealthCheckOutput, GetHealthCheckOutputError>) -> Void)
    {
        guard let healthCheckId = input.healthCheckId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component healthCheckId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/healthcheck/\(healthCheckId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHealthCheck")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetHealthCheckInput, GetHealthCheckOutput, GetHealthCheckOutputError>(id: "getHealthCheck")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetHealthCheckInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetHealthCheckInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetHealthCheckInput, GetHealthCheckOutput, GetHealthCheckOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the number of health checks that are associated with the current AWS account.</p>
    public func getHealthCheckCount(input: GetHealthCheckCountInput, completion: @escaping (SdkResult<GetHealthCheckCountOutput, GetHealthCheckCountOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/healthcheckcount"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHealthCheckCount")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetHealthCheckCountInput, GetHealthCheckCountOutput, GetHealthCheckCountOutputError>(id: "getHealthCheckCount")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetHealthCheckCountInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetHealthCheckCountInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetHealthCheckCountInput, GetHealthCheckCountOutput, GetHealthCheckCountOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the reason that a specified health check failed most recently.</p>
    public func getHealthCheckLastFailureReason(input: GetHealthCheckLastFailureReasonInput, completion: @escaping (SdkResult<GetHealthCheckLastFailureReasonOutput, GetHealthCheckLastFailureReasonOutputError>) -> Void)
    {
        guard let healthCheckId = input.healthCheckId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component healthCheckId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/healthcheck/\(healthCheckId)/lastfailurereason"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHealthCheckLastFailureReason")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetHealthCheckLastFailureReasonInput, GetHealthCheckLastFailureReasonOutput, GetHealthCheckLastFailureReasonOutputError>(id: "getHealthCheckLastFailureReason")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetHealthCheckLastFailureReasonInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetHealthCheckLastFailureReasonInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetHealthCheckLastFailureReasonInput, GetHealthCheckLastFailureReasonOutput, GetHealthCheckLastFailureReasonOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets status of a specified health check. </p>
    public func getHealthCheckStatus(input: GetHealthCheckStatusInput, completion: @escaping (SdkResult<GetHealthCheckStatusOutput, GetHealthCheckStatusOutputError>) -> Void)
    {
        guard let healthCheckId = input.healthCheckId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component healthCheckId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/healthcheck/\(healthCheckId)/status"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHealthCheckStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetHealthCheckStatusInput, GetHealthCheckStatusOutput, GetHealthCheckStatusOutputError>(id: "getHealthCheckStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetHealthCheckStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetHealthCheckStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetHealthCheckStatusInput, GetHealthCheckStatusOutput, GetHealthCheckStatusOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a specified hosted zone including the four name servers assigned to the hosted zone.</p>
    public func getHostedZone(input: GetHostedZoneInput, completion: @escaping (SdkResult<GetHostedZoneOutput, GetHostedZoneOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHostedZone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetHostedZoneInput, GetHostedZoneOutput, GetHostedZoneOutputError>(id: "getHostedZone")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetHostedZoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetHostedZoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetHostedZoneInput, GetHostedZoneOutput, GetHostedZoneOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the number of hosted zones that are associated with the current AWS account.</p>
    public func getHostedZoneCount(input: GetHostedZoneCountInput, completion: @escaping (SdkResult<GetHostedZoneCountOutput, GetHostedZoneCountOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/hostedzonecount"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHostedZoneCount")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetHostedZoneCountInput, GetHostedZoneCountOutput, GetHostedZoneCountOutputError>(id: "getHostedZoneCount")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetHostedZoneCountInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetHostedZoneCountInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetHostedZoneCountInput, GetHostedZoneCountOutput, GetHostedZoneCountOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the specified limit for a specified hosted zone, for example, the maximum number of records that you
    /// 			can create in the hosted zone. </p>
    /// 		       <p>For the default limit, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a>
    /// 			in the <i>Amazon Route 53 Developer Guide</i>. To request a higher limit,
    /// 			<a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-route53">open a case</a>.</p>
    public func getHostedZoneLimit(input: GetHostedZoneLimitInput, completion: @escaping (SdkResult<GetHostedZoneLimitOutput, GetHostedZoneLimitOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        guard let type = input.type else {
            completion(.failure(.client(ClientError.serializationFailed("uri component type unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzonelimit/\(hostedZoneId)/\(type.rawValue)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHostedZoneLimit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetHostedZoneLimitInput, GetHostedZoneLimitOutput, GetHostedZoneLimitOutputError>(id: "getHostedZoneLimit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetHostedZoneLimitInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetHostedZoneLimitInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetHostedZoneLimitInput, GetHostedZoneLimitOutput, GetHostedZoneLimitOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a specified configuration for DNS query logging.</p>
    /// 		
    /// 		       <p>For more information about DNS query logs, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateQueryLoggingConfig.html">CreateQueryLoggingConfig</a>
    /// 			and
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html">Logging DNS Queries</a>.</p>
    public func getQueryLoggingConfig(input: GetQueryLoggingConfigInput, completion: @escaping (SdkResult<GetQueryLoggingConfigOutput, GetQueryLoggingConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/queryloggingconfig/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getQueryLoggingConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetQueryLoggingConfigInput, GetQueryLoggingConfigOutput, GetQueryLoggingConfigOutputError>(id: "getQueryLoggingConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetQueryLoggingConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetQueryLoggingConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetQueryLoggingConfigInput, GetQueryLoggingConfigOutput, GetQueryLoggingConfigOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves information about a specified reusable delegation set, including the four name servers that are assigned
    /// 			to the delegation set.</p>
    public func getReusableDelegationSet(input: GetReusableDelegationSetInput, completion: @escaping (SdkResult<GetReusableDelegationSetOutput, GetReusableDelegationSetOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/delegationset/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getReusableDelegationSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetReusableDelegationSetInput, GetReusableDelegationSetOutput, GetReusableDelegationSetOutputError>(id: "getReusableDelegationSet")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetReusableDelegationSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetReusableDelegationSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetReusableDelegationSetInput, GetReusableDelegationSetOutput, GetReusableDelegationSetOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the maximum number of hosted zones that you can associate with the specified reusable delegation set.</p>
    /// 		       <p>For the default limit, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a>
    /// 			in the <i>Amazon Route 53 Developer Guide</i>. To request a higher limit,
    /// 			<a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-route53">open a case</a>.</p>
    public func getReusableDelegationSetLimit(input: GetReusableDelegationSetLimitInput, completion: @escaping (SdkResult<GetReusableDelegationSetLimitOutput, GetReusableDelegationSetLimitOutputError>) -> Void)
    {
        guard let delegationSetId = input.delegationSetId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component delegationSetId unexpectedly nil"))))
            return
        }
        guard let type = input.type else {
            completion(.failure(.client(ClientError.serializationFailed("uri component type unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/reusabledelegationsetlimit/\(delegationSetId)/\(type.rawValue)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getReusableDelegationSetLimit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetReusableDelegationSetLimitInput, GetReusableDelegationSetLimitOutput, GetReusableDelegationSetLimitOutputError>(id: "getReusableDelegationSetLimit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetReusableDelegationSetLimitInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetReusableDelegationSetLimitInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetReusableDelegationSetLimitInput, GetReusableDelegationSetLimitOutput, GetReusableDelegationSetLimitOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a specific traffic policy version.</p>
    /// 		       <p>For information about how of deleting a traffic policy affects the response from <code>GetTrafficPolicy</code>, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_DeleteTrafficPolicy.html">DeleteTrafficPolicy</a>.
    /// 		</p>
    public func getTrafficPolicy(input: GetTrafficPolicyInput, completion: @escaping (SdkResult<GetTrafficPolicyOutput, GetTrafficPolicyOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        guard let version = input.version else {
            completion(.failure(.client(ClientError.serializationFailed("uri component version unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/trafficpolicy/\(id)/\(version)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getTrafficPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetTrafficPolicyInput, GetTrafficPolicyOutput, GetTrafficPolicyOutputError>(id: "getTrafficPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetTrafficPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetTrafficPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetTrafficPolicyInput, GetTrafficPolicyOutput, GetTrafficPolicyOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a specified traffic policy instance.</p>
    /// 		       <note>
    /// 			         <p>After you submit a <code>CreateTrafficPolicyInstance</code> or an <code>UpdateTrafficPolicyInstance</code> request,
    /// 				there's a brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For
    /// 				more information, see the <code>State</code> response element.</p>
    /// 		       </note>
    /// 		       <note>
    /// 			         <p>In the Route 53 console, traffic policy instances are known as policy records.</p>
    /// 		       </note>
    public func getTrafficPolicyInstance(input: GetTrafficPolicyInstanceInput, completion: @escaping (SdkResult<GetTrafficPolicyInstanceOutput, GetTrafficPolicyInstanceOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/trafficpolicyinstance/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getTrafficPolicyInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetTrafficPolicyInstanceInput, GetTrafficPolicyInstanceOutput, GetTrafficPolicyInstanceOutputError>(id: "getTrafficPolicyInstance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetTrafficPolicyInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetTrafficPolicyInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetTrafficPolicyInstanceInput, GetTrafficPolicyInstanceOutput, GetTrafficPolicyInstanceOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the number of traffic policy instances that are associated with the current AWS account.</p>
    public func getTrafficPolicyInstanceCount(input: GetTrafficPolicyInstanceCountInput, completion: @escaping (SdkResult<GetTrafficPolicyInstanceCountOutput, GetTrafficPolicyInstanceCountOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/trafficpolicyinstancecount"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getTrafficPolicyInstanceCount")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetTrafficPolicyInstanceCountInput, GetTrafficPolicyInstanceCountOutput, GetTrafficPolicyInstanceCountOutputError>(id: "getTrafficPolicyInstanceCount")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetTrafficPolicyInstanceCountInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetTrafficPolicyInstanceCountInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetTrafficPolicyInstanceCountInput, GetTrafficPolicyInstanceCountOutput, GetTrafficPolicyInstanceCountOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of supported geographic locations.</p>
    /// 		       <p>Countries are listed first, and continents are listed last. If Amazon Route 53 supports subdivisions for a country (for example, states or provinces),
    /// 			the subdivisions for that country are listed in alphabetical order immediately after the corresponding country.</p>
    /// 	        <p>Route 53 does not perform authorization for this API because it retrieves information that is already available to the public.</p>
    /// 	        <p>For a list of supported geolocation codes, see the
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GeoLocation.html">GeoLocation</a> data type.</p>
    public func listGeoLocations(input: ListGeoLocationsInput, completion: @escaping (SdkResult<ListGeoLocationsOutput, ListGeoLocationsOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/geolocations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listGeoLocations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListGeoLocationsInput, ListGeoLocationsOutput, ListGeoLocationsOutputError>(id: "listGeoLocations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListGeoLocationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListGeoLocationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListGeoLocationsInput, ListGeoLocationsOutput, ListGeoLocationsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieve a list of the health checks that are associated with the current AWS account. </p>
    public func listHealthChecks(input: ListHealthChecksInput, completion: @escaping (SdkResult<ListHealthChecksOutput, ListHealthChecksOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/healthcheck"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listHealthChecks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListHealthChecksInput, ListHealthChecksOutput, ListHealthChecksOutputError>(id: "listHealthChecks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListHealthChecksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListHealthChecksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListHealthChecksInput, ListHealthChecksOutput, ListHealthChecksOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of the public and private hosted zones that are associated with the current AWS account. The response
    /// 			includes a <code>HostedZones</code> child element for each hosted zone.</p>
    /// 		       <p>Amazon Route 53 returns a maximum of 100 items in each response. If you have a lot of hosted zones, you can use the
    /// 			<code>maxitems</code> parameter to list them in groups of up to 100.</p>
    public func listHostedZones(input: ListHostedZonesInput, completion: @escaping (SdkResult<ListHostedZonesOutput, ListHostedZonesOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/hostedzone"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listHostedZones")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListHostedZonesInput, ListHostedZonesOutput, ListHostedZonesOutputError>(id: "listHostedZones")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListHostedZonesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListHostedZonesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListHostedZonesInput, ListHostedZonesOutput, ListHostedZonesOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of your hosted zones in lexicographic order. The response includes a <code>HostedZones</code> child element
    /// 			for each hosted zone created by the current AWS account. </p>
    /// 		       <p>
    ///             <code>ListHostedZonesByName</code> sorts hosted zones by name with the labels reversed. For example:</p>
    ///
    /// 		       <p>
    ///             <code>com.example.www.</code>
    ///          </p>
    ///
    /// 		       <p>Note the trailing dot, which can change the sort order in some circumstances.</p>
    /// 		       <p>If the domain name includes escape characters or Punycode, <code>ListHostedZonesByName</code> alphabetizes the domain name
    /// 			using the escaped or Punycoded value, which is the format that Amazon Route 53 saves in its database. For example, to create a hosted zone
    /// 			for exämple.com, you specify ex\344mple.com for the domain name. <code>ListHostedZonesByName</code> alphabetizes it as:</p>
    ///
    /// 		       <p>
    ///             <code>com.ex\344mple.</code>
    ///          </p>
    /// 		
    /// 		       <p>The labels are reversed and alphabetized using the escaped value. For more information about valid domain name formats,
    /// 			including internationalized domain names, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html">DNS Domain Name Format</a> in the
    /// 			<i>Amazon Route 53 Developer Guide</i>.</p>
    /// 		       <p>Route 53 returns up to 100 items in each response. If you have a lot of hosted zones, use the <code>MaxItems</code> parameter to list
    /// 			them in groups of up to 100. The response includes values that help navigate from one group of <code>MaxItems</code> hosted zones to the next:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The <code>DNSName</code> and <code>HostedZoneId</code> elements in the response contain the values, if any, specified for the
    /// 					<code>dnsname</code> and <code>hostedzoneid</code> parameters in the request that produced the current response.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The <code>MaxItems</code> element in the response contains the value, if any, that you specified for the <code>maxitems</code>
    /// 					parameter in the request that produced the current response.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>If the value of <code>IsTruncated</code> in the response is true, there are more hosted zones associated with the
    /// 					current AWS account. </p>
    /// 				           <p>If <code>IsTruncated</code> is false, this response includes the last hosted zone that is associated with the current account.
    /// 					The <code>NextDNSName</code> element and <code>NextHostedZoneId</code> elements are omitted from the response.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The <code>NextDNSName</code> and <code>NextHostedZoneId</code> elements in the response contain the domain name and the
    /// 					hosted zone ID of the next hosted zone that is associated with the current AWS account. If you want to list more hosted zones,
    /// 					make another call to <code>ListHostedZonesByName</code>, and specify the value of <code>NextDNSName</code> and
    /// 					<code>NextHostedZoneId</code> in the <code>dnsname</code> and <code>hostedzoneid</code> parameters, respectively.</p>
    /// 			         </li>
    ///          </ul>
    public func listHostedZonesByName(input: ListHostedZonesByNameInput, completion: @escaping (SdkResult<ListHostedZonesByNameOutput, ListHostedZonesByNameOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/hostedzonesbyname"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listHostedZonesByName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListHostedZonesByNameInput, ListHostedZonesByNameOutput, ListHostedZonesByNameOutputError>(id: "listHostedZonesByName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListHostedZonesByNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListHostedZonesByNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListHostedZonesByNameInput, ListHostedZonesByNameOutput, ListHostedZonesByNameOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all the private hosted zones that a specified VPC is associated with, regardless of which AWS account or AWS service owns the
    /// 			hosted zones. The <code>HostedZoneOwner</code> structure in the response contains one of the following values:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>An <code>OwningAccount</code> element, which contains the account number of either the current AWS account or
    /// 				another AWS account. Some services, such as AWS Cloud Map, create hosted zones using the current account. </p>
    /// 			         </li>
    ///             <li>
    ///                <p>An <code>OwningService</code> element, which identifies the AWS service that created and owns the hosted zone.
    /// 				For example, if a hosted zone was created by Amazon Elastic File System (Amazon EFS), the value of <code>Owner</code> is
    /// 				<code>efs.amazonaws.com</code>. </p>
    /// 			         </li>
    ///          </ul>
    public func listHostedZonesByVPC(input: ListHostedZonesByVPCInput, completion: @escaping (SdkResult<ListHostedZonesByVPCOutput, ListHostedZonesByVPCOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/hostedzonesbyvpc"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listHostedZonesByVPC")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListHostedZonesByVPCInput, ListHostedZonesByVPCOutput, ListHostedZonesByVPCOutputError>(id: "listHostedZonesByVPC")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListHostedZonesByVPCInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListHostedZonesByVPCInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListHostedZonesByVPCInput, ListHostedZonesByVPCOutput, ListHostedZonesByVPCOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the configurations for DNS query logging that are associated with the current AWS account or the configuration
    /// 			that is associated with a specified hosted zone.</p>
    ///
    /// 		       <p>For more information about DNS query logs, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateQueryLoggingConfig.html">CreateQueryLoggingConfig</a>.
    /// 			Additional information, including the format of DNS query logs, appears in
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html">Logging DNS Queries</a>
    /// 			in the <i>Amazon Route 53 Developer Guide</i>.</p>
    public func listQueryLoggingConfigs(input: ListQueryLoggingConfigsInput, completion: @escaping (SdkResult<ListQueryLoggingConfigsOutput, ListQueryLoggingConfigsOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/queryloggingconfig"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listQueryLoggingConfigs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListQueryLoggingConfigsInput, ListQueryLoggingConfigsOutput, ListQueryLoggingConfigsOutputError>(id: "listQueryLoggingConfigs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListQueryLoggingConfigsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListQueryLoggingConfigsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListQueryLoggingConfigsInput, ListQueryLoggingConfigsOutput, ListQueryLoggingConfigsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the resource record sets in a specified hosted zone.</p>
    /// 		       <p>
    ///             <code>ListResourceRecordSets</code> returns up to 300 resource record sets at a time in ASCII order,
    /// 			beginning at a position specified by the <code>name</code> and <code>type</code> elements.</p>
    /// 		
    /// 		       <p>
    ///             <b>Sort order</b>
    ///          </p>
    /// 			      <p>
    ///             <code>ListResourceRecordSets</code> sorts results first by DNS name with the labels reversed, for example:</p>
    /// 			      <p>
    ///             <code>com.example.www.</code>
    ///          </p>
    /// 			      <p>Note the trailing dot, which can change the sort order when the record name contains characters that appear before
    /// 				<code>.</code> (decimal 46) in the ASCII table. These characters include the following: <code>! " # $ % & ' ( ) * + , -</code>
    ///          </p>
    /// 			      <p>When multiple records have the same DNS name, <code>ListResourceRecordSets</code> sorts results by the record type.</p>
    /// 		
    /// 		       <p>
    ///             <b>Specifying where to start listing records</b>
    ///          </p>
    /// 			      <p>You can use the name and type elements to specify the resource record set that the list begins with:</p>
    /// 			      <dl>
    ///             <dt>If you do not specify Name or Type</dt>
    ///             <dd>
    ///                <p>The results begin with the first resource record set that the hosted zone contains.</p>
    ///             </dd>
    ///             <dt>If you specify Name but not Type</dt>
    ///             <dd>
    ///                <p>The results begin with the first resource record set in the list whose name is greater than or equal to
    /// 						<code>Name</code>.</p>
    ///             </dd>
    ///             <dt>If you specify Type but not Name</dt>
    ///             <dd>
    ///                <p>Amazon Route 53 returns the <code>InvalidInput</code> error.</p>
    ///             </dd>
    ///             <dt>If you specify both Name and Type</dt>
    ///             <dd>
    ///                <p>The results begin with the first resource record set in the list whose name is greater than or equal to
    /// 						<code>Name</code>, and whose type is greater than or equal to <code>Type</code>.</p>
    ///             </dd>
    ///          </dl>
    /// 		
    /// 		       <p>
    ///             <b>Resource record sets that are PENDING</b>
    ///          </p>
    /// 			      <p>This action returns the most current version of the records. This includes records that are <code>PENDING</code>,
    /// 				and that are not yet available on all Route 53 DNS servers.</p>
    /// 		
    /// 		       <p>
    ///             <b>Changing resource record sets</b>
    ///          </p>
    /// 			      <p>To ensure that you get an accurate listing of the resource record sets for a hosted zone at a point in time,
    /// 				do not submit a <code>ChangeResourceRecordSets</code> request while you're paging through the results of a
    /// 				<code>ListResourceRecordSets</code> request. If you do, some pages may display results without the latest changes
    /// 				while other pages display results with the latest changes.</p>
    /// 		
    /// 		       <p>
    ///             <b>Displaying the next page of results</b>
    ///          </p>
    /// 			      <p>If a <code>ListResourceRecordSets</code> command returns more than one page of results, the value of <code>IsTruncated</code>
    /// 				is <code>true</code>. To display the next page of results, get the values of <code>NextRecordName</code>, <code>NextRecordType</code>,
    /// 				and <code>NextRecordIdentifier</code> (if any) from the response. Then submit another <code>ListResourceRecordSets</code> request, and
    /// 				specify those values for <code>StartRecordName</code>, <code>StartRecordType</code>, and <code>StartRecordIdentifier</code>.</p>
    public func listResourceRecordSets(input: ListResourceRecordSetsInput, completion: @escaping (SdkResult<ListResourceRecordSetsOutput, ListResourceRecordSetsOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(hostedZoneId)/rrset"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listResourceRecordSets")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListResourceRecordSetsInput, ListResourceRecordSetsOutput, ListResourceRecordSetsOutputError>(id: "listResourceRecordSets")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListResourceRecordSetsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListResourceRecordSetsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListResourceRecordSetsInput, ListResourceRecordSetsOutput, ListResourceRecordSetsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of the reusable delegation sets that are associated with the current AWS account.</p>
    public func listReusableDelegationSets(input: ListReusableDelegationSetsInput, completion: @escaping (SdkResult<ListReusableDelegationSetsOutput, ListReusableDelegationSetsOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/delegationset"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listReusableDelegationSets")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListReusableDelegationSetsInput, ListReusableDelegationSetsOutput, ListReusableDelegationSetsOutputError>(id: "listReusableDelegationSets")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListReusableDelegationSetsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListReusableDelegationSetsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListReusableDelegationSetsInput, ListReusableDelegationSetsOutput, ListReusableDelegationSetsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists tags for one health check or hosted zone. </p>
    /// 		       <p>For information about using tags for cost allocation, see
    /// 			<a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags</a>
    /// 			in the <i>AWS Billing and Cost Management User Guide</i>.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutput, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceType = input.resourceType else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceType unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/tags/\(resourceType.rawValue)/\(resourceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists tags for up to 10 health checks or hosted zones.</p>
    /// 		       <p>For information about using tags for cost allocation, see
    /// 			<a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags</a>
    /// 			in the <i>AWS Billing and Cost Management User Guide</i>.</p>
    public func listTagsForResources(input: ListTagsForResourcesInput, completion: @escaping (SdkResult<ListTagsForResourcesOutput, ListTagsForResourcesOutputError>) -> Void)
    {
        guard let resourceType = input.resourceType else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceType unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/tags/\(resourceType.rawValue)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResources")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourcesInput, ListTagsForResourcesOutput, ListTagsForResourcesOutputError>(id: "listTagsForResources")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourcesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourcesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourcesInput, ListTagsForResourcesOutput, ListTagsForResourcesOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourcesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about the latest version for every traffic policy that is associated with the current AWS account.
    /// 			Policies are listed in the order that they were created in. </p>
    /// 		
    /// 		       <p>For information about how of deleting a traffic policy affects the response from <code>ListTrafficPolicies</code>, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_DeleteTrafficPolicy.html">DeleteTrafficPolicy</a>.
    ///
    /// 		</p>
    public func listTrafficPolicies(input: ListTrafficPoliciesInput, completion: @escaping (SdkResult<ListTrafficPoliciesOutput, ListTrafficPoliciesOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/trafficpolicies"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTrafficPolicies")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTrafficPoliciesInput, ListTrafficPoliciesOutput, ListTrafficPoliciesOutputError>(id: "listTrafficPolicies")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTrafficPoliciesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTrafficPoliciesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTrafficPoliciesInput, ListTrafficPoliciesOutput, ListTrafficPoliciesOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about the traffic policy instances that you created by using the current AWS account.</p>
    /// 		       <note>
    /// 			         <p>After you submit an <code>UpdateTrafficPolicyInstance</code> request, there's a brief delay while Amazon Route 53 creates the
    /// 				resource record sets that are specified in the traffic policy definition. For more information, see the <code>State</code> response element.</p>
    /// 		       </note>
    /// 		       <p>Route 53 returns a maximum of 100 items in each response. If you have a lot of traffic policy instances, you can use the
    /// 			<code>MaxItems</code> parameter to list them in groups of up to 100.</p>
    public func listTrafficPolicyInstances(input: ListTrafficPolicyInstancesInput, completion: @escaping (SdkResult<ListTrafficPolicyInstancesOutput, ListTrafficPolicyInstancesOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/trafficpolicyinstances"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTrafficPolicyInstances")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTrafficPolicyInstancesInput, ListTrafficPolicyInstancesOutput, ListTrafficPolicyInstancesOutputError>(id: "listTrafficPolicyInstances")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTrafficPolicyInstancesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTrafficPolicyInstancesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTrafficPolicyInstancesInput, ListTrafficPolicyInstancesOutput, ListTrafficPolicyInstancesOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about the traffic policy instances that you created in a specified hosted zone.</p>
    /// 		       <note>
    /// 			         <p>After you submit a <code>CreateTrafficPolicyInstance</code> or an <code>UpdateTrafficPolicyInstance</code> request, there's a
    /// 				brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For more information,
    /// 				see the <code>State</code> response element.</p>
    /// 		       </note>
    /// 		       <p>Route 53 returns a maximum of 100 items in each response. If you have a lot of traffic policy instances, you can use the
    /// 			<code>MaxItems</code> parameter to list them in groups of up to 100.</p>
    public func listTrafficPolicyInstancesByHostedZone(input: ListTrafficPolicyInstancesByHostedZoneInput, completion: @escaping (SdkResult<ListTrafficPolicyInstancesByHostedZoneOutput, ListTrafficPolicyInstancesByHostedZoneOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/trafficpolicyinstances/hostedzone"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTrafficPolicyInstancesByHostedZone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTrafficPolicyInstancesByHostedZoneInput, ListTrafficPolicyInstancesByHostedZoneOutput, ListTrafficPolicyInstancesByHostedZoneOutputError>(id: "listTrafficPolicyInstancesByHostedZone")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTrafficPolicyInstancesByHostedZoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTrafficPolicyInstancesByHostedZoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTrafficPolicyInstancesByHostedZoneInput, ListTrafficPolicyInstancesByHostedZoneOutput, ListTrafficPolicyInstancesByHostedZoneOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about the traffic policy instances that you created by using a specify traffic policy version.</p>
    /// 		       <note>
    /// 			         <p>After you submit a <code>CreateTrafficPolicyInstance</code> or an <code>UpdateTrafficPolicyInstance</code> request,
    /// 				there's a brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For
    /// 				more information, see the <code>State</code> response element.</p>
    /// 		       </note>
    /// 		       <p>Route 53 returns a maximum of 100 items in each response. If you have a lot of traffic policy instances, you can use the
    /// 			<code>MaxItems</code> parameter to list them in groups of up to 100.</p>
    public func listTrafficPolicyInstancesByPolicy(input: ListTrafficPolicyInstancesByPolicyInput, completion: @escaping (SdkResult<ListTrafficPolicyInstancesByPolicyOutput, ListTrafficPolicyInstancesByPolicyOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/trafficpolicyinstances/trafficpolicy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTrafficPolicyInstancesByPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTrafficPolicyInstancesByPolicyInput, ListTrafficPolicyInstancesByPolicyOutput, ListTrafficPolicyInstancesByPolicyOutputError>(id: "listTrafficPolicyInstancesByPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTrafficPolicyInstancesByPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTrafficPolicyInstancesByPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTrafficPolicyInstancesByPolicyInput, ListTrafficPolicyInstancesByPolicyOutput, ListTrafficPolicyInstancesByPolicyOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about all of the versions for a specified traffic policy.</p>
    /// 		       <p>Traffic policy versions are listed in numerical order by <code>VersionNumber</code>.</p>
    public func listTrafficPolicyVersions(input: ListTrafficPolicyVersionsInput, completion: @escaping (SdkResult<ListTrafficPolicyVersionsOutput, ListTrafficPolicyVersionsOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/trafficpolicies/\(id)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTrafficPolicyVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTrafficPolicyVersionsInput, ListTrafficPolicyVersionsOutput, ListTrafficPolicyVersionsOutputError>(id: "listTrafficPolicyVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTrafficPolicyVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTrafficPolicyVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTrafficPolicyVersionsInput, ListTrafficPolicyVersionsOutput, ListTrafficPolicyVersionsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of the VPCs that were created by other accounts and that can be associated with a
    /// 			specified hosted zone because you've submitted one or more <code>CreateVPCAssociationAuthorization</code> requests. </p>
    /// 		       <p>The response includes a <code>VPCs</code> element with a <code>VPC</code> child element for each VPC
    /// 			that can be associated with the hosted zone.</p>
    public func listVPCAssociationAuthorizations(input: ListVPCAssociationAuthorizationsInput, completion: @escaping (SdkResult<ListVPCAssociationAuthorizationsOutput, ListVPCAssociationAuthorizationsOutputError>) -> Void)
    {
        guard let hostedZoneId = input.hostedZoneId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hostedZoneId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(hostedZoneId)/authorizevpcassociation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVPCAssociationAuthorizations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListVPCAssociationAuthorizationsInput, ListVPCAssociationAuthorizationsOutput, ListVPCAssociationAuthorizationsOutputError>(id: "listVPCAssociationAuthorizations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListVPCAssociationAuthorizationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListVPCAssociationAuthorizationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListVPCAssociationAuthorizationsInput, ListVPCAssociationAuthorizationsOutput, ListVPCAssociationAuthorizationsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the value that Amazon Route 53 returns in response to a DNS request for a specified record name and type. You can optionally specify
    /// 			the IP address of a DNS resolver, an EDNS0 client subnet IP address, and a subnet mask. </p>
    /// 		       <p>This call only supports querying public hosted zones.</p>
    public func testDNSAnswer(input: TestDNSAnswerInput, completion: @escaping (SdkResult<TestDNSAnswerOutput, TestDNSAnswerOutputError>) -> Void)
    {
        let urlPath = "/2013-04-01/testdnsanswer"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "testDNSAnswer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TestDNSAnswerInput, TestDNSAnswerOutput, TestDNSAnswerOutputError>(id: "testDNSAnswer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TestDNSAnswerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TestDNSAnswerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TestDNSAnswerInput, TestDNSAnswerOutput, TestDNSAnswerOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an existing health check. Note that some values can't be updated. </p>
    /// 		       <p>For more information about updating health checks, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/health-checks-creating-deleting.html">Creating, Updating, and Deleting Health Checks</a>
    /// 			in the <i>Amazon Route 53 Developer Guide</i>.</p>
    public func updateHealthCheck(input: UpdateHealthCheckInput, completion: @escaping (SdkResult<UpdateHealthCheckOutput, UpdateHealthCheckOutputError>) -> Void)
    {
        guard let healthCheckId = input.healthCheckId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component healthCheckId unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/healthcheck/\(healthCheckId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateHealthCheck")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateHealthCheckInput, UpdateHealthCheckOutput, UpdateHealthCheckOutputError>(id: "updateHealthCheck")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateHealthCheckInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateHealthCheckInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateHealthCheckInput, UpdateHealthCheckOutput, UpdateHealthCheckOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateHealthCheckInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the comment for a specified hosted zone.</p>
    public func updateHostedZoneComment(input: UpdateHostedZoneCommentInput, completion: @escaping (SdkResult<UpdateHostedZoneCommentOutput, UpdateHostedZoneCommentOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/hostedzone/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateHostedZoneComment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateHostedZoneCommentInput, UpdateHostedZoneCommentOutput, UpdateHostedZoneCommentOutputError>(id: "updateHostedZoneComment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateHostedZoneCommentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateHostedZoneCommentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateHostedZoneCommentInput, UpdateHostedZoneCommentOutput, UpdateHostedZoneCommentOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateHostedZoneCommentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the comment for a specified traffic policy version.</p>
    public func updateTrafficPolicyComment(input: UpdateTrafficPolicyCommentInput, completion: @escaping (SdkResult<UpdateTrafficPolicyCommentOutput, UpdateTrafficPolicyCommentOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        guard let version = input.version else {
            completion(.failure(.client(ClientError.serializationFailed("uri component version unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/trafficpolicy/\(id)/\(version)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateTrafficPolicyComment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateTrafficPolicyCommentInput, UpdateTrafficPolicyCommentOutput, UpdateTrafficPolicyCommentOutputError>(id: "updateTrafficPolicyComment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateTrafficPolicyCommentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateTrafficPolicyCommentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateTrafficPolicyCommentInput, UpdateTrafficPolicyCommentOutput, UpdateTrafficPolicyCommentOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateTrafficPolicyCommentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the resource record sets in a specified hosted zone that were created based on the settings in a specified traffic policy version.</p>
    /// 		       <p>When you update a traffic policy instance, Amazon Route 53 continues to respond to DNS queries for the root resource record set name
    /// 			(such as example.com) while it replaces one group of resource record sets with another. Route 53 performs the following operations:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>Route 53 creates a new group of resource record sets based on the specified traffic policy. This is true regardless of how significant
    /// 					the differences are between the existing resource record sets and the new resource record sets. </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>When all of the new resource record sets have been created, Route 53 starts to respond to DNS queries for the root resource record set name
    /// 					(such as example.com) by using the new resource record sets.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Route 53 deletes the old group of resource record sets that are associated with the root resource record set name.</p>
    /// 			         </li>
    ///          </ol>
    public func updateTrafficPolicyInstance(input: UpdateTrafficPolicyInstanceInput, completion: @escaping (SdkResult<UpdateTrafficPolicyInstanceOutput, UpdateTrafficPolicyInstanceOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2013-04-01/trafficpolicyinstance/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateTrafficPolicyInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "route53.\(config.region).amazonaws.com")
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateTrafficPolicyInstanceInput, UpdateTrafficPolicyInstanceOutput, UpdateTrafficPolicyInstanceOutputError>(id: "updateTrafficPolicyInstance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateTrafficPolicyInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateTrafficPolicyInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateTrafficPolicyInstanceInput, UpdateTrafficPolicyInstanceOutput, UpdateTrafficPolicyInstanceOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateTrafficPolicyInstanceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
