// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case id
        case parameters
        case tags
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, actionparametermap0) in parameters {
                try parametersContainer.encode(actionparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .targets)
            for (dictKey0, actiontargetmap0) in targets {
                try targetsContainer.encode(actiontargetmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: ActionParameter?].self, forKey: .parameters)
        var parametersDecoded0: [String:ActionParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:ActionParameter]()
            for (key0, actionparameter0) in parametersContainer {
                if let actionparameter0 = actionparameter0 {
                    parametersDecoded0?[key0] = actionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([String: ActionTarget?].self, forKey: .targets)
        var targetsDecoded0: [String:ActionTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String:ActionTarget]()
            for (key0, actiontarget0) in targetsContainer {
                if let actiontarget0 = actiontarget0 {
                    targetsDecoded0?[key0] = actiontarget0
                }
            }
        }
        targets = targetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Action(description: \(String(describing: description)), id: \(String(describing: id)), parameters: \(String(describing: parameters)), tags: \(String(describing: tags)), targets: \(String(describing: targets)))"}
}

/// <p>Describes an action. For more information, see <a href="https://docs.aws.amazon.com/fis/latest/userguide/fis-actions-reference.html">AWS FIS actions</a>
///          in the <i>AWS Fault Injection Simulator User Guide</i>.</p>
public struct Action: Equatable {
    /// <p>The description for the action.</p>
    public let description: String?
    /// <p>The ID of the action.</p>
    public let id: String?
    /// <p>The action parameters, if applicable.</p>
    public let parameters: [String:ActionParameter]?
    /// <p>The tags for the action.</p>
    public let tags: [String:String]?
    /// <p>The supported targets for the action.</p>
    public let targets: [String:ActionTarget]?

    public init (
        description: String? = nil,
        id: String? = nil,
        parameters: [String:ActionParameter]? = nil,
        tags: [String:String]? = nil,
        targets: [String:ActionTarget]? = nil
    )
    {
        self.description = description
        self.id = id
        self.parameters = parameters
        self.tags = tags
        self.targets = targets
    }
}

extension ActionParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case `required` = "required"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if `required` != false {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let requiredDecoded = try containerValues.decode(Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension ActionParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionParameter(description: \(String(describing: description)), required: \(String(describing: `required`)))"}
}

/// <p>Describes a parameter for an action.</p>
public struct ActionParameter: Equatable {
    /// <p>Indicates whether the parameter is required.</p>
    public let `required`: Bool
    /// <p>The parameter description.</p>
    public let description: String?

    public init (
        `required`: Bool = false,
        description: String? = nil
    )
    {
        self.`required` = `required`
        self.description = description
    }
}

extension ActionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case id
        case tags
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .targets)
            for (dictKey0, actiontargetmap0) in targets {
                try targetsContainer.encode(actiontargetmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([String: ActionTarget?].self, forKey: .targets)
        var targetsDecoded0: [String:ActionTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String:ActionTarget]()
            for (key0, actiontarget0) in targetsContainer {
                if let actiontarget0 = actiontarget0 {
                    targetsDecoded0?[key0] = actiontarget0
                }
            }
        }
        targets = targetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ActionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionSummary(description: \(String(describing: description)), id: \(String(describing: id)), tags: \(String(describing: tags)), targets: \(String(describing: targets)))"}
}

/// <p>Provides a summary of an action.</p>
public struct ActionSummary: Equatable {
    /// <p>The description for the action.</p>
    public let description: String?
    /// <p>The ID of the action.</p>
    public let id: String?
    /// <p>The tags for the action.</p>
    public let tags: [String:String]?
    /// <p>The targets for the action.</p>
    public let targets: [String:ActionTarget]?

    public init (
        description: String? = nil,
        id: String? = nil,
        tags: [String:String]? = nil,
        targets: [String:ActionTarget]? = nil
    )
    {
        self.description = description
        self.id = id
        self.tags = tags
        self.targets = targets
    }
}

extension ActionTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ActionTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionTarget(resourceType: \(String(describing: resourceType)))"}
}

/// <p>Describes a target for an action.</p>
public struct ActionTarget: Equatable {
    /// <p>The resource type of the target.</p>
    public let resourceType: String?

    public init (
        resourceType: String? = nil
    )
    {
        self.resourceType = resourceType
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request could not be processed because of a conflict.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateExperimentTemplateActionInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, experimenttemplateactionparametermap0) in parameters {
                try parametersContainer.encode(experimenttemplateactionparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimenttemplateactionstartafterlist0 in startAfter {
                try startAfterContainer.encode(experimenttemplateactionstartafterlist0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .targets)
            for (dictKey0, experimenttemplateactiontargetmap0) in targets {
                try targetsContainer.encode(experimenttemplateactiontargetmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, experimenttemplateactionparameter0) in parametersContainer {
                if let experimenttemplateactionparameter0 = experimenttemplateactionparameter0 {
                    parametersDecoded0?[key0] = experimenttemplateactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .targets)
        var targetsDecoded0: [String:String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String:String]()
            for (key0, experimenttemplatetargetname0) in targetsContainer {
                if let experimenttemplatetargetname0 = experimenttemplatetargetname0 {
                    targetsDecoded0?[key0] = experimenttemplatetargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([String?].self, forKey: .startAfter)
        var startAfterDecoded0:[String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
    }
}

extension CreateExperimentTemplateActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateExperimentTemplateActionInput(actionId: \(String(describing: actionId)), description: \(String(describing: description)), parameters: \(String(describing: parameters)), startAfter: \(String(describing: startAfter)), targets: \(String(describing: targets)))"}
}

/// <p>Specifies an action for an experiment template.</p>
public struct CreateExperimentTemplateActionInput: Equatable {
    /// <p>The ID of the action.</p>
    public let actionId: String?
    /// <p>A description for the action.</p>
    public let description: String?
    /// <p>The parameters for the action, if applicable.</p>
    public let parameters: [String:String]?
    /// <p>The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.</p>
    public let startAfter: [String]?
    /// <p>The targets for the action.</p>
    public let targets: [String:String]?

    public init (
        actionId: String? = nil,
        description: String? = nil,
        parameters: [String:String]? = nil,
        startAfter: [String]? = nil,
        targets: [String:String]? = nil
    )
    {
        self.actionId = actionId
        self.description = description
        self.parameters = parameters
        self.startAfter = startAfter
        self.targets = targets
    }
}

public struct CreateExperimentTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateExperimentTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateExperimentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateExperimentTemplateInput>
    public typealias MOutput = OperationOutput<CreateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateExperimentTemplateOutputError>
}

extension CreateExperimentTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateExperimentTemplateInput(actions: \(String(describing: actions)), clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), roleArn: \(String(describing: roleArn)), stopConditions: \(String(describing: stopConditions)), tags: \(String(describing: tags)), targets: \(String(describing: targets)))"}
}

extension CreateExperimentTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case clientToken
        case description
        case roleArn
        case stopConditions
        case tags
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .actions)
            for (dictKey0, createexperimenttemplateactioninputmap0) in actions {
                try actionsContainer.encode(createexperimenttemplateactioninputmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for createexperimenttemplatestopconditioninputlist0 in stopConditions {
                try stopConditionsContainer.encode(createexperimenttemplatestopconditioninputlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .targets)
            for (dictKey0, createexperimenttemplatetargetinputmap0) in targets {
                try targetsContainer.encode(createexperimenttemplatetargetinputmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateExperimentTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateExperimentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateExperimentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateExperimentTemplateInput>
    public typealias MOutput = OperationOutput<CreateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateExperimentTemplateOutputError>
}

public struct CreateExperimentTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateExperimentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateExperimentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateExperimentTemplateInput>
    public typealias MOutput = OperationOutput<CreateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateExperimentTemplateOutputError>
}

public struct CreateExperimentTemplateInput: Equatable {
    /// <p>The actions for the experiment.</p>
    public let actions: [String:CreateExperimentTemplateActionInput]?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public var clientToken: String?
    /// <p>A description for the experiment template. Can contain up to 64 letters (A-Z and a-z).</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of an IAM role that grants the AWS FIS service permission to perform service actions on your behalf.</p>
    public let roleArn: String?
    /// <p>The stop conditions.</p>
    public let stopConditions: [CreateExperimentTemplateStopConditionInput]?
    /// <p>The tags to apply to the experiment template.</p>
    public let tags: [String:String]?
    /// <p>The targets for the experiment.</p>
    public let targets: [String:CreateExperimentTemplateTargetInput]?

    public init (
        actions: [String:CreateExperimentTemplateActionInput]? = nil,
        clientToken: String? = nil,
        description: String? = nil,
        roleArn: String? = nil,
        stopConditions: [CreateExperimentTemplateStopConditionInput]? = nil,
        tags: [String:String]? = nil,
        targets: [String:CreateExperimentTemplateTargetInput]? = nil
    )
    {
        self.actions = actions
        self.clientToken = clientToken
        self.description = description
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.tags = tags
        self.targets = targets
    }
}

struct CreateExperimentTemplateInputBody: Equatable {
    public let clientToken: String?
    public let description: String?
    public let stopConditions: [CreateExperimentTemplateStopConditionInput]?
    public let targets: [String:CreateExperimentTemplateTargetInput]?
    public let actions: [String:CreateExperimentTemplateActionInput]?
    public let roleArn: String?
    public let tags: [String:String]?
}

extension CreateExperimentTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions
        case clientToken
        case description
        case roleArn
        case stopConditions
        case tags
        case targets
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stopConditionsContainer = try containerValues.decodeIfPresent([CreateExperimentTemplateStopConditionInput?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[CreateExperimentTemplateStopConditionInput]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [CreateExperimentTemplateStopConditionInput]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([String: CreateExperimentTemplateTargetInput?].self, forKey: .targets)
        var targetsDecoded0: [String:CreateExperimentTemplateTargetInput]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String:CreateExperimentTemplateTargetInput]()
            for (key0, createexperimenttemplatetargetinput0) in targetsContainer {
                if let createexperimenttemplatetargetinput0 = createexperimenttemplatetargetinput0 {
                    targetsDecoded0?[key0] = createexperimenttemplatetargetinput0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([String: CreateExperimentTemplateActionInput?].self, forKey: .actions)
        var actionsDecoded0: [String:CreateExperimentTemplateActionInput]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [String:CreateExperimentTemplateActionInput]()
            for (key0, createexperimenttemplateactioninput0) in actionsContainer {
                if let createexperimenttemplateactioninput0 = createexperimenttemplateactioninput0 {
                    actionsDecoded0?[key0] = createexperimenttemplateactioninput0
                }
            }
        }
        actions = actionsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateExperimentTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateExperimentTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateExperimentTemplateOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateExperimentTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateExperimentTemplateOutputResponse(experimentTemplate: \(String(describing: experimentTemplate)))"}
}

extension CreateExperimentTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateExperimentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct CreateExperimentTemplateOutputResponse: Equatable {
    /// <p>Information about the experiment template.</p>
    public let experimentTemplate: ExperimentTemplate?

    public init (
        experimentTemplate: ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct CreateExperimentTemplateOutputResponseBody: Equatable {
    public let experimentTemplate: ExperimentTemplate?
}

extension CreateExperimentTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case experimentTemplate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

extension CreateExperimentTemplateStopConditionInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CreateExperimentTemplateStopConditionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateExperimentTemplateStopConditionInput(source: \(String(describing: source)), value: \(String(describing: value)))"}
}

/// <p>Specifies a stop condition for an experiment template.</p>
public struct CreateExperimentTemplateStopConditionInput: Equatable {
    /// <p>The source for the stop condition. Specify <code>aws:cloudwatch:alarm</code> if the stop
    ///          condition is defined by a CloudWatch alarm. Specify <code>none</code> if there is no stop
    ///          condition.</p>
    public let source: String?
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch alarm. This is required if the source is
    ///          a CloudWatch alarm.</p>
    public let value: String?

    public init (
        source: String? = nil,
        value: String? = nil
    )
    {
        self.source = source
        self.value = value
    }
}

extension CreateExperimentTemplateTargetInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttemplatetargetfilterinputlist0 in filters {
                try filtersContainer.encode(experimenttemplatetargetfilterinputlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .resourceTags)
            for (dictKey0, tagmap0) in resourceTags {
                try resourceTagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [String:String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ExperimentTemplateTargetInputFilter?].self, forKey: .filters)
        var filtersDecoded0:[ExperimentTemplateTargetInputFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ExperimentTemplateTargetInputFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
    }
}

extension CreateExperimentTemplateTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateExperimentTemplateTargetInput(filters: \(String(describing: filters)), resourceArns: \(String(describing: resourceArns)), resourceTags: \(String(describing: resourceTags)), resourceType: \(String(describing: resourceType)), selectionMode: \(String(describing: selectionMode)))"}
}

/// <p>Specifies a target for an experiment. You must specify at least one Amazon Resource Name (ARN) or
///          at least one resource tag. You cannot specify both ARNs and tags.</p>
public struct CreateExperimentTemplateTargetInput: Equatable {
    /// <p>The filters to apply to identify target resources using specific attributes.</p>
    public let filters: [ExperimentTemplateTargetInputFilter]?
    /// <p>The Amazon Resource Names (ARNs) of the resources.</p>
    public let resourceArns: [String]?
    /// <p>The tags for the target resources.</p>
    public let resourceTags: [String:String]?
    /// <p>The AWS resource type. The resource type must be supported for the specified action.</p>
    public let resourceType: String?
    /// <p>Scopes the identified resources to a specific count of the resources at random, or a percentage of the resources. All identified resources are included in the target.</p>
    ///          <ul>
    ///             <li>
    ///                <p>ALL - Run the action on all identified targets. This is the default.</p>
    ///             </li>
    ///             <li>
    ///                <p>COUNT(n) - Run the action on the specified number of targets, chosen from the identified targets at random.
    ///                 For example, COUNT(1) selects one of the targets.</p>
    ///             </li>
    ///             <li>
    ///                <p>PERCENT(n) - Run the action on the specified percentage of targets, chosen from the identified targets
    ///                at random. For example, PERCENT(25) selects 25% of the targets.</p>
    ///             </li>
    ///          </ul>
    public let selectionMode: String?

    public init (
        filters: [ExperimentTemplateTargetInputFilter]? = nil,
        resourceArns: [String]? = nil,
        resourceTags: [String:String]? = nil,
        resourceType: String? = nil,
        selectionMode: String? = nil
    )
    {
        self.filters = filters
        self.resourceArns = resourceArns
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.selectionMode = selectionMode
    }
}

extension DeleteExperimentTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteExperimentTemplateInput(id: \(String(describing: id)))"}
}

extension DeleteExperimentTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteExperimentTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteExperimentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteExperimentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteExperimentTemplateInput>
    public typealias MOutput = OperationOutput<DeleteExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteExperimentTemplateOutputError>
}

public struct DeleteExperimentTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteExperimentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteExperimentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteExperimentTemplateInput>
    public typealias MOutput = OperationOutput<DeleteExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteExperimentTemplateOutputError>
}

public struct DeleteExperimentTemplateInput: Equatable {
    /// <p>The ID of the experiment template.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteExperimentTemplateInputBody: Equatable {
}

extension DeleteExperimentTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteExperimentTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteExperimentTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteExperimentTemplateOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExperimentTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteExperimentTemplateOutputResponse(experimentTemplate: \(String(describing: experimentTemplate)))"}
}

extension DeleteExperimentTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteExperimentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct DeleteExperimentTemplateOutputResponse: Equatable {
    /// <p>Information about the experiment template.</p>
    public let experimentTemplate: ExperimentTemplate?

    public init (
        experimentTemplate: ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct DeleteExperimentTemplateOutputResponseBody: Equatable {
    public let experimentTemplate: ExperimentTemplate?
}

extension DeleteExperimentTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case experimentTemplate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

extension Experiment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case creationTime
        case endTime
        case experimentTemplateId
        case id
        case roleArn
        case startTime
        case state
        case stopConditions
        case tags
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .actions)
            for (dictKey0, experimentactionmap0) in actions {
                try actionsContainer.encode(experimentactionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let experimentTemplateId = experimentTemplateId {
            try encodeContainer.encode(experimentTemplateId, forKey: .experimentTemplateId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for experimentstopconditionlist0 in stopConditions {
                try stopConditionsContainer.encode(experimentstopconditionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .targets)
            for (dictKey0, experimenttargetmap0) in targets {
                try targetsContainer.encode(experimenttargetmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let experimentTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .experimentTemplateId)
        experimentTemplateId = experimentTemplateIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ExperimentState.self, forKey: .state)
        state = stateDecoded
        let targetsContainer = try containerValues.decodeIfPresent([String: ExperimentTarget?].self, forKey: .targets)
        var targetsDecoded0: [String:ExperimentTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String:ExperimentTarget]()
            for (key0, experimenttarget0) in targetsContainer {
                if let experimenttarget0 = experimenttarget0 {
                    targetsDecoded0?[key0] = experimenttarget0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([String: ExperimentAction?].self, forKey: .actions)
        var actionsDecoded0: [String:ExperimentAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [String:ExperimentAction]()
            for (key0, experimentaction0) in actionsContainer {
                if let experimentaction0 = experimentaction0 {
                    actionsDecoded0?[key0] = experimentaction0
                }
            }
        }
        actions = actionsDecoded0
        let stopConditionsContainer = try containerValues.decodeIfPresent([ExperimentStopCondition?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[ExperimentStopCondition]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [ExperimentStopCondition]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Experiment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Experiment(actions: \(String(describing: actions)), creationTime: \(String(describing: creationTime)), endTime: \(String(describing: endTime)), experimentTemplateId: \(String(describing: experimentTemplateId)), id: \(String(describing: id)), roleArn: \(String(describing: roleArn)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), stopConditions: \(String(describing: stopConditions)), tags: \(String(describing: tags)), targets: \(String(describing: targets)))"}
}

/// <p>Describes an experiment.</p>
public struct Experiment: Equatable {
    /// <p>The actions for the experiment.</p>
    public let actions: [String:ExperimentAction]?
    /// <p>The time the experiment was created.</p>
    public let creationTime: Date?
    /// <p>The time that the experiment ended.</p>
    public let endTime: Date?
    /// <p>The ID of the experiment template.</p>
    public let experimentTemplateId: String?
    /// <p>The ID of the experiment.</p>
    public let id: String?
    /// <p>The Amazon Resource Name (ARN) of an IAM role that grants the AWS FIS service permission to perform service actions on your behalf.</p>
    public let roleArn: String?
    /// <p>The time that the experiment was started.</p>
    public let startTime: Date?
    /// <p>The state of the experiment.</p>
    public let state: ExperimentState?
    /// <p>The stop conditions for the experiment.</p>
    public let stopConditions: [ExperimentStopCondition]?
    /// <p>The tags for the experiment.</p>
    public let tags: [String:String]?
    /// <p>The targets for the experiment.</p>
    public let targets: [String:ExperimentTarget]?

    public init (
        actions: [String:ExperimentAction]? = nil,
        creationTime: Date? = nil,
        endTime: Date? = nil,
        experimentTemplateId: String? = nil,
        id: String? = nil,
        roleArn: String? = nil,
        startTime: Date? = nil,
        state: ExperimentState? = nil,
        stopConditions: [ExperimentStopCondition]? = nil,
        tags: [String:String]? = nil,
        targets: [String:ExperimentTarget]? = nil
    )
    {
        self.actions = actions
        self.creationTime = creationTime
        self.endTime = endTime
        self.experimentTemplateId = experimentTemplateId
        self.id = id
        self.roleArn = roleArn
        self.startTime = startTime
        self.state = state
        self.stopConditions = stopConditions
        self.tags = tags
        self.targets = targets
    }
}

extension ExperimentAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case state
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, experimentactionparametermap0) in parameters {
                try parametersContainer.encode(experimentactionparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimentactionstartafterlist0 in startAfter {
                try startAfterContainer.encode(experimentactionstartafterlist0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .targets)
            for (dictKey0, experimentactiontargetmap0) in targets {
                try targetsContainer.encode(experimentactiontargetmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, experimentactionparameter0) in parametersContainer {
                if let experimentactionparameter0 = experimentactionparameter0 {
                    parametersDecoded0?[key0] = experimentactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .targets)
        var targetsDecoded0: [String:String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String:String]()
            for (key0, experimenttargetname0) in targetsContainer {
                if let experimenttargetname0 = experimenttargetname0 {
                    targetsDecoded0?[key0] = experimenttargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([String?].self, forKey: .startAfter)
        var startAfterDecoded0:[String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(ExperimentActionState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ExperimentAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentAction(actionId: \(String(describing: actionId)), description: \(String(describing: description)), parameters: \(String(describing: parameters)), startAfter: \(String(describing: startAfter)), state: \(String(describing: state)), targets: \(String(describing: targets)))"}
}

/// <p>Describes the action for an experiment.</p>
public struct ExperimentAction: Equatable {
    /// <p>The ID of the action.</p>
    public let actionId: String?
    /// <p>The description for the action.</p>
    public let description: String?
    /// <p>The parameters for the action.</p>
    public let parameters: [String:String]?
    /// <p>The name of the action that must be completed before this action starts.</p>
    public let startAfter: [String]?
    /// <p>The state of the action.</p>
    public let state: ExperimentActionState?
    /// <p>The targets for the action.</p>
    public let targets: [String:String]?

    public init (
        actionId: String? = nil,
        description: String? = nil,
        parameters: [String:String]? = nil,
        startAfter: [String]? = nil,
        state: ExperimentActionState? = nil,
        targets: [String:String]? = nil
    )
    {
        self.actionId = actionId
        self.description = description
        self.parameters = parameters
        self.startAfter = startAfter
        self.state = state
        self.targets = targets
    }
}

extension ExperimentActionState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ExperimentActionStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ExperimentActionState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentActionState(reason: \(String(describing: reason)), status: \(String(describing: status)))"}
}

/// <p>Describes the state of an action.</p>
public struct ExperimentActionState: Equatable {
    /// <p>The reason for the state.</p>
    public let reason: String?
    /// <p>The state of the action.</p>
    public let status: ExperimentActionStatus?

    public init (
        reason: String? = nil,
        status: ExperimentActionStatus? = nil
    )
    {
        self.reason = reason
        self.status = status
    }
}

public enum ExperimentActionStatus {
    case cancelled
    case completed
    case failed
    case initiating
    case pending
    case running
    case stopped
    case stopping
    case sdkUnknown(String)
}

extension ExperimentActionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExperimentActionStatus] {
        return [
            .cancelled,
            .completed,
            .failed,
            .initiating,
            .pending,
            .running,
            .stopped,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "cancelled"
        case .completed: return "completed"
        case .failed: return "failed"
        case .initiating: return "initiating"
        case .pending: return "pending"
        case .running: return "running"
        case .stopped: return "stopped"
        case .stopping: return "stopping"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExperimentActionStatus(rawValue: rawValue) ?? ExperimentActionStatus.sdkUnknown(rawValue)
    }
}

extension ExperimentState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ExperimentStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ExperimentState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentState(reason: \(String(describing: reason)), status: \(String(describing: status)))"}
}

/// <p>Describes the state of an experiment.</p>
public struct ExperimentState: Equatable {
    /// <p>The reason for the state.</p>
    public let reason: String?
    /// <p>The state of the experiment.</p>
    public let status: ExperimentStatus?

    public init (
        reason: String? = nil,
        status: ExperimentStatus? = nil
    )
    {
        self.reason = reason
        self.status = status
    }
}

public enum ExperimentStatus {
    case completed
    case failed
    case initiating
    case pending
    case running
    case stopped
    case stopping
    case sdkUnknown(String)
}

extension ExperimentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExperimentStatus] {
        return [
            .completed,
            .failed,
            .initiating,
            .pending,
            .running,
            .stopped,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "completed"
        case .failed: return "failed"
        case .initiating: return "initiating"
        case .pending: return "pending"
        case .running: return "running"
        case .stopped: return "stopped"
        case .stopping: return "stopping"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExperimentStatus(rawValue: rawValue) ?? ExperimentStatus.sdkUnknown(rawValue)
    }
}

extension ExperimentStopCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ExperimentStopCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentStopCondition(source: \(String(describing: source)), value: \(String(describing: value)))"}
}

/// <p>Describes the stop condition for an experiment.</p>
public struct ExperimentStopCondition: Equatable {
    /// <p>The source for the stop condition.</p>
    public let source: String?
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.</p>
    public let value: String?

    public init (
        source: String? = nil,
        value: String? = nil
    )
    {
        self.source = source
        self.value = value
    }
}

extension ExperimentSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case experimentTemplateId
        case id
        case state
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let experimentTemplateId = experimentTemplateId {
            try encodeContainer.encode(experimentTemplateId, forKey: .experimentTemplateId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let experimentTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .experimentTemplateId)
        experimentTemplateId = experimentTemplateIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ExperimentState.self, forKey: .state)
        state = stateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ExperimentSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentSummary(creationTime: \(String(describing: creationTime)), experimentTemplateId: \(String(describing: experimentTemplateId)), id: \(String(describing: id)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

/// <p>Provides a summary of an experiment.</p>
public struct ExperimentSummary: Equatable {
    /// <p>The time that the experiment was created.</p>
    public let creationTime: Date?
    /// <p>The ID of the experiment template.</p>
    public let experimentTemplateId: String?
    /// <p>The ID of the experiment.</p>
    public let id: String?
    /// <p>The state of the experiment.</p>
    public let state: ExperimentState?
    /// <p>The tags for the experiment.</p>
    public let tags: [String:String]?

    public init (
        creationTime: Date? = nil,
        experimentTemplateId: String? = nil,
        id: String? = nil,
        state: ExperimentState? = nil,
        tags: [String:String]? = nil
    )
    {
        self.creationTime = creationTime
        self.experimentTemplateId = experimentTemplateId
        self.id = id
        self.state = state
        self.tags = tags
    }
}

extension ExperimentTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttargetfilterlist0 in filters {
                try filtersContainer.encode(experimenttargetfilterlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .resourceTags)
            for (dictKey0, tagmap0) in resourceTags {
                try resourceTagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [String:String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ExperimentTargetFilter?].self, forKey: .filters)
        var filtersDecoded0:[ExperimentTargetFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ExperimentTargetFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
    }
}

extension ExperimentTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentTarget(filters: \(String(describing: filters)), resourceArns: \(String(describing: resourceArns)), resourceTags: \(String(describing: resourceTags)), resourceType: \(String(describing: resourceType)), selectionMode: \(String(describing: selectionMode)))"}
}

/// <p>Describes a target for an experiment.</p>
public struct ExperimentTarget: Equatable {
    /// <p>The filters to apply to identify target resources using specific attributes.</p>
    public let filters: [ExperimentTargetFilter]?
    /// <p>The Amazon Resource Names (ARNs) of the resources.</p>
    public let resourceArns: [String]?
    /// <p>The tags for the target resources.</p>
    public let resourceTags: [String:String]?
    /// <p>The resource type.</p>
    public let resourceType: String?
    /// <p>Scopes the identified resources to a specific count or percentage.</p>
    public let selectionMode: String?

    public init (
        filters: [ExperimentTargetFilter]? = nil,
        resourceArns: [String]? = nil,
        resourceTags: [String:String]? = nil,
        resourceType: String? = nil,
        selectionMode: String? = nil
    )
    {
        self.filters = filters
        self.resourceArns = resourceArns
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.selectionMode = selectionMode
    }
}

extension ExperimentTargetFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case path
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for experimenttargetfiltervalues0 in values {
                try valuesContainer.encode(experimenttargetfiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ExperimentTargetFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentTargetFilter(path: \(String(describing: path)), values: \(String(describing: values)))"}
}

/// <p>Describes a filter used for the target resources in an experiment.</p>
public struct ExperimentTargetFilter: Equatable {
    /// <p>The attribute path for the filter.</p>
    public let path: String?
    /// <p>The attribute values for the filter.</p>
    public let values: [String]?

    public init (
        path: String? = nil,
        values: [String]? = nil
    )
    {
        self.path = path
        self.values = values
    }
}

extension ExperimentTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case creationTime
        case description
        case id
        case lastUpdateTime
        case roleArn
        case stopConditions
        case tags
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .actions)
            for (dictKey0, experimenttemplateactionmap0) in actions {
                try actionsContainer.encode(experimenttemplateactionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for experimenttemplatestopconditionlist0 in stopConditions {
                try stopConditionsContainer.encode(experimenttemplatestopconditionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .targets)
            for (dictKey0, experimenttemplatetargetmap0) in targets {
                try targetsContainer.encode(experimenttemplatetargetmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([String: ExperimentTemplateTarget?].self, forKey: .targets)
        var targetsDecoded0: [String:ExperimentTemplateTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String:ExperimentTemplateTarget]()
            for (key0, experimenttemplatetarget0) in targetsContainer {
                if let experimenttemplatetarget0 = experimenttemplatetarget0 {
                    targetsDecoded0?[key0] = experimenttemplatetarget0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([String: ExperimentTemplateAction?].self, forKey: .actions)
        var actionsDecoded0: [String:ExperimentTemplateAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [String:ExperimentTemplateAction]()
            for (key0, experimenttemplateaction0) in actionsContainer {
                if let experimenttemplateaction0 = experimenttemplateaction0 {
                    actionsDecoded0?[key0] = experimenttemplateaction0
                }
            }
        }
        actions = actionsDecoded0
        let stopConditionsContainer = try containerValues.decodeIfPresent([ExperimentTemplateStopCondition?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[ExperimentTemplateStopCondition]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [ExperimentTemplateStopCondition]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ExperimentTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentTemplate(actions: \(String(describing: actions)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdateTime: \(String(describing: lastUpdateTime)), roleArn: \(String(describing: roleArn)), stopConditions: \(String(describing: stopConditions)), tags: \(String(describing: tags)), targets: \(String(describing: targets)))"}
}

/// <p>Describes an experiment template.</p>
public struct ExperimentTemplate: Equatable {
    /// <p>The actions for the experiment.</p>
    public let actions: [String:ExperimentTemplateAction]?
    /// <p>The time the experiment template was created.</p>
    public let creationTime: Date?
    /// <p>The description for the experiment template.</p>
    public let description: String?
    /// <p>The ID of the experiment template.</p>
    public let id: String?
    /// <p>The time the experiment template was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of an IAM role.</p>
    public let roleArn: String?
    /// <p>The stop conditions for the experiment.</p>
    public let stopConditions: [ExperimentTemplateStopCondition]?
    /// <p>The tags for the experiment template.</p>
    public let tags: [String:String]?
    /// <p>The targets for the experiment.</p>
    public let targets: [String:ExperimentTemplateTarget]?

    public init (
        actions: [String:ExperimentTemplateAction]? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdateTime: Date? = nil,
        roleArn: String? = nil,
        stopConditions: [ExperimentTemplateStopCondition]? = nil,
        tags: [String:String]? = nil,
        targets: [String:ExperimentTemplateTarget]? = nil
    )
    {
        self.actions = actions
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastUpdateTime = lastUpdateTime
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.tags = tags
        self.targets = targets
    }
}

extension ExperimentTemplateAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, experimenttemplateactionparametermap0) in parameters {
                try parametersContainer.encode(experimenttemplateactionparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimenttemplateactionstartafterlist0 in startAfter {
                try startAfterContainer.encode(experimenttemplateactionstartafterlist0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .targets)
            for (dictKey0, experimenttemplateactiontargetmap0) in targets {
                try targetsContainer.encode(experimenttemplateactiontargetmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, experimenttemplateactionparameter0) in parametersContainer {
                if let experimenttemplateactionparameter0 = experimenttemplateactionparameter0 {
                    parametersDecoded0?[key0] = experimenttemplateactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .targets)
        var targetsDecoded0: [String:String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String:String]()
            for (key0, experimenttemplatetargetname0) in targetsContainer {
                if let experimenttemplatetargetname0 = experimenttemplatetargetname0 {
                    targetsDecoded0?[key0] = experimenttemplatetargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([String?].self, forKey: .startAfter)
        var startAfterDecoded0:[String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
    }
}

extension ExperimentTemplateAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentTemplateAction(actionId: \(String(describing: actionId)), description: \(String(describing: description)), parameters: \(String(describing: parameters)), startAfter: \(String(describing: startAfter)), targets: \(String(describing: targets)))"}
}

/// <p>Describes an action for an experiment template.</p>
public struct ExperimentTemplateAction: Equatable {
    /// <p>The ID of the action.</p>
    public let actionId: String?
    /// <p>A description for the action.</p>
    public let description: String?
    /// <p>The parameters for the action.</p>
    public let parameters: [String:String]?
    /// <p>The name of the action that must be completed before the current action starts.</p>
    public let startAfter: [String]?
    /// <p>The targets for the action.</p>
    public let targets: [String:String]?

    public init (
        actionId: String? = nil,
        description: String? = nil,
        parameters: [String:String]? = nil,
        startAfter: [String]? = nil,
        targets: [String:String]? = nil
    )
    {
        self.actionId = actionId
        self.description = description
        self.parameters = parameters
        self.startAfter = startAfter
        self.targets = targets
    }
}

extension ExperimentTemplateStopCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ExperimentTemplateStopCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentTemplateStopCondition(source: \(String(describing: source)), value: \(String(describing: value)))"}
}

/// <p>Describes a stop condition for an experiment template.</p>
public struct ExperimentTemplateStopCondition: Equatable {
    /// <p>The source for the stop condition.</p>
    public let source: String?
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.</p>
    public let value: String?

    public init (
        source: String? = nil,
        value: String? = nil
    )
    {
        self.source = source
        self.value = value
    }
}

extension ExperimentTemplateSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case description
        case id
        case lastUpdateTime
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ExperimentTemplateSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentTemplateSummary(creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdateTime: \(String(describing: lastUpdateTime)), tags: \(String(describing: tags)))"}
}

/// <p>Provides a summary of an experiment template.</p>
public struct ExperimentTemplateSummary: Equatable {
    /// <p>The time that the experiment template was created.</p>
    public let creationTime: Date?
    /// <p>The description of the experiment template.</p>
    public let description: String?
    /// <p>The ID of the experiment template.</p>
    public let id: String?
    /// <p>The time that the experiment template was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The tags for the experiment template.</p>
    public let tags: [String:String]?

    public init (
        creationTime: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdateTime: Date? = nil,
        tags: [String:String]? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastUpdateTime = lastUpdateTime
        self.tags = tags
    }
}

extension ExperimentTemplateTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttemplatetargetfilterlist0 in filters {
                try filtersContainer.encode(experimenttemplatetargetfilterlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .resourceTags)
            for (dictKey0, tagmap0) in resourceTags {
                try resourceTagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [String:String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ExperimentTemplateTargetFilter?].self, forKey: .filters)
        var filtersDecoded0:[ExperimentTemplateTargetFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ExperimentTemplateTargetFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
    }
}

extension ExperimentTemplateTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentTemplateTarget(filters: \(String(describing: filters)), resourceArns: \(String(describing: resourceArns)), resourceTags: \(String(describing: resourceTags)), resourceType: \(String(describing: resourceType)), selectionMode: \(String(describing: selectionMode)))"}
}

/// <p>Describes a target for an experiment template.</p>
public struct ExperimentTemplateTarget: Equatable {
    /// <p>The filters to apply to identify target resources using specific attributes.</p>
    public let filters: [ExperimentTemplateTargetFilter]?
    /// <p>The Amazon Resource Names (ARNs) of the targets.</p>
    public let resourceArns: [String]?
    /// <p>The tags for the target resources.</p>
    public let resourceTags: [String:String]?
    /// <p>The resource type.</p>
    public let resourceType: String?
    /// <p>Scopes the identified resources to a specific count or percentage.</p>
    public let selectionMode: String?

    public init (
        filters: [ExperimentTemplateTargetFilter]? = nil,
        resourceArns: [String]? = nil,
        resourceTags: [String:String]? = nil,
        resourceType: String? = nil,
        selectionMode: String? = nil
    )
    {
        self.filters = filters
        self.resourceArns = resourceArns
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.selectionMode = selectionMode
    }
}

extension ExperimentTemplateTargetFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case path
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for experimenttemplatetargetfiltervalues0 in values {
                try valuesContainer.encode(experimenttemplatetargetfiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ExperimentTemplateTargetFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentTemplateTargetFilter(path: \(String(describing: path)), values: \(String(describing: values)))"}
}

/// <p>Describes a filter used for the target resources in an experiment template.</p>
public struct ExperimentTemplateTargetFilter: Equatable {
    /// <p>The attribute path for the filter.</p>
    public let path: String?
    /// <p>The attribute values for the filter.</p>
    public let values: [String]?

    public init (
        path: String? = nil,
        values: [String]? = nil
    )
    {
        self.path = path
        self.values = values
    }
}

extension ExperimentTemplateTargetInputFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case path
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for experimenttemplatetargetfiltervalues0 in values {
                try valuesContainer.encode(experimenttemplatetargetfiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ExperimentTemplateTargetInputFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExperimentTemplateTargetInputFilter(path: \(String(describing: path)), values: \(String(describing: values)))"}
}

/// <p>Describes a filter used for the target resource input in an experiment template.</p>
public struct ExperimentTemplateTargetInputFilter: Equatable {
    /// <p>The attribute path for the filter.</p>
    public let path: String?
    /// <p>The attribute values for the filter.</p>
    public let values: [String]?

    public init (
        path: String? = nil,
        values: [String]? = nil
    )
    {
        self.path = path
        self.values = values
    }
}

extension GetActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetActionInput(id: \(String(describing: id)))"}
}

extension GetActionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetActionInputHeadersMiddleware: Middleware {
    public let id: String = "GetActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetActionInput>
    public typealias MOutput = OperationOutput<GetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetActionOutputError>
}

public struct GetActionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetActionInput>
    public typealias MOutput = OperationOutput<GetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetActionOutputError>
}

public struct GetActionInput: Equatable {
    /// <p>The ID of the action.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetActionInputBody: Equatable {
}

extension GetActionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetActionOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetActionOutputResponse(action: \(String(describing: action)))"}
}

extension GetActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
        } else {
            self.action = nil
        }
    }
}

public struct GetActionOutputResponse: Equatable {
    /// <p>Information about the action.</p>
    public let action: Action?

    public init (
        action: Action? = nil
    )
    {
        self.action = action
    }
}

struct GetActionOutputResponseBody: Equatable {
    public let action: Action?
}

extension GetActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
    }
}

extension GetExperimentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExperimentInput(id: \(String(describing: id)))"}
}

extension GetExperimentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetExperimentInputHeadersMiddleware: Middleware {
    public let id: String = "GetExperimentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExperimentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExperimentInput>
    public typealias MOutput = OperationOutput<GetExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExperimentOutputError>
}

public struct GetExperimentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetExperimentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExperimentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExperimentInput>
    public typealias MOutput = OperationOutput<GetExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExperimentOutputError>
}

public struct GetExperimentInput: Equatable {
    /// <p>The ID of the experiment.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetExperimentInputBody: Equatable {
}

extension GetExperimentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetExperimentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExperimentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExperimentOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExperimentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExperimentOutputResponse(experiment: \(String(describing: experiment)))"}
}

extension GetExperimentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct GetExperimentOutputResponse: Equatable {
    /// <p>Information about the experiment.</p>
    public let experiment: Experiment?

    public init (
        experiment: Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct GetExperimentOutputResponseBody: Equatable {
    public let experiment: Experiment?
}

extension GetExperimentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case experiment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

extension GetExperimentTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExperimentTemplateInput(id: \(String(describing: id)))"}
}

extension GetExperimentTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetExperimentTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetExperimentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExperimentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExperimentTemplateInput>
    public typealias MOutput = OperationOutput<GetExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExperimentTemplateOutputError>
}

public struct GetExperimentTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetExperimentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExperimentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExperimentTemplateInput>
    public typealias MOutput = OperationOutput<GetExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExperimentTemplateOutputError>
}

public struct GetExperimentTemplateInput: Equatable {
    /// <p>The ID of the experiment template.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetExperimentTemplateInputBody: Equatable {
}

extension GetExperimentTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetExperimentTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExperimentTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExperimentTemplateOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExperimentTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExperimentTemplateOutputResponse(experimentTemplate: \(String(describing: experimentTemplate)))"}
}

extension GetExperimentTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetExperimentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct GetExperimentTemplateOutputResponse: Equatable {
    /// <p>Information about the experiment template.</p>
    public let experimentTemplate: ExperimentTemplate?

    public init (
        experimentTemplate: ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct GetExperimentTemplateOutputResponseBody: Equatable {
    public let experimentTemplate: ExperimentTemplate?
}

extension GetExperimentTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case experimentTemplate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

extension ListActionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListActionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListActionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListActionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActionsInput>
    public typealias MOutput = OperationOutput<ListActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActionsOutputError>
}

public struct ListActionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActionsInput>
    public typealias MOutput = OperationOutput<ListActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActionsOutputError>
}

public struct ListActionsInput: Equatable {
    /// <p>The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListActionsInputBody: Equatable {
}

extension ListActionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListActionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListActionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListActionsOutputError: Swift.Error, Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListActionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListActionsOutputResponse(actions: \(String(describing: actions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListActionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct ListActionsOutputResponse: Equatable {
    /// <p>The actions.</p>
    public let actions: [ActionSummary]?
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?

    public init (
        actions: [ActionSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct ListActionsOutputResponseBody: Equatable {
    public let actions: [ActionSummary]?
    public let nextToken: String?
}

extension ListActionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([ActionSummary?].self, forKey: .actions)
        var actionsDecoded0:[ActionSummary]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [ActionSummary]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExperimentTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListExperimentTemplatesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListExperimentTemplatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListExperimentTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListExperimentTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExperimentTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExperimentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExperimentTemplatesInput>
    public typealias MOutput = OperationOutput<ListExperimentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExperimentTemplatesOutputError>
}

public struct ListExperimentTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListExperimentTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExperimentTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExperimentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExperimentTemplatesInput>
    public typealias MOutput = OperationOutput<ListExperimentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExperimentTemplatesOutputError>
}

public struct ListExperimentTemplatesInput: Equatable {
    /// <p>The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExperimentTemplatesInputBody: Equatable {
}

extension ListExperimentTemplatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListExperimentTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExperimentTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExperimentTemplatesOutputError: Swift.Error, Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExperimentTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListExperimentTemplatesOutputResponse(experimentTemplates: \(String(describing: experimentTemplates)), nextToken: \(String(describing: nextToken)))"}
}

extension ListExperimentTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListExperimentTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplates = output.experimentTemplates
            self.nextToken = output.nextToken
        } else {
            self.experimentTemplates = nil
            self.nextToken = nil
        }
    }
}

public struct ListExperimentTemplatesOutputResponse: Equatable {
    /// <p>The experiment templates.</p>
    public let experimentTemplates: [ExperimentTemplateSummary]?
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?

    public init (
        experimentTemplates: [ExperimentTemplateSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.experimentTemplates = experimentTemplates
        self.nextToken = nextToken
    }
}

struct ListExperimentTemplatesOutputResponseBody: Equatable {
    public let experimentTemplates: [ExperimentTemplateSummary]?
    public let nextToken: String?
}

extension ListExperimentTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case experimentTemplates
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplatesContainer = try containerValues.decodeIfPresent([ExperimentTemplateSummary?].self, forKey: .experimentTemplates)
        var experimentTemplatesDecoded0:[ExperimentTemplateSummary]? = nil
        if let experimentTemplatesContainer = experimentTemplatesContainer {
            experimentTemplatesDecoded0 = [ExperimentTemplateSummary]()
            for structure0 in experimentTemplatesContainer {
                if let structure0 = structure0 {
                    experimentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        experimentTemplates = experimentTemplatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExperimentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListExperimentsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListExperimentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListExperimentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListExperimentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExperimentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExperimentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExperimentsInput>
    public typealias MOutput = OperationOutput<ListExperimentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExperimentsOutputError>
}

public struct ListExperimentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListExperimentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExperimentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExperimentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExperimentsInput>
    public typealias MOutput = OperationOutput<ListExperimentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExperimentsOutputError>
}

public struct ListExperimentsInput: Equatable {
    /// <p>The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExperimentsInputBody: Equatable {
}

extension ListExperimentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListExperimentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExperimentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExperimentsOutputError: Swift.Error, Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExperimentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListExperimentsOutputResponse(experiments: \(String(describing: experiments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListExperimentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListExperimentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiments = output.experiments
            self.nextToken = output.nextToken
        } else {
            self.experiments = nil
            self.nextToken = nil
        }
    }
}

public struct ListExperimentsOutputResponse: Equatable {
    /// <p>The experiments.</p>
    public let experiments: [ExperimentSummary]?
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?

    public init (
        experiments: [ExperimentSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.experiments = experiments
        self.nextToken = nextToken
    }
}

struct ListExperimentsOutputResponseBody: Equatable {
    public let experiments: [ExperimentSummary]?
    public let nextToken: String?
}

extension ListExperimentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case experiments
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentsContainer = try containerValues.decodeIfPresent([ExperimentSummary?].self, forKey: .experiments)
        var experimentsDecoded0:[ExperimentSummary]? = nil
        if let experimentsContainer = experimentsContainer {
            experimentsDecoded0 = [ExperimentSummary]()
            for structure0 in experimentsContainer {
                if let structure0 = structure0 {
                    experimentsDecoded0?.append(structure0)
                }
            }
        }
        experiments = experimentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags for the resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource cannot be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded your service quota.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartExperimentInputBodyMiddleware: Middleware {
    public let id: String = "StartExperimentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExperimentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExperimentInput>
    public typealias MOutput = OperationOutput<StartExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExperimentOutputError>
}

extension StartExperimentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartExperimentInput(clientToken: \(String(describing: clientToken)), experimentTemplateId: \(String(describing: experimentTemplateId)), tags: \(String(describing: tags)))"}
}

extension StartExperimentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case experimentTemplateId
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let experimentTemplateId = experimentTemplateId {
            try encodeContainer.encode(experimentTemplateId, forKey: .experimentTemplateId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartExperimentInputHeadersMiddleware: Middleware {
    public let id: String = "StartExperimentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExperimentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExperimentInput>
    public typealias MOutput = OperationOutput<StartExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExperimentOutputError>
}

public struct StartExperimentInputQueryItemMiddleware: Middleware {
    public let id: String = "StartExperimentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExperimentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExperimentInput>
    public typealias MOutput = OperationOutput<StartExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExperimentOutputError>
}

public struct StartExperimentInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public var clientToken: String?
    /// <p>The ID of the experiment template.</p>
    public let experimentTemplateId: String?
    /// <p>The tags to apply to the experiment.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        experimentTemplateId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.experimentTemplateId = experimentTemplateId
        self.tags = tags
    }
}

struct StartExperimentInputBody: Equatable {
    public let clientToken: String?
    public let experimentTemplateId: String?
    public let tags: [String:String]?
}

extension StartExperimentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case experimentTemplateId
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let experimentTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .experimentTemplateId)
        experimentTemplateId = experimentTemplateIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartExperimentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartExperimentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartExperimentOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartExperimentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartExperimentOutputResponse(experiment: \(String(describing: experiment)))"}
}

extension StartExperimentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct StartExperimentOutputResponse: Equatable {
    /// <p>Information about the experiment.</p>
    public let experiment: Experiment?

    public init (
        experiment: Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct StartExperimentOutputResponseBody: Equatable {
    public let experiment: Experiment?
}

extension StartExperimentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case experiment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

extension StopExperimentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopExperimentInput(id: \(String(describing: id)))"}
}

extension StopExperimentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopExperimentInputHeadersMiddleware: Middleware {
    public let id: String = "StopExperimentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopExperimentInput>,
                  next: H) -> Swift.Result<OperationOutput<StopExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopExperimentInput>
    public typealias MOutput = OperationOutput<StopExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopExperimentOutputError>
}

public struct StopExperimentInputQueryItemMiddleware: Middleware {
    public let id: String = "StopExperimentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopExperimentInput>,
                  next: H) -> Swift.Result<OperationOutput<StopExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopExperimentInput>
    public typealias MOutput = OperationOutput<StopExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopExperimentOutputError>
}

public struct StopExperimentInput: Equatable {
    /// <p>The ID of the experiment.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct StopExperimentInputBody: Equatable {
}

extension StopExperimentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopExperimentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopExperimentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopExperimentOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopExperimentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopExperimentOutputResponse(experiment: \(String(describing: experiment)))"}
}

extension StopExperimentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct StopExperimentOutputResponse: Equatable {
    /// <p>Information about the experiment.</p>
    public let experiment: Experiment?

    public init (
        experiment: Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct StopExperimentOutputResponseBody: Equatable {
    public let experiment: Experiment?
}

extension StopExperimentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case experiment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tags for the resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tag keys to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateExperimentTemplateActionInputItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, experimenttemplateactionparametermap0) in parameters {
                try parametersContainer.encode(experimenttemplateactionparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimenttemplateactionstartafterlist0 in startAfter {
                try startAfterContainer.encode(experimenttemplateactionstartafterlist0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .targets)
            for (dictKey0, experimenttemplateactiontargetmap0) in targets {
                try targetsContainer.encode(experimenttemplateactiontargetmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, experimenttemplateactionparameter0) in parametersContainer {
                if let experimenttemplateactionparameter0 = experimenttemplateactionparameter0 {
                    parametersDecoded0?[key0] = experimenttemplateactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .targets)
        var targetsDecoded0: [String:String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String:String]()
            for (key0, experimenttemplatetargetname0) in targetsContainer {
                if let experimenttemplatetargetname0 = experimenttemplatetargetname0 {
                    targetsDecoded0?[key0] = experimenttemplatetargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([String?].self, forKey: .startAfter)
        var startAfterDecoded0:[String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
    }
}

extension UpdateExperimentTemplateActionInputItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateExperimentTemplateActionInputItem(actionId: \(String(describing: actionId)), description: \(String(describing: description)), parameters: \(String(describing: parameters)), startAfter: \(String(describing: startAfter)), targets: \(String(describing: targets)))"}
}

/// <p>Specifies an action for an experiment template.</p>
public struct UpdateExperimentTemplateActionInputItem: Equatable {
    /// <p>The ID of the action.</p>
    public let actionId: String?
    /// <p>A description for the action.</p>
    public let description: String?
    /// <p>The parameters for the action, if applicable.</p>
    public let parameters: [String:String]?
    /// <p>The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.</p>
    public let startAfter: [String]?
    /// <p>The targets for the action.</p>
    public let targets: [String:String]?

    public init (
        actionId: String? = nil,
        description: String? = nil,
        parameters: [String:String]? = nil,
        startAfter: [String]? = nil,
        targets: [String:String]? = nil
    )
    {
        self.actionId = actionId
        self.description = description
        self.parameters = parameters
        self.startAfter = startAfter
        self.targets = targets
    }
}

public struct UpdateExperimentTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateExperimentTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateExperimentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateExperimentTemplateInput>
    public typealias MOutput = OperationOutput<UpdateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateExperimentTemplateOutputError>
}

extension UpdateExperimentTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateExperimentTemplateInput(actions: \(String(describing: actions)), description: \(String(describing: description)), id: \(String(describing: id)), roleArn: \(String(describing: roleArn)), stopConditions: \(String(describing: stopConditions)), targets: \(String(describing: targets)))"}
}

extension UpdateExperimentTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case description
        case roleArn
        case stopConditions
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .actions)
            for (dictKey0, updateexperimenttemplateactioninputmap0) in actions {
                try actionsContainer.encode(updateexperimenttemplateactioninputmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for updateexperimenttemplatestopconditioninputlist0 in stopConditions {
                try stopConditionsContainer.encode(updateexperimenttemplatestopconditioninputlist0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .targets)
            for (dictKey0, updateexperimenttemplatetargetinputmap0) in targets {
                try targetsContainer.encode(updateexperimenttemplatetargetinputmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateExperimentTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateExperimentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateExperimentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateExperimentTemplateInput>
    public typealias MOutput = OperationOutput<UpdateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateExperimentTemplateOutputError>
}

public struct UpdateExperimentTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateExperimentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateExperimentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateExperimentTemplateInput>
    public typealias MOutput = OperationOutput<UpdateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateExperimentTemplateOutputError>
}

public struct UpdateExperimentTemplateInput: Equatable {
    /// <p>The actions for the experiment.</p>
    public let actions: [String:UpdateExperimentTemplateActionInputItem]?
    /// <p>A description for the template.</p>
    public let description: String?
    /// <p>The ID of the experiment template.</p>
    public let id: String?
    /// <p>The Amazon Resource Name (ARN) of an IAM role that grants the AWS FIS service permission to perform service actions on your behalf.</p>
    public let roleArn: String?
    /// <p>The stop conditions for the experiment.</p>
    public let stopConditions: [UpdateExperimentTemplateStopConditionInput]?
    /// <p>The targets for the experiment.</p>
    public let targets: [String:UpdateExperimentTemplateTargetInput]?

    public init (
        actions: [String:UpdateExperimentTemplateActionInputItem]? = nil,
        description: String? = nil,
        id: String? = nil,
        roleArn: String? = nil,
        stopConditions: [UpdateExperimentTemplateStopConditionInput]? = nil,
        targets: [String:UpdateExperimentTemplateTargetInput]? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.id = id
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.targets = targets
    }
}

struct UpdateExperimentTemplateInputBody: Equatable {
    public let description: String?
    public let stopConditions: [UpdateExperimentTemplateStopConditionInput]?
    public let targets: [String:UpdateExperimentTemplateTargetInput]?
    public let actions: [String:UpdateExperimentTemplateActionInputItem]?
    public let roleArn: String?
}

extension UpdateExperimentTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions
        case description
        case roleArn
        case stopConditions
        case targets
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stopConditionsContainer = try containerValues.decodeIfPresent([UpdateExperimentTemplateStopConditionInput?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[UpdateExperimentTemplateStopConditionInput]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [UpdateExperimentTemplateStopConditionInput]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([String: UpdateExperimentTemplateTargetInput?].self, forKey: .targets)
        var targetsDecoded0: [String:UpdateExperimentTemplateTargetInput]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String:UpdateExperimentTemplateTargetInput]()
            for (key0, updateexperimenttemplatetargetinput0) in targetsContainer {
                if let updateexperimenttemplatetargetinput0 = updateexperimenttemplatetargetinput0 {
                    targetsDecoded0?[key0] = updateexperimenttemplatetargetinput0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([String: UpdateExperimentTemplateActionInputItem?].self, forKey: .actions)
        var actionsDecoded0: [String:UpdateExperimentTemplateActionInputItem]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [String:UpdateExperimentTemplateActionInputItem]()
            for (key0, updateexperimenttemplateactioninputitem0) in actionsContainer {
                if let updateexperimenttemplateactioninputitem0 = updateexperimenttemplateactioninputitem0 {
                    actionsDecoded0?[key0] = updateexperimenttemplateactioninputitem0
                }
            }
        }
        actions = actionsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateExperimentTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateExperimentTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateExperimentTemplateOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateExperimentTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateExperimentTemplateOutputResponse(experimentTemplate: \(String(describing: experimentTemplate)))"}
}

extension UpdateExperimentTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateExperimentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct UpdateExperimentTemplateOutputResponse: Equatable {
    /// <p>Information about the experiment template.</p>
    public let experimentTemplate: ExperimentTemplate?

    public init (
        experimentTemplate: ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct UpdateExperimentTemplateOutputResponseBody: Equatable {
    public let experimentTemplate: ExperimentTemplate?
}

extension UpdateExperimentTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case experimentTemplate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

extension UpdateExperimentTemplateStopConditionInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension UpdateExperimentTemplateStopConditionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateExperimentTemplateStopConditionInput(source: \(String(describing: source)), value: \(String(describing: value)))"}
}

/// <p>Specifies a stop condition for an experiment. You can define a stop condition as a CloudWatch alarm.</p>
public struct UpdateExperimentTemplateStopConditionInput: Equatable {
    /// <p>The source for the stop condition. Specify <code>aws:cloudwatch:alarm</code> if the stop
    ///          condition is defined by a CloudWatch alarm. Specify <code>none</code> if there is no stop
    ///          condition.</p>
    public let source: String?
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch alarm.</p>
    public let value: String?

    public init (
        source: String? = nil,
        value: String? = nil
    )
    {
        self.source = source
        self.value = value
    }
}

extension UpdateExperimentTemplateTargetInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttemplatetargetfilterinputlist0 in filters {
                try filtersContainer.encode(experimenttemplatetargetfilterinputlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .resourceTags)
            for (dictKey0, tagmap0) in resourceTags {
                try resourceTagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [String:String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ExperimentTemplateTargetInputFilter?].self, forKey: .filters)
        var filtersDecoded0:[ExperimentTemplateTargetInputFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ExperimentTemplateTargetInputFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
    }
}

extension UpdateExperimentTemplateTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateExperimentTemplateTargetInput(filters: \(String(describing: filters)), resourceArns: \(String(describing: resourceArns)), resourceTags: \(String(describing: resourceTags)), resourceType: \(String(describing: resourceType)), selectionMode: \(String(describing: selectionMode)))"}
}

/// <p>Specifies a target for an experiment. You must specify at least one Amazon Resource Name (ARN) or at least one resource tag. You cannot specify both.</p>
public struct UpdateExperimentTemplateTargetInput: Equatable {
    /// <p>The filters to apply to identify target resources using specific attributes.</p>
    public let filters: [ExperimentTemplateTargetInputFilter]?
    /// <p>The Amazon Resource Names (ARNs) of the targets.</p>
    public let resourceArns: [String]?
    /// <p>The tags for the target resources.</p>
    public let resourceTags: [String:String]?
    /// <p>The AWS resource type. The resource type must be supported for the specified action.</p>
    public let resourceType: String?
    /// <p>Scopes the identified resources to a specific count or percentage.</p>
    public let selectionMode: String?

    public init (
        filters: [ExperimentTemplateTargetInputFilter]? = nil,
        resourceArns: [String]? = nil,
        resourceTags: [String:String]? = nil,
        resourceType: String? = nil,
        selectionMode: String? = nil
    )
    {
        self.filters = filters
        self.resourceArns = resourceArns
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.selectionMode = selectionMode
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified input is not valid, or fails to satisfy the constraints for the request.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
