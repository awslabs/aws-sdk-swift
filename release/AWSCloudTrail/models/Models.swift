// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountHasOngoingImportException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccountHasOngoingImportExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when you start a new import and a previous import is still in progress.
public struct AccountHasOngoingImportException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountHasOngoingImportExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountHasOngoingImportExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccountNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when when the specified account is not found or not part of an organization.
public struct AccountNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountNotRegisteredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccountNotRegisteredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified account is not registered as the CloudTrail delegated administrator.
public struct AccountNotRegisteredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountNotRegisteredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountNotRegisteredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountRegisteredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccountRegisteredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the account is already registered as the CloudTrail delegated administrator.
public struct AccountRegisteredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountRegisteredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountRegisteredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tag0 in tagsList {
                try tagsListContainer.encode(tag0)
            }
        }
    }
}

extension AddTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies the tags to add to a trail or event data store.
public struct AddTagsInput: Swift.Equatable {
    /// Specifies the ARN of the trail or event data store to which one or more tags will be added. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var resourceId: Swift.String?
    /// Contains a list of tags, up to a limit of 50
    /// This member is required.
    public var tagsList: [CloudTrailClientTypes.Tag]?

    public init (
        resourceId: Swift.String? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagsList = tagsList
    }
}

struct AddTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagsList: [CloudTrailClientTypes.Tag]?
}

extension AddTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension AddTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InactiveEventDataStore" : self = .inactiveEventDataStoreException(try InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameter" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceTypeNotSupported" : self = .resourceTypeNotSupportedException(try ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsLimitExceeded" : self = .tagsLimitExceededException(try TagsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddTagsOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case conflictException(ConflictException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case inactiveEventDataStoreException(InactiveEventDataStoreException)
    case invalidTagParameterException(InvalidTagParameterException)
    case invalidTrailNameException(InvalidTrailNameException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceTypeNotSupportedException(ResourceTypeNotSupportedException)
    case tagsLimitExceededException(TagsLimitExceededException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Returns the objects or data if successful. Otherwise, returns an error.
public struct AddTagsOutputResponse: Swift.Equatable {

    public init () { }
}

extension CloudTrailClientTypes.AdvancedEventSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldSelectors = "FieldSelectors"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldSelectors = fieldSelectors {
            var fieldSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldSelectors)
            for advancedfieldselector0 in fieldSelectors {
                try fieldSelectorsContainer.encode(advancedfieldselector0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fieldSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedFieldSelector?].self, forKey: .fieldSelectors)
        var fieldSelectorsDecoded0:[CloudTrailClientTypes.AdvancedFieldSelector]? = nil
        if let fieldSelectorsContainer = fieldSelectorsContainer {
            fieldSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedFieldSelector]()
            for structure0 in fieldSelectorsContainer {
                if let structure0 = structure0 {
                    fieldSelectorsDecoded0?.append(structure0)
                }
            }
        }
        fieldSelectors = fieldSelectorsDecoded0
    }
}

extension CloudTrailClientTypes {
    /// Advanced event selectors let you create fine-grained selectors for the following CloudTrail event record ﬁelds. They help you control costs by logging only those events that are important to you. For more information about advanced event selectors, see [Logging data events for trails](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html) in the CloudTrail User Guide.
    ///
    /// * readOnly
    ///
    /// * eventSource
    ///
    /// * eventName
    ///
    /// * eventCategory
    ///
    /// * resources.type
    ///
    /// * resources.ARN
    ///
    ///
    /// You cannot apply both event selectors and advanced event selectors to a trail.
    public struct AdvancedEventSelector: Swift.Equatable {
        /// Contains all selector statements in an advanced event selector.
        /// This member is required.
        public var fieldSelectors: [CloudTrailClientTypes.AdvancedFieldSelector]?
        /// An optional, descriptive name for an advanced event selector, such as "Log data events for only two S3 buckets".
        public var name: Swift.String?

        public init (
            fieldSelectors: [CloudTrailClientTypes.AdvancedFieldSelector]? = nil,
            name: Swift.String? = nil
        )
        {
            self.fieldSelectors = fieldSelectors
            self.name = name
        }
    }

}

extension CloudTrailClientTypes.AdvancedFieldSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endsWith = "EndsWith"
        case equals = "Equals"
        case field = "Field"
        case notEndsWith = "NotEndsWith"
        case notEquals = "NotEquals"
        case notStartsWith = "NotStartsWith"
        case startsWith = "StartsWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endsWith = endsWith {
            var endsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endsWith)
            for operatorvalue0 in endsWith {
                try endsWithContainer.encode(operatorvalue0)
            }
        }
        if let equals = equals {
            var equalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .equals)
            for operatorvalue0 in equals {
                try equalsContainer.encode(operatorvalue0)
            }
        }
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let notEndsWith = notEndsWith {
            var notEndsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEndsWith)
            for operatorvalue0 in notEndsWith {
                try notEndsWithContainer.encode(operatorvalue0)
            }
        }
        if let notEquals = notEquals {
            var notEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEquals)
            for operatorvalue0 in notEquals {
                try notEqualsContainer.encode(operatorvalue0)
            }
        }
        if let notStartsWith = notStartsWith {
            var notStartsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notStartsWith)
            for operatorvalue0 in notStartsWith {
                try notStartsWithContainer.encode(operatorvalue0)
            }
        }
        if let startsWith = startsWith {
            var startsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startsWith)
            for operatorvalue0 in startsWith {
                try startsWithContainer.encode(operatorvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let equalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .equals)
        var equalsDecoded0:[Swift.String]? = nil
        if let equalsContainer = equalsContainer {
            equalsDecoded0 = [Swift.String]()
            for string0 in equalsContainer {
                if let string0 = string0 {
                    equalsDecoded0?.append(string0)
                }
            }
        }
        equals = equalsDecoded0
        let startsWithContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startsWith)
        var startsWithDecoded0:[Swift.String]? = nil
        if let startsWithContainer = startsWithContainer {
            startsWithDecoded0 = [Swift.String]()
            for string0 in startsWithContainer {
                if let string0 = string0 {
                    startsWithDecoded0?.append(string0)
                }
            }
        }
        startsWith = startsWithDecoded0
        let endsWithContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endsWith)
        var endsWithDecoded0:[Swift.String]? = nil
        if let endsWithContainer = endsWithContainer {
            endsWithDecoded0 = [Swift.String]()
            for string0 in endsWithContainer {
                if let string0 = string0 {
                    endsWithDecoded0?.append(string0)
                }
            }
        }
        endsWith = endsWithDecoded0
        let notEqualsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notEquals)
        var notEqualsDecoded0:[Swift.String]? = nil
        if let notEqualsContainer = notEqualsContainer {
            notEqualsDecoded0 = [Swift.String]()
            for string0 in notEqualsContainer {
                if let string0 = string0 {
                    notEqualsDecoded0?.append(string0)
                }
            }
        }
        notEquals = notEqualsDecoded0
        let notStartsWithContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notStartsWith)
        var notStartsWithDecoded0:[Swift.String]? = nil
        if let notStartsWithContainer = notStartsWithContainer {
            notStartsWithDecoded0 = [Swift.String]()
            for string0 in notStartsWithContainer {
                if let string0 = string0 {
                    notStartsWithDecoded0?.append(string0)
                }
            }
        }
        notStartsWith = notStartsWithDecoded0
        let notEndsWithContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notEndsWith)
        var notEndsWithDecoded0:[Swift.String]? = nil
        if let notEndsWithContainer = notEndsWithContainer {
            notEndsWithDecoded0 = [Swift.String]()
            for string0 in notEndsWithContainer {
                if let string0 = string0 {
                    notEndsWithDecoded0?.append(string0)
                }
            }
        }
        notEndsWith = notEndsWithDecoded0
    }
}

extension CloudTrailClientTypes {
    /// A single selector statement in an advanced event selector.
    public struct AdvancedFieldSelector: Swift.Equatable {
        /// An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        public var endsWith: [Swift.String]?
        /// An operator that includes events that match the exact value of the event record field specified as the value of Field. This is the only valid operator that you can use with the readOnly, eventCategory, and resources.type fields.
        public var equals: [Swift.String]?
        /// A field in an event record on which to filter events to be logged. Supported fields include readOnly, eventCategory, eventSource (for management events), eventName, resources.type, and resources.ARN.
        ///
        /// * readOnly - Optional. Can be set to Equals a value of true or false. If you do not add this field, CloudTrail logs both read and write events. A value of true logs only read events. A value of false logs only write events.
        ///
        /// * eventSource - For filtering management events only. This can be set only to NotEqualskms.amazonaws.com.
        ///
        /// * eventName - Can use any operator. You can use it to ﬁlter in or ﬁlter out any data event logged to CloudTrail, such as PutBucket or GetSnapshotBlock. You can have multiple values for this ﬁeld, separated by commas.
        ///
        /// * eventCategory - This is required. It must be set to Equals, and the value must be Management or Data.
        ///
        /// * resources.type - This ﬁeld is required. resources.type can only use the Equals operator, and the value can be one of the following:
        ///
        /// * AWS::S3::Object
        ///
        /// * AWS::Lambda::Function
        ///
        /// * AWS::DynamoDB::Table
        ///
        /// * AWS::S3Outposts::Object
        ///
        /// * AWS::ManagedBlockchain::Node
        ///
        /// * AWS::S3ObjectLambda::AccessPoint
        ///
        /// * AWS::EC2::Snapshot
        ///
        /// * AWS::S3::AccessPoint
        ///
        /// * AWS::DynamoDB::Stream
        ///
        /// * AWS::Glue::Table
        ///
        ///
        /// You can have only one resources.type ﬁeld per selector. To log data events on more than one resource type, add another selector.
        ///
        /// * resources.ARN - You can use any operator with resources.ARN, but if you use Equals or NotEquals, the value must exactly match the ARN of a valid resource of the type you've speciﬁed in the template as the value of resources.type. For example, if resources.type equals AWS::S3::Object, the ARN must be in one of the following formats. To log all data events for all objects in a specific S3 bucket, use the StartsWith operator, and include only the bucket ARN as the matching value. The trailing slash is intentional; do not exclude it. Replace the text between less than and greater than symbols (<>) with resource-specific information.
        ///
        /// * arn::s3:::/
        ///
        /// * arn::s3::://
        ///
        ///
        /// When resources.type equals AWS::S3::AccessPoint, and the operator is set to Equals or NotEquals, the ARN must be in one of the following formats. To log events on all objects in an S3 access point, we recommend that you use only the access point ARN, don’t include the object path, and use the StartsWith or NotStartsWith operators.
        ///
        /// * arn::s3:::accesspoint/
        ///
        /// * arn::s3:::accesspoint//object/
        ///
        ///
        /// When resources.type equals AWS::Lambda::Function, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::lambda:::function:
        ///
        ///
        /// When resources.type equals AWS::DynamoDB::Table, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::dynamodb:::table/
        ///
        ///
        /// When resources.type equals AWS::S3Outposts::Object, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::s3-outposts:::
        ///
        ///
        /// When resources.type equals AWS::ManagedBlockchain::Node, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::managedblockchain:::nodes/
        ///
        ///
        /// When resources.type equals AWS::S3ObjectLambda::AccessPoint, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::s3-object-lambda:::accesspoint/
        ///
        ///
        /// When resources.type equals AWS::EC2::Snapshot, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::ec2:::snapshot/
        ///
        ///
        /// When resources.type equals AWS::DynamoDB::Stream, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::dynamodb:::table//stream/
        ///
        ///
        /// When resources.type equals AWS::Glue::Table, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::glue:::table//
        /// This member is required.
        public var field: Swift.String?
        /// An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        public var notEndsWith: [Swift.String]?
        /// An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        public var notEquals: [Swift.String]?
        /// An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        public var notStartsWith: [Swift.String]?
        /// An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        public var startsWith: [Swift.String]?

        public init (
            endsWith: [Swift.String]? = nil,
            equals: [Swift.String]? = nil,
            field: Swift.String? = nil,
            notEndsWith: [Swift.String]? = nil,
            notEquals: [Swift.String]? = nil,
            notStartsWith: [Swift.String]? = nil,
            startsWith: [Swift.String]? = nil
        )
        {
            self.endsWith = endsWith
            self.equals = equals
            self.field = field
            self.notEndsWith = notEndsWith
            self.notEquals = notEquals
            self.notStartsWith = notStartsWith
            self.startsWith = startsWith
        }
    }

}

extension CancelQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
        case queryId = "QueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
    }
}

extension CancelQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelQueryInput: Swift.Equatable {
    /// The ARN (or the ID suffix of the ARN) of an event data store on which the specified query is running.
    @available(*, deprecated, message: "EventDataStore is no longer required by CancelQueryRequest")
    public var eventDataStore: Swift.String?
    /// The ID of the query that you want to cancel. The QueryId comes from the response of a StartQuery operation.
    /// This member is required.
    public var queryId: Swift.String?

    public init (
        eventDataStore: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
        self.queryId = queryId
    }
}

struct CancelQueryInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
    let queryId: Swift.String?
}

extension CancelQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
        case queryId = "QueryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
    }
}

extension CancelQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreARNInvalid" : self = .eventDataStoreARNInvalidException(try EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InactiveEventDataStore" : self = .inactiveEventDataStoreException(try InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InactiveQuery" : self = .inactiveQueryException(try InactiveQueryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryIdNotFound" : self = .queryIdNotFoundException(try QueryIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelQueryOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case eventDataStoreARNInvalidException(EventDataStoreARNInvalidException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case inactiveEventDataStoreException(InactiveEventDataStoreException)
    case inactiveQueryException(InactiveQueryException)
    case invalidParameterException(InvalidParameterException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case operationNotPermittedException(OperationNotPermittedException)
    case queryIdNotFoundException(QueryIdNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryId = output.queryId
            self.queryStatus = output.queryStatus
        } else {
            self.queryId = nil
            self.queryStatus = nil
        }
    }
}

public struct CancelQueryOutputResponse: Swift.Equatable {
    /// The ID of the canceled query.
    /// This member is required.
    public var queryId: Swift.String?
    /// Shows the status of a query after a CancelQuery request. Typically, the values shown are either RUNNING or CANCELLED.
    /// This member is required.
    public var queryStatus: CloudTrailClientTypes.QueryStatus?

    public init (
        queryId: Swift.String? = nil,
        queryStatus: CloudTrailClientTypes.QueryStatus? = nil
    )
    {
        self.queryId = queryId
        self.queryStatus = queryStatus
    }
}

struct CancelQueryOutputResponseBody: Swift.Equatable {
    let queryId: Swift.String?
    let queryStatus: CloudTrailClientTypes.QueryStatus?
}

extension CancelQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
        case queryStatus = "QueryStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
    }
}

extension CannotDelegateManagementAccountException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CannotDelegateManagementAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the management account of an organization is registered as the CloudTrail delegated administrator.
public struct CannotDelegateManagementAccountException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CannotDelegateManagementAccountExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CannotDelegateManagementAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.Channel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CloudTrailClientTypes {
    /// Contains information about a returned CloudTrail channel.
    public struct Channel: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a channel.
        public var channelArn: Swift.String?
        /// The name of the CloudTrail channel. For service-linked channels, the name is aws-service-channel/service-name/custom-suffix where service-name represents the name of the Amazon Web Services service that created the channel and custom-suffix represents the suffix created by the Amazon Web Services service.
        public var name: Swift.String?

        public init (
            channelArn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.channelArn = channelArn
            self.name = name
        }
    }

}

extension ChannelARNInvalidException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ChannelARNInvalidExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified value of ChannelARN is not valid.
public struct ChannelARNInvalidException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ChannelARNInvalidExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ChannelARNInvalidExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChannelNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ChannelNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified channel was not found.
public struct ChannelNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ChannelNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ChannelNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailARNInvalidException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CloudTrailARNInvalidExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when an operation is called with a trail ARN that is not valid. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
public struct CloudTrailARNInvalidException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudTrailARNInvalidExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudTrailARNInvalidExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailAccessNotEnabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CloudTrailAccessNotEnabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when trusted access has not been enabled between CloudTrail and Organizations. For more information, see [Enabling Trusted Access with Other Amazon Web Services Services](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_integrate_services.html) and [Prepare For Creating a Trail For Your Organization](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html).
public struct CloudTrailAccessNotEnabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudTrailAccessNotEnabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudTrailAccessNotEnabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailInvalidClientTokenIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CloudTrailInvalidClientTokenIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when a call results in the InvalidClientTokenId error code. This can occur when you are creating or updating a trail to send notifications to an Amazon SNS topic that is in a suspended Amazon Web Services account.
public struct CloudTrailInvalidClientTokenIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudTrailInvalidClientTokenIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudTrailInvalidClientTokenIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudWatchLogsDeliveryUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CloudWatchLogsDeliveryUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot set a CloudWatch Logs delivery for this region.
public struct CloudWatchLogsDeliveryUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudWatchLogsDeliveryUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudWatchLogsDeliveryUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified resource is not ready for an operation. This can occur when you try to run an operation on a resource before CloudTrail has time to fully load the resource. If this exception occurs, wait a few minutes, and then try the operation again.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateEventDataStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case tagsList = "TagsList"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedEventSelectors = advancedEventSelectors {
            var advancedEventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedEventSelectors)
            for advancedeventselector0 in advancedEventSelectors {
                try advancedEventSelectorsContainer.encode(advancedeventselector0)
            }
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let multiRegionEnabled = self.multiRegionEnabled {
            try encodeContainer.encode(multiRegionEnabled, forKey: .multiRegionEnabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationEnabled = self.organizationEnabled {
            try encodeContainer.encode(organizationEnabled, forKey: .organizationEnabled)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tag0 in tagsList {
                try tagsListContainer.encode(tag0)
            }
        }
        if let terminationProtectionEnabled = self.terminationProtectionEnabled {
            try encodeContainer.encode(terminationProtectionEnabled, forKey: .terminationProtectionEnabled)
        }
    }
}

extension CreateEventDataStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEventDataStoreInput: Swift.Equatable {
    /// The advanced event selectors to use to select the events for the data store. For more information about how to use advanced event selectors, see [Log events by using advanced event selectors](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html#creating-data-event-selectors-advanced) in the CloudTrail User Guide.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// Specifies the KMS key ID to use to encrypt the events delivered by CloudTrail. The value can be an alias name prefixed by alias/, a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. Disabling or deleting the KMS key, or removing CloudTrail permissions on the key, prevents CloudTrail from logging events to the event data store, and prevents users from querying the data in the event data store that was encrypted with the key. After you associate an event data store with a KMS key, the KMS key cannot be removed or changed. Before you disable or delete a KMS key that you are using with an event data store, delete or back up your event data store. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether the event data store includes events from all regions, or only from the region in which the event data store is created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies whether an event data store collects events logged for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period of the event data store, in days. You can set a retention period of up to 2557 days, the equivalent of seven years.
    public var retentionPeriod: Swift.Int?
    /// A list of tags.
    public var tagsList: [CloudTrailClientTypes.Tag]?
    /// Specifies whether termination protection is enabled for the event data store. If termination protection is enabled, you cannot delete the event data store until termination protection is disabled.
    public var terminationProtectionEnabled: Swift.Bool?

    public init (
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.tagsList = tagsList
        self.terminationProtectionEnabled = terminationProtectionEnabled
    }
}

struct CreateEventDataStoreInputBody: Swift.Equatable {
    let name: Swift.String?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    let multiRegionEnabled: Swift.Bool?
    let organizationEnabled: Swift.Bool?
    let retentionPeriod: Swift.Int?
    let terminationProtectionEnabled: Swift.Bool?
    let tagsList: [CloudTrailClientTypes.Tag]?
    let kmsKeyId: Swift.String?
}

extension CreateEventDataStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case tagsList = "TagsList"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension CreateEventDataStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventDataStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailAccessNotEnabled" : self = .cloudTrailAccessNotEnabledException(try CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreAlreadyExists" : self = .eventDataStoreAlreadyExistsException(try EventDataStoreAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreMaxLimitExceeded" : self = .eventDataStoreMaxLimitExceededException(try EventDataStoreMaxLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientEncryptionPolicy" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventSelectors" : self = .invalidEventSelectorsException(try InvalidEventSelectorsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKmsKeyId" : self = .invalidKmsKeyIdException(try InvalidKmsKeyIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameter" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyNotFound" : self = .kmsKeyNotFoundException(try KmsKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesMode" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationsNotInUse" : self = .organizationsNotInUseException(try OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateEventDataStoreOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailAccessNotEnabledException(CloudTrailAccessNotEnabledException)
    case conflictException(ConflictException)
    case eventDataStoreAlreadyExistsException(EventDataStoreAlreadyExistsException)
    case eventDataStoreMaxLimitExceededException(EventDataStoreMaxLimitExceededException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case invalidEventSelectorsException(InvalidEventSelectorsException)
    case invalidKmsKeyIdException(InvalidKmsKeyIdException)
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case kmsException(KmsException)
    case kmsKeyNotFoundException(KmsKeyNotFoundException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case organizationsNotInUseException(OrganizationsNotInUseException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventDataStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateEventDataStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.createdTimestamp = output.createdTimestamp
            self.eventDataStoreArn = output.eventDataStoreArn
            self.kmsKeyId = output.kmsKeyId
            self.multiRegionEnabled = output.multiRegionEnabled
            self.name = output.name
            self.organizationEnabled = output.organizationEnabled
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
            self.tagsList = output.tagsList
            self.terminationProtectionEnabled = output.terminationProtectionEnabled
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.advancedEventSelectors = nil
            self.createdTimestamp = nil
            self.eventDataStoreArn = nil
            self.kmsKeyId = nil
            self.multiRegionEnabled = nil
            self.name = nil
            self.organizationEnabled = nil
            self.retentionPeriod = nil
            self.status = nil
            self.tagsList = nil
            self.terminationProtectionEnabled = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct CreateEventDataStoreOutputResponse: Swift.Equatable {
    /// The advanced event selectors that were used to select the events for the data store.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The timestamp that shows when the event data store was created.
    public var createdTimestamp: ClientRuntime.Date?
    /// The ARN of the event data store.
    public var eventDataStoreArn: Swift.String?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Indicates whether the event data store collects events from all regions, or only from the region in which it was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    public var name: Swift.String?
    /// Indicates whether an event data store is collecting logged events for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period of an event data store, in days.
    public var retentionPeriod: Swift.Int?
    /// The status of event data store creation.
    public var status: CloudTrailClientTypes.EventDataStoreStatus?
    /// A list of tags.
    public var tagsList: [CloudTrailClientTypes.Tag]?
    /// Indicates whether termination protection is enabled for the event data store.
    public var terminationProtectionEnabled: Swift.Bool?
    /// The timestamp that shows when an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
    public var updatedTimestamp: ClientRuntime.Date?

    public init (
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        eventDataStoreArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.createdTimestamp = createdTimestamp
        self.eventDataStoreArn = eventDataStoreArn
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.tagsList = tagsList
        self.terminationProtectionEnabled = terminationProtectionEnabled
        self.updatedTimestamp = updatedTimestamp
    }
}

struct CreateEventDataStoreOutputResponseBody: Swift.Equatable {
    let eventDataStoreArn: Swift.String?
    let name: Swift.String?
    let status: CloudTrailClientTypes.EventDataStoreStatus?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    let multiRegionEnabled: Swift.Bool?
    let organizationEnabled: Swift.Bool?
    let retentionPeriod: Swift.Int?
    let terminationProtectionEnabled: Swift.Bool?
    let tagsList: [CloudTrailClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
    let kmsKeyId: Swift.String?
}

extension CreateEventDataStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case createdTimestamp = "CreatedTimestamp"
        case eventDataStoreArn = "EventDataStoreArn"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case tagsList = "TagsList"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStoreArn)
        eventDataStoreArn = eventDataStoreArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventDataStoreStatus.self, forKey: .status)
        status = statusDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension CreateTrailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = self.cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = self.cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let enableLogFileValidation = self.enableLogFileValidation {
            try encodeContainer.encode(enableLogFileValidation, forKey: .enableLogFileValidation)
        }
        if let includeGlobalServiceEvents = self.includeGlobalServiceEvents {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if let isMultiRegionTrail = self.isMultiRegionTrail {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if let isOrganizationTrail = self.isOrganizationTrail {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicName = self.snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tag0 in tagsList {
                try tagsListContainer.encode(tag0)
            }
        }
    }
}

extension CreateTrailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies the settings for each trail.
public struct CreateTrailInput: Swift.Equatable {
    /// Specifies a log group name using an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered. Not required unless you specify CloudWatchLogsRoleArn.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether log file integrity validation is enabled. The default is false. When you disable log file integrity validation, the chain of digest files is broken after one hour. CloudTrail does not create digest files for log files that were delivered during a period in which log file integrity validation was disabled. For example, if you enable log file integrity validation at noon on January 1, disable it at noon on January 2, and re-enable it at noon on January 10, digest files will not be created for the log files delivered from noon on January 2 to noon on January 10. The same applies whenever you stop CloudTrail logging or delete a trail.
    public var enableLogFileValidation: Swift.Bool?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail is created in the current region or in all regions. The default is false, which creates a trail only in the region where you are signed in. As a best practice, consider creating trails that log events in all regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is created for all accounts in an organization in Organizations, or only for the current Amazon Web Services account. The default is false, and cannot be true unless the call is made on behalf of an Amazon Web Services account that is the management account for an organization in Organizations.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. The value can be an alias name prefixed by alias/, a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies the name of the trail. The name must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files. See [Amazon S3 Bucket Naming Requirements](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create_trail_naming_policy.html).
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html). The maximum length is 200 characters.
    public var s3KeyPrefix: Swift.String?
    /// Specifies the name of the Amazon SNS topic defined for notification of log file delivery. The maximum length is 256 characters.
    public var snsTopicName: Swift.String?
    /// A list of tags.
    public var tagsList: [CloudTrailClientTypes.Tag]?

    public init (
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        enableLogFileValidation: Swift.Bool? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicName: Swift.String? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.enableLogFileValidation = enableLogFileValidation
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicName = snsTopicName
        self.tagsList = tagsList
    }
}

struct CreateTrailInputBody: Swift.Equatable {
    let name: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let snsTopicName: Swift.String?
    let includeGlobalServiceEvents: Swift.Bool?
    let isMultiRegionTrail: Swift.Bool?
    let enableLogFileValidation: Swift.Bool?
    let cloudWatchLogsLogGroupArn: Swift.String?
    let cloudWatchLogsRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let isOrganizationTrail: Swift.Bool?
    let tagsList: [CloudTrailClientTypes.Tag]?
}

extension CreateTrailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
        case tagsList = "TagsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let enableLogFileValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableLogFileValidation)
        enableLogFileValidation = enableLogFileValidationDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension CreateTrailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTrailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailAccessNotEnabled" : self = .cloudTrailAccessNotEnabledException(try CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudTrailInvalidClientTokenId" : self = .cloudTrailInvalidClientTokenIdException(try CloudTrailInvalidClientTokenIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudWatchLogsDeliveryUnavailable" : self = .cloudWatchLogsDeliveryUnavailableException(try CloudWatchLogsDeliveryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientEncryptionPolicy" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientS3BucketPolicy" : self = .insufficientS3BucketPolicyException(try InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientSnsTopicPolicy" : self = .insufficientSnsTopicPolicyException(try InsufficientSnsTopicPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchLogsLogGroupArn" : self = .invalidCloudWatchLogsLogGroupArnException(try InvalidCloudWatchLogsLogGroupArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchLogsRoleArn" : self = .invalidCloudWatchLogsRoleArnException(try InvalidCloudWatchLogsRoleArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKmsKeyId" : self = .invalidKmsKeyIdException(try InvalidKmsKeyIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationError" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketName" : self = .invalidS3BucketNameException(try InvalidS3BucketNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3Prefix" : self = .invalidS3PrefixException(try InvalidS3PrefixException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSnsTopicName" : self = .invalidSnsTopicNameException(try InvalidSnsTopicNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameter" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyDisabled" : self = .kmsKeyDisabledException(try KmsKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyNotFound" : self = .kmsKeyNotFoundException(try KmsKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumNumberOfTrailsExceeded" : self = .maximumNumberOfTrailsExceededException(try MaximumNumberOfTrailsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesMode" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationsNotInUse" : self = .organizationsNotInUseException(try OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3BucketDoesNotExist" : self = .s3BucketDoesNotExistException(try S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsLimitExceeded" : self = .tagsLimitExceededException(try TagsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailAlreadyExists" : self = .trailAlreadyExistsException(try TrailAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotProvided" : self = .trailNotProvidedException(try TrailNotProvidedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTrailOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailAccessNotEnabledException(CloudTrailAccessNotEnabledException)
    case cloudTrailInvalidClientTokenIdException(CloudTrailInvalidClientTokenIdException)
    case cloudWatchLogsDeliveryUnavailableException(CloudWatchLogsDeliveryUnavailableException)
    case conflictException(ConflictException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case insufficientS3BucketPolicyException(InsufficientS3BucketPolicyException)
    case insufficientSnsTopicPolicyException(InsufficientSnsTopicPolicyException)
    case invalidCloudWatchLogsLogGroupArnException(InvalidCloudWatchLogsLogGroupArnException)
    case invalidCloudWatchLogsRoleArnException(InvalidCloudWatchLogsRoleArnException)
    case invalidKmsKeyIdException(InvalidKmsKeyIdException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidS3BucketNameException(InvalidS3BucketNameException)
    case invalidS3PrefixException(InvalidS3PrefixException)
    case invalidSnsTopicNameException(InvalidSnsTopicNameException)
    case invalidTagParameterException(InvalidTagParameterException)
    case invalidTrailNameException(InvalidTrailNameException)
    case kmsException(KmsException)
    case kmsKeyDisabledException(KmsKeyDisabledException)
    case kmsKeyNotFoundException(KmsKeyNotFoundException)
    case maximumNumberOfTrailsExceededException(MaximumNumberOfTrailsExceededException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case organizationsNotInUseException(OrganizationsNotInUseException)
    case s3BucketDoesNotExistException(S3BucketDoesNotExistException)
    case tagsLimitExceededException(TagsLimitExceededException)
    case trailAlreadyExistsException(TrailAlreadyExistsException)
    case trailNotProvidedException(TrailNotProvidedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTrailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTrailOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchLogsLogGroupArn = output.cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = output.cloudWatchLogsRoleArn
            self.includeGlobalServiceEvents = output.includeGlobalServiceEvents
            self.isMultiRegionTrail = output.isMultiRegionTrail
            self.isOrganizationTrail = output.isOrganizationTrail
            self.kmsKeyId = output.kmsKeyId
            self.logFileValidationEnabled = output.logFileValidationEnabled
            self.name = output.name
            self.s3BucketName = output.s3BucketName
            self.s3KeyPrefix = output.s3KeyPrefix
            self.snsTopicARN = output.snsTopicARN
            self.snsTopicName = output.snsTopicName
            self.trailARN = output.trailARN
        } else {
            self.cloudWatchLogsLogGroupArn = nil
            self.cloudWatchLogsRoleArn = nil
            self.includeGlobalServiceEvents = nil
            self.isMultiRegionTrail = nil
            self.isOrganizationTrail = nil
            self.kmsKeyId = nil
            self.logFileValidationEnabled = nil
            self.name = nil
            self.s3BucketName = nil
            self.s3KeyPrefix = nil
            self.snsTopicARN = nil
            self.snsTopicName = nil
            self.trailARN = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct CreateTrailOutputResponse: Swift.Equatable {
    /// Specifies the Amazon Resource Name (ARN) of the log group to which CloudTrail logs will be delivered.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail exists in one region or in all regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is an organization trail.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether log file integrity validation is enabled.
    public var logFileValidationEnabled: Swift.Bool?
    /// Specifies the name of the trail.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files.
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html).
    public var s3KeyPrefix: Swift.String?
    /// Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The format of a topic ARN is: arn:aws:sns:us-east-2:123456789012:MyTopic
    public var snsTopicARN: Swift.String?
    /// This field is no longer in use. Use SnsTopicARN.
    @available(*, deprecated)
    public var snsTopicName: Swift.String?
    /// Specifies the ARN of the trail that was created. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    public var trailARN: Swift.String?

    public init (
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        logFileValidationEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicARN: Swift.String? = nil,
        snsTopicName: Swift.String? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.logFileValidationEnabled = logFileValidationEnabled
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicARN = snsTopicARN
        self.snsTopicName = snsTopicName
        self.trailARN = trailARN
    }
}

struct CreateTrailOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let snsTopicName: Swift.String?
    let snsTopicARN: Swift.String?
    let includeGlobalServiceEvents: Swift.Bool?
    let isMultiRegionTrail: Swift.Bool?
    let trailARN: Swift.String?
    let logFileValidationEnabled: Swift.Bool?
    let cloudWatchLogsLogGroupArn: Swift.String?
    let cloudWatchLogsRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let isOrganizationTrail: Swift.Bool?
}

extension CreateTrailOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicARN = "SnsTopicARN"
        case snsTopicName = "SnsTopicName"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

extension CloudTrailClientTypes.DataResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CloudTrailClientTypes {
    /// The Amazon S3 buckets, Lambda functions, or Amazon DynamoDB tables that you specify in your event selectors for your trail to log data events. Data events provide information about the resource operations performed on or within a resource itself. These are also known as data plane operations. You can specify up to 250 data resources for a trail. The total number of allowed data resources is 250. This number can be distributed between 1 and 5 event selectors, but the total cannot exceed 250 across all selectors. If you are using advanced event selectors, the maximum total number of values for all conditions, across all advanced event selectors for the trail, is 500. The following example demonstrates how logging works when you configure logging of all data events for an S3 bucket named bucket-1. In this example, the CloudTrail user specified an empty prefix, and the option to log both Read and Write data events.
    ///
    /// * A user uploads an image file to bucket-1.
    ///
    /// * The PutObject API operation is an Amazon S3 object-level API. It is recorded as a data event in CloudTrail. Because the CloudTrail user specified an S3 bucket with an empty prefix, events that occur on any object in that bucket are logged. The trail processes and logs the event.
    ///
    /// * A user uploads an object to an Amazon S3 bucket named arn:aws:s3:::bucket-2.
    ///
    /// * The PutObject API operation occurred for an object in an S3 bucket that the CloudTrail user didn't specify for the trail. The trail doesn’t log the event.
    ///
    ///
    /// The following example demonstrates how logging works when you configure logging of Lambda data events for a Lambda function named MyLambdaFunction, but not for all Lambda functions.
    ///
    /// * A user runs a script that includes a call to the MyLambdaFunction function and the MyOtherLambdaFunction function.
    ///
    /// * The Invoke API operation on MyLambdaFunction is an Lambda API. It is recorded as a data event in CloudTrail. Because the CloudTrail user specified logging data events for MyLambdaFunction, any invocations of that function are logged. The trail processes and logs the event.
    ///
    /// * The Invoke API operation on MyOtherLambdaFunction is an Lambda API. Because the CloudTrail user did not specify logging data events for all Lambda functions, the Invoke operation for MyOtherLambdaFunction does not match the function specified for the trail. The trail doesn’t log the event.
    public struct DataResource: Swift.Equatable {
        /// The resource type in which you want to log data events. You can specify the following basic event selector resource types:
        ///
        /// * AWS::S3::Object
        ///
        /// * AWS::Lambda::Function
        ///
        /// * AWS::DynamoDB::Table
        ///
        ///
        /// The following resource types are also available through advanced event selectors. Basic event selector resource types are valid in advanced event selectors, but advanced event selector resource types are not valid in basic event selectors. For more information, see [AdvancedFieldSelector$Field].
        ///
        /// * AWS::S3Outposts::Object
        ///
        /// * AWS::ManagedBlockchain::Node
        ///
        /// * AWS::S3ObjectLambda::AccessPoint
        ///
        /// * AWS::EC2::Snapshot
        ///
        /// * AWS::S3::AccessPoint
        ///
        /// * AWS::DynamoDB::Stream
        ///
        /// * AWS::Glue::Table
        public var type: Swift.String?
        /// An array of Amazon Resource Name (ARN) strings or partial ARN strings for the specified objects.
        ///
        /// * To log data events for all objects in all S3 buckets in your Amazon Web Services account, specify the prefix as arn:aws:s3. This also enables logging of data event activity performed by any user or role in your Amazon Web Services account, even if that activity is performed on a bucket that belongs to another Amazon Web Services account.
        ///
        /// * To log data events for all objects in an S3 bucket, specify the bucket and an empty object prefix such as arn:aws:s3:::bucket-1/. The trail logs data events for all objects in this S3 bucket.
        ///
        /// * To log data events for specific objects, specify the S3 bucket and object prefix such as arn:aws:s3:::bucket-1/example-images. The trail logs data events for objects in this S3 bucket that match the prefix.
        ///
        /// * To log data events for all Lambda functions in your Amazon Web Services account, specify the prefix as arn:aws:lambda. This also enables logging of Invoke activity performed by any user or role in your Amazon Web Services account, even if that activity is performed on a function that belongs to another Amazon Web Services account.
        ///
        /// * To log data events for a specific Lambda function, specify the function ARN. Lambda function ARNs are exact. For example, if you specify a function ARN arn:aws:lambda:us-west-2:111111111111:function:helloworld, data events will only be logged for arn:aws:lambda:us-west-2:111111111111:function:helloworld. They will not be logged for arn:aws:lambda:us-west-2:111111111111:function:helloworld2.
        ///
        /// * To log data events for all DynamoDB tables in your Amazon Web Services account, specify the prefix as arn:aws:dynamodb.
        public var values: [Swift.String]?

        public init (
            type: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.type = type
            self.values = values
        }
    }

}

extension DelegatedAdminAccountLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DelegatedAdminAccountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the maximum number of CloudTrail delegated administrators is reached.
public struct DelegatedAdminAccountLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DelegatedAdminAccountLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DelegatedAdminAccountLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteEventDataStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
    }
}

extension DeleteEventDataStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEventDataStoreInput: Swift.Equatable {
    /// The ARN (or the ID suffix of the ARN) of the event data store to delete.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init (
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

struct DeleteEventDataStoreInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
}

extension DeleteEventDataStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
    }
}

extension DeleteEventDataStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventDataStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventDataStoreARNInvalid" : self = .eventDataStoreARNInvalidException(try EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreHasOngoingImport" : self = .eventDataStoreHasOngoingImportException(try EventDataStoreHasOngoingImportException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreTerminationProtectedException" : self = .eventDataStoreTerminationProtectedException(try EventDataStoreTerminationProtectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InactiveEventDataStore" : self = .inactiveEventDataStoreException(try InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteEventDataStoreOutputError: Swift.Error, Swift.Equatable {
    case eventDataStoreARNInvalidException(EventDataStoreARNInvalidException)
    case eventDataStoreHasOngoingImportException(EventDataStoreHasOngoingImportException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case eventDataStoreTerminationProtectedException(EventDataStoreTerminationProtectedException)
    case inactiveEventDataStoreException(InactiveEventDataStoreException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidParameterException(InvalidParameterException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventDataStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventDataStoreOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteTrailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteTrailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The request that specifies the name of a trail to delete.
public struct DeleteTrailInput: Swift.Equatable {
    /// Specifies the name or the CloudTrail ARN of the trail to be deleted. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteTrailInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteTrailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteTrailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTrailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegion" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTrailOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case conflictException(ConflictException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidTrailNameException(InvalidTrailNameException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTrailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct DeleteTrailOutputResponse: Swift.Equatable {

    public init () { }
}

extension CloudTrailClientTypes {
    public enum DeliveryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case accessDeniedSigningFile
        case cancelled
        case failed
        case failedSigningFile
        case pending
        case resourceNotFound
        case success
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliveryStatus] {
            return [
                .accessDenied,
                .accessDeniedSigningFile,
                .cancelled,
                .failed,
                .failedSigningFile,
                .pending,
                .resourceNotFound,
                .success,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .accessDeniedSigningFile: return "ACCESS_DENIED_SIGNING_FILE"
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .failedSigningFile: return "FAILED_SIGNING_FILE"
            case .pending: return "PENDING"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .success: return "SUCCESS"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeliveryStatus(rawValue: rawValue) ?? DeliveryStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeregisterOrganizationDelegatedAdminInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccountId = "DelegatedAdminAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegatedAdminAccountId = self.delegatedAdminAccountId {
            try encodeContainer.encode(delegatedAdminAccountId, forKey: .delegatedAdminAccountId)
        }
    }
}

extension DeregisterOrganizationDelegatedAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Removes CloudTrail delegated administrator permissions from a specified member account in an organization that is currently designated as a delegated administrator.
public struct DeregisterOrganizationDelegatedAdminInput: Swift.Equatable {
    /// A delegated administrator account ID. This is a member account in an organization that is currently designated as a delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init (
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

struct DeregisterOrganizationDelegatedAdminInputBody: Swift.Equatable {
    let delegatedAdminAccountId: Swift.String?
}

extension DeregisterOrganizationDelegatedAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccountId = "DelegatedAdminAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccountId)
        delegatedAdminAccountId = delegatedAdminAccountIdDecoded
    }
}

extension DeregisterOrganizationDelegatedAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterOrganizationDelegatedAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountNotFound" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotRegistered" : self = .accountNotRegisteredException(try AccountNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudTrailAccessNotEnabled" : self = .cloudTrailAccessNotEnabledException(try CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationManagementAccount" : self = .notOrganizationManagementAccountException(try NotOrganizationManagementAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesMode" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationsNotInUse" : self = .organizationsNotInUseException(try OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterOrganizationDelegatedAdminOutputError: Swift.Error, Swift.Equatable {
    case accountNotFoundException(AccountNotFoundException)
    case accountNotRegisteredException(AccountNotRegisteredException)
    case cloudTrailAccessNotEnabledException(CloudTrailAccessNotEnabledException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidParameterException(InvalidParameterException)
    case notOrganizationManagementAccountException(NotOrganizationManagementAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case organizationsNotInUseException(OrganizationsNotInUseException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterOrganizationDelegatedAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Returns the following response if successful. Otherwise, returns an error.
public struct DeregisterOrganizationDelegatedAdminOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
        case queryId = "QueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
    }
}

extension DescribeQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeQueryInput: Swift.Equatable {
    /// The ARN (or the ID suffix of the ARN) of an event data store on which the specified query was run.
    @available(*, deprecated, message: "EventDataStore is no longer required by DescribeQueryRequest")
    public var eventDataStore: Swift.String?
    /// The query ID.
    /// This member is required.
    public var queryId: Swift.String?

    public init (
        eventDataStore: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
        self.queryId = queryId
    }
}

struct DescribeQueryInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
    let queryId: Swift.String?
}

extension DescribeQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
        case queryId = "QueryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
    }
}

extension DescribeQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventDataStoreARNInvalid" : self = .eventDataStoreARNInvalidException(try EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InactiveEventDataStore" : self = .inactiveEventDataStoreException(try InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryIdNotFound" : self = .queryIdNotFoundException(try QueryIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeQueryOutputError: Swift.Error, Swift.Equatable {
    case eventDataStoreARNInvalidException(EventDataStoreARNInvalidException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case inactiveEventDataStoreException(InactiveEventDataStoreException)
    case invalidParameterException(InvalidParameterException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case operationNotPermittedException(OperationNotPermittedException)
    case queryIdNotFoundException(QueryIdNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deliveryS3Uri = output.deliveryS3Uri
            self.deliveryStatus = output.deliveryStatus
            self.errorMessage = output.errorMessage
            self.queryId = output.queryId
            self.queryStatistics = output.queryStatistics
            self.queryStatus = output.queryStatus
            self.queryString = output.queryString
        } else {
            self.deliveryS3Uri = nil
            self.deliveryStatus = nil
            self.errorMessage = nil
            self.queryId = nil
            self.queryStatistics = nil
            self.queryStatus = nil
            self.queryString = nil
        }
    }
}

public struct DescribeQueryOutputResponse: Swift.Equatable {
    /// The URI for the S3 bucket where CloudTrail delivered query results, if applicable.
    public var deliveryS3Uri: Swift.String?
    /// The delivery status.
    public var deliveryStatus: CloudTrailClientTypes.DeliveryStatus?
    /// The error message returned if a query failed.
    public var errorMessage: Swift.String?
    /// The ID of the query.
    public var queryId: Swift.String?
    /// Metadata about a query, including the number of events that were matched, the total number of events scanned, the query run time in milliseconds, and the query's creation time.
    public var queryStatistics: CloudTrailClientTypes.QueryStatisticsForDescribeQuery?
    /// The status of a query. Values for QueryStatus include QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED
    public var queryStatus: CloudTrailClientTypes.QueryStatus?
    /// The SQL code of a query.
    public var queryString: Swift.String?

    public init (
        deliveryS3Uri: Swift.String? = nil,
        deliveryStatus: CloudTrailClientTypes.DeliveryStatus? = nil,
        errorMessage: Swift.String? = nil,
        queryId: Swift.String? = nil,
        queryStatistics: CloudTrailClientTypes.QueryStatisticsForDescribeQuery? = nil,
        queryStatus: CloudTrailClientTypes.QueryStatus? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.deliveryS3Uri = deliveryS3Uri
        self.deliveryStatus = deliveryStatus
        self.errorMessage = errorMessage
        self.queryId = queryId
        self.queryStatistics = queryStatistics
        self.queryStatus = queryStatus
        self.queryString = queryString
    }
}

struct DescribeQueryOutputResponseBody: Swift.Equatable {
    let queryId: Swift.String?
    let queryString: Swift.String?
    let queryStatus: CloudTrailClientTypes.QueryStatus?
    let queryStatistics: CloudTrailClientTypes.QueryStatisticsForDescribeQuery?
    let errorMessage: Swift.String?
    let deliveryS3Uri: Swift.String?
    let deliveryStatus: CloudTrailClientTypes.DeliveryStatus?
}

extension DescribeQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryS3Uri = "DeliveryS3Uri"
        case deliveryStatus = "DeliveryStatus"
        case errorMessage = "ErrorMessage"
        case queryId = "QueryId"
        case queryStatistics = "QueryStatistics"
        case queryStatus = "QueryStatus"
        case queryString = "QueryString"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
        let queryStatisticsDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatisticsForDescribeQuery.self, forKey: .queryStatistics)
        queryStatistics = queryStatisticsDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let deliveryS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryS3Uri)
        deliveryS3Uri = deliveryS3UriDecoded
        let deliveryStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.DeliveryStatus.self, forKey: .deliveryStatus)
        deliveryStatus = deliveryStatusDecoded
    }
}

extension DescribeTrailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeShadowTrails
        case trailNameList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeShadowTrails = self.includeShadowTrails {
            try encodeContainer.encode(includeShadowTrails, forKey: .includeShadowTrails)
        }
        if let trailNameList = trailNameList {
            var trailNameListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trailNameList)
            for string0 in trailNameList {
                try trailNameListContainer.encode(string0)
            }
        }
    }
}

extension DescribeTrailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Returns information about the trail.
public struct DescribeTrailsInput: Swift.Equatable {
    /// Specifies whether to include shadow trails in the response. A shadow trail is the replication in a region of a trail that was created in a different region, or in the case of an organization trail, the replication of an organization trail in member accounts. If you do not include shadow trails, organization trails in a member account and region replication trails will not be returned. The default is true.
    public var includeShadowTrails: Swift.Bool?
    /// Specifies a list of trail names, trail ARNs, or both, of the trails to describe. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail If an empty list is specified, information for the trail in the current region is returned.
    ///
    /// * If an empty list is specified and IncludeShadowTrails is false, then information for all trails in the current region is returned.
    ///
    /// * If an empty list is specified and IncludeShadowTrails is null or true, then information for all trails in the current region and any associated shadow trails in other regions is returned.
    ///
    ///
    /// If one or more trail names are specified, information is returned only if the names match the names of trails belonging only to the current region. To return information about a trail in another region, you must specify its trail ARN.
    public var trailNameList: [Swift.String]?

    public init (
        includeShadowTrails: Swift.Bool? = nil,
        trailNameList: [Swift.String]? = nil
    )
    {
        self.includeShadowTrails = includeShadowTrails
        self.trailNameList = trailNameList
    }
}

struct DescribeTrailsInputBody: Swift.Equatable {
    let trailNameList: [Swift.String]?
    let includeShadowTrails: Swift.Bool?
}

extension DescribeTrailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeShadowTrails
        case trailNameList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trailNameList)
        var trailNameListDecoded0:[Swift.String]? = nil
        if let trailNameListContainer = trailNameListContainer {
            trailNameListDecoded0 = [Swift.String]()
            for string0 in trailNameListContainer {
                if let string0 = string0 {
                    trailNameListDecoded0?.append(string0)
                }
            }
        }
        trailNameList = trailNameListDecoded0
        let includeShadowTrailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeShadowTrails)
        includeShadowTrails = includeShadowTrailsDecoded
    }
}

extension DescribeTrailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTrailsOutputError: Swift.Error, Swift.Equatable {
    case invalidTrailNameException(InvalidTrailNameException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTrailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trailList = output.trailList
        } else {
            self.trailList = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct DescribeTrailsOutputResponse: Swift.Equatable {
    /// The list of trail objects. Trail objects with string values are only returned if values for the objects exist in a trail's configuration. For example, SNSTopicName and SNSTopicARN are only returned in results if a trail is configured to send SNS notifications. Similarly, KMSKeyId only appears in results if a trail's log files are encrypted with KMS customer managed keys.
    public var trailList: [CloudTrailClientTypes.Trail]?

    public init (
        trailList: [CloudTrailClientTypes.Trail]? = nil
    )
    {
        self.trailList = trailList
    }
}

struct DescribeTrailsOutputResponseBody: Swift.Equatable {
    let trailList: [CloudTrailClientTypes.Trail]?
}

extension DescribeTrailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Trail?].self, forKey: .trailList)
        var trailListDecoded0:[CloudTrailClientTypes.Trail]? = nil
        if let trailListContainer = trailListContainer {
            trailListDecoded0 = [CloudTrailClientTypes.Trail]()
            for structure0 in trailListContainer {
                if let structure0 = structure0 {
                    trailListDecoded0?.append(structure0)
                }
            }
        }
        trailList = trailListDecoded0
    }
}

extension CloudTrailClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location = "Location"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.DestinationType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
    }
}

extension CloudTrailClientTypes {
    /// Contains information about the service where CloudTrail delivers events.
    public struct Destination: Swift.Equatable {
        /// For service-linked channels, the value is the name of the Amazon Web Services service.
        /// This member is required.
        public var location: Swift.String?
        /// The type of destination for events arriving from a channel. For service-linked channels, the value is AWS_SERVICE.
        /// This member is required.
        public var type: CloudTrailClientTypes.DestinationType?

        public init (
            location: Swift.String? = nil,
            type: CloudTrailClientTypes.DestinationType? = nil
        )
        {
            self.location = location
            self.type = type
        }
    }

}

extension CloudTrailClientTypes {
    public enum DestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsService
        case eventDataStore
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationType] {
            return [
                .awsService,
                .eventDataStore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsService: return "AWS_SERVICE"
            case .eventDataStore: return "EVENT_DATA_STORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationType(rawValue: rawValue) ?? DestinationType.sdkUnknown(rawValue)
        }
    }
}

extension CloudTrailClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case cloudTrailEvent = "CloudTrailEvent"
        case eventId = "EventId"
        case eventName = "EventName"
        case eventSource = "EventSource"
        case eventTime = "EventTime"
        case readOnly = "ReadOnly"
        case resources = "Resources"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let cloudTrailEvent = self.cloudTrailEvent {
            try encodeContainer.encode(cloudTrailEvent, forKey: .cloudTrailEvent)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let eventSource = self.eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let readOnly = self.readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[CloudTrailClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [CloudTrailClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let cloudTrailEventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudTrailEvent)
        cloudTrailEvent = cloudTrailEventDecoded
    }
}

extension CloudTrailClientTypes {
    /// Contains information about an event that was returned by a lookup request. The result includes a representation of a CloudTrail event.
    public struct Event: Swift.Equatable {
        /// The Amazon Web Services access key ID that was used to sign the request. If the request was made with temporary security credentials, this is the access key ID of the temporary credentials.
        public var accessKeyId: Swift.String?
        /// A JSON string that contains a representation of the event returned.
        public var cloudTrailEvent: Swift.String?
        /// The CloudTrail ID of the event returned.
        public var eventId: Swift.String?
        /// The name of the event returned.
        public var eventName: Swift.String?
        /// The Amazon Web Services service to which the request was made.
        public var eventSource: Swift.String?
        /// The date and time of the event returned.
        public var eventTime: ClientRuntime.Date?
        /// Information about whether the event is a write event or a read event.
        public var readOnly: Swift.String?
        /// A list of resources referenced by the event returned.
        public var resources: [CloudTrailClientTypes.Resource]?
        /// A user name or role name of the requester that called the API in the event returned.
        public var username: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            cloudTrailEvent: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventName: Swift.String? = nil,
            eventSource: Swift.String? = nil,
            eventTime: ClientRuntime.Date? = nil,
            readOnly: Swift.String? = nil,
            resources: [CloudTrailClientTypes.Resource]? = nil,
            username: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.cloudTrailEvent = cloudTrailEvent
            self.eventId = eventId
            self.eventName = eventName
            self.eventSource = eventSource
            self.eventTime = eventTime
            self.readOnly = readOnly
            self.resources = resources
            self.username = username
        }
    }

}

extension CloudTrailClientTypes {
    public enum EventCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insight
        case sdkUnknown(Swift.String)

        public static var allCases: [EventCategory] {
            return [
                .insight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insight: return "insight"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventCategory(rawValue: rawValue) ?? EventCategory.sdkUnknown(rawValue)
        }
    }
}

extension CloudTrailClientTypes.EventDataStore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case createdTimestamp = "CreatedTimestamp"
        case eventDataStoreArn = "EventDataStoreArn"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedEventSelectors = advancedEventSelectors {
            var advancedEventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedEventSelectors)
            for advancedeventselector0 in advancedEventSelectors {
                try advancedEventSelectorsContainer.encode(advancedeventselector0)
            }
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let eventDataStoreArn = self.eventDataStoreArn {
            try encodeContainer.encode(eventDataStoreArn, forKey: .eventDataStoreArn)
        }
        if let multiRegionEnabled = self.multiRegionEnabled {
            try encodeContainer.encode(multiRegionEnabled, forKey: .multiRegionEnabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationEnabled = self.organizationEnabled {
            try encodeContainer.encode(organizationEnabled, forKey: .organizationEnabled)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let terminationProtectionEnabled = self.terminationProtectionEnabled {
            try encodeContainer.encode(terminationProtectionEnabled, forKey: .terminationProtectionEnabled)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .epochSeconds, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStoreArn)
        eventDataStoreArn = eventDataStoreArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventDataStoreStatus.self, forKey: .status)
        status = statusDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension CloudTrailClientTypes {
    /// A storage lake of event data against which you can run complex SQL-based queries. An event data store can include events that you have logged on your account from the last 90 to 2557 days (about three months to up to seven years). To select events for an event data store, use [advanced event selectors](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html#creating-data-event-selectors-advanced).
    public struct EventDataStore: Swift.Equatable {
        /// This field is being deprecated. The advanced event selectors that were used to select events for the data store.
        @available(*, deprecated, message: "AdvancedEventSelectors is no longer returned by ListEventDataStores")
        public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
        /// This field is being deprecated. The timestamp of the event data store's creation.
        @available(*, deprecated, message: "CreatedTimestamp is no longer returned by ListEventDataStores")
        public var createdTimestamp: ClientRuntime.Date?
        /// The ARN of the event data store.
        public var eventDataStoreArn: Swift.String?
        /// This field is being deprecated. Indicates whether the event data store includes events from all regions, or only from the region in which it was created.
        @available(*, deprecated, message: "MultiRegionEnabled is no longer returned by ListEventDataStores")
        public var multiRegionEnabled: Swift.Bool?
        /// The name of the event data store.
        public var name: Swift.String?
        /// This field is being deprecated. Indicates that an event data store is collecting logged events for an organization.
        @available(*, deprecated, message: "OrganizationEnabled is no longer returned by ListEventDataStores")
        public var organizationEnabled: Swift.Bool?
        /// This field is being deprecated. The retention period, in days.
        @available(*, deprecated, message: "RetentionPeriod is no longer returned by ListEventDataStores")
        public var retentionPeriod: Swift.Int?
        /// This field is being deprecated. The status of an event data store. Values are ENABLED and PENDING_DELETION.
        @available(*, deprecated, message: "Status is no longer returned by ListEventDataStores")
        public var status: CloudTrailClientTypes.EventDataStoreStatus?
        /// This field is being deprecated. Indicates whether the event data store is protected from termination.
        @available(*, deprecated, message: "TerminationProtectionEnabled is no longer returned by ListEventDataStores")
        public var terminationProtectionEnabled: Swift.Bool?
        /// This field is being deprecated. The timestamp showing when an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
        @available(*, deprecated, message: "UpdatedTimestamp is no longer returned by ListEventDataStores")
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            eventDataStoreArn: Swift.String? = nil,
            multiRegionEnabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            organizationEnabled: Swift.Bool? = nil,
            retentionPeriod: Swift.Int? = nil,
            status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
            terminationProtectionEnabled: Swift.Bool? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.advancedEventSelectors = advancedEventSelectors
            self.createdTimestamp = createdTimestamp
            self.eventDataStoreArn = eventDataStoreArn
            self.multiRegionEnabled = multiRegionEnabled
            self.name = name
            self.organizationEnabled = organizationEnabled
            self.retentionPeriod = retentionPeriod
            self.status = status
            self.terminationProtectionEnabled = terminationProtectionEnabled
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension EventDataStoreARNInvalidException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EventDataStoreARNInvalidExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified event data store ARN is not valid or does not map to an event data store in your account.
public struct EventDataStoreARNInvalidException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EventDataStoreARNInvalidExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventDataStoreARNInvalidExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventDataStoreAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EventDataStoreAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An event data store with that name already exists.
public struct EventDataStoreAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EventDataStoreAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventDataStoreAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventDataStoreHasOngoingImportException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EventDataStoreHasOngoingImportExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when you try to update or delete an event data store that currently has an import in progress.
public struct EventDataStoreHasOngoingImportException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EventDataStoreHasOngoingImportExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventDataStoreHasOngoingImportExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventDataStoreMaxLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EventDataStoreMaxLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your account has used the maximum number of event data stores.
public struct EventDataStoreMaxLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EventDataStoreMaxLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventDataStoreMaxLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventDataStoreNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EventDataStoreNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified event data store was not found.
public struct EventDataStoreNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EventDataStoreNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventDataStoreNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes {
    public enum EventDataStoreStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case enabled
        case pendingDeletion
        case sdkUnknown(Swift.String)

        public static var allCases: [EventDataStoreStatus] {
            return [
                .created,
                .enabled,
                .pendingDeletion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .enabled: return "ENABLED"
            case .pendingDeletion: return "PENDING_DELETION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventDataStoreStatus(rawValue: rawValue) ?? EventDataStoreStatus.sdkUnknown(rawValue)
        }
    }
}

extension EventDataStoreTerminationProtectedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EventDataStoreTerminationProtectedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The event data store cannot be deleted because termination protection is enabled for it.
public struct EventDataStoreTerminationProtectedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EventDataStoreTerminationProtectedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventDataStoreTerminationProtectedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.EventSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataResources = "DataResources"
        case excludeManagementEventSources = "ExcludeManagementEventSources"
        case includeManagementEvents = "IncludeManagementEvents"
        case readWriteType = "ReadWriteType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataResources = dataResources {
            var dataResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataResources)
            for dataresource0 in dataResources {
                try dataResourcesContainer.encode(dataresource0)
            }
        }
        if let excludeManagementEventSources = excludeManagementEventSources {
            var excludeManagementEventSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeManagementEventSources)
            for string0 in excludeManagementEventSources {
                try excludeManagementEventSourcesContainer.encode(string0)
            }
        }
        if let includeManagementEvents = self.includeManagementEvents {
            try encodeContainer.encode(includeManagementEvents, forKey: .includeManagementEvents)
        }
        if let readWriteType = self.readWriteType {
            try encodeContainer.encode(readWriteType.rawValue, forKey: .readWriteType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readWriteTypeDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ReadWriteType.self, forKey: .readWriteType)
        readWriteType = readWriteTypeDecoded
        let includeManagementEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeManagementEvents)
        includeManagementEvents = includeManagementEventsDecoded
        let dataResourcesContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.DataResource?].self, forKey: .dataResources)
        var dataResourcesDecoded0:[CloudTrailClientTypes.DataResource]? = nil
        if let dataResourcesContainer = dataResourcesContainer {
            dataResourcesDecoded0 = [CloudTrailClientTypes.DataResource]()
            for structure0 in dataResourcesContainer {
                if let structure0 = structure0 {
                    dataResourcesDecoded0?.append(structure0)
                }
            }
        }
        dataResources = dataResourcesDecoded0
        let excludeManagementEventSourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeManagementEventSources)
        var excludeManagementEventSourcesDecoded0:[Swift.String]? = nil
        if let excludeManagementEventSourcesContainer = excludeManagementEventSourcesContainer {
            excludeManagementEventSourcesDecoded0 = [Swift.String]()
            for string0 in excludeManagementEventSourcesContainer {
                if let string0 = string0 {
                    excludeManagementEventSourcesDecoded0?.append(string0)
                }
            }
        }
        excludeManagementEventSources = excludeManagementEventSourcesDecoded0
    }
}

extension CloudTrailClientTypes {
    /// Use event selectors to further specify the management and data event settings for your trail. By default, trails created without specific event selectors will be configured to log all read and write management events, and no data events. When an event occurs in your account, CloudTrail evaluates the event selector for all trails. For each trail, if the event matches any event selector, the trail processes and logs the event. If the event doesn't match any event selector, the trail doesn't log the event. You can configure up to five event selectors for a trail. You cannot apply both event selectors and advanced event selectors to a trail.
    public struct EventSelector: Swift.Equatable {
        /// CloudTrail supports data event logging for Amazon S3 objects, Lambda functions, and Amazon DynamoDB tables with basic event selectors. You can specify up to 250 resources for an individual event selector, but the total number of data resources cannot exceed 250 across all event selectors in a trail. This limit does not apply if you configure resource logging for all data events. For more information, see [Data Events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html) and [Limits in CloudTrail](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/WhatIsCloudTrail-Limits.html) in the CloudTrail User Guide.
        public var dataResources: [CloudTrailClientTypes.DataResource]?
        /// An optional list of service event sources from which you do not want management events to be logged on your trail. In this release, the list can be empty (disables the filter), or it can filter out Key Management Service or Amazon RDS Data API events by containing kms.amazonaws.com or rdsdata.amazonaws.com. By default, ExcludeManagementEventSources is empty, and KMS and Amazon RDS Data API events are logged to your trail. You can exclude management event sources only in regions that support the event source.
        public var excludeManagementEventSources: [Swift.String]?
        /// Specify if you want your event selector to include management events for your trail. For more information, see [Management Events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-management-events-with-cloudtrail.html) in the CloudTrail User Guide. By default, the value is true. The first copy of management events is free. You are charged for additional copies of management events that you are logging on any subsequent trail in the same region. For more information about CloudTrail pricing, see [CloudTrail Pricing](http://aws.amazon.com/cloudtrail/pricing/).
        public var includeManagementEvents: Swift.Bool?
        /// Specify if you want your trail to log read-only events, write-only events, or all. For example, the EC2 GetConsoleOutput is a read-only API operation and RunInstances is a write-only API operation. By default, the value is All.
        public var readWriteType: CloudTrailClientTypes.ReadWriteType?

        public init (
            dataResources: [CloudTrailClientTypes.DataResource]? = nil,
            excludeManagementEventSources: [Swift.String]? = nil,
            includeManagementEvents: Swift.Bool? = nil,
            readWriteType: CloudTrailClientTypes.ReadWriteType? = nil
        )
        {
            self.dataResources = dataResources
            self.excludeManagementEventSources = excludeManagementEventSources
            self.includeManagementEvents = includeManagementEvents
            self.readWriteType = readWriteType
        }
    }

}

extension GetChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
    }
}

extension GetChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetChannelInput: Swift.Equatable {
    /// The ARN or UUID of a channel.
    /// This member is required.
    public var channel: Swift.String?

    public init (
        channel: Swift.String? = nil
    )
    {
        self.channel = channel
    }
}

struct GetChannelInputBody: Swift.Equatable {
    let channel: Swift.String?
}

extension GetChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension GetChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ChannelARNInvalid" : self = .channelARNInvalidException(try ChannelARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ChannelNotFound" : self = .channelNotFoundException(try ChannelNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChannelOutputError: Swift.Error, Swift.Equatable {
    case channelARNInvalidException(ChannelARNInvalidException)
    case channelNotFoundException(ChannelNotFoundException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.destinations = output.destinations
            self.name = output.name
            self.source = output.source
            self.sourceConfig = output.sourceConfig
        } else {
            self.channelArn = nil
            self.destinations = nil
            self.name = nil
            self.source = nil
            self.sourceConfig = nil
        }
    }
}

public struct GetChannelOutputResponse: Swift.Equatable {
    /// The ARN of an channel returned by a GetChannel request.
    public var channelArn: Swift.String?
    /// The Amazon Web Services service that created the service-linked channel.
    public var destinations: [CloudTrailClientTypes.Destination]?
    /// The name of the CloudTrail channel. For service-linked channels, the value is aws-service-channel/service-name/custom-suffix where service-name represents the name of the Amazon Web Services service that created the channel and custom-suffix represents the suffix generated by the Amazon Web Services service.
    public var name: Swift.String?
    /// The event source for the CloudTrail channel.
    public var source: Swift.String?
    /// Provides information about the advanced event selectors configured for the channel, and whether the channel applies to all regions or a single region.
    public var sourceConfig: CloudTrailClientTypes.SourceConfig?

    public init (
        channelArn: Swift.String? = nil,
        destinations: [CloudTrailClientTypes.Destination]? = nil,
        name: Swift.String? = nil,
        source: Swift.String? = nil,
        sourceConfig: CloudTrailClientTypes.SourceConfig? = nil
    )
    {
        self.channelArn = channelArn
        self.destinations = destinations
        self.name = name
        self.source = source
        self.sourceConfig = sourceConfig
    }
}

struct GetChannelOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let name: Swift.String?
    let source: Swift.String?
    let sourceConfig: CloudTrailClientTypes.SourceConfig?
    let destinations: [CloudTrailClientTypes.Destination]?
}

extension GetChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case destinations = "Destinations"
        case name = "Name"
        case source = "Source"
        case sourceConfig = "SourceConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let sourceConfigDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.SourceConfig.self, forKey: .sourceConfig)
        sourceConfig = sourceConfigDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[CloudTrailClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [CloudTrailClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

extension GetEventDataStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
    }
}

extension GetEventDataStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEventDataStoreInput: Swift.Equatable {
    /// The ARN (or ID suffix of the ARN) of the event data store about which you want information.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init (
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

struct GetEventDataStoreInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
}

extension GetEventDataStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
    }
}

extension GetEventDataStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventDataStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventDataStoreARNInvalid" : self = .eventDataStoreARNInvalidException(try EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEventDataStoreOutputError: Swift.Error, Swift.Equatable {
    case eventDataStoreARNInvalidException(EventDataStoreARNInvalidException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventDataStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEventDataStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.createdTimestamp = output.createdTimestamp
            self.eventDataStoreArn = output.eventDataStoreArn
            self.kmsKeyId = output.kmsKeyId
            self.multiRegionEnabled = output.multiRegionEnabled
            self.name = output.name
            self.organizationEnabled = output.organizationEnabled
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
            self.terminationProtectionEnabled = output.terminationProtectionEnabled
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.advancedEventSelectors = nil
            self.createdTimestamp = nil
            self.eventDataStoreArn = nil
            self.kmsKeyId = nil
            self.multiRegionEnabled = nil
            self.name = nil
            self.organizationEnabled = nil
            self.retentionPeriod = nil
            self.status = nil
            self.terminationProtectionEnabled = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct GetEventDataStoreOutputResponse: Swift.Equatable {
    /// The advanced event selectors used to select events for the data store.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The timestamp of the event data store's creation.
    public var createdTimestamp: ClientRuntime.Date?
    /// The event data store Amazon Resource Number (ARN).
    public var eventDataStoreArn: Swift.String?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Indicates whether the event data store includes events from all regions, or only from the region in which it was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    public var name: Swift.String?
    /// Indicates whether an event data store is collecting logged events for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period of the event data store, in days.
    public var retentionPeriod: Swift.Int?
    /// The status of an event data store. Values can be ENABLED and PENDING_DELETION.
    public var status: CloudTrailClientTypes.EventDataStoreStatus?
    /// Indicates that termination protection is enabled.
    public var terminationProtectionEnabled: Swift.Bool?
    /// Shows the time that an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
    public var updatedTimestamp: ClientRuntime.Date?

    public init (
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        eventDataStoreArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.createdTimestamp = createdTimestamp
        self.eventDataStoreArn = eventDataStoreArn
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.terminationProtectionEnabled = terminationProtectionEnabled
        self.updatedTimestamp = updatedTimestamp
    }
}

struct GetEventDataStoreOutputResponseBody: Swift.Equatable {
    let eventDataStoreArn: Swift.String?
    let name: Swift.String?
    let status: CloudTrailClientTypes.EventDataStoreStatus?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    let multiRegionEnabled: Swift.Bool?
    let organizationEnabled: Swift.Bool?
    let retentionPeriod: Swift.Int?
    let terminationProtectionEnabled: Swift.Bool?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
    let kmsKeyId: Swift.String?
}

extension GetEventDataStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case createdTimestamp = "CreatedTimestamp"
        case eventDataStoreArn = "EventDataStoreArn"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStoreArn)
        eventDataStoreArn = eventDataStoreArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventDataStoreStatus.self, forKey: .status)
        status = statusDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension GetEventSelectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailName = "TrailName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trailName = self.trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

extension GetEventSelectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEventSelectorsInput: Swift.Equatable {
    /// Specifies the name of the trail or trail ARN. If you specify a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If you specify a trail ARN, it must be in the format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var trailName: Swift.String?

    public init (
        trailName: Swift.String? = nil
    )
    {
        self.trailName = trailName
    }
}

struct GetEventSelectorsInputBody: Swift.Equatable {
    let trailName: Swift.String?
}

extension GetEventSelectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailName = "TrailName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailName)
        trailName = trailNameDecoded
    }
}

extension GetEventSelectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventSelectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEventSelectorsOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case invalidTrailNameException(InvalidTrailNameException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventSelectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEventSelectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.eventSelectors = output.eventSelectors
            self.trailARN = output.trailARN
        } else {
            self.advancedEventSelectors = nil
            self.eventSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct GetEventSelectorsOutputResponse: Swift.Equatable {
    /// The advanced event selectors that are configured for the trail.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The event selectors that are configured for the trail.
    public var eventSelectors: [CloudTrailClientTypes.EventSelector]?
    /// The specified trail ARN that has the event selectors.
    public var trailARN: Swift.String?

    public init (
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventSelectors: [CloudTrailClientTypes.EventSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailARN = trailARN
    }
}

struct GetEventSelectorsOutputResponseBody: Swift.Equatable {
    let trailARN: Swift.String?
    let eventSelectors: [CloudTrailClientTypes.EventSelector]?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
}

extension GetEventSelectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let eventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.EventSelector?].self, forKey: .eventSelectors)
        var eventSelectorsDecoded0:[CloudTrailClientTypes.EventSelector]? = nil
        if let eventSelectorsContainer = eventSelectorsContainer {
            eventSelectorsDecoded0 = [CloudTrailClientTypes.EventSelector]()
            for structure0 in eventSelectorsContainer {
                if let structure0 = structure0 {
                    eventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        eventSelectors = eventSelectorsDecoded0
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

extension GetImportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId = "ImportId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importId = self.importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
    }
}

extension GetImportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetImportInput: Swift.Equatable {
    /// The ID for the import.
    /// This member is required.
    public var importId: Swift.String?

    public init (
        importId: Swift.String? = nil
    )
    {
        self.importId = importId
    }
}

struct GetImportInputBody: Swift.Equatable {
    let importId: Swift.String?
}

extension GetImportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId = "ImportId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
    }
}

extension GetImportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ImportNotFound" : self = .importNotFoundException(try ImportNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetImportOutputError: Swift.Error, Swift.Equatable {
    case importNotFoundException(ImportNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetImportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.destinations = output.destinations
            self.endEventTime = output.endEventTime
            self.importId = output.importId
            self.importSource = output.importSource
            self.importStatistics = output.importStatistics
            self.importStatus = output.importStatus
            self.startEventTime = output.startEventTime
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.createdTimestamp = nil
            self.destinations = nil
            self.endEventTime = nil
            self.importId = nil
            self.importSource = nil
            self.importStatistics = nil
            self.importStatus = nil
            self.startEventTime = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct GetImportOutputResponse: Swift.Equatable {
    /// The timestamp of the import's creation.
    public var createdTimestamp: ClientRuntime.Date?
    /// The ARN of the destination event data store.
    public var destinations: [Swift.String]?
    /// Used with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var endEventTime: ClientRuntime.Date?
    /// The ID of the import.
    public var importId: Swift.String?
    /// The source S3 bucket.
    public var importSource: CloudTrailClientTypes.ImportSource?
    /// Provides statistics for the import. CloudTrail does not update import statistics in real-time. Returned values for parameters such as EventsCompleted may be lower than the actual value, because CloudTrail updates statistics incrementally over the course of the import.
    public var importStatistics: CloudTrailClientTypes.ImportStatistics?
    /// The status of the import.
    public var importStatus: CloudTrailClientTypes.ImportStatus?
    /// Used with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var startEventTime: ClientRuntime.Date?
    /// The timestamp of when the import was updated.
    public var updatedTimestamp: ClientRuntime.Date?

    public init (
        createdTimestamp: ClientRuntime.Date? = nil,
        destinations: [Swift.String]? = nil,
        endEventTime: ClientRuntime.Date? = nil,
        importId: Swift.String? = nil,
        importSource: CloudTrailClientTypes.ImportSource? = nil,
        importStatistics: CloudTrailClientTypes.ImportStatistics? = nil,
        importStatus: CloudTrailClientTypes.ImportStatus? = nil,
        startEventTime: ClientRuntime.Date? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinations = destinations
        self.endEventTime = endEventTime
        self.importId = importId
        self.importSource = importSource
        self.importStatistics = importStatistics
        self.importStatus = importStatus
        self.startEventTime = startEventTime
        self.updatedTimestamp = updatedTimestamp
    }
}

struct GetImportOutputResponseBody: Swift.Equatable {
    let importId: Swift.String?
    let destinations: [Swift.String]?
    let importSource: CloudTrailClientTypes.ImportSource?
    let startEventTime: ClientRuntime.Date?
    let endEventTime: ClientRuntime.Date?
    let importStatus: CloudTrailClientTypes.ImportStatus?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
    let importStatistics: CloudTrailClientTypes.ImportStatistics?
}

extension GetImportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case destinations = "Destinations"
        case endEventTime = "EndEventTime"
        case importId = "ImportId"
        case importSource = "ImportSource"
        case importStatistics = "ImportStatistics"
        case importStatus = "ImportStatus"
        case startEventTime = "StartEventTime"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinations)
        var destinationsDecoded0:[Swift.String]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [Swift.String]()
            for string0 in destinationsContainer {
                if let string0 = string0 {
                    destinationsDecoded0?.append(string0)
                }
            }
        }
        destinations = destinationsDecoded0
        let importSourceDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportSource.self, forKey: .importSource)
        importSource = importSourceDecoded
        let startEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startEventTime)
        startEventTime = startEventTimeDecoded
        let endEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endEventTime)
        endEventTime = endEventTimeDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let importStatisticsDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatistics.self, forKey: .importStatistics)
        importStatistics = importStatisticsDecoded
    }
}

extension GetInsightSelectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailName = "TrailName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trailName = self.trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

extension GetInsightSelectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInsightSelectorsInput: Swift.Equatable {
    /// Specifies the name of the trail or trail ARN. If you specify a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If you specify a trail ARN, it must be in the format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var trailName: Swift.String?

    public init (
        trailName: Swift.String? = nil
    )
    {
        self.trailName = trailName
    }
}

struct GetInsightSelectorsInputBody: Swift.Equatable {
    let trailName: Swift.String?
}

extension GetInsightSelectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailName = "TrailName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailName)
        trailName = trailNameDecoded
    }
}

extension GetInsightSelectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightSelectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsightNotEnabled" : self = .insightNotEnabledException(try InsightNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetInsightSelectorsOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case insightNotEnabledException(InsightNotEnabledException)
    case invalidTrailNameException(InvalidTrailNameException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightSelectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetInsightSelectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.insightSelectors = output.insightSelectors
            self.trailARN = output.trailARN
        } else {
            self.insightSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct GetInsightSelectorsOutputResponse: Swift.Equatable {
    /// A JSON string that contains the insight types you want to log on a trail. In this release, ApiErrorRateInsight and ApiCallRateInsight are supported as insight types.
    public var insightSelectors: [CloudTrailClientTypes.InsightSelector]?
    /// The Amazon Resource Name (ARN) of a trail for which you want to get Insights selectors.
    public var trailARN: Swift.String?

    public init (
        insightSelectors: [CloudTrailClientTypes.InsightSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.insightSelectors = insightSelectors
        self.trailARN = trailARN
    }
}

struct GetInsightSelectorsOutputResponseBody: Swift.Equatable {
    let trailARN: Swift.String?
    let insightSelectors: [CloudTrailClientTypes.InsightSelector]?
}

extension GetInsightSelectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let insightSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.InsightSelector?].self, forKey: .insightSelectors)
        var insightSelectorsDecoded0:[CloudTrailClientTypes.InsightSelector]? = nil
        if let insightSelectorsContainer = insightSelectorsContainer {
            insightSelectorsDecoded0 = [CloudTrailClientTypes.InsightSelector]()
            for structure0 in insightSelectorsContainer {
                if let structure0 = structure0 {
                    insightSelectorsDecoded0?.append(structure0)
                }
            }
        }
        insightSelectors = insightSelectorsDecoded0
    }
}

extension GetQueryResultsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
        case maxQueryResults = "MaxQueryResults"
        case nextToken = "NextToken"
        case queryId = "QueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
        if let maxQueryResults = self.maxQueryResults {
            try encodeContainer.encode(maxQueryResults, forKey: .maxQueryResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
    }
}

extension GetQueryResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetQueryResultsInput: Swift.Equatable {
    /// The ARN (or ID suffix of the ARN) of the event data store against which the query was run.
    @available(*, deprecated, message: "EventDataStore is no longer required by GetQueryResultsRequest")
    public var eventDataStore: Swift.String?
    /// The maximum number of query results to display on a single page.
    public var maxQueryResults: Swift.Int?
    /// A token you can use to get the next page of query results.
    public var nextToken: Swift.String?
    /// The ID of the query for which you want to get results.
    /// This member is required.
    public var queryId: Swift.String?

    public init (
        eventDataStore: Swift.String? = nil,
        maxQueryResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
        self.maxQueryResults = maxQueryResults
        self.nextToken = nextToken
        self.queryId = queryId
    }
}

struct GetQueryResultsInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
    let queryId: Swift.String?
    let nextToken: Swift.String?
    let maxQueryResults: Swift.Int?
}

extension GetQueryResultsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
        case maxQueryResults = "MaxQueryResults"
        case nextToken = "NextToken"
        case queryId = "QueryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxQueryResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxQueryResults)
        maxQueryResults = maxQueryResultsDecoded
    }
}

extension GetQueryResultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQueryResultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventDataStoreARNInvalid" : self = .eventDataStoreARNInvalidException(try EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InactiveEventDataStore" : self = .inactiveEventDataStoreException(try InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientEncryptionPolicy" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResults" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryIdNotFound" : self = .queryIdNotFoundException(try QueryIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetQueryResultsOutputError: Swift.Error, Swift.Equatable {
    case eventDataStoreARNInvalidException(EventDataStoreARNInvalidException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case inactiveEventDataStoreException(InactiveEventDataStoreException)
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case operationNotPermittedException(OperationNotPermittedException)
    case queryIdNotFoundException(QueryIdNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQueryResultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetQueryResultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorMessage = output.errorMessage
            self.nextToken = output.nextToken
            self.queryResultRows = output.queryResultRows
            self.queryStatistics = output.queryStatistics
            self.queryStatus = output.queryStatus
        } else {
            self.errorMessage = nil
            self.nextToken = nil
            self.queryResultRows = nil
            self.queryStatistics = nil
            self.queryStatus = nil
        }
    }
}

public struct GetQueryResultsOutputResponse: Swift.Equatable {
    /// The error message returned if a query failed.
    public var errorMessage: Swift.String?
    /// A token you can use to get the next page of query results.
    public var nextToken: Swift.String?
    /// Contains the individual event results of the query.
    public var queryResultRows: [[[Swift.String:Swift.String]]]?
    /// Shows the count of query results.
    public var queryStatistics: CloudTrailClientTypes.QueryStatistics?
    /// The status of the query. Values include QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED.
    public var queryStatus: CloudTrailClientTypes.QueryStatus?

    public init (
        errorMessage: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        queryResultRows: [[[Swift.String:Swift.String]]]? = nil,
        queryStatistics: CloudTrailClientTypes.QueryStatistics? = nil,
        queryStatus: CloudTrailClientTypes.QueryStatus? = nil
    )
    {
        self.errorMessage = errorMessage
        self.nextToken = nextToken
        self.queryResultRows = queryResultRows
        self.queryStatistics = queryStatistics
        self.queryStatus = queryStatus
    }
}

struct GetQueryResultsOutputResponseBody: Swift.Equatable {
    let queryStatus: CloudTrailClientTypes.QueryStatus?
    let queryStatistics: CloudTrailClientTypes.QueryStatistics?
    let queryResultRows: [[[Swift.String:Swift.String]]]?
    let nextToken: Swift.String?
    let errorMessage: Swift.String?
}

extension GetQueryResultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage = "ErrorMessage"
        case nextToken = "NextToken"
        case queryResultRows = "QueryResultRows"
        case queryStatistics = "QueryStatistics"
        case queryStatus = "QueryStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
        let queryStatisticsDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatistics.self, forKey: .queryStatistics)
        queryStatistics = queryStatisticsDecoded
        let queryResultRowsContainer = try containerValues.decodeIfPresent([[[Swift.String: Swift.String?]?]?].self, forKey: .queryResultRows)
        var queryResultRowsDecoded0:[[[Swift.String:Swift.String]]]? = nil
        if let queryResultRowsContainer = queryResultRowsContainer {
            queryResultRowsDecoded0 = [[[Swift.String:Swift.String]]]()
            for list0 in queryResultRowsContainer {
                var list0Decoded0: [[Swift.String: Swift.String]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[Swift.String: Swift.String]]()
                    for map1 in list0 {
                        var list0Decoded1: [Swift.String: Swift.String]? = nil
                        if let map1 = map1 {
                            list0Decoded1 = [Swift.String: Swift.String]()
                            for (key2, queryresultvalue2) in map1 {
                                if let queryresultvalue2 = queryresultvalue2 {
                                    list0Decoded1?[key2] = queryresultvalue2
                                }
                            }
                        }
                        if let list0Decoded1 = list0Decoded1 {
                            list0Decoded0?.append(list0Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    queryResultRowsDecoded0?.append(list0Decoded0)
                }
            }
        }
        queryResultRows = queryResultRowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension GetTrailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetTrailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTrailInput: Swift.Equatable {
    /// The name or the Amazon Resource Name (ARN) of the trail for which you want to retrieve settings information.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetTrailInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetTrailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTrailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTrailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTrailOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTrailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTrailOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trail = output.trail
        } else {
            self.trail = nil
        }
    }
}

public struct GetTrailOutputResponse: Swift.Equatable {
    /// The settings for a trail.
    public var trail: CloudTrailClientTypes.Trail?

    public init (
        trail: CloudTrailClientTypes.Trail? = nil
    )
    {
        self.trail = trail
    }
}

struct GetTrailOutputResponseBody: Swift.Equatable {
    let trail: CloudTrailClientTypes.Trail?
}

extension GetTrailOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trail = "Trail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.Trail.self, forKey: .trail)
        trail = trailDecoded
    }
}

extension GetTrailStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetTrailStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The name of a trail about which you want the current status.
public struct GetTrailStatusInput: Swift.Equatable {
    /// Specifies the name or the CloudTrail ARN of the trail for which you are requesting status. To get the status of a shadow trail (a replication of the trail in another region), you must specify its ARN. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetTrailStatusInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetTrailStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTrailStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTrailStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTrailStatusOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTrailStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTrailStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isLogging = output.isLogging
            self.latestCloudWatchLogsDeliveryError = output.latestCloudWatchLogsDeliveryError
            self.latestCloudWatchLogsDeliveryTime = output.latestCloudWatchLogsDeliveryTime
            self.latestDeliveryAttemptSucceeded = output.latestDeliveryAttemptSucceeded
            self.latestDeliveryAttemptTime = output.latestDeliveryAttemptTime
            self.latestDeliveryError = output.latestDeliveryError
            self.latestDeliveryTime = output.latestDeliveryTime
            self.latestDigestDeliveryError = output.latestDigestDeliveryError
            self.latestDigestDeliveryTime = output.latestDigestDeliveryTime
            self.latestNotificationAttemptSucceeded = output.latestNotificationAttemptSucceeded
            self.latestNotificationAttemptTime = output.latestNotificationAttemptTime
            self.latestNotificationError = output.latestNotificationError
            self.latestNotificationTime = output.latestNotificationTime
            self.startLoggingTime = output.startLoggingTime
            self.stopLoggingTime = output.stopLoggingTime
            self.timeLoggingStarted = output.timeLoggingStarted
            self.timeLoggingStopped = output.timeLoggingStopped
        } else {
            self.isLogging = nil
            self.latestCloudWatchLogsDeliveryError = nil
            self.latestCloudWatchLogsDeliveryTime = nil
            self.latestDeliveryAttemptSucceeded = nil
            self.latestDeliveryAttemptTime = nil
            self.latestDeliveryError = nil
            self.latestDeliveryTime = nil
            self.latestDigestDeliveryError = nil
            self.latestDigestDeliveryTime = nil
            self.latestNotificationAttemptSucceeded = nil
            self.latestNotificationAttemptTime = nil
            self.latestNotificationError = nil
            self.latestNotificationTime = nil
            self.startLoggingTime = nil
            self.stopLoggingTime = nil
            self.timeLoggingStarted = nil
            self.timeLoggingStopped = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct GetTrailStatusOutputResponse: Swift.Equatable {
    /// Whether the CloudTrail trail is currently logging Amazon Web Services API calls.
    public var isLogging: Swift.Bool?
    /// Displays any CloudWatch Logs error that CloudTrail encountered when attempting to deliver logs to CloudWatch Logs.
    public var latestCloudWatchLogsDeliveryError: Swift.String?
    /// Displays the most recent date and time when CloudTrail delivered logs to CloudWatch Logs.
    public var latestCloudWatchLogsDeliveryTime: ClientRuntime.Date?
    /// This field is no longer in use.
    public var latestDeliveryAttemptSucceeded: Swift.String?
    /// This field is no longer in use.
    public var latestDeliveryAttemptTime: Swift.String?
    /// Displays any Amazon S3 error that CloudTrail encountered when attempting to deliver log files to the designated bucket. For more information, see [Error Responses](https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html) in the Amazon S3 API Reference. This error occurs only when there is a problem with the destination S3 bucket, and does not occur for requests that time out. To resolve the issue, create a new bucket, and then call UpdateTrail to specify the new bucket; or fix the existing objects so that CloudTrail can again write to the bucket.
    public var latestDeliveryError: Swift.String?
    /// Specifies the date and time that CloudTrail last delivered log files to an account's Amazon S3 bucket.
    public var latestDeliveryTime: ClientRuntime.Date?
    /// Displays any Amazon S3 error that CloudTrail encountered when attempting to deliver a digest file to the designated bucket. For more information, see [Error Responses](https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html) in the Amazon S3 API Reference. This error occurs only when there is a problem with the destination S3 bucket, and does not occur for requests that time out. To resolve the issue, create a new bucket, and then call UpdateTrail to specify the new bucket; or fix the existing objects so that CloudTrail can again write to the bucket.
    public var latestDigestDeliveryError: Swift.String?
    /// Specifies the date and time that CloudTrail last delivered a digest file to an account's Amazon S3 bucket.
    public var latestDigestDeliveryTime: ClientRuntime.Date?
    /// This field is no longer in use.
    public var latestNotificationAttemptSucceeded: Swift.String?
    /// This field is no longer in use.
    public var latestNotificationAttemptTime: Swift.String?
    /// Displays any Amazon SNS error that CloudTrail encountered when attempting to send a notification. For more information about Amazon SNS errors, see the [Amazon SNS Developer Guide](https://docs.aws.amazon.com/sns/latest/dg/welcome.html).
    public var latestNotificationError: Swift.String?
    /// Specifies the date and time of the most recent Amazon SNS notification that CloudTrail has written a new log file to an account's Amazon S3 bucket.
    public var latestNotificationTime: ClientRuntime.Date?
    /// Specifies the most recent date and time when CloudTrail started recording API calls for an Amazon Web Services account.
    public var startLoggingTime: ClientRuntime.Date?
    /// Specifies the most recent date and time when CloudTrail stopped recording API calls for an Amazon Web Services account.
    public var stopLoggingTime: ClientRuntime.Date?
    /// This field is no longer in use.
    public var timeLoggingStarted: Swift.String?
    /// This field is no longer in use.
    public var timeLoggingStopped: Swift.String?

    public init (
        isLogging: Swift.Bool? = nil,
        latestCloudWatchLogsDeliveryError: Swift.String? = nil,
        latestCloudWatchLogsDeliveryTime: ClientRuntime.Date? = nil,
        latestDeliveryAttemptSucceeded: Swift.String? = nil,
        latestDeliveryAttemptTime: Swift.String? = nil,
        latestDeliveryError: Swift.String? = nil,
        latestDeliveryTime: ClientRuntime.Date? = nil,
        latestDigestDeliveryError: Swift.String? = nil,
        latestDigestDeliveryTime: ClientRuntime.Date? = nil,
        latestNotificationAttemptSucceeded: Swift.String? = nil,
        latestNotificationAttemptTime: Swift.String? = nil,
        latestNotificationError: Swift.String? = nil,
        latestNotificationTime: ClientRuntime.Date? = nil,
        startLoggingTime: ClientRuntime.Date? = nil,
        stopLoggingTime: ClientRuntime.Date? = nil,
        timeLoggingStarted: Swift.String? = nil,
        timeLoggingStopped: Swift.String? = nil
    )
    {
        self.isLogging = isLogging
        self.latestCloudWatchLogsDeliveryError = latestCloudWatchLogsDeliveryError
        self.latestCloudWatchLogsDeliveryTime = latestCloudWatchLogsDeliveryTime
        self.latestDeliveryAttemptSucceeded = latestDeliveryAttemptSucceeded
        self.latestDeliveryAttemptTime = latestDeliveryAttemptTime
        self.latestDeliveryError = latestDeliveryError
        self.latestDeliveryTime = latestDeliveryTime
        self.latestDigestDeliveryError = latestDigestDeliveryError
        self.latestDigestDeliveryTime = latestDigestDeliveryTime
        self.latestNotificationAttemptSucceeded = latestNotificationAttemptSucceeded
        self.latestNotificationAttemptTime = latestNotificationAttemptTime
        self.latestNotificationError = latestNotificationError
        self.latestNotificationTime = latestNotificationTime
        self.startLoggingTime = startLoggingTime
        self.stopLoggingTime = stopLoggingTime
        self.timeLoggingStarted = timeLoggingStarted
        self.timeLoggingStopped = timeLoggingStopped
    }
}

struct GetTrailStatusOutputResponseBody: Swift.Equatable {
    let isLogging: Swift.Bool?
    let latestDeliveryError: Swift.String?
    let latestNotificationError: Swift.String?
    let latestDeliveryTime: ClientRuntime.Date?
    let latestNotificationTime: ClientRuntime.Date?
    let startLoggingTime: ClientRuntime.Date?
    let stopLoggingTime: ClientRuntime.Date?
    let latestCloudWatchLogsDeliveryError: Swift.String?
    let latestCloudWatchLogsDeliveryTime: ClientRuntime.Date?
    let latestDigestDeliveryTime: ClientRuntime.Date?
    let latestDigestDeliveryError: Swift.String?
    let latestDeliveryAttemptTime: Swift.String?
    let latestNotificationAttemptTime: Swift.String?
    let latestNotificationAttemptSucceeded: Swift.String?
    let latestDeliveryAttemptSucceeded: Swift.String?
    let timeLoggingStarted: Swift.String?
    let timeLoggingStopped: Swift.String?
}

extension GetTrailStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLogging = "IsLogging"
        case latestCloudWatchLogsDeliveryError = "LatestCloudWatchLogsDeliveryError"
        case latestCloudWatchLogsDeliveryTime = "LatestCloudWatchLogsDeliveryTime"
        case latestDeliveryAttemptSucceeded = "LatestDeliveryAttemptSucceeded"
        case latestDeliveryAttemptTime = "LatestDeliveryAttemptTime"
        case latestDeliveryError = "LatestDeliveryError"
        case latestDeliveryTime = "LatestDeliveryTime"
        case latestDigestDeliveryError = "LatestDigestDeliveryError"
        case latestDigestDeliveryTime = "LatestDigestDeliveryTime"
        case latestNotificationAttemptSucceeded = "LatestNotificationAttemptSucceeded"
        case latestNotificationAttemptTime = "LatestNotificationAttemptTime"
        case latestNotificationError = "LatestNotificationError"
        case latestNotificationTime = "LatestNotificationTime"
        case startLoggingTime = "StartLoggingTime"
        case stopLoggingTime = "StopLoggingTime"
        case timeLoggingStarted = "TimeLoggingStarted"
        case timeLoggingStopped = "TimeLoggingStopped"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isLoggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLogging)
        isLogging = isLoggingDecoded
        let latestDeliveryErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDeliveryError)
        latestDeliveryError = latestDeliveryErrorDecoded
        let latestNotificationErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestNotificationError)
        latestNotificationError = latestNotificationErrorDecoded
        let latestDeliveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestDeliveryTime)
        latestDeliveryTime = latestDeliveryTimeDecoded
        let latestNotificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestNotificationTime)
        latestNotificationTime = latestNotificationTimeDecoded
        let startLoggingTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startLoggingTime)
        startLoggingTime = startLoggingTimeDecoded
        let stopLoggingTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopLoggingTime)
        stopLoggingTime = stopLoggingTimeDecoded
        let latestCloudWatchLogsDeliveryErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestCloudWatchLogsDeliveryError)
        latestCloudWatchLogsDeliveryError = latestCloudWatchLogsDeliveryErrorDecoded
        let latestCloudWatchLogsDeliveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestCloudWatchLogsDeliveryTime)
        latestCloudWatchLogsDeliveryTime = latestCloudWatchLogsDeliveryTimeDecoded
        let latestDigestDeliveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestDigestDeliveryTime)
        latestDigestDeliveryTime = latestDigestDeliveryTimeDecoded
        let latestDigestDeliveryErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDigestDeliveryError)
        latestDigestDeliveryError = latestDigestDeliveryErrorDecoded
        let latestDeliveryAttemptTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDeliveryAttemptTime)
        latestDeliveryAttemptTime = latestDeliveryAttemptTimeDecoded
        let latestNotificationAttemptTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestNotificationAttemptTime)
        latestNotificationAttemptTime = latestNotificationAttemptTimeDecoded
        let latestNotificationAttemptSucceededDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestNotificationAttemptSucceeded)
        latestNotificationAttemptSucceeded = latestNotificationAttemptSucceededDecoded
        let latestDeliveryAttemptSucceededDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDeliveryAttemptSucceeded)
        latestDeliveryAttemptSucceeded = latestDeliveryAttemptSucceededDecoded
        let timeLoggingStartedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeLoggingStarted)
        timeLoggingStarted = timeLoggingStartedDecoded
        let timeLoggingStoppedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeLoggingStopped)
        timeLoggingStopped = timeLoggingStoppedDecoded
    }
}

extension CloudTrailClientTypes.ImportFailureListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage = "ErrorMessage"
        case errorType = "ErrorType"
        case lastUpdatedTime = "LastUpdatedTime"
        case location = "Location"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType, forKey: .errorType)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportFailureStatus.self, forKey: .status)
        status = statusDecoded
        let errorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorType)
        errorType = errorTypeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension CloudTrailClientTypes {
    /// Provides information about an import failure.
    public struct ImportFailureListItem: Swift.Equatable {
        /// Provides the reason the import failed.
        public var errorMessage: Swift.String?
        /// The type of import error.
        public var errorType: Swift.String?
        /// When the import was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The location of the failure in the S3 bucket.
        public var location: Swift.String?
        /// The status of the import.
        public var status: CloudTrailClientTypes.ImportFailureStatus?

        public init (
            errorMessage: Swift.String? = nil,
            errorType: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            location: Swift.String? = nil,
            status: CloudTrailClientTypes.ImportFailureStatus? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorType = errorType
            self.lastUpdatedTime = lastUpdatedTime
            self.location = location
            self.status = status
        }
    }

}

extension CloudTrailClientTypes {
    public enum ImportFailureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case retry
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportFailureStatus] {
            return [
                .failed,
                .retry,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .retry: return "RETRY"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportFailureStatus(rawValue: rawValue) ?? ImportFailureStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImportNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified import was not found.
public struct ImportNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImportNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ImportNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.ImportSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3 = "S3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.S3ImportSource.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension CloudTrailClientTypes {
    /// The import source.
    public struct ImportSource: Swift.Equatable {
        /// The source S3 bucket.
        /// This member is required.
        public var s3: CloudTrailClientTypes.S3ImportSource?

        public init (
            s3: CloudTrailClientTypes.S3ImportSource? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension CloudTrailClientTypes.ImportStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventsCompleted = "EventsCompleted"
        case failedEntries = "FailedEntries"
        case filesCompleted = "FilesCompleted"
        case prefixesCompleted = "PrefixesCompleted"
        case prefixesFound = "PrefixesFound"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventsCompleted = self.eventsCompleted {
            try encodeContainer.encode(eventsCompleted, forKey: .eventsCompleted)
        }
        if let failedEntries = self.failedEntries {
            try encodeContainer.encode(failedEntries, forKey: .failedEntries)
        }
        if let filesCompleted = self.filesCompleted {
            try encodeContainer.encode(filesCompleted, forKey: .filesCompleted)
        }
        if let prefixesCompleted = self.prefixesCompleted {
            try encodeContainer.encode(prefixesCompleted, forKey: .prefixesCompleted)
        }
        if let prefixesFound = self.prefixesFound {
            try encodeContainer.encode(prefixesFound, forKey: .prefixesFound)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixesFoundDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .prefixesFound)
        prefixesFound = prefixesFoundDecoded
        let prefixesCompletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .prefixesCompleted)
        prefixesCompleted = prefixesCompletedDecoded
        let filesCompletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .filesCompleted)
        filesCompleted = filesCompletedDecoded
        let eventsCompletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventsCompleted)
        eventsCompleted = eventsCompletedDecoded
        let failedEntriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedEntries)
        failedEntries = failedEntriesDecoded
    }
}

extension CloudTrailClientTypes {
    /// Provides statistics for the specified ImportID. CloudTrail does not update import statistics in real-time. Returned values for parameters such as EventsCompleted may be lower than the actual value, because CloudTrail updates statistics incrementally over the course of the import.
    public struct ImportStatistics: Swift.Equatable {
        /// The number of trail events imported into the event data store.
        public var eventsCompleted: Swift.Int?
        /// The number of failed entries.
        public var failedEntries: Swift.Int?
        /// The number of log files that completed import.
        public var filesCompleted: Swift.Int?
        /// The number of S3 prefixes that completed import.
        public var prefixesCompleted: Swift.Int?
        /// The number of S3 prefixes found for the import.
        public var prefixesFound: Swift.Int?

        public init (
            eventsCompleted: Swift.Int? = nil,
            failedEntries: Swift.Int? = nil,
            filesCompleted: Swift.Int? = nil,
            prefixesCompleted: Swift.Int? = nil,
            prefixesFound: Swift.Int? = nil
        )
        {
            self.eventsCompleted = eventsCompleted
            self.failedEntries = failedEntries
            self.filesCompleted = filesCompleted
            self.prefixesCompleted = prefixesCompleted
            self.prefixesFound = prefixesFound
        }
    }

}

extension CloudTrailClientTypes {
    public enum ImportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case initializing
        case inProgress
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportStatus] {
            return [
                .completed,
                .failed,
                .initializing,
                .inProgress,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .initializing: return "INITIALIZING"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportStatus(rawValue: rawValue) ?? ImportStatus.sdkUnknown(rawValue)
        }
    }
}

extension CloudTrailClientTypes.ImportsListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case destinations = "Destinations"
        case importId = "ImportId"
        case importStatus = "ImportStatus"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for eventdatastorearn0 in destinations {
                try destinationsContainer.encode(eventdatastorearn0)
            }
        }
        if let importId = self.importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
        if let importStatus = self.importStatus {
            try encodeContainer.encode(importStatus.rawValue, forKey: .importStatus)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .epochSeconds, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinations)
        var destinationsDecoded0:[Swift.String]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [Swift.String]()
            for string0 in destinationsContainer {
                if let string0 = string0 {
                    destinationsDecoded0?.append(string0)
                }
            }
        }
        destinations = destinationsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension CloudTrailClientTypes {
    /// Contains information about an import that was returned by a lookup request.
    public struct ImportsListItem: Swift.Equatable {
        /// The timestamp of the import's creation.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ARN of the destination event data store.
        public var destinations: [Swift.String]?
        /// The ID of the import.
        public var importId: Swift.String?
        /// The status of the import.
        public var importStatus: CloudTrailClientTypes.ImportStatus?
        /// The timestamp of the import's last update.
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            destinations: [Swift.String]? = nil,
            importId: Swift.String? = nil,
            importStatus: CloudTrailClientTypes.ImportStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.destinations = destinations
            self.importId = importId
            self.importStatus = importStatus
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension InactiveEventDataStoreException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InactiveEventDataStoreExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The event data store is inactive.
public struct InactiveEventDataStoreException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InactiveEventDataStoreExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InactiveEventDataStoreExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InactiveQueryException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InactiveQueryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified query cannot be canceled because it is in the FINISHED, FAILED, TIMED_OUT, or CANCELLED state.
public struct InactiveQueryException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InactiveQueryExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InactiveQueryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsightNotEnabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InsightNotEnabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// If you run GetInsightSelectors on a trail that does not have Insights events enabled, the operation throws the exception InsightNotEnabledException.
public struct InsightNotEnabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsightNotEnabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsightNotEnabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.InsightSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightType = "InsightType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightType = self.insightType {
            try encodeContainer.encode(insightType.rawValue, forKey: .insightType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightTypeDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.InsightType.self, forKey: .insightType)
        insightType = insightTypeDecoded
    }
}

extension CloudTrailClientTypes {
    /// A JSON string that contains a list of insight types that are logged on a trail.
    public struct InsightSelector: Swift.Equatable {
        /// The type of insights to log on a trail. ApiCallRateInsight and ApiErrorRateInsight are valid insight types.
        public var insightType: CloudTrailClientTypes.InsightType?

        public init (
            insightType: CloudTrailClientTypes.InsightType? = nil
        )
        {
            self.insightType = insightType
        }
    }

}

extension CloudTrailClientTypes {
    public enum InsightType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apicallrateinsight
        case apierrorrateinsight
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightType] {
            return [
                .apicallrateinsight,
                .apierrorrateinsight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apicallrateinsight: return "ApiCallRateInsight"
            case .apierrorrateinsight: return "ApiErrorRateInsight"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightType(rawValue: rawValue) ?? InsightType.sdkUnknown(rawValue)
        }
    }
}

extension InsufficientDependencyServiceAccessPermissionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InsufficientDependencyServiceAccessPermissionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the IAM user or role that is used to create the organization resource lacks one or more required permissions for creating an organization resource in a required service.
public struct InsufficientDependencyServiceAccessPermissionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDependencyServiceAccessPermissionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientDependencyServiceAccessPermissionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientEncryptionPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InsufficientEncryptionPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the policy on the S3 bucket or KMS key does not have sufficient permissions for the operation.
public struct InsufficientEncryptionPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientEncryptionPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientEncryptionPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientS3BucketPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InsufficientS3BucketPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the policy on the S3 bucket is not sufficient.
public struct InsufficientS3BucketPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientS3BucketPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientS3BucketPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientSnsTopicPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InsufficientSnsTopicPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the policy on the Amazon SNS topic is not sufficient.
public struct InsufficientSnsTopicPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientSnsTopicPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientSnsTopicPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCloudWatchLogsLogGroupArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidCloudWatchLogsLogGroupArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided CloudWatch Logs log group is not valid.
public struct InvalidCloudWatchLogsLogGroupArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCloudWatchLogsLogGroupArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCloudWatchLogsLogGroupArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCloudWatchLogsRoleArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidCloudWatchLogsRoleArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided role is not valid.
public struct InvalidCloudWatchLogsRoleArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCloudWatchLogsRoleArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCloudWatchLogsRoleArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDateRangeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidDateRangeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A date range for the query was specified that is not valid. Be sure that the start time is chronologically before the end time. For more information about writing a query, see [Create or edit a query](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-create-edit-query.html) in the CloudTrail User Guide.
public struct InvalidDateRangeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDateRangeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDateRangeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventCategoryException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidEventCategoryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs if an event category that is not valid is specified as a value of EventCategory.
public struct InvalidEventCategoryException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventCategoryExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEventCategoryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventDataStoreCategoryException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidEventDataStoreCategoryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when event categories of specified event data stores are not valid.
public struct InvalidEventDataStoreCategoryException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventDataStoreCategoryExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEventDataStoreCategoryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventDataStoreStatusException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidEventDataStoreStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The event data store is not in a status that supports the operation.
public struct InvalidEventDataStoreStatusException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventDataStoreStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEventDataStoreStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventSelectorsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidEventSelectorsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the PutEventSelectors operation is called with a number of event selectors, advanced event selectors, or data resources that is not valid. The combination of event selectors or advanced event selectors and data resources is not valid. A trail can have up to 5 event selectors. If a trail uses advanced event selectors, a maximum of 500 total values for all conditions in all advanced event selectors is allowed. A trail is limited to 250 data resources. These data resources can be distributed across event selectors, but the overall total cannot exceed 250. You can:
///
/// * Specify a valid number of event selectors (1 to 5) for a trail.
///
/// * Specify a valid number of data resources (1 to 250) for an event selector. The limit of number of resources on an individual event selector is configurable up to 250. However, this upper limit is allowed only if the total number of data resources does not exceed 250 across all event selectors for a trail.
///
/// * Specify up to 500 values for all conditions in all advanced event selectors for a trail.
///
/// * Specify a valid value for a parameter. For example, specifying the ReadWriteType parameter with a value of read-only is not valid.
public struct InvalidEventSelectorsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventSelectorsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEventSelectorsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHomeRegionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidHomeRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when an operation is called on a trail from a region other than the region in which the trail was created.
public struct InvalidHomeRegionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidHomeRegionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidHomeRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidImportSourceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidImportSourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided source S3 bucket is not valid for import.
public struct InvalidImportSourceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidImportSourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidImportSourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInsightSelectorsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidInsightSelectorsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The formatting or syntax of the InsightSelectors JSON statement in your PutInsightSelectors or GetInsightSelectors request is not valid, or the specified insight type in the InsightSelectors statement is not a valid insight type.
public struct InvalidInsightSelectorsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInsightSelectorsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInsightSelectorsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidKmsKeyIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidKmsKeyIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the KMS key ARN is not valid.
public struct InvalidKmsKeyIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidKmsKeyIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidKmsKeyIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLookupAttributesException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidLookupAttributesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs when a lookup attribute is specified that is not valid.
public struct InvalidLookupAttributesException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLookupAttributesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLookupAttributesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxResultsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidMaxResultsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown if the limit specified is not valid.
public struct InvalidMaxResultsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxResultsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMaxResultsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A token that is not valid, or a token that was previously used in a request with different parameters. This exception is thrown if the token is not valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the combination of parameters provided is not valid.
public struct InvalidParameterCombinationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request includes a parameter that is not valid.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidQueryStatementException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidQueryStatementExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The query that was submitted has validation errors, or uses incorrect syntax or unsupported keywords. For more information about writing a query, see [Create or edit a query](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-create-edit-query.html) in the CloudTrail User Guide.
public struct InvalidQueryStatementException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidQueryStatementExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidQueryStatementExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidQueryStatusException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidQueryStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The query status is not valid for the operation.
public struct InvalidQueryStatusException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidQueryStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidQueryStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3BucketNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidS3BucketNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided S3 bucket name is not valid.
public struct InvalidS3BucketNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3BucketNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3BucketNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3PrefixException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidS3PrefixExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided S3 prefix is not valid.
public struct InvalidS3PrefixException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3PrefixExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3PrefixExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSnsTopicNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidSnsTopicNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided SNS topic name is not valid.
public struct InvalidSnsTopicNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSnsTopicNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSnsTopicNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTagParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified tag key or values are not valid. It can also occur if there are duplicate tags or too many tags on the resource.
public struct InvalidTagParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTimeRangeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTimeRangeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs if the timestamp values are not valid. Either the start time occurs after the end time, or the time range is outside the range of possible values.
public struct InvalidTimeRangeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTimeRangeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTimeRangeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Reserved for future use.
public struct InvalidTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTrailNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTrailNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:
///
/// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
///
/// * Start with a letter or number, and end with a letter or number
///
/// * Be between 3 and 128 characters
///
/// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
///
/// * Not be in IP address format (for example, 192.168.5.4)
public struct InvalidTrailNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTrailNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTrailNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: KmsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when there is an issue with the specified KMS key and the trail or event data store can't be updated.
public struct KmsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KmsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KmsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsKeyDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: KmsKeyDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is no longer in use.
@available(*, deprecated)
public struct KmsKeyDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KmsKeyDisabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KmsKeyDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsKeyNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: KmsKeyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the KMS key does not exist, when the S3 bucket and the KMS key are not in the same region, or when the KMS key associated with the Amazon SNS topic either does not exist or is not in the same region.
public struct KmsKeyNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KmsKeyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KmsKeyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListChannelsInput: Swift.Equatable {
    /// The maximum number of CloudTrail channels to display on a single page.
    public var maxResults: Swift.Int?
    /// The token to use to get the next page of results after a previous API call. This token must be passed in with the same parameters that were specified in the original call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Swift.Equatable {
    /// The list of channels in the account.
    public var channels: [CloudTrailClientTypes.Channel]?
    /// The token to use to get the next page of results after a previous API call.
    public var nextToken: Swift.String?

    public init (
        channels: [CloudTrailClientTypes.Channel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Swift.Equatable {
    let channels: [CloudTrailClientTypes.Channel]?
    let nextToken: Swift.String?
}

extension ListChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Channel?].self, forKey: .channels)
        var channelsDecoded0:[CloudTrailClientTypes.Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [CloudTrailClientTypes.Channel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEventDataStoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEventDataStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEventDataStoresInput: Swift.Equatable {
    /// The maximum number of event data stores to display on a single page.
    public var maxResults: Swift.Int?
    /// A token you can use to get the next page of event data store results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventDataStoresInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEventDataStoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventDataStoresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventDataStoresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidMaxResults" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEventDataStoresOutputError: Swift.Error, Swift.Equatable {
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventDataStoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEventDataStoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventDataStores = output.eventDataStores
            self.nextToken = output.nextToken
        } else {
            self.eventDataStores = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventDataStoresOutputResponse: Swift.Equatable {
    /// Contains information about event data stores in the account, in the current region.
    public var eventDataStores: [CloudTrailClientTypes.EventDataStore]?
    /// A token you can use to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        eventDataStores: [CloudTrailClientTypes.EventDataStore]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventDataStores = eventDataStores
        self.nextToken = nextToken
    }
}

struct ListEventDataStoresOutputResponseBody: Swift.Equatable {
    let eventDataStores: [CloudTrailClientTypes.EventDataStore]?
    let nextToken: Swift.String?
}

extension ListEventDataStoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStores = "EventDataStores"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoresContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.EventDataStore?].self, forKey: .eventDataStores)
        var eventDataStoresDecoded0:[CloudTrailClientTypes.EventDataStore]? = nil
        if let eventDataStoresContainer = eventDataStoresContainer {
            eventDataStoresDecoded0 = [CloudTrailClientTypes.EventDataStore]()
            for structure0 in eventDataStoresContainer {
                if let structure0 = structure0 {
                    eventDataStoresDecoded0?.append(structure0)
                }
            }
        }
        eventDataStores = eventDataStoresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImportFailuresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId = "ImportId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importId = self.importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImportFailuresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListImportFailuresInput: Swift.Equatable {
    /// The ID of the import.
    /// This member is required.
    public var importId: Swift.String?
    /// The maximum number of failures to display on a single page.
    public var maxResults: Swift.Int?
    /// A token you can use to get the next page of import failures.
    public var nextToken: Swift.String?

    public init (
        importId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importId = importId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImportFailuresInputBody: Swift.Equatable {
    let importId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImportFailuresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId = "ImportId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImportFailuresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImportFailuresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListImportFailuresOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImportFailuresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListImportFailuresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.nextToken = output.nextToken
        } else {
            self.failures = nil
            self.nextToken = nil
        }
    }
}

public struct ListImportFailuresOutputResponse: Swift.Equatable {
    /// Contains information about the import failures.
    public var failures: [CloudTrailClientTypes.ImportFailureListItem]?
    /// A token you can use to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        failures: [CloudTrailClientTypes.ImportFailureListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.failures = failures
        self.nextToken = nextToken
    }
}

struct ListImportFailuresOutputResponseBody: Swift.Equatable {
    let failures: [CloudTrailClientTypes.ImportFailureListItem]?
    let nextToken: Swift.String?
}

extension ListImportFailuresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures = "Failures"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failuresContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.ImportFailureListItem?].self, forKey: .failures)
        var failuresDecoded0:[CloudTrailClientTypes.ImportFailureListItem]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [CloudTrailClientTypes.ImportFailureListItem]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case importStatus = "ImportStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let importStatus = self.importStatus {
            try encodeContainer.encode(importStatus.rawValue, forKey: .importStatus)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListImportsInput: Swift.Equatable {
    /// The ARN of the destination event data store.
    public var destination: Swift.String?
    /// The status of the import.
    public var importStatus: CloudTrailClientTypes.ImportStatus?
    /// The maximum number of imports to display on a single page.
    public var maxResults: Swift.Int?
    /// A token you can use to get the next page of import results.
    public var nextToken: Swift.String?

    public init (
        destination: Swift.String? = nil,
        importStatus: CloudTrailClientTypes.ImportStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destination = destination
        self.importStatus = importStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImportsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let destination: Swift.String?
    let importStatus: CloudTrailClientTypes.ImportStatus?
    let nextToken: Swift.String?
}

extension ListImportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case importStatus = "ImportStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventDataStoreARNInvalid" : self = .eventDataStoreARNInvalidException(try EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListImportsOutputError: Swift.Error, Swift.Equatable {
    case eventDataStoreARNInvalidException(EventDataStoreARNInvalidException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListImportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imports = output.imports
            self.nextToken = output.nextToken
        } else {
            self.imports = nil
            self.nextToken = nil
        }
    }
}

public struct ListImportsOutputResponse: Swift.Equatable {
    /// The list of returned imports.
    public var imports: [CloudTrailClientTypes.ImportsListItem]?
    /// A token you can use to get the next page of import results.
    public var nextToken: Swift.String?

    public init (
        imports: [CloudTrailClientTypes.ImportsListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imports = imports
        self.nextToken = nextToken
    }
}

struct ListImportsOutputResponseBody: Swift.Equatable {
    let imports: [CloudTrailClientTypes.ImportsListItem]?
    let nextToken: Swift.String?
}

extension ListImportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imports = "Imports"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.ImportsListItem?].self, forKey: .imports)
        var importsDecoded0:[CloudTrailClientTypes.ImportsListItem]? = nil
        if let importsContainer = importsContainer {
            importsDecoded0 = [CloudTrailClientTypes.ImportsListItem]()
            for structure0 in importsContainer {
                if let structure0 = structure0 {
                    importsDecoded0?.append(structure0)
                }
            }
        }
        imports = importsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPublicKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListPublicKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Requests the public keys for a specified time range.
public struct ListPublicKeysInput: Swift.Equatable {
    /// Optionally specifies, in UTC, the end of the time range to look up public keys for CloudTrail digest files. If not specified, the current time is used.
    public var endTime: ClientRuntime.Date?
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Optionally specifies, in UTC, the start of the time range to look up public keys for CloudTrail digest files. If not specified, the current time is used, and the current public key is returned.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct ListPublicKeysInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let nextToken: Swift.String?
}

extension ListPublicKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPublicKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPublicKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTimeRange" : self = .invalidTimeRangeException(try InvalidTimeRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidToken" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPublicKeysOutputError: Swift.Error, Swift.Equatable {
    case invalidTimeRangeException(InvalidTimeRangeException)
    case invalidTokenException(InvalidTokenException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPublicKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPublicKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.publicKeyList = output.publicKeyList
        } else {
            self.nextToken = nil
            self.publicKeyList = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct ListPublicKeysOutputResponse: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Contains an array of PublicKey objects. The returned public keys may have validity time ranges that overlap.
    public var publicKeyList: [CloudTrailClientTypes.PublicKey]?

    public init (
        nextToken: Swift.String? = nil,
        publicKeyList: [CloudTrailClientTypes.PublicKey]? = nil
    )
    {
        self.nextToken = nextToken
        self.publicKeyList = publicKeyList
    }
}

struct ListPublicKeysOutputResponseBody: Swift.Equatable {
    let publicKeyList: [CloudTrailClientTypes.PublicKey]?
    let nextToken: Swift.String?
}

extension ListPublicKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case publicKeyList = "PublicKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.PublicKey?].self, forKey: .publicKeyList)
        var publicKeyListDecoded0:[CloudTrailClientTypes.PublicKey]? = nil
        if let publicKeyListContainer = publicKeyListContainer {
            publicKeyListDecoded0 = [CloudTrailClientTypes.PublicKey]()
            for structure0 in publicKeyListContainer {
                if let structure0 = structure0 {
                    publicKeyListDecoded0?.append(structure0)
                }
            }
        }
        publicKeyList = publicKeyListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListQueriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case eventDataStore = "EventDataStore"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case queryStatus = "QueryStatus"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryStatus = self.queryStatus {
            try encodeContainer.encode(queryStatus.rawValue, forKey: .queryStatus)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListQueriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListQueriesInput: Swift.Equatable {
    /// Use with StartTime to bound a ListQueries request, and limit its results to only those queries run within a specified time period.
    public var endTime: ClientRuntime.Date?
    /// The ARN (or the ID suffix of the ARN) of an event data store on which queries were run.
    /// This member is required.
    public var eventDataStore: Swift.String?
    /// The maximum number of queries to show on a page.
    public var maxResults: Swift.Int?
    /// A token you can use to get the next page of results.
    public var nextToken: Swift.String?
    /// The status of queries that you want to return in results. Valid values for QueryStatus include QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED.
    public var queryStatus: CloudTrailClientTypes.QueryStatus?
    /// Use with EndTime to bound a ListQueries request, and limit its results to only those queries run within a specified time period.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        eventDataStore: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryStatus: CloudTrailClientTypes.QueryStatus? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventDataStore = eventDataStore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryStatus = queryStatus
        self.startTime = startTime
    }
}

struct ListQueriesInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let queryStatus: CloudTrailClientTypes.QueryStatus?
}

extension ListQueriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case eventDataStore = "EventDataStore"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case queryStatus = "QueryStatus"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let queryStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
    }
}

extension ListQueriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQueriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventDataStoreARNInvalid" : self = .eventDataStoreARNInvalidException(try EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InactiveEventDataStore" : self = .inactiveEventDataStoreException(try InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDateRange" : self = .invalidDateRangeException(try InvalidDateRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResults" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStatus" : self = .invalidQueryStatusException(try InvalidQueryStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListQueriesOutputError: Swift.Error, Swift.Equatable {
    case eventDataStoreARNInvalidException(EventDataStoreARNInvalidException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case inactiveEventDataStoreException(InactiveEventDataStoreException)
    case invalidDateRangeException(InvalidDateRangeException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidQueryStatusException(InvalidQueryStatusException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQueriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListQueriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queries = output.queries
        } else {
            self.nextToken = nil
            self.queries = nil
        }
    }
}

public struct ListQueriesOutputResponse: Swift.Equatable {
    /// A token you can use to get the next page of results.
    public var nextToken: Swift.String?
    /// Lists matching query results, and shows query ID, status, and creation time of each query.
    public var queries: [CloudTrailClientTypes.Query]?

    public init (
        nextToken: Swift.String? = nil,
        queries: [CloudTrailClientTypes.Query]? = nil
    )
    {
        self.nextToken = nextToken
        self.queries = queries
    }
}

struct ListQueriesOutputResponseBody: Swift.Equatable {
    let queries: [CloudTrailClientTypes.Query]?
    let nextToken: Swift.String?
}

extension ListQueriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case queries = "Queries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queriesContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Query?].self, forKey: .queries)
        var queriesDecoded0:[CloudTrailClientTypes.Query]? = nil
        if let queriesContainer = queriesContainer {
            queriesDecoded0 = [CloudTrailClientTypes.Query]()
            for structure0 in queriesContainer {
                if let structure0 = structure0 {
                    queriesDecoded0?.append(structure0)
                }
            }
        }
        queries = queriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceIdList = "ResourceIdList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIdList = resourceIdList {
            var resourceIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIdList)
            for string0 in resourceIdList {
                try resourceIdListContainer.encode(string0)
            }
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies a list of tags to return.
public struct ListTagsInput: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Specifies a list of trail and event data store ARNs whose tags will be listed. The list has a limit of 20 ARNs.
    /// This member is required.
    public var resourceIdList: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        resourceIdList: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdList = resourceIdList
    }
}

struct ListTagsInputBody: Swift.Equatable {
    let resourceIdList: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceIdList = "ResourceIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIdList)
        var resourceIdListDecoded0:[Swift.String]? = nil
        if let resourceIdListContainer = resourceIdListContainer {
            resourceIdListDecoded0 = [Swift.String]()
            for string0 in resourceIdListContainer {
                if let string0 = string0 {
                    resourceIdListDecoded0?.append(string0)
                }
            }
        }
        resourceIdList = resourceIdListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InactiveEventDataStore" : self = .inactiveEventDataStoreException(try InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidToken" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceTypeNotSupported" : self = .resourceTypeNotSupportedException(try ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case inactiveEventDataStoreException(InactiveEventDataStoreException)
    case invalidTokenException(InvalidTokenException)
    case invalidTrailNameException(InvalidTrailNameException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceTypeNotSupportedException(ResourceTypeNotSupportedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceTagList = output.resourceTagList
        } else {
            self.nextToken = nil
            self.resourceTagList = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct ListTagsOutputResponse: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// A list of resource tags.
    public var resourceTagList: [CloudTrailClientTypes.ResourceTag]?

    public init (
        nextToken: Swift.String? = nil,
        resourceTagList: [CloudTrailClientTypes.ResourceTag]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTagList = resourceTagList
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    let resourceTagList: [CloudTrailClientTypes.ResourceTag]?
    let nextToken: Swift.String?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceTagList = "ResourceTagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTagListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.ResourceTag?].self, forKey: .resourceTagList)
        var resourceTagListDecoded0:[CloudTrailClientTypes.ResourceTag]? = nil
        if let resourceTagListContainer = resourceTagListContainer {
            resourceTagListDecoded0 = [CloudTrailClientTypes.ResourceTag]()
            for structure0 in resourceTagListContainer {
                if let structure0 = structure0 {
                    resourceTagListDecoded0?.append(structure0)
                }
            }
        }
        resourceTagList = resourceTagListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTrailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTrailsInput: Swift.Equatable {
    /// The token to use to get the next page of results after a previous API call. This token must be passed in with the same parameters that were specified in the original call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListTrailsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListTrailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTrailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTrailsOutputError: Swift.Error, Swift.Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTrailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTrailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trails = output.trails
        } else {
            self.nextToken = nil
            self.trails = nil
        }
    }
}

public struct ListTrailsOutputResponse: Swift.Equatable {
    /// The token to use to get the next page of results after a previous API call. If the token does not appear, there are no more results to return. The token must be passed in with the same parameters as the previous call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?
    /// Returns the name, ARN, and home region of trails in the current account.
    public var trails: [CloudTrailClientTypes.TrailInfo]?

    public init (
        nextToken: Swift.String? = nil,
        trails: [CloudTrailClientTypes.TrailInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.trails = trails
    }
}

struct ListTrailsOutputResponseBody: Swift.Equatable {
    let trails: [CloudTrailClientTypes.TrailInfo]?
    let nextToken: Swift.String?
}

extension ListTrailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case trails = "Trails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.TrailInfo?].self, forKey: .trails)
        var trailsDecoded0:[CloudTrailClientTypes.TrailInfo]? = nil
        if let trailsContainer = trailsContainer {
            trailsDecoded0 = [CloudTrailClientTypes.TrailInfo]()
            for structure0 in trailsContainer {
                if let structure0 = structure0 {
                    trailsDecoded0?.append(structure0)
                }
            }
        }
        trails = trailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudTrailClientTypes.LookupAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeKey = "AttributeKey"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeKey = self.attributeKey {
            try encodeContainer.encode(attributeKey.rawValue, forKey: .attributeKey)
        }
        if let attributeValue = self.attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeKeyDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.LookupAttributeKey.self, forKey: .attributeKey)
        attributeKey = attributeKeyDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension CloudTrailClientTypes {
    /// Specifies an attribute and value that filter the events returned.
    public struct LookupAttribute: Swift.Equatable {
        /// Specifies an attribute on which to filter the events returned.
        /// This member is required.
        public var attributeKey: CloudTrailClientTypes.LookupAttributeKey?
        /// Specifies a value for the specified AttributeKey.
        /// This member is required.
        public var attributeValue: Swift.String?

        public init (
            attributeKey: CloudTrailClientTypes.LookupAttributeKey? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributeKey = attributeKey
            self.attributeValue = attributeValue
        }
    }

}

extension CloudTrailClientTypes {
    public enum LookupAttributeKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessKeyId
        case eventId
        case eventName
        case eventSource
        case readOnly
        case resourceName
        case resourceType
        case username
        case sdkUnknown(Swift.String)

        public static var allCases: [LookupAttributeKey] {
            return [
                .accessKeyId,
                .eventId,
                .eventName,
                .eventSource,
                .readOnly,
                .resourceName,
                .resourceType,
                .username,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessKeyId: return "AccessKeyId"
            case .eventId: return "EventId"
            case .eventName: return "EventName"
            case .eventSource: return "EventSource"
            case .readOnly: return "ReadOnly"
            case .resourceName: return "ResourceName"
            case .resourceType: return "ResourceType"
            case .username: return "Username"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LookupAttributeKey(rawValue: rawValue) ?? LookupAttributeKey.sdkUnknown(rawValue)
        }
    }
}

extension LookupEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case eventCategory = "EventCategory"
        case lookupAttributes = "LookupAttributes"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let eventCategory = self.eventCategory {
            try encodeContainer.encode(eventCategory.rawValue, forKey: .eventCategory)
        }
        if let lookupAttributes = lookupAttributes {
            var lookupAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lookupAttributes)
            for lookupattribute0 in lookupAttributes {
                try lookupAttributesContainer.encode(lookupattribute0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension LookupEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains a request for LookupEvents.
public struct LookupEventsInput: Swift.Equatable {
    /// Specifies that only events that occur before or at the specified time are returned. If the specified end time is before the specified start time, an error is returned.
    public var endTime: ClientRuntime.Date?
    /// Specifies the event category. If you do not specify an event category, events of the category are not returned in the response. For example, if you do not specify insight as the value of EventCategory, no Insights events are returned.
    public var eventCategory: CloudTrailClientTypes.EventCategory?
    /// Contains a list of lookup attributes. Currently the list can contain only one item.
    public var lookupAttributes: [CloudTrailClientTypes.LookupAttribute]?
    /// The number of events to return. Possible values are 1 through 50. The default is 50.
    public var maxResults: Swift.Int?
    /// The token to use to get the next page of results after a previous API call. This token must be passed in with the same parameters that were specified in the original call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?
    /// Specifies that only events that occur after or at the specified time are returned. If the specified start time is after the specified end time, an error is returned.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        eventCategory: CloudTrailClientTypes.EventCategory? = nil,
        lookupAttributes: [CloudTrailClientTypes.LookupAttribute]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventCategory = eventCategory
        self.lookupAttributes = lookupAttributes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct LookupEventsInputBody: Swift.Equatable {
    let lookupAttributes: [CloudTrailClientTypes.LookupAttribute]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let eventCategory: CloudTrailClientTypes.EventCategory?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension LookupEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case eventCategory = "EventCategory"
        case lookupAttributes = "LookupAttributes"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lookupAttributesContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.LookupAttribute?].self, forKey: .lookupAttributes)
        var lookupAttributesDecoded0:[CloudTrailClientTypes.LookupAttribute]? = nil
        if let lookupAttributesContainer = lookupAttributesContainer {
            lookupAttributesDecoded0 = [CloudTrailClientTypes.LookupAttribute]()
            for structure0 in lookupAttributesContainer {
                if let structure0 = structure0 {
                    lookupAttributesDecoded0?.append(structure0)
                }
            }
        }
        lookupAttributes = lookupAttributesDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let eventCategoryDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventCategory.self, forKey: .eventCategory)
        eventCategory = eventCategoryDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LookupEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LookupEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEventCategory" : self = .invalidEventCategoryException(try InvalidEventCategoryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLookupAttributes" : self = .invalidLookupAttributesException(try InvalidLookupAttributesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResults" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTimeRange" : self = .invalidTimeRangeException(try InvalidTimeRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum LookupEventsOutputError: Swift.Error, Swift.Equatable {
    case invalidEventCategoryException(InvalidEventCategoryException)
    case invalidLookupAttributesException(InvalidLookupAttributesException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidTimeRangeException(InvalidTimeRangeException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension LookupEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LookupEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

/// Contains a response to a LookupEvents action.
public struct LookupEventsOutputResponse: Swift.Equatable {
    /// A list of events returned based on the lookup attributes specified and the CloudTrail event. The events list is sorted by time. The most recent event is listed first.
    public var events: [CloudTrailClientTypes.Event]?
    /// The token to use to get the next page of results after a previous API call. If the token does not appear, there are no more results to return. The token must be passed in with the same parameters as the previous call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?

    public init (
        events: [CloudTrailClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct LookupEventsOutputResponseBody: Swift.Equatable {
    let events: [CloudTrailClientTypes.Event]?
    let nextToken: Swift.String?
}

extension LookupEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[CloudTrailClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [CloudTrailClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MaxConcurrentQueriesException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaxConcurrentQueriesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are already running the maximum number of concurrent queries. Wait a minute for some queries to finish, and then run the query again.
public struct MaxConcurrentQueriesException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxConcurrentQueriesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxConcurrentQueriesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumNumberOfTrailsExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaximumNumberOfTrailsExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the maximum number of trails is reached.
public struct MaximumNumberOfTrailsExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumNumberOfTrailsExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumNumberOfTrailsExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoManagementAccountSLRExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoManagementAccountSLRExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the management account does not have a service-linked role.
public struct NoManagementAccountSLRExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoManagementAccountSLRExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoManagementAccountSLRExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotOrganizationManagementAccountException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotOrganizationManagementAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the account making the request is not the organization's management account.
public struct NotOrganizationManagementAccountException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotOrganizationManagementAccountExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotOrganizationManagementAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotOrganizationMasterAccountException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotOrganizationMasterAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail or event data store is not the management account for an organization in Organizations. For more information, see [Prepare For Creating a Trail For Your Organization](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html) or [Create an event data store](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-event-data-store.html).
public struct NotOrganizationMasterAccountException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotOrganizationMasterAccountExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotOrganizationMasterAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotPermittedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the requested operation is not permitted.
public struct OperationNotPermittedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNotInAllFeaturesModeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OrganizationNotInAllFeaturesModeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when Organizations is not configured to support all features. All features must be enabled in Organizations to support creating an organization trail or event data store.
public struct OrganizationNotInAllFeaturesModeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationNotInAllFeaturesModeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationNotInAllFeaturesModeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationsNotInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OrganizationsNotInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the request is made from an Amazon Web Services account that is not a member of an organization. To make this request, sign in using the credentials of an account that belongs to an organization.
public struct OrganizationsNotInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationsNotInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationsNotInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.PublicKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fingerprint = "Fingerprint"
        case validityEndTime = "ValidityEndTime"
        case validityStartTime = "ValidityStartTime"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fingerprint = self.fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
        if let validityEndTime = self.validityEndTime {
            try encodeContainer.encodeTimestamp(validityEndTime, format: .epochSeconds, forKey: .validityEndTime)
        }
        if let validityStartTime = self.validityStartTime {
            try encodeContainer.encodeTimestamp(validityStartTime, format: .epochSeconds, forKey: .validityStartTime)
        }
        if let value = self.value {
            try encodeContainer.encode(value.base64EncodedString(), forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .value)
        value = valueDecoded
        let validityStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .validityStartTime)
        validityStartTime = validityStartTimeDecoded
        let validityEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .validityEndTime)
        validityEndTime = validityEndTimeDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
    }
}

extension CloudTrailClientTypes {
    /// Contains information about a returned public key.
    public struct PublicKey: Swift.Equatable {
        /// The fingerprint of the public key.
        public var fingerprint: Swift.String?
        /// The ending time of validity of the public key.
        public var validityEndTime: ClientRuntime.Date?
        /// The starting time of validity of the public key.
        public var validityStartTime: ClientRuntime.Date?
        /// The DER encoded public key value in PKCS#1 format.
        public var value: ClientRuntime.Data?

        public init (
            fingerprint: Swift.String? = nil,
            validityEndTime: ClientRuntime.Date? = nil,
            validityStartTime: ClientRuntime.Date? = nil,
            value: ClientRuntime.Data? = nil
        )
        {
            self.fingerprint = fingerprint
            self.validityEndTime = validityEndTime
            self.validityStartTime = validityStartTime
            self.value = value
        }
    }

}

extension PutEventSelectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailName = "TrailName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedEventSelectors = advancedEventSelectors {
            var advancedEventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedEventSelectors)
            for advancedeventselector0 in advancedEventSelectors {
                try advancedEventSelectorsContainer.encode(advancedeventselector0)
            }
        }
        if let eventSelectors = eventSelectors {
            var eventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSelectors)
            for eventselector0 in eventSelectors {
                try eventSelectorsContainer.encode(eventselector0)
            }
        }
        if let trailName = self.trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

extension PutEventSelectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutEventSelectorsInput: Swift.Equatable {
    /// Specifies the settings for advanced event selectors. You can add advanced event selectors, and conditions for your advanced event selectors, up to a maximum of 500 values for all conditions and selectors on a trail. You can use either AdvancedEventSelectors or EventSelectors, but not both. If you apply AdvancedEventSelectors to a trail, any existing EventSelectors are overwritten. For more information about advanced event selectors, see [Logging data events for trails](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html) in the CloudTrail User Guide.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// Specifies the settings for your event selectors. You can configure up to five event selectors for a trail. You can use either EventSelectors or AdvancedEventSelectors in a PutEventSelectors request, but not both. If you apply EventSelectors to a trail, any existing AdvancedEventSelectors are overwritten.
    public var eventSelectors: [CloudTrailClientTypes.EventSelector]?
    /// Specifies the name of the trail or trail ARN. If you specify a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If you specify a trail ARN, it must be in the following format. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var trailName: Swift.String?

    public init (
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventSelectors: [CloudTrailClientTypes.EventSelector]? = nil,
        trailName: Swift.String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailName = trailName
    }
}

struct PutEventSelectorsInputBody: Swift.Equatable {
    let trailName: Swift.String?
    let eventSelectors: [CloudTrailClientTypes.EventSelector]?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
}

extension PutEventSelectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailName = "TrailName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailName)
        trailName = trailNameDecoded
        let eventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.EventSelector?].self, forKey: .eventSelectors)
        var eventSelectorsDecoded0:[CloudTrailClientTypes.EventSelector]? = nil
        if let eventSelectorsContainer = eventSelectorsContainer {
            eventSelectorsDecoded0 = [CloudTrailClientTypes.EventSelector]()
            for structure0 in eventSelectorsContainer {
                if let structure0 = structure0 {
                    eventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        eventSelectors = eventSelectorsDecoded0
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

extension PutEventSelectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEventSelectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventSelectors" : self = .invalidEventSelectorsException(try InvalidEventSelectorsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegion" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutEventSelectorsOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidEventSelectorsException(InvalidEventSelectorsException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidTrailNameException(InvalidTrailNameException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEventSelectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutEventSelectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.eventSelectors = output.eventSelectors
            self.trailARN = output.trailARN
        } else {
            self.advancedEventSelectors = nil
            self.eventSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct PutEventSelectorsOutputResponse: Swift.Equatable {
    /// Specifies the advanced event selectors configured for your trail.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// Specifies the event selectors configured for your trail.
    public var eventSelectors: [CloudTrailClientTypes.EventSelector]?
    /// Specifies the ARN of the trail that was updated with event selectors. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    public var trailARN: Swift.String?

    public init (
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventSelectors: [CloudTrailClientTypes.EventSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailARN = trailARN
    }
}

struct PutEventSelectorsOutputResponseBody: Swift.Equatable {
    let trailARN: Swift.String?
    let eventSelectors: [CloudTrailClientTypes.EventSelector]?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
}

extension PutEventSelectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let eventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.EventSelector?].self, forKey: .eventSelectors)
        var eventSelectorsDecoded0:[CloudTrailClientTypes.EventSelector]? = nil
        if let eventSelectorsContainer = eventSelectorsContainer {
            eventSelectorsDecoded0 = [CloudTrailClientTypes.EventSelector]()
            for structure0 in eventSelectorsContainer {
                if let structure0 = structure0 {
                    eventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        eventSelectors = eventSelectorsDecoded0
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

extension PutInsightSelectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailName = "TrailName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightSelectors = insightSelectors {
            var insightSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insightSelectors)
            for insightselector0 in insightSelectors {
                try insightSelectorsContainer.encode(insightselector0)
            }
        }
        if let trailName = self.trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

extension PutInsightSelectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutInsightSelectorsInput: Swift.Equatable {
    /// A JSON string that contains the insight types you want to log on a trail. ApiCallRateInsight and ApiErrorRateInsight are valid insight types.
    /// This member is required.
    public var insightSelectors: [CloudTrailClientTypes.InsightSelector]?
    /// The name of the CloudTrail trail for which you want to change or add Insights selectors.
    /// This member is required.
    public var trailName: Swift.String?

    public init (
        insightSelectors: [CloudTrailClientTypes.InsightSelector]? = nil,
        trailName: Swift.String? = nil
    )
    {
        self.insightSelectors = insightSelectors
        self.trailName = trailName
    }
}

struct PutInsightSelectorsInputBody: Swift.Equatable {
    let trailName: Swift.String?
    let insightSelectors: [CloudTrailClientTypes.InsightSelector]?
}

extension PutInsightSelectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailName = "TrailName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailName)
        trailName = trailNameDecoded
        let insightSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.InsightSelector?].self, forKey: .insightSelectors)
        var insightSelectorsDecoded0:[CloudTrailClientTypes.InsightSelector]? = nil
        if let insightSelectorsContainer = insightSelectorsContainer {
            insightSelectorsDecoded0 = [CloudTrailClientTypes.InsightSelector]()
            for structure0 in insightSelectorsContainer {
                if let structure0 = structure0 {
                    insightSelectorsDecoded0?.append(structure0)
                }
            }
        }
        insightSelectors = insightSelectorsDecoded0
    }
}

extension PutInsightSelectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutInsightSelectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientEncryptionPolicy" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientS3BucketPolicy" : self = .insufficientS3BucketPolicyException(try InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegion" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInsightSelectors" : self = .invalidInsightSelectorsException(try InvalidInsightSelectorsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3BucketDoesNotExist" : self = .s3BucketDoesNotExistException(try S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutInsightSelectorsOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case insufficientS3BucketPolicyException(InsufficientS3BucketPolicyException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidInsightSelectorsException(InvalidInsightSelectorsException)
    case invalidTrailNameException(InvalidTrailNameException)
    case kmsException(KmsException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case s3BucketDoesNotExistException(S3BucketDoesNotExistException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutInsightSelectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutInsightSelectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.insightSelectors = output.insightSelectors
            self.trailARN = output.trailARN
        } else {
            self.insightSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct PutInsightSelectorsOutputResponse: Swift.Equatable {
    /// A JSON string that contains the Insights event types that you want to log on a trail. The valid Insights types in this release are ApiErrorRateInsight and ApiCallRateInsight.
    public var insightSelectors: [CloudTrailClientTypes.InsightSelector]?
    /// The Amazon Resource Name (ARN) of a trail for which you want to change or add Insights selectors.
    public var trailARN: Swift.String?

    public init (
        insightSelectors: [CloudTrailClientTypes.InsightSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.insightSelectors = insightSelectors
        self.trailARN = trailARN
    }
}

struct PutInsightSelectorsOutputResponseBody: Swift.Equatable {
    let trailARN: Swift.String?
    let insightSelectors: [CloudTrailClientTypes.InsightSelector]?
}

extension PutInsightSelectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let insightSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.InsightSelector?].self, forKey: .insightSelectors)
        var insightSelectorsDecoded0:[CloudTrailClientTypes.InsightSelector]? = nil
        if let insightSelectorsContainer = insightSelectorsContainer {
            insightSelectorsDecoded0 = [CloudTrailClientTypes.InsightSelector]()
            for structure0 in insightSelectorsContainer {
                if let structure0 = structure0 {
                    insightSelectorsDecoded0?.append(structure0)
                }
            }
        }
        insightSelectors = insightSelectorsDecoded0
    }
}

extension CloudTrailClientTypes.Query: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case queryId = "QueryId"
        case queryStatus = "QueryStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
        if let queryStatus = self.queryStatus {
            try encodeContainer.encode(queryStatus.rawValue, forKey: .queryStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CloudTrailClientTypes {
    /// A SQL string of criteria about events that you want to collect in an event data store.
    public struct Query: Swift.Equatable {
        /// The creation time of a query.
        public var creationTime: ClientRuntime.Date?
        /// The ID of a query.
        public var queryId: Swift.String?
        /// The status of the query. This can be QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED.
        public var queryStatus: CloudTrailClientTypes.QueryStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            queryId: Swift.String? = nil,
            queryStatus: CloudTrailClientTypes.QueryStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.queryId = queryId
            self.queryStatus = queryStatus
        }
    }

}

extension QueryIdNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: QueryIdNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The query ID does not exist or does not map to a query.
public struct QueryIdNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct QueryIdNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension QueryIdNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.QueryStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesScanned = "BytesScanned"
        case resultsCount = "ResultsCount"
        case totalResultsCount = "TotalResultsCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesScanned = self.bytesScanned {
            try encodeContainer.encode(bytesScanned, forKey: .bytesScanned)
        }
        if let resultsCount = self.resultsCount {
            try encodeContainer.encode(resultsCount, forKey: .resultsCount)
        }
        if let totalResultsCount = self.totalResultsCount {
            try encodeContainer.encode(totalResultsCount, forKey: .totalResultsCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resultsCount)
        resultsCount = resultsCountDecoded
        let totalResultsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResultsCount)
        totalResultsCount = totalResultsCountDecoded
        let bytesScannedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesScanned)
        bytesScanned = bytesScannedDecoded
    }
}

extension CloudTrailClientTypes {
    /// Metadata about a query, such as the number of results.
    public struct QueryStatistics: Swift.Equatable {
        /// The total bytes that the query scanned in the event data store. This value matches the number of bytes for which your account is billed for the query, unless the query is still running.
        public var bytesScanned: Swift.Int?
        /// The number of results returned.
        public var resultsCount: Swift.Int?
        /// The total number of results returned by a query.
        public var totalResultsCount: Swift.Int?

        public init (
            bytesScanned: Swift.Int? = nil,
            resultsCount: Swift.Int? = nil,
            totalResultsCount: Swift.Int? = nil
        )
        {
            self.bytesScanned = bytesScanned
            self.resultsCount = resultsCount
            self.totalResultsCount = totalResultsCount
        }
    }

}

extension CloudTrailClientTypes.QueryStatisticsForDescribeQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesScanned = "BytesScanned"
        case creationTime = "CreationTime"
        case eventsMatched = "EventsMatched"
        case eventsScanned = "EventsScanned"
        case executionTimeInMillis = "ExecutionTimeInMillis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesScanned = self.bytesScanned {
            try encodeContainer.encode(bytesScanned, forKey: .bytesScanned)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let eventsMatched = self.eventsMatched {
            try encodeContainer.encode(eventsMatched, forKey: .eventsMatched)
        }
        if let eventsScanned = self.eventsScanned {
            try encodeContainer.encode(eventsScanned, forKey: .eventsScanned)
        }
        if let executionTimeInMillis = self.executionTimeInMillis {
            try encodeContainer.encode(executionTimeInMillis, forKey: .executionTimeInMillis)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsMatchedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventsMatched)
        eventsMatched = eventsMatchedDecoded
        let eventsScannedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventsScanned)
        eventsScanned = eventsScannedDecoded
        let bytesScannedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesScanned)
        bytesScanned = bytesScannedDecoded
        let executionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTimeInMillis)
        executionTimeInMillis = executionTimeInMillisDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CloudTrailClientTypes {
    /// Gets metadata about a query, including the number of events that were matched, the total number of events scanned, the query run time in milliseconds, and the query's creation time.
    public struct QueryStatisticsForDescribeQuery: Swift.Equatable {
        /// The total bytes that the query scanned in the event data store. This value matches the number of bytes for which your account is billed for the query, unless the query is still running.
        public var bytesScanned: Swift.Int?
        /// The creation time of the query.
        public var creationTime: ClientRuntime.Date?
        /// The number of events that matched a query.
        public var eventsMatched: Swift.Int?
        /// The number of events that the query scanned in the event data store.
        public var eventsScanned: Swift.Int?
        /// The query's run time, in milliseconds.
        public var executionTimeInMillis: Swift.Int?

        public init (
            bytesScanned: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            eventsMatched: Swift.Int? = nil,
            eventsScanned: Swift.Int? = nil,
            executionTimeInMillis: Swift.Int? = nil
        )
        {
            self.bytesScanned = bytesScanned
            self.creationTime = creationTime
            self.eventsMatched = eventsMatched
            self.eventsScanned = eventsScanned
            self.executionTimeInMillis = executionTimeInMillis
        }
    }

}

extension CloudTrailClientTypes {
    public enum QueryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case finished
        case queued
        case running
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryStatus] {
            return [
                .cancelled,
                .failed,
                .finished,
                .queued,
                .running,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryStatus(rawValue: rawValue) ?? QueryStatus.sdkUnknown(rawValue)
        }
    }
}

extension CloudTrailClientTypes {
    public enum ReadWriteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case readonly
        case writeonly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadWriteType] {
            return [
                .all,
                .readonly,
                .writeonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .readonly: return "ReadOnly"
            case .writeonly: return "WriteOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadWriteType(rawValue: rawValue) ?? ReadWriteType.sdkUnknown(rawValue)
        }
    }
}

extension RegisterOrganizationDelegatedAdminInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId = "MemberAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = self.memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
    }
}

extension RegisterOrganizationDelegatedAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies an organization member account ID as a CloudTrail delegated administrator.
public struct RegisterOrganizationDelegatedAdminInput: Swift.Equatable {
    /// An organization member account ID that you want to designate as a delegated administrator.
    /// This member is required.
    public var memberAccountId: Swift.String?

    public init (
        memberAccountId: Swift.String? = nil
    )
    {
        self.memberAccountId = memberAccountId
    }
}

struct RegisterOrganizationDelegatedAdminInputBody: Swift.Equatable {
    let memberAccountId: Swift.String?
}

extension RegisterOrganizationDelegatedAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId = "MemberAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
    }
}

extension RegisterOrganizationDelegatedAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterOrganizationDelegatedAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountNotFound" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountRegistered" : self = .accountRegisteredException(try AccountRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotDelegateManagementAccount" : self = .cannotDelegateManagementAccountException(try CannotDelegateManagementAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudTrailAccessNotEnabled" : self = .cloudTrailAccessNotEnabledException(try CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DelegatedAdminAccountLimitExceeded" : self = .delegatedAdminAccountLimitExceededException(try DelegatedAdminAccountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationManagementAccount" : self = .notOrganizationManagementAccountException(try NotOrganizationManagementAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesMode" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationsNotInUse" : self = .organizationsNotInUseException(try OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterOrganizationDelegatedAdminOutputError: Swift.Error, Swift.Equatable {
    case accountNotFoundException(AccountNotFoundException)
    case accountRegisteredException(AccountRegisteredException)
    case cannotDelegateManagementAccountException(CannotDelegateManagementAccountException)
    case cloudTrailAccessNotEnabledException(CloudTrailAccessNotEnabledException)
    case delegatedAdminAccountLimitExceededException(DelegatedAdminAccountLimitExceededException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidParameterException(InvalidParameterException)
    case notOrganizationManagementAccountException(NotOrganizationManagementAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case organizationsNotInUseException(OrganizationsNotInUseException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterOrganizationDelegatedAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Returns the following response if successful. Otherwise, returns an error.
public struct RegisterOrganizationDelegatedAdminOutputResponse: Swift.Equatable {

    public init () { }
}

extension RemoveTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tag0 in tagsList {
                try tagsListContainer.encode(tag0)
            }
        }
    }
}

extension RemoveTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies the tags to remove from a trail or event data store.
public struct RemoveTagsInput: Swift.Equatable {
    /// Specifies the ARN of the trail or event data store from which tags should be removed. Example trail ARN format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail Example event data store ARN format: arn:aws:cloudtrail:us-east-2:12345678910:eventdatastore/EXAMPLE-f852-4e8f-8bd1-bcf6cEXAMPLE
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specifies a list of tags to be removed.
    /// This member is required.
    public var tagsList: [CloudTrailClientTypes.Tag]?

    public init (
        resourceId: Swift.String? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagsList = tagsList
    }
}

struct RemoveTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagsList: [CloudTrailClientTypes.Tag]?
}

extension RemoveTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension RemoveTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InactiveEventDataStore" : self = .inactiveEventDataStoreException(try InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameter" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceTypeNotSupported" : self = .resourceTypeNotSupportedException(try ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveTagsOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case inactiveEventDataStoreException(InactiveEventDataStoreException)
    case invalidTagParameterException(InvalidTagParameterException)
    case invalidTrailNameException(InvalidTrailNameException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceTypeNotSupportedException(ResourceTypeNotSupportedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct RemoveTagsOutputResponse: Swift.Equatable {

    public init () { }
}

extension CloudTrailClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CloudTrailClientTypes {
    /// Specifies the type and name of a resource referenced by an event.
    public struct Resource: Swift.Equatable {
        /// The name of the resource referenced by the event returned. These are user-created names whose values will depend on the environment. For example, the resource name might be "auto-scaling-test-group" for an Auto Scaling Group or "i-1234567" for an EC2 Instance.
        public var resourceName: Swift.String?
        /// The type of a resource referenced by the event returned. When the resource type cannot be determined, null is returned. Some examples of resource types are: Instance for EC2, Trail for CloudTrail, DBInstance for Amazon RDS, and AccessKey for IAM. To learn more about how to look up and filter events by the resource types supported for a service, see [Filtering CloudTrail Events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/view-cloudtrail-events-console.html#filtering-cloudtrail-events).
        public var resourceType: Swift.String?

        public init (
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified resource is not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.ResourceTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tag0 in tagsList {
                try tagsListContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension CloudTrailClientTypes {
    /// A resource tag.
    public struct ResourceTag: Swift.Equatable {
        /// Specifies the ARN of the resource.
        public var resourceId: Swift.String?
        /// A list of tags.
        public var tagsList: [CloudTrailClientTypes.Tag]?

        public init (
            resourceId: Swift.String? = nil,
            tagsList: [CloudTrailClientTypes.Tag]? = nil
        )
        {
            self.resourceId = resourceId
            self.tagsList = tagsList
        }
    }

}

extension ResourceTypeNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceTypeNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified resource type is not supported by CloudTrail.
public struct ResourceTypeNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceTypeNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceTypeNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestoreEventDataStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
    }
}

extension RestoreEventDataStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreEventDataStoreInput: Swift.Equatable {
    /// The ARN (or the ID suffix of the ARN) of the event data store that you want to restore.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init (
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

struct RestoreEventDataStoreInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
}

extension RestoreEventDataStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
    }
}

extension RestoreEventDataStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreEventDataStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailAccessNotEnabled" : self = .cloudTrailAccessNotEnabledException(try CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreARNInvalid" : self = .eventDataStoreARNInvalidException(try EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreMaxLimitExceeded" : self = .eventDataStoreMaxLimitExceededException(try EventDataStoreMaxLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventDataStoreStatus" : self = .invalidEventDataStoreStatusException(try InvalidEventDataStoreStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesMode" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationsNotInUse" : self = .organizationsNotInUseException(try OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RestoreEventDataStoreOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailAccessNotEnabledException(CloudTrailAccessNotEnabledException)
    case eventDataStoreARNInvalidException(EventDataStoreARNInvalidException)
    case eventDataStoreMaxLimitExceededException(EventDataStoreMaxLimitExceededException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidEventDataStoreStatusException(InvalidEventDataStoreStatusException)
    case invalidParameterException(InvalidParameterException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case organizationsNotInUseException(OrganizationsNotInUseException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreEventDataStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RestoreEventDataStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.createdTimestamp = output.createdTimestamp
            self.eventDataStoreArn = output.eventDataStoreArn
            self.kmsKeyId = output.kmsKeyId
            self.multiRegionEnabled = output.multiRegionEnabled
            self.name = output.name
            self.organizationEnabled = output.organizationEnabled
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
            self.terminationProtectionEnabled = output.terminationProtectionEnabled
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.advancedEventSelectors = nil
            self.createdTimestamp = nil
            self.eventDataStoreArn = nil
            self.kmsKeyId = nil
            self.multiRegionEnabled = nil
            self.name = nil
            self.organizationEnabled = nil
            self.retentionPeriod = nil
            self.status = nil
            self.terminationProtectionEnabled = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct RestoreEventDataStoreOutputResponse: Swift.Equatable {
    /// The advanced event selectors that were used to select events.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The timestamp of an event data store's creation.
    public var createdTimestamp: ClientRuntime.Date?
    /// The event data store ARN.
    public var eventDataStoreArn: Swift.String?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Indicates whether the event data store is collecting events from all regions, or only from the region in which the event data store was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    public var name: Swift.String?
    /// Indicates whether an event data store is collecting logged events for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period, in days.
    public var retentionPeriod: Swift.Int?
    /// The status of the event data store.
    public var status: CloudTrailClientTypes.EventDataStoreStatus?
    /// Indicates that termination protection is enabled and the event data store cannot be automatically deleted.
    public var terminationProtectionEnabled: Swift.Bool?
    /// The timestamp that shows when an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
    public var updatedTimestamp: ClientRuntime.Date?

    public init (
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        eventDataStoreArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.createdTimestamp = createdTimestamp
        self.eventDataStoreArn = eventDataStoreArn
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.terminationProtectionEnabled = terminationProtectionEnabled
        self.updatedTimestamp = updatedTimestamp
    }
}

struct RestoreEventDataStoreOutputResponseBody: Swift.Equatable {
    let eventDataStoreArn: Swift.String?
    let name: Swift.String?
    let status: CloudTrailClientTypes.EventDataStoreStatus?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    let multiRegionEnabled: Swift.Bool?
    let organizationEnabled: Swift.Bool?
    let retentionPeriod: Swift.Int?
    let terminationProtectionEnabled: Swift.Bool?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
    let kmsKeyId: Swift.String?
}

extension RestoreEventDataStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case createdTimestamp = "CreatedTimestamp"
        case eventDataStoreArn = "EventDataStoreArn"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStoreArn)
        eventDataStoreArn = eventDataStoreArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventDataStoreStatus.self, forKey: .status)
        status = statusDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension S3BucketDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: S3BucketDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified S3 bucket does not exist.
public struct S3BucketDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct S3BucketDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension S3BucketDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.S3ImportSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketAccessRoleArn = "S3BucketAccessRoleArn"
        case s3BucketRegion = "S3BucketRegion"
        case s3LocationUri = "S3LocationUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketAccessRoleArn = self.s3BucketAccessRoleArn {
            try encodeContainer.encode(s3BucketAccessRoleArn, forKey: .s3BucketAccessRoleArn)
        }
        if let s3BucketRegion = self.s3BucketRegion {
            try encodeContainer.encode(s3BucketRegion, forKey: .s3BucketRegion)
        }
        if let s3LocationUri = self.s3LocationUri {
            try encodeContainer.encode(s3LocationUri, forKey: .s3LocationUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3LocationUri)
        s3LocationUri = s3LocationUriDecoded
        let s3BucketRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketRegion)
        s3BucketRegion = s3BucketRegionDecoded
        let s3BucketAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketAccessRoleArn)
        s3BucketAccessRoleArn = s3BucketAccessRoleArnDecoded
    }
}

extension CloudTrailClientTypes {
    /// The settings for the source S3 bucket.
    public struct S3ImportSource: Swift.Equatable {
        /// The IAM ARN role used to access the source S3 bucket.
        /// This member is required.
        public var s3BucketAccessRoleArn: Swift.String?
        /// The region associated with the source S3 bucket.
        /// This member is required.
        public var s3BucketRegion: Swift.String?
        /// The URI for the source S3 bucket.
        /// This member is required.
        public var s3LocationUri: Swift.String?

        public init (
            s3BucketAccessRoleArn: Swift.String? = nil,
            s3BucketRegion: Swift.String? = nil,
            s3LocationUri: Swift.String? = nil
        )
        {
            self.s3BucketAccessRoleArn = s3BucketAccessRoleArn
            self.s3BucketRegion = s3BucketRegion
            self.s3LocationUri = s3LocationUri
        }
    }

}

extension CloudTrailClientTypes.SourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case applyToAllRegions = "ApplyToAllRegions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedEventSelectors = advancedEventSelectors {
            var advancedEventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedEventSelectors)
            for advancedeventselector0 in advancedEventSelectors {
                try advancedEventSelectorsContainer.encode(advancedeventselector0)
            }
        }
        if let applyToAllRegions = self.applyToAllRegions {
            try encodeContainer.encode(applyToAllRegions, forKey: .applyToAllRegions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applyToAllRegionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyToAllRegions)
        applyToAllRegions = applyToAllRegionsDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

extension CloudTrailClientTypes {
    /// Contains configuration information about the channel.
    public struct SourceConfig: Swift.Equatable {
        /// The advanced event selectors that are configured for the channel.
        public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
        /// Specifies whether the channel applies to a single region or to all regions.
        public var applyToAllRegions: Swift.Bool?

        public init (
            advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
            applyToAllRegions: Swift.Bool? = nil
        )
        {
            self.advancedEventSelectors = advancedEventSelectors
            self.applyToAllRegions = applyToAllRegions
        }
    }

}

extension StartImportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "Destinations"
        case endEventTime = "EndEventTime"
        case importId = "ImportId"
        case importSource = "ImportSource"
        case startEventTime = "StartEventTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for eventdatastorearn0 in destinations {
                try destinationsContainer.encode(eventdatastorearn0)
            }
        }
        if let endEventTime = self.endEventTime {
            try encodeContainer.encodeTimestamp(endEventTime, format: .epochSeconds, forKey: .endEventTime)
        }
        if let importId = self.importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
        if let importSource = self.importSource {
            try encodeContainer.encode(importSource, forKey: .importSource)
        }
        if let startEventTime = self.startEventTime {
            try encodeContainer.encodeTimestamp(startEventTime, format: .epochSeconds, forKey: .startEventTime)
        }
    }
}

extension StartImportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartImportInput: Swift.Equatable {
    /// The ARN of the destination event data store. Use this parameter for a new import.
    public var destinations: [Swift.String]?
    /// Use with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period. When you specify a time range, CloudTrail checks the prefix and log file names to verify the names contain a date between the specified StartEventTime and EndEventTime before attempting to import events.
    public var endEventTime: ClientRuntime.Date?
    /// The ID of the import. Use this parameter when you are retrying an import.
    public var importId: Swift.String?
    /// The source S3 bucket for the import. Use this parameter for a new import.
    public var importSource: CloudTrailClientTypes.ImportSource?
    /// Use with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period. When you specify a time range, CloudTrail checks the prefix and log file names to verify the names contain a date between the specified StartEventTime and EndEventTime before attempting to import events.
    public var startEventTime: ClientRuntime.Date?

    public init (
        destinations: [Swift.String]? = nil,
        endEventTime: ClientRuntime.Date? = nil,
        importId: Swift.String? = nil,
        importSource: CloudTrailClientTypes.ImportSource? = nil,
        startEventTime: ClientRuntime.Date? = nil
    )
    {
        self.destinations = destinations
        self.endEventTime = endEventTime
        self.importId = importId
        self.importSource = importSource
        self.startEventTime = startEventTime
    }
}

struct StartImportInputBody: Swift.Equatable {
    let destinations: [Swift.String]?
    let importSource: CloudTrailClientTypes.ImportSource?
    let startEventTime: ClientRuntime.Date?
    let endEventTime: ClientRuntime.Date?
    let importId: Swift.String?
}

extension StartImportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "Destinations"
        case endEventTime = "EndEventTime"
        case importId = "ImportId"
        case importSource = "ImportSource"
        case startEventTime = "StartEventTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinations)
        var destinationsDecoded0:[Swift.String]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [Swift.String]()
            for string0 in destinationsContainer {
                if let string0 = string0 {
                    destinationsDecoded0?.append(string0)
                }
            }
        }
        destinations = destinationsDecoded0
        let importSourceDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportSource.self, forKey: .importSource)
        importSource = importSourceDecoded
        let startEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startEventTime)
        startEventTime = startEventTimeDecoded
        let endEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endEventTime)
        endEventTime = endEventTimeDecoded
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
    }
}

extension StartImportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountHasOngoingImport" : self = .accountHasOngoingImportException(try AccountHasOngoingImportException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreARNInvalid" : self = .eventDataStoreARNInvalidException(try EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ImportNotFound" : self = .importNotFoundException(try ImportNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InactiveEventDataStore" : self = .inactiveEventDataStoreException(try InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventDataStoreCategory" : self = .invalidEventDataStoreCategoryException(try InvalidEventDataStoreCategoryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventDataStoreStatus" : self = .invalidEventDataStoreStatusException(try InvalidEventDataStoreStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidImportSource" : self = .invalidImportSourceException(try InvalidImportSourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartImportOutputError: Swift.Error, Swift.Equatable {
    case accountHasOngoingImportException(AccountHasOngoingImportException)
    case eventDataStoreARNInvalidException(EventDataStoreARNInvalidException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case importNotFoundException(ImportNotFoundException)
    case inactiveEventDataStoreException(InactiveEventDataStoreException)
    case invalidEventDataStoreCategoryException(InvalidEventDataStoreCategoryException)
    case invalidEventDataStoreStatusException(InvalidEventDataStoreStatusException)
    case invalidImportSourceException(InvalidImportSourceException)
    case invalidParameterException(InvalidParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartImportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.destinations = output.destinations
            self.endEventTime = output.endEventTime
            self.importId = output.importId
            self.importSource = output.importSource
            self.importStatus = output.importStatus
            self.startEventTime = output.startEventTime
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.createdTimestamp = nil
            self.destinations = nil
            self.endEventTime = nil
            self.importId = nil
            self.importSource = nil
            self.importStatus = nil
            self.startEventTime = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct StartImportOutputResponse: Swift.Equatable {
    /// The timestamp for the import's creation.
    public var createdTimestamp: ClientRuntime.Date?
    /// The ARN of the destination event data store.
    public var destinations: [Swift.String]?
    /// Used with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var endEventTime: ClientRuntime.Date?
    /// The ID of the import.
    public var importId: Swift.String?
    /// The source S3 bucket for the import.
    public var importSource: CloudTrailClientTypes.ImportSource?
    /// Shows the status of the import after a StartImport request. An import finishes with a status of COMPLETED if there were no failures, or FAILED if there were failures.
    public var importStatus: CloudTrailClientTypes.ImportStatus?
    /// Used with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var startEventTime: ClientRuntime.Date?
    /// The timestamp of the import's last update, if applicable.
    public var updatedTimestamp: ClientRuntime.Date?

    public init (
        createdTimestamp: ClientRuntime.Date? = nil,
        destinations: [Swift.String]? = nil,
        endEventTime: ClientRuntime.Date? = nil,
        importId: Swift.String? = nil,
        importSource: CloudTrailClientTypes.ImportSource? = nil,
        importStatus: CloudTrailClientTypes.ImportStatus? = nil,
        startEventTime: ClientRuntime.Date? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinations = destinations
        self.endEventTime = endEventTime
        self.importId = importId
        self.importSource = importSource
        self.importStatus = importStatus
        self.startEventTime = startEventTime
        self.updatedTimestamp = updatedTimestamp
    }
}

struct StartImportOutputResponseBody: Swift.Equatable {
    let importId: Swift.String?
    let destinations: [Swift.String]?
    let importSource: CloudTrailClientTypes.ImportSource?
    let startEventTime: ClientRuntime.Date?
    let endEventTime: ClientRuntime.Date?
    let importStatus: CloudTrailClientTypes.ImportStatus?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
}

extension StartImportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case destinations = "Destinations"
        case endEventTime = "EndEventTime"
        case importId = "ImportId"
        case importSource = "ImportSource"
        case importStatus = "ImportStatus"
        case startEventTime = "StartEventTime"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinations)
        var destinationsDecoded0:[Swift.String]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [Swift.String]()
            for string0 in destinationsContainer {
                if let string0 = string0 {
                    destinationsDecoded0?.append(string0)
                }
            }
        }
        destinations = destinationsDecoded0
        let importSourceDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportSource.self, forKey: .importSource)
        importSource = importSourceDecoded
        let startEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startEventTime)
        startEventTime = startEventTimeDecoded
        let endEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endEventTime)
        endEventTime = endEventTimeDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension StartLoggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StartLoggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The request to CloudTrail to start logging Amazon Web Services API calls for an account.
public struct StartLoggingInput: Swift.Equatable {
    /// Specifies the name or the CloudTrail ARN of the trail for which CloudTrail logs Amazon Web Services API calls. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StartLoggingInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StartLoggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartLoggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartLoggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegion" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartLoggingOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidTrailNameException(InvalidTrailNameException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartLoggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct StartLoggingOutputResponse: Swift.Equatable {

    public init () { }
}

extension StartQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryS3Uri = "DeliveryS3Uri"
        case queryStatement = "QueryStatement"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryS3Uri = self.deliveryS3Uri {
            try encodeContainer.encode(deliveryS3Uri, forKey: .deliveryS3Uri)
        }
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
    }
}

extension StartQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartQueryInput: Swift.Equatable {
    /// The URI for the S3 bucket where CloudTrail delivers the query results.
    public var deliveryS3Uri: Swift.String?
    /// The SQL code of your query.
    /// This member is required.
    public var queryStatement: Swift.String?

    public init (
        deliveryS3Uri: Swift.String? = nil,
        queryStatement: Swift.String? = nil
    )
    {
        self.deliveryS3Uri = deliveryS3Uri
        self.queryStatement = queryStatement
    }
}

struct StartQueryInputBody: Swift.Equatable {
    let queryStatement: Swift.String?
    let deliveryS3Uri: Swift.String?
}

extension StartQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryS3Uri = "DeliveryS3Uri"
        case queryStatement = "QueryStatement"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let deliveryS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryS3Uri)
        deliveryS3Uri = deliveryS3UriDecoded
    }
}

extension StartQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventDataStoreARNInvalid" : self = .eventDataStoreARNInvalidException(try EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InactiveEventDataStore" : self = .inactiveEventDataStoreException(try InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientEncryptionPolicy" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientS3BucketPolicy" : self = .insufficientS3BucketPolicyException(try InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStatement" : self = .invalidQueryStatementException(try InvalidQueryStatementException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketName" : self = .invalidS3BucketNameException(try InvalidS3BucketNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3Prefix" : self = .invalidS3PrefixException(try InvalidS3PrefixException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxConcurrentQueries" : self = .maxConcurrentQueriesException(try MaxConcurrentQueriesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3BucketDoesNotExist" : self = .s3BucketDoesNotExistException(try S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartQueryOutputError: Swift.Error, Swift.Equatable {
    case eventDataStoreARNInvalidException(EventDataStoreARNInvalidException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case inactiveEventDataStoreException(InactiveEventDataStoreException)
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case insufficientS3BucketPolicyException(InsufficientS3BucketPolicyException)
    case invalidParameterException(InvalidParameterException)
    case invalidQueryStatementException(InvalidQueryStatementException)
    case invalidS3BucketNameException(InvalidS3BucketNameException)
    case invalidS3PrefixException(InvalidS3PrefixException)
    case maxConcurrentQueriesException(MaxConcurrentQueriesException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case operationNotPermittedException(OperationNotPermittedException)
    case s3BucketDoesNotExistException(S3BucketDoesNotExistException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryId = output.queryId
        } else {
            self.queryId = nil
        }
    }
}

public struct StartQueryOutputResponse: Swift.Equatable {
    /// The ID of the started query.
    public var queryId: Swift.String?

    public init (
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

struct StartQueryOutputResponseBody: Swift.Equatable {
    let queryId: Swift.String?
}

extension StartQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
    }
}

extension StopImportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId = "ImportId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importId = self.importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
    }
}

extension StopImportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopImportInput: Swift.Equatable {
    /// The ID of the import.
    /// This member is required.
    public var importId: Swift.String?

    public init (
        importId: Swift.String? = nil
    )
    {
        self.importId = importId
    }
}

struct StopImportInputBody: Swift.Equatable {
    let importId: Swift.String?
}

extension StopImportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId = "ImportId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
    }
}

extension StopImportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopImportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ImportNotFound" : self = .importNotFoundException(try ImportNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopImportOutputError: Swift.Error, Swift.Equatable {
    case importNotFoundException(ImportNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopImportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopImportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.destinations = output.destinations
            self.endEventTime = output.endEventTime
            self.importId = output.importId
            self.importSource = output.importSource
            self.importStatistics = output.importStatistics
            self.importStatus = output.importStatus
            self.startEventTime = output.startEventTime
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.createdTimestamp = nil
            self.destinations = nil
            self.endEventTime = nil
            self.importId = nil
            self.importSource = nil
            self.importStatistics = nil
            self.importStatus = nil
            self.startEventTime = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct StopImportOutputResponse: Swift.Equatable {
    /// The timestamp of the import's creation.
    public var createdTimestamp: ClientRuntime.Date?
    /// The ARN of the destination event data store.
    public var destinations: [Swift.String]?
    /// Used with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var endEventTime: ClientRuntime.Date?
    /// The ID for the import.
    public var importId: Swift.String?
    /// The source S3 bucket for the import.
    public var importSource: CloudTrailClientTypes.ImportSource?
    /// Returns information on the stopped import.
    public var importStatistics: CloudTrailClientTypes.ImportStatistics?
    /// The status of the import.
    public var importStatus: CloudTrailClientTypes.ImportStatus?
    /// Used with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var startEventTime: ClientRuntime.Date?
    /// The timestamp of the import's last update.
    public var updatedTimestamp: ClientRuntime.Date?

    public init (
        createdTimestamp: ClientRuntime.Date? = nil,
        destinations: [Swift.String]? = nil,
        endEventTime: ClientRuntime.Date? = nil,
        importId: Swift.String? = nil,
        importSource: CloudTrailClientTypes.ImportSource? = nil,
        importStatistics: CloudTrailClientTypes.ImportStatistics? = nil,
        importStatus: CloudTrailClientTypes.ImportStatus? = nil,
        startEventTime: ClientRuntime.Date? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinations = destinations
        self.endEventTime = endEventTime
        self.importId = importId
        self.importSource = importSource
        self.importStatistics = importStatistics
        self.importStatus = importStatus
        self.startEventTime = startEventTime
        self.updatedTimestamp = updatedTimestamp
    }
}

struct StopImportOutputResponseBody: Swift.Equatable {
    let importId: Swift.String?
    let importSource: CloudTrailClientTypes.ImportSource?
    let destinations: [Swift.String]?
    let importStatus: CloudTrailClientTypes.ImportStatus?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
    let startEventTime: ClientRuntime.Date?
    let endEventTime: ClientRuntime.Date?
    let importStatistics: CloudTrailClientTypes.ImportStatistics?
}

extension StopImportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case destinations = "Destinations"
        case endEventTime = "EndEventTime"
        case importId = "ImportId"
        case importSource = "ImportSource"
        case importStatistics = "ImportStatistics"
        case importStatus = "ImportStatus"
        case startEventTime = "StartEventTime"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let importSourceDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportSource.self, forKey: .importSource)
        importSource = importSourceDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinations)
        var destinationsDecoded0:[Swift.String]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [Swift.String]()
            for string0 in destinationsContainer {
                if let string0 = string0 {
                    destinationsDecoded0?.append(string0)
                }
            }
        }
        destinations = destinationsDecoded0
        let importStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let startEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startEventTime)
        startEventTime = startEventTimeDecoded
        let endEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endEventTime)
        endEventTime = endEventTimeDecoded
        let importStatisticsDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatistics.self, forKey: .importStatistics)
        importStatistics = importStatisticsDecoded
    }
}

extension StopLoggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StopLoggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Passes the request to CloudTrail to stop logging Amazon Web Services API calls for the specified account.
public struct StopLoggingInput: Swift.Equatable {
    /// Specifies the name or the CloudTrail ARN of the trail for which CloudTrail will stop logging Amazon Web Services API calls. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StopLoggingInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StopLoggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopLoggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopLoggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegion" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopLoggingOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidTrailNameException(InvalidTrailNameException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopLoggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct StopLoggingOutputResponse: Swift.Equatable {

    public init () { }
}

extension CloudTrailClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudTrailClientTypes {
    /// A custom key-value pair associated with a resource such as a CloudTrail trail.
    public struct Tag: Swift.Equatable {
        /// The key in a key-value pair. The key must be must be no longer than 128 Unicode characters. The key must be unique for the resource to which it applies.
        /// This member is required.
        public var key: Swift.String?
        /// The value in a key-value pair of a tag. The value must be no longer than 256 Unicode characters.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagsLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagsLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of tags per trail has exceeded the permitted amount. Currently, the limit is 50.
public struct TagsLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagsLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagsLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.Trail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case hasCustomEventSelectors = "HasCustomEventSelectors"
        case hasInsightSelectors = "HasInsightSelectors"
        case homeRegion = "HomeRegion"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicARN = "SnsTopicARN"
        case snsTopicName = "SnsTopicName"
        case trailARN = "TrailARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = self.cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = self.cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let hasCustomEventSelectors = self.hasCustomEventSelectors {
            try encodeContainer.encode(hasCustomEventSelectors, forKey: .hasCustomEventSelectors)
        }
        if let hasInsightSelectors = self.hasInsightSelectors {
            try encodeContainer.encode(hasInsightSelectors, forKey: .hasInsightSelectors)
        }
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let includeGlobalServiceEvents = self.includeGlobalServiceEvents {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if let isMultiRegionTrail = self.isMultiRegionTrail {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if let isOrganizationTrail = self.isOrganizationTrail {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let logFileValidationEnabled = self.logFileValidationEnabled {
            try encodeContainer.encode(logFileValidationEnabled, forKey: .logFileValidationEnabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicARN = self.snsTopicARN {
            try encodeContainer.encode(snsTopicARN, forKey: .snsTopicARN)
        }
        if let snsTopicName = self.snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
        if let trailARN = self.trailARN {
            try encodeContainer.encode(trailARN, forKey: .trailARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let hasCustomEventSelectorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasCustomEventSelectors)
        hasCustomEventSelectors = hasCustomEventSelectorsDecoded
        let hasInsightSelectorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasInsightSelectors)
        hasInsightSelectors = hasInsightSelectorsDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

extension CloudTrailClientTypes {
    /// The settings for a trail.
    public struct Trail: Swift.Equatable {
        /// Specifies an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
        public var cloudWatchLogsRoleArn: Swift.String?
        /// Specifies if the trail has custom event selectors.
        public var hasCustomEventSelectors: Swift.Bool?
        /// Specifies whether a trail has insight types specified in an InsightSelector list.
        public var hasInsightSelectors: Swift.Bool?
        /// The region in which the trail was created.
        public var homeRegion: Swift.String?
        /// Set to True to include Amazon Web Services API calls from Amazon Web Services global services such as IAM. Otherwise, False.
        public var includeGlobalServiceEvents: Swift.Bool?
        /// Specifies whether the trail exists only in one region or exists in all regions.
        public var isMultiRegionTrail: Swift.Bool?
        /// Specifies whether the trail is an organization trail.
        public var isOrganizationTrail: Swift.Bool?
        /// Specifies the KMS key ID that encrypts the logs delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
        public var kmsKeyId: Swift.String?
        /// Specifies whether log file validation is enabled.
        public var logFileValidationEnabled: Swift.Bool?
        /// Name of the trail set by calling [CreateTrail]. The maximum length is 128 characters.
        public var name: Swift.String?
        /// Name of the Amazon S3 bucket into which CloudTrail delivers your trail files. See [Amazon S3 Bucket Naming Requirements](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create_trail_naming_policy.html).
        public var s3BucketName: Swift.String?
        /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html). The maximum length is 200 characters.
        public var s3KeyPrefix: Swift.String?
        /// Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The following is the format of a topic ARN. arn:aws:sns:us-east-2:123456789012:MyTopic
        public var snsTopicARN: Swift.String?
        /// This field is no longer in use. Use SnsTopicARN.
        @available(*, deprecated)
        public var snsTopicName: Swift.String?
        /// Specifies the ARN of the trail. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
        public var trailARN: Swift.String?

        public init (
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            cloudWatchLogsRoleArn: Swift.String? = nil,
            hasCustomEventSelectors: Swift.Bool? = nil,
            hasInsightSelectors: Swift.Bool? = nil,
            homeRegion: Swift.String? = nil,
            includeGlobalServiceEvents: Swift.Bool? = nil,
            isMultiRegionTrail: Swift.Bool? = nil,
            isOrganizationTrail: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            logFileValidationEnabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            snsTopicARN: Swift.String? = nil,
            snsTopicName: Swift.String? = nil,
            trailARN: Swift.String? = nil
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.hasCustomEventSelectors = hasCustomEventSelectors
            self.hasInsightSelectors = hasInsightSelectors
            self.homeRegion = homeRegion
            self.includeGlobalServiceEvents = includeGlobalServiceEvents
            self.isMultiRegionTrail = isMultiRegionTrail
            self.isOrganizationTrail = isOrganizationTrail
            self.kmsKeyId = kmsKeyId
            self.logFileValidationEnabled = logFileValidationEnabled
            self.name = name
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.snsTopicARN = snsTopicARN
            self.snsTopicName = snsTopicName
            self.trailARN = trailARN
        }
    }

}

extension TrailAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TrailAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified trail already exists.
public struct TrailAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrailAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrailAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.TrailInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegion = "HomeRegion"
        case name = "Name"
        case trailARN = "TrailARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let trailARN = self.trailARN {
            try encodeContainer.encode(trailARN, forKey: .trailARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
    }
}

extension CloudTrailClientTypes {
    /// Information about a CloudTrail trail, including the trail's name, home region, and Amazon Resource Name (ARN).
    public struct TrailInfo: Swift.Equatable {
        /// The Amazon Web Services Region in which a trail was created.
        public var homeRegion: Swift.String?
        /// The name of a trail.
        public var name: Swift.String?
        /// The ARN of a trail.
        public var trailARN: Swift.String?

        public init (
            homeRegion: Swift.String? = nil,
            name: Swift.String? = nil,
            trailARN: Swift.String? = nil
        )
        {
            self.homeRegion = homeRegion
            self.name = name
            self.trailARN = trailARN
        }
    }

}

extension TrailNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TrailNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the trail with the given name is not found.
public struct TrailNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrailNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrailNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrailNotProvidedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TrailNotProvidedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is no longer in use.
public struct TrailNotProvidedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrailNotProvidedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrailNotProvidedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the requested operation is not supported.
public struct UnsupportedOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateEventDataStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventDataStore = "EventDataStore"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedEventSelectors = advancedEventSelectors {
            var advancedEventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedEventSelectors)
            for advancedeventselector0 in advancedEventSelectors {
                try advancedEventSelectorsContainer.encode(advancedeventselector0)
            }
        }
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let multiRegionEnabled = self.multiRegionEnabled {
            try encodeContainer.encode(multiRegionEnabled, forKey: .multiRegionEnabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationEnabled = self.organizationEnabled {
            try encodeContainer.encode(organizationEnabled, forKey: .organizationEnabled)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let terminationProtectionEnabled = self.terminationProtectionEnabled {
            try encodeContainer.encode(terminationProtectionEnabled, forKey: .terminationProtectionEnabled)
        }
    }
}

extension UpdateEventDataStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEventDataStoreInput: Swift.Equatable {
    /// The advanced event selectors used to select events for the event data store. You can configure up to five advanced event selectors for each event data store.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The ARN (or the ID suffix of the ARN) of the event data store that you want to update.
    /// This member is required.
    public var eventDataStore: Swift.String?
    /// Specifies the KMS key ID to use to encrypt the events delivered by CloudTrail. The value can be an alias name prefixed by alias/, a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. Disabling or deleting the KMS key, or removing CloudTrail permissions on the key, prevents CloudTrail from logging events to the event data store, and prevents users from querying the data in the event data store that was encrypted with the key. After you associate an event data store with a KMS key, the KMS key cannot be removed or changed. Before you disable or delete a KMS key that you are using with an event data store, delete or back up your event data store. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether an event data store collects events from all regions, or only from the region in which it was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The event data store name.
    public var name: Swift.String?
    /// Specifies whether an event data store collects events logged for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period, in days.
    public var retentionPeriod: Swift.Int?
    /// Indicates that termination protection is enabled and the event data store cannot be automatically deleted.
    public var terminationProtectionEnabled: Swift.Bool?

    public init (
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventDataStore: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventDataStore = eventDataStore
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.terminationProtectionEnabled = terminationProtectionEnabled
    }
}

struct UpdateEventDataStoreInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
    let name: Swift.String?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    let multiRegionEnabled: Swift.Bool?
    let organizationEnabled: Swift.Bool?
    let retentionPeriod: Swift.Int?
    let terminationProtectionEnabled: Swift.Bool?
    let kmsKeyId: Swift.String?
}

extension UpdateEventDataStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventDataStore = "EventDataStore"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension UpdateEventDataStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEventDataStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailAccessNotEnabled" : self = .cloudTrailAccessNotEnabledException(try CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreARNInvalid" : self = .eventDataStoreARNInvalidException(try EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreHasOngoingImport" : self = .eventDataStoreHasOngoingImportException(try EventDataStoreHasOngoingImportException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDataStoreNotFound" : self = .eventDataStoreNotFoundException(try EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InactiveEventDataStore" : self = .inactiveEventDataStoreException(try InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientEncryptionPolicy" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventSelectors" : self = .invalidEventSelectorsException(try InvalidEventSelectorsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKmsKeyId" : self = .invalidKmsKeyIdException(try InvalidKmsKeyIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyNotFound" : self = .kmsKeyNotFoundException(try KmsKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesMode" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationsNotInUse" : self = .organizationsNotInUseException(try OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateEventDataStoreOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailAccessNotEnabledException(CloudTrailAccessNotEnabledException)
    case eventDataStoreARNInvalidException(EventDataStoreARNInvalidException)
    case eventDataStoreHasOngoingImportException(EventDataStoreHasOngoingImportException)
    case eventDataStoreNotFoundException(EventDataStoreNotFoundException)
    case inactiveEventDataStoreException(InactiveEventDataStoreException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case invalidEventSelectorsException(InvalidEventSelectorsException)
    case invalidKmsKeyIdException(InvalidKmsKeyIdException)
    case invalidParameterException(InvalidParameterException)
    case kmsException(KmsException)
    case kmsKeyNotFoundException(KmsKeyNotFoundException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case organizationsNotInUseException(OrganizationsNotInUseException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEventDataStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateEventDataStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.createdTimestamp = output.createdTimestamp
            self.eventDataStoreArn = output.eventDataStoreArn
            self.kmsKeyId = output.kmsKeyId
            self.multiRegionEnabled = output.multiRegionEnabled
            self.name = output.name
            self.organizationEnabled = output.organizationEnabled
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
            self.terminationProtectionEnabled = output.terminationProtectionEnabled
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.advancedEventSelectors = nil
            self.createdTimestamp = nil
            self.eventDataStoreArn = nil
            self.kmsKeyId = nil
            self.multiRegionEnabled = nil
            self.name = nil
            self.organizationEnabled = nil
            self.retentionPeriod = nil
            self.status = nil
            self.terminationProtectionEnabled = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct UpdateEventDataStoreOutputResponse: Swift.Equatable {
    /// The advanced event selectors that are applied to the event data store.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The timestamp that shows when an event data store was first created.
    public var createdTimestamp: ClientRuntime.Date?
    /// The ARN of the event data store.
    public var eventDataStoreArn: Swift.String?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Indicates whether the event data store includes events from all regions, or only from the region in which it was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    public var name: Swift.String?
    /// Indicates whether an event data store is collecting logged events for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period, in days.
    public var retentionPeriod: Swift.Int?
    /// The status of an event data store. Values can be ENABLED and PENDING_DELETION.
    public var status: CloudTrailClientTypes.EventDataStoreStatus?
    /// Indicates whether termination protection is enabled for the event data store.
    public var terminationProtectionEnabled: Swift.Bool?
    /// The timestamp that shows when the event data store was last updated. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
    public var updatedTimestamp: ClientRuntime.Date?

    public init (
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        eventDataStoreArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.createdTimestamp = createdTimestamp
        self.eventDataStoreArn = eventDataStoreArn
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.terminationProtectionEnabled = terminationProtectionEnabled
        self.updatedTimestamp = updatedTimestamp
    }
}

struct UpdateEventDataStoreOutputResponseBody: Swift.Equatable {
    let eventDataStoreArn: Swift.String?
    let name: Swift.String?
    let status: CloudTrailClientTypes.EventDataStoreStatus?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    let multiRegionEnabled: Swift.Bool?
    let organizationEnabled: Swift.Bool?
    let retentionPeriod: Swift.Int?
    let terminationProtectionEnabled: Swift.Bool?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
    let kmsKeyId: Swift.String?
}

extension UpdateEventDataStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case createdTimestamp = "CreatedTimestamp"
        case eventDataStoreArn = "EventDataStoreArn"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStoreArn)
        eventDataStoreArn = eventDataStoreArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventDataStoreStatus.self, forKey: .status)
        status = statusDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension UpdateTrailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = self.cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = self.cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let enableLogFileValidation = self.enableLogFileValidation {
            try encodeContainer.encode(enableLogFileValidation, forKey: .enableLogFileValidation)
        }
        if let includeGlobalServiceEvents = self.includeGlobalServiceEvents {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if let isMultiRegionTrail = self.isMultiRegionTrail {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if let isOrganizationTrail = self.isOrganizationTrail {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicName = self.snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
    }
}

extension UpdateTrailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies settings to update for the trail.
public struct UpdateTrailInput: Swift.Equatable {
    /// Specifies a log group name using an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs are delivered. Not required unless you specify CloudWatchLogsRoleArn.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether log file validation is enabled. The default is false. When you disable log file integrity validation, the chain of digest files is broken after one hour. CloudTrail does not create digest files for log files that were delivered during a period in which log file integrity validation was disabled. For example, if you enable log file integrity validation at noon on January 1, disable it at noon on January 2, and re-enable it at noon on January 10, digest files will not be created for the log files delivered from noon on January 2 to noon on January 10. The same applies whenever you stop CloudTrail logging or delete a trail.
    public var enableLogFileValidation: Swift.Bool?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail applies only to the current region or to all regions. The default is false. If the trail exists only in the current region and this value is set to true, shadow trails (replications of the trail) will be created in the other regions. If the trail exists in all regions and this value is set to false, the trail will remain in the region where it was created, and its shadow trails in other regions will be deleted. As a best practice, consider using trails that log events in all regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is applied to all accounts in an organization in Organizations, or only for the current Amazon Web Services account. The default is false, and cannot be true unless the call is made on behalf of an Amazon Web Services account that is the management account for an organization in Organizations. If the trail is not an organization trail and this is set to true, the trail will be created in all Amazon Web Services accounts that belong to the organization. If the trail is an organization trail and this is set to false, the trail will remain in the current Amazon Web Services account but be deleted from all member accounts in the organization.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. The value can be an alias name prefixed by "alias/", a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies the name of the trail or trail ARN. If Name is a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If Name is a trail ARN, it must be in the following format. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files. See [Amazon S3 Bucket Naming Requirements](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create_trail_naming_policy.html).
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html). The maximum length is 200 characters.
    public var s3KeyPrefix: Swift.String?
    /// Specifies the name of the Amazon SNS topic defined for notification of log file delivery. The maximum length is 256 characters.
    public var snsTopicName: Swift.String?

    public init (
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        enableLogFileValidation: Swift.Bool? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicName: Swift.String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.enableLogFileValidation = enableLogFileValidation
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicName = snsTopicName
    }
}

struct UpdateTrailInputBody: Swift.Equatable {
    let name: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let snsTopicName: Swift.String?
    let includeGlobalServiceEvents: Swift.Bool?
    let isMultiRegionTrail: Swift.Bool?
    let enableLogFileValidation: Swift.Bool?
    let cloudWatchLogsLogGroupArn: Swift.String?
    let cloudWatchLogsRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let isOrganizationTrail: Swift.Bool?
}

extension UpdateTrailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let enableLogFileValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableLogFileValidation)
        enableLogFileValidation = enableLogFileValidationDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

extension UpdateTrailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTrailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailAccessNotEnabled" : self = .cloudTrailAccessNotEnabledException(try CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudTrailInvalidClientTokenId" : self = .cloudTrailInvalidClientTokenIdException(try CloudTrailInvalidClientTokenIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudWatchLogsDeliveryUnavailable" : self = .cloudWatchLogsDeliveryUnavailableException(try CloudWatchLogsDeliveryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientEncryptionPolicy" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientS3BucketPolicy" : self = .insufficientS3BucketPolicyException(try InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientSnsTopicPolicy" : self = .insufficientSnsTopicPolicyException(try InsufficientSnsTopicPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchLogsLogGroupArn" : self = .invalidCloudWatchLogsLogGroupArnException(try InvalidCloudWatchLogsLogGroupArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchLogsRoleArn" : self = .invalidCloudWatchLogsRoleArnException(try InvalidCloudWatchLogsRoleArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventSelectors" : self = .invalidEventSelectorsException(try InvalidEventSelectorsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegion" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKmsKeyId" : self = .invalidKmsKeyIdException(try InvalidKmsKeyIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationError" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketName" : self = .invalidS3BucketNameException(try InvalidS3BucketNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3Prefix" : self = .invalidS3PrefixException(try InvalidS3PrefixException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSnsTopicName" : self = .invalidSnsTopicNameException(try InvalidSnsTopicNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyDisabled" : self = .kmsKeyDisabledException(try KmsKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyNotFound" : self = .kmsKeyNotFoundException(try KmsKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoManagementAccountSLRExists" : self = .noManagementAccountSLRExistsException(try NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesMode" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationsNotInUse" : self = .organizationsNotInUseException(try OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3BucketDoesNotExist" : self = .s3BucketDoesNotExistException(try S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotProvided" : self = .trailNotProvidedException(try TrailNotProvidedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTrailOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailAccessNotEnabledException(CloudTrailAccessNotEnabledException)
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case cloudTrailInvalidClientTokenIdException(CloudTrailInvalidClientTokenIdException)
    case cloudWatchLogsDeliveryUnavailableException(CloudWatchLogsDeliveryUnavailableException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case insufficientS3BucketPolicyException(InsufficientS3BucketPolicyException)
    case insufficientSnsTopicPolicyException(InsufficientSnsTopicPolicyException)
    case invalidCloudWatchLogsLogGroupArnException(InvalidCloudWatchLogsLogGroupArnException)
    case invalidCloudWatchLogsRoleArnException(InvalidCloudWatchLogsRoleArnException)
    case invalidEventSelectorsException(InvalidEventSelectorsException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidKmsKeyIdException(InvalidKmsKeyIdException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterException(InvalidParameterException)
    case invalidS3BucketNameException(InvalidS3BucketNameException)
    case invalidS3PrefixException(InvalidS3PrefixException)
    case invalidSnsTopicNameException(InvalidSnsTopicNameException)
    case invalidTrailNameException(InvalidTrailNameException)
    case kmsException(KmsException)
    case kmsKeyDisabledException(KmsKeyDisabledException)
    case kmsKeyNotFoundException(KmsKeyNotFoundException)
    case noManagementAccountSLRExistsException(NoManagementAccountSLRExistsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case organizationsNotInUseException(OrganizationsNotInUseException)
    case s3BucketDoesNotExistException(S3BucketDoesNotExistException)
    case trailNotFoundException(TrailNotFoundException)
    case trailNotProvidedException(TrailNotProvidedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTrailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateTrailOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchLogsLogGroupArn = output.cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = output.cloudWatchLogsRoleArn
            self.includeGlobalServiceEvents = output.includeGlobalServiceEvents
            self.isMultiRegionTrail = output.isMultiRegionTrail
            self.isOrganizationTrail = output.isOrganizationTrail
            self.kmsKeyId = output.kmsKeyId
            self.logFileValidationEnabled = output.logFileValidationEnabled
            self.name = output.name
            self.s3BucketName = output.s3BucketName
            self.s3KeyPrefix = output.s3KeyPrefix
            self.snsTopicARN = output.snsTopicARN
            self.snsTopicName = output.snsTopicName
            self.trailARN = output.trailARN
        } else {
            self.cloudWatchLogsLogGroupArn = nil
            self.cloudWatchLogsRoleArn = nil
            self.includeGlobalServiceEvents = nil
            self.isMultiRegionTrail = nil
            self.isOrganizationTrail = nil
            self.kmsKeyId = nil
            self.logFileValidationEnabled = nil
            self.name = nil
            self.s3BucketName = nil
            self.s3KeyPrefix = nil
            self.snsTopicARN = nil
            self.snsTopicName = nil
            self.trailARN = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct UpdateTrailOutputResponse: Swift.Equatable {
    /// Specifies the Amazon Resource Name (ARN) of the log group to which CloudTrail logs are delivered.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail exists in one region or in all regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is an organization trail.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID that encrypts the logs delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether log file integrity validation is enabled.
    public var logFileValidationEnabled: Swift.Bool?
    /// Specifies the name of the trail.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files.
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your IAM Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html).
    public var s3KeyPrefix: Swift.String?
    /// Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The following is the format of a topic ARN. arn:aws:sns:us-east-2:123456789012:MyTopic
    public var snsTopicARN: Swift.String?
    /// This field is no longer in use. Use [UpdateTrailResponse$SnsTopicARN].
    @available(*, deprecated)
    public var snsTopicName: Swift.String?
    /// Specifies the ARN of the trail that was updated. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    public var trailARN: Swift.String?

    public init (
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        logFileValidationEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicARN: Swift.String? = nil,
        snsTopicName: Swift.String? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.logFileValidationEnabled = logFileValidationEnabled
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicARN = snsTopicARN
        self.snsTopicName = snsTopicName
        self.trailARN = trailARN
    }
}

struct UpdateTrailOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let snsTopicName: Swift.String?
    let snsTopicARN: Swift.String?
    let includeGlobalServiceEvents: Swift.Bool?
    let isMultiRegionTrail: Swift.Bool?
    let trailARN: Swift.String?
    let logFileValidationEnabled: Swift.Bool?
    let cloudWatchLogsLogGroupArn: Swift.String?
    let cloudWatchLogsRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let isOrganizationTrail: Swift.Bool?
}

extension UpdateTrailOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicARN = "SnsTopicARN"
        case snsTopicName = "SnsTopicName"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}
