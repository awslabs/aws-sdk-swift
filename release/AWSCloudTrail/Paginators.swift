// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[GetQueryResultsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetQueryResultsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetQueryResultsOutputResponse`
extension CloudTrailClient {
    public func getQueryResultsPaginated(input: GetQueryResultsInput) -> ClientRuntime.PaginatorSequence<GetQueryResultsInput, GetQueryResultsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetQueryResultsInput, GetQueryResultsOutputResponse>(input: input, inputKey: \GetQueryResultsInput.nextToken, outputKey: \GetQueryResultsOutputResponse.nextToken, paginationFunction: self.getQueryResults(input:))
    }
}

extension GetQueryResultsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetQueryResultsInput {
        return GetQueryResultsInput(
            eventDataStore: self.eventDataStore,
            maxQueryResults: self.maxQueryResults,
            nextToken: token,
            queryId: self.queryId
        )}
}

/// Paginate over `[ListChannelsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListChannelsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListChannelsOutputResponse`
extension CloudTrailClient {
    public func listChannelsPaginated(input: ListChannelsInput) -> ClientRuntime.PaginatorSequence<ListChannelsInput, ListChannelsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListChannelsInput, ListChannelsOutputResponse>(input: input, inputKey: \ListChannelsInput.nextToken, outputKey: \ListChannelsOutputResponse.nextToken, paginationFunction: self.listChannels(input:))
    }
}

extension ListChannelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListChannelsInput {
        return ListChannelsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListEventDataStoresOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListEventDataStoresInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListEventDataStoresOutputResponse`
extension CloudTrailClient {
    public func listEventDataStoresPaginated(input: ListEventDataStoresInput) -> ClientRuntime.PaginatorSequence<ListEventDataStoresInput, ListEventDataStoresOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEventDataStoresInput, ListEventDataStoresOutputResponse>(input: input, inputKey: \ListEventDataStoresInput.nextToken, outputKey: \ListEventDataStoresOutputResponse.nextToken, paginationFunction: self.listEventDataStores(input:))
    }
}

extension ListEventDataStoresInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEventDataStoresInput {
        return ListEventDataStoresInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListImportFailuresOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListImportFailuresInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListImportFailuresOutputResponse`
extension CloudTrailClient {
    public func listImportFailuresPaginated(input: ListImportFailuresInput) -> ClientRuntime.PaginatorSequence<ListImportFailuresInput, ListImportFailuresOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListImportFailuresInput, ListImportFailuresOutputResponse>(input: input, inputKey: \ListImportFailuresInput.nextToken, outputKey: \ListImportFailuresOutputResponse.nextToken, paginationFunction: self.listImportFailures(input:))
    }
}

extension ListImportFailuresInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImportFailuresInput {
        return ListImportFailuresInput(
            importId: self.importId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listImportFailuresPaginated`
/// to access the nested member `[CloudTrailClientTypes.ImportFailureListItem]`
/// - Returns: `[CloudTrailClientTypes.ImportFailureListItem]`
extension PaginatorSequence where Input == ListImportFailuresInput, Output == ListImportFailuresOutputResponse {
    public func failures() async throws -> [CloudTrailClientTypes.ImportFailureListItem] {
        return try await self.asyncCompactMap { item in item.failures }
    }
}

/// Paginate over `[ListImportsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListImportsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListImportsOutputResponse`
extension CloudTrailClient {
    public func listImportsPaginated(input: ListImportsInput) -> ClientRuntime.PaginatorSequence<ListImportsInput, ListImportsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListImportsInput, ListImportsOutputResponse>(input: input, inputKey: \ListImportsInput.nextToken, outputKey: \ListImportsOutputResponse.nextToken, paginationFunction: self.listImports(input:))
    }
}

extension ListImportsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImportsInput {
        return ListImportsInput(
            destination: self.destination,
            importStatus: self.importStatus,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listImportsPaginated`
/// to access the nested member `[CloudTrailClientTypes.ImportsListItem]`
/// - Returns: `[CloudTrailClientTypes.ImportsListItem]`
extension PaginatorSequence where Input == ListImportsInput, Output == ListImportsOutputResponse {
    public func imports() async throws -> [CloudTrailClientTypes.ImportsListItem] {
        return try await self.asyncCompactMap { item in item.imports }
    }
}

/// Paginate over `[ListPublicKeysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPublicKeysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPublicKeysOutputResponse`
extension CloudTrailClient {
    public func listPublicKeysPaginated(input: ListPublicKeysInput) -> ClientRuntime.PaginatorSequence<ListPublicKeysInput, ListPublicKeysOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPublicKeysInput, ListPublicKeysOutputResponse>(input: input, inputKey: \ListPublicKeysInput.nextToken, outputKey: \ListPublicKeysOutputResponse.nextToken, paginationFunction: self.listPublicKeys(input:))
    }
}

extension ListPublicKeysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPublicKeysInput {
        return ListPublicKeysInput(
            endTime: self.endTime,
            nextToken: token,
            startTime: self.startTime
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPublicKeysPaginated`
/// to access the nested member `[CloudTrailClientTypes.PublicKey]`
/// - Returns: `[CloudTrailClientTypes.PublicKey]`
extension PaginatorSequence where Input == ListPublicKeysInput, Output == ListPublicKeysOutputResponse {
    public func publicKeyList() async throws -> [CloudTrailClientTypes.PublicKey] {
        return try await self.asyncCompactMap { item in item.publicKeyList }
    }
}

/// Paginate over `[ListQueriesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListQueriesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListQueriesOutputResponse`
extension CloudTrailClient {
    public func listQueriesPaginated(input: ListQueriesInput) -> ClientRuntime.PaginatorSequence<ListQueriesInput, ListQueriesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListQueriesInput, ListQueriesOutputResponse>(input: input, inputKey: \ListQueriesInput.nextToken, outputKey: \ListQueriesOutputResponse.nextToken, paginationFunction: self.listQueries(input:))
    }
}

extension ListQueriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQueriesInput {
        return ListQueriesInput(
            endTime: self.endTime,
            eventDataStore: self.eventDataStore,
            maxResults: self.maxResults,
            nextToken: token,
            queryStatus: self.queryStatus,
            startTime: self.startTime
        )}
}

/// Paginate over `[ListTagsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTagsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTagsOutputResponse`
extension CloudTrailClient {
    public func listTagsPaginated(input: ListTagsInput) -> ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutputResponse>(input: input, inputKey: \ListTagsInput.nextToken, outputKey: \ListTagsOutputResponse.nextToken, paginationFunction: self.listTags(input:))
    }
}

extension ListTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsInput {
        return ListTagsInput(
            nextToken: token,
            resourceIdList: self.resourceIdList
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTagsPaginated`
/// to access the nested member `[CloudTrailClientTypes.ResourceTag]`
/// - Returns: `[CloudTrailClientTypes.ResourceTag]`
extension PaginatorSequence where Input == ListTagsInput, Output == ListTagsOutputResponse {
    public func resourceTagList() async throws -> [CloudTrailClientTypes.ResourceTag] {
        return try await self.asyncCompactMap { item in item.resourceTagList }
    }
}

/// Paginate over `[ListTrailsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTrailsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTrailsOutputResponse`
extension CloudTrailClient {
    public func listTrailsPaginated(input: ListTrailsInput) -> ClientRuntime.PaginatorSequence<ListTrailsInput, ListTrailsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTrailsInput, ListTrailsOutputResponse>(input: input, inputKey: \ListTrailsInput.nextToken, outputKey: \ListTrailsOutputResponse.nextToken, paginationFunction: self.listTrails(input:))
    }
}

extension ListTrailsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTrailsInput {
        return ListTrailsInput(
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTrailsPaginated`
/// to access the nested member `[CloudTrailClientTypes.TrailInfo]`
/// - Returns: `[CloudTrailClientTypes.TrailInfo]`
extension PaginatorSequence where Input == ListTrailsInput, Output == ListTrailsOutputResponse {
    public func trails() async throws -> [CloudTrailClientTypes.TrailInfo] {
        return try await self.asyncCompactMap { item in item.trails }
    }
}

/// Paginate over `[LookupEventsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[LookupEventsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `LookupEventsOutputResponse`
extension CloudTrailClient {
    public func lookupEventsPaginated(input: LookupEventsInput) -> ClientRuntime.PaginatorSequence<LookupEventsInput, LookupEventsOutputResponse> {
        return ClientRuntime.PaginatorSequence<LookupEventsInput, LookupEventsOutputResponse>(input: input, inputKey: \LookupEventsInput.nextToken, outputKey: \LookupEventsOutputResponse.nextToken, paginationFunction: self.lookupEvents(input:))
    }
}

extension LookupEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> LookupEventsInput {
        return LookupEventsInput(
            endTime: self.endTime,
            eventCategory: self.eventCategory,
            lookupAttributes: self.lookupAttributes,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `lookupEventsPaginated`
/// to access the nested member `[CloudTrailClientTypes.Event]`
/// - Returns: `[CloudTrailClientTypes.Event]`
extension PaginatorSequence where Input == LookupEventsInput, Output == LookupEventsOutputResponse {
    public func events() async throws -> [CloudTrailClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}
