// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AugmentedManifestsListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeNames = "AttributeNames"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributenameslist0 in attributeNames {
                try attributeNamesContainer.encode(attributenameslist0)
            }
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension AugmentedManifestsListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AugmentedManifestsListItem(attributeNames: \(String(describing: attributeNames)), s3Uri: \(String(describing: s3Uri)))"}
}

/// <p>An augmented manifest file that provides training data for your custom model. An augmented
///       manifest file is a labeled dataset that is produced by Amazon SageMaker Ground Truth.</p>
public struct AugmentedManifestsListItem: Equatable {
    /// <p>The JSON attribute that contains the annotations for your training documents. The number
    ///       of attribute names that you specify depends on whether your augmented manifest file is the
    ///       output of a single labeling job or a chained labeling job.</p>
    ///          <p>If your file is the output of a single labeling job, specify the LabelAttributeName key
    ///       that was used when the job was created in Ground Truth.</p>
    ///          <p>If your file is the output of a chained labeling job, specify the LabelAttributeName key
    ///       for one or more jobs in the chain. Each LabelAttributeName key provides the annotations from
    ///       an individual job.</p>
    public let attributeNames: [String]?
    /// <p>The Amazon S3 location of the augmented manifest file.</p>
    public let s3Uri: String?

    public init (
        attributeNames: [String]? = nil,
        s3Uri: String? = nil
    )
    {
        self.attributeNames = attributeNames
        self.s3Uri = s3Uri
    }
}

public struct BatchDetectDominantLanguageInputBodyMiddleware: Middleware {
    public let id: String = "BatchDetectDominantLanguageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectDominantLanguageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectDominantLanguageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectDominantLanguageInput>
    public typealias MOutput = OperationOutput<BatchDetectDominantLanguageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectDominantLanguageOutputError>
}

extension BatchDetectDominantLanguageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetectDominantLanguageInput(textList: \(String(describing: textList)))"}
}

extension BatchDetectDominantLanguageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case textList = "TextList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let textList = textList {
            var textListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textList)
            for customerinputstringlist0 in textList {
                try textListContainer.encode(customerinputstringlist0)
            }
        }
    }
}

public struct BatchDetectDominantLanguageInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDetectDominantLanguageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectDominantLanguageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectDominantLanguageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectDominantLanguageInput>
    public typealias MOutput = OperationOutput<BatchDetectDominantLanguageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectDominantLanguageOutputError>
}

public struct BatchDetectDominantLanguageInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDetectDominantLanguageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectDominantLanguageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectDominantLanguageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectDominantLanguageInput>
    public typealias MOutput = OperationOutput<BatchDetectDominantLanguageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectDominantLanguageOutputError>
}

public struct BatchDetectDominantLanguageInput: Equatable {
    /// <p>A list containing the text of the input documents. The list can contain a maximum of 25
    ///       documents. Each document should contain at least 20 characters and must contain fewer than
    ///       5,000 bytes of UTF-8 encoded characters.</p>
    public let textList: [String]?

    public init (
        textList: [String]? = nil
    )
    {
        self.textList = textList
    }
}

struct BatchDetectDominantLanguageInputBody: Equatable {
    public let textList: [String]?
}

extension BatchDetectDominantLanguageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case textList = "TextList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .textList)
        var textListDecoded0:[String]? = nil
        if let textListContainer = textListContainer {
            textListDecoded0 = [String]()
            for string0 in textListContainer {
                if let string0 = string0 {
                    textListDecoded0?.append(string0)
                }
            }
        }
        textList = textListDecoded0
    }
}

extension BatchDetectDominantLanguageItemResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case index = "Index"
        case languages = "Languages"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let index = index {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let languages = languages {
            var languagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .languages)
            for listofdominantlanguages0 in languages {
                try languagesContainer.encode(listofdominantlanguages0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .index)
        index = indexDecoded
        let languagesContainer = try containerValues.decodeIfPresent([DominantLanguage?].self, forKey: .languages)
        var languagesDecoded0:[DominantLanguage]? = nil
        if let languagesContainer = languagesContainer {
            languagesDecoded0 = [DominantLanguage]()
            for structure0 in languagesContainer {
                if let structure0 = structure0 {
                    languagesDecoded0?.append(structure0)
                }
            }
        }
        languages = languagesDecoded0
    }
}

extension BatchDetectDominantLanguageItemResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetectDominantLanguageItemResult(index: \(String(describing: index)), languages: \(String(describing: languages)))"}
}

/// <p>The result of calling the  operation.
///       The operation returns one object for each document that is successfully processed by the
///       operation.</p>
public struct BatchDetectDominantLanguageItemResult: Equatable {
    /// <p>The zero-based index of the document in the input list.</p>
    public let index: Int?
    /// <p>One or more <a>DominantLanguage</a> objects describing the dominant
    ///       languages in the document.</p>
    public let languages: [DominantLanguage]?

    public init (
        index: Int? = nil,
        languages: [DominantLanguage]? = nil
    )
    {
        self.index = index
        self.languages = languages
    }
}

extension BatchDetectDominantLanguageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDetectDominantLanguageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BatchSizeLimitExceededException" : self = .batchSizeLimitExceededException(try BatchSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDetectDominantLanguageOutputError: Swift.Error, Equatable {
    case batchSizeLimitExceededException(BatchSizeLimitExceededException)
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDetectDominantLanguageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

extension BatchDetectDominantLanguageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDetectDominantLanguageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorList = output.errorList
            self.resultList = output.resultList
        } else {
            self.errorList = nil
            self.resultList = nil
        }
    }
}

public struct BatchDetectDominantLanguageOutputResponse: Equatable {
    /// <p>A list containing one  object for each document
    ///       that contained an error. The results are sorted in ascending order by the <code>Index</code>
    ///       field and match the order of the documents in the input list. If there are no errors in the
    ///       batch, the <code>ErrorList</code> is empty.</p>
    public let errorList: [BatchItemError]?
    /// <p>A list of  objects
    ///       containing the results of the operation. The results are sorted in ascending order by the
    ///         <code>Index</code> field and match the order of the documents in the input list. If all of
    ///       the documents contain an error, the <code>ResultList</code> is empty.</p>
    public let resultList: [BatchDetectDominantLanguageItemResult]?

    public init (
        errorList: [BatchItemError]? = nil,
        resultList: [BatchDetectDominantLanguageItemResult]? = nil
    )
    {
        self.errorList = errorList
        self.resultList = resultList
    }
}

struct BatchDetectDominantLanguageOutputResponseBody: Equatable {
    public let resultList: [BatchDetectDominantLanguageItemResult]?
    public let errorList: [BatchItemError]?
}

extension BatchDetectDominantLanguageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorList = "ErrorList"
        case resultList = "ResultList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultListContainer = try containerValues.decodeIfPresent([BatchDetectDominantLanguageItemResult?].self, forKey: .resultList)
        var resultListDecoded0:[BatchDetectDominantLanguageItemResult]? = nil
        if let resultListContainer = resultListContainer {
            resultListDecoded0 = [BatchDetectDominantLanguageItemResult]()
            for structure0 in resultListContainer {
                if let structure0 = structure0 {
                    resultListDecoded0?.append(structure0)
                }
            }
        }
        resultList = resultListDecoded0
        let errorListContainer = try containerValues.decodeIfPresent([BatchItemError?].self, forKey: .errorList)
        var errorListDecoded0:[BatchItemError]? = nil
        if let errorListContainer = errorListContainer {
            errorListDecoded0 = [BatchItemError]()
            for structure0 in errorListContainer {
                if let structure0 = structure0 {
                    errorListDecoded0?.append(structure0)
                }
            }
        }
        errorList = errorListDecoded0
    }
}

public struct BatchDetectEntitiesInputBodyMiddleware: Middleware {
    public let id: String = "BatchDetectEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectEntitiesInput>
    public typealias MOutput = OperationOutput<BatchDetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectEntitiesOutputError>
}

extension BatchDetectEntitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetectEntitiesInput(languageCode: \(String(describing: languageCode)), textList: \(String(describing: textList)))"}
}

extension BatchDetectEntitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case textList = "TextList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let textList = textList {
            var textListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textList)
            for customerinputstringlist0 in textList {
                try textListContainer.encode(customerinputstringlist0)
            }
        }
    }
}

public struct BatchDetectEntitiesInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDetectEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectEntitiesInput>
    public typealias MOutput = OperationOutput<BatchDetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectEntitiesOutputError>
}

public struct BatchDetectEntitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDetectEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectEntitiesInput>
    public typealias MOutput = OperationOutput<BatchDetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectEntitiesOutputError>
}

public struct BatchDetectEntitiesInput: Equatable {
    /// <p>The language of the input documents. You can specify any of the primary languages
    ///       supported by Amazon Comprehend. All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>A list containing the text of the input documents. The list can contain a maximum of 25
    ///       documents. Each document must contain fewer than 5,000 bytes of UTF-8 encoded
    ///       characters.</p>
    public let textList: [String]?

    public init (
        languageCode: LanguageCode? = nil,
        textList: [String]? = nil
    )
    {
        self.languageCode = languageCode
        self.textList = textList
    }
}

struct BatchDetectEntitiesInputBody: Equatable {
    public let textList: [String]?
    public let languageCode: LanguageCode?
}

extension BatchDetectEntitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case textList = "TextList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .textList)
        var textListDecoded0:[String]? = nil
        if let textListContainer = textListContainer {
            textListDecoded0 = [String]()
            for string0 in textListContainer {
                if let string0 = string0 {
                    textListDecoded0?.append(string0)
                }
            }
        }
        textList = textListDecoded0
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension BatchDetectEntitiesItemResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entities = "Entities"
        case index = "Index"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entities = entities {
            var entitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entities)
            for listofentities0 in entities {
                try entitiesContainer.encode(listofentities0)
            }
        }
        if let index = index {
            try encodeContainer.encode(index, forKey: .index)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .index)
        index = indexDecoded
        let entitiesContainer = try containerValues.decodeIfPresent([Entity?].self, forKey: .entities)
        var entitiesDecoded0:[Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
    }
}

extension BatchDetectEntitiesItemResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetectEntitiesItemResult(entities: \(String(describing: entities)), index: \(String(describing: index)))"}
}

/// <p>The result of calling the  operation. The
///       operation returns one object for each document that is successfully processed by the
///       operation.</p>
public struct BatchDetectEntitiesItemResult: Equatable {
    /// <p>One or more <a>Entity</a> objects, one for each entity detected in the
    ///       document.</p>
    public let entities: [Entity]?
    /// <p>The zero-based index of the document in the input list.</p>
    public let index: Int?

    public init (
        entities: [Entity]? = nil,
        index: Int? = nil
    )
    {
        self.entities = entities
        self.index = index
    }
}

extension BatchDetectEntitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDetectEntitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BatchSizeLimitExceededException" : self = .batchSizeLimitExceededException(try BatchSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguageException" : self = .unsupportedLanguageException(try UnsupportedLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDetectEntitiesOutputError: Swift.Error, Equatable {
    case batchSizeLimitExceededException(BatchSizeLimitExceededException)
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unsupportedLanguageException(UnsupportedLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDetectEntitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

extension BatchDetectEntitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDetectEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorList = output.errorList
            self.resultList = output.resultList
        } else {
            self.errorList = nil
            self.resultList = nil
        }
    }
}

public struct BatchDetectEntitiesOutputResponse: Equatable {
    /// <p>A list containing one  object for each document
    ///       that contained an error. The results are sorted in ascending order by the <code>Index</code>
    ///       field and match the order of the documents in the input list. If there are no errors in the
    ///       batch, the <code>ErrorList</code> is empty.</p>
    public let errorList: [BatchItemError]?
    /// <p>A list of  objects containing the
    ///       results of the operation. The results are sorted in ascending order by the <code>Index</code>
    ///       field and match the order of the documents in the input list. If all of the documents contain
    ///       an error, the <code>ResultList</code> is empty.</p>
    public let resultList: [BatchDetectEntitiesItemResult]?

    public init (
        errorList: [BatchItemError]? = nil,
        resultList: [BatchDetectEntitiesItemResult]? = nil
    )
    {
        self.errorList = errorList
        self.resultList = resultList
    }
}

struct BatchDetectEntitiesOutputResponseBody: Equatable {
    public let resultList: [BatchDetectEntitiesItemResult]?
    public let errorList: [BatchItemError]?
}

extension BatchDetectEntitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorList = "ErrorList"
        case resultList = "ResultList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultListContainer = try containerValues.decodeIfPresent([BatchDetectEntitiesItemResult?].self, forKey: .resultList)
        var resultListDecoded0:[BatchDetectEntitiesItemResult]? = nil
        if let resultListContainer = resultListContainer {
            resultListDecoded0 = [BatchDetectEntitiesItemResult]()
            for structure0 in resultListContainer {
                if let structure0 = structure0 {
                    resultListDecoded0?.append(structure0)
                }
            }
        }
        resultList = resultListDecoded0
        let errorListContainer = try containerValues.decodeIfPresent([BatchItemError?].self, forKey: .errorList)
        var errorListDecoded0:[BatchItemError]? = nil
        if let errorListContainer = errorListContainer {
            errorListDecoded0 = [BatchItemError]()
            for structure0 in errorListContainer {
                if let structure0 = structure0 {
                    errorListDecoded0?.append(structure0)
                }
            }
        }
        errorList = errorListDecoded0
    }
}

public struct BatchDetectKeyPhrasesInputBodyMiddleware: Middleware {
    public let id: String = "BatchDetectKeyPhrasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectKeyPhrasesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectKeyPhrasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectKeyPhrasesInput>
    public typealias MOutput = OperationOutput<BatchDetectKeyPhrasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectKeyPhrasesOutputError>
}

extension BatchDetectKeyPhrasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetectKeyPhrasesInput(languageCode: \(String(describing: languageCode)), textList: \(String(describing: textList)))"}
}

extension BatchDetectKeyPhrasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case textList = "TextList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let textList = textList {
            var textListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textList)
            for customerinputstringlist0 in textList {
                try textListContainer.encode(customerinputstringlist0)
            }
        }
    }
}

public struct BatchDetectKeyPhrasesInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDetectKeyPhrasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectKeyPhrasesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectKeyPhrasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectKeyPhrasesInput>
    public typealias MOutput = OperationOutput<BatchDetectKeyPhrasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectKeyPhrasesOutputError>
}

public struct BatchDetectKeyPhrasesInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDetectKeyPhrasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectKeyPhrasesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectKeyPhrasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectKeyPhrasesInput>
    public typealias MOutput = OperationOutput<BatchDetectKeyPhrasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectKeyPhrasesOutputError>
}

public struct BatchDetectKeyPhrasesInput: Equatable {
    /// <p>The language of the input documents. You can specify any of the primary languages
    ///       supported by Amazon Comprehend. All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>A list containing the text of the input documents. The list can contain a maximum of 25
    ///       documents. Each document must contain fewer that 5,000 bytes of UTF-8 encoded
    ///       characters.</p>
    public let textList: [String]?

    public init (
        languageCode: LanguageCode? = nil,
        textList: [String]? = nil
    )
    {
        self.languageCode = languageCode
        self.textList = textList
    }
}

struct BatchDetectKeyPhrasesInputBody: Equatable {
    public let textList: [String]?
    public let languageCode: LanguageCode?
}

extension BatchDetectKeyPhrasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case textList = "TextList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .textList)
        var textListDecoded0:[String]? = nil
        if let textListContainer = textListContainer {
            textListDecoded0 = [String]()
            for string0 in textListContainer {
                if let string0 = string0 {
                    textListDecoded0?.append(string0)
                }
            }
        }
        textList = textListDecoded0
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension BatchDetectKeyPhrasesItemResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case index = "Index"
        case keyPhrases = "KeyPhrases"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let index = index {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let keyPhrases = keyPhrases {
            var keyPhrasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keyPhrases)
            for listofkeyphrases0 in keyPhrases {
                try keyPhrasesContainer.encode(listofkeyphrases0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .index)
        index = indexDecoded
        let keyPhrasesContainer = try containerValues.decodeIfPresent([KeyPhrase?].self, forKey: .keyPhrases)
        var keyPhrasesDecoded0:[KeyPhrase]? = nil
        if let keyPhrasesContainer = keyPhrasesContainer {
            keyPhrasesDecoded0 = [KeyPhrase]()
            for structure0 in keyPhrasesContainer {
                if let structure0 = structure0 {
                    keyPhrasesDecoded0?.append(structure0)
                }
            }
        }
        keyPhrases = keyPhrasesDecoded0
    }
}

extension BatchDetectKeyPhrasesItemResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetectKeyPhrasesItemResult(index: \(String(describing: index)), keyPhrases: \(String(describing: keyPhrases)))"}
}

/// <p>The result of calling the  operation. The
///       operation returns one object for each document that is successfully processed by the
///       operation.</p>
public struct BatchDetectKeyPhrasesItemResult: Equatable {
    /// <p>The zero-based index of the document in the input list.</p>
    public let index: Int?
    /// <p>One or more <a>KeyPhrase</a> objects, one for each key phrase detected in
    ///       the document.</p>
    public let keyPhrases: [KeyPhrase]?

    public init (
        index: Int? = nil,
        keyPhrases: [KeyPhrase]? = nil
    )
    {
        self.index = index
        self.keyPhrases = keyPhrases
    }
}

extension BatchDetectKeyPhrasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDetectKeyPhrasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BatchSizeLimitExceededException" : self = .batchSizeLimitExceededException(try BatchSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguageException" : self = .unsupportedLanguageException(try UnsupportedLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDetectKeyPhrasesOutputError: Swift.Error, Equatable {
    case batchSizeLimitExceededException(BatchSizeLimitExceededException)
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unsupportedLanguageException(UnsupportedLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDetectKeyPhrasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

extension BatchDetectKeyPhrasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDetectKeyPhrasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorList = output.errorList
            self.resultList = output.resultList
        } else {
            self.errorList = nil
            self.resultList = nil
        }
    }
}

public struct BatchDetectKeyPhrasesOutputResponse: Equatable {
    /// <p>A list containing one  object for each document
    ///       that contained an error. The results are sorted in ascending order by the <code>Index</code>
    ///       field and match the order of the documents in the input list. If there are no errors in the
    ///       batch, the <code>ErrorList</code> is empty.</p>
    public let errorList: [BatchItemError]?
    /// <p>A list of  objects containing the
    ///       results of the operation. The results are sorted in ascending order by the <code>Index</code>
    ///       field and match the order of the documents in the input list. If all of the documents contain
    ///       an error, the <code>ResultList</code> is empty.</p>
    public let resultList: [BatchDetectKeyPhrasesItemResult]?

    public init (
        errorList: [BatchItemError]? = nil,
        resultList: [BatchDetectKeyPhrasesItemResult]? = nil
    )
    {
        self.errorList = errorList
        self.resultList = resultList
    }
}

struct BatchDetectKeyPhrasesOutputResponseBody: Equatable {
    public let resultList: [BatchDetectKeyPhrasesItemResult]?
    public let errorList: [BatchItemError]?
}

extension BatchDetectKeyPhrasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorList = "ErrorList"
        case resultList = "ResultList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultListContainer = try containerValues.decodeIfPresent([BatchDetectKeyPhrasesItemResult?].self, forKey: .resultList)
        var resultListDecoded0:[BatchDetectKeyPhrasesItemResult]? = nil
        if let resultListContainer = resultListContainer {
            resultListDecoded0 = [BatchDetectKeyPhrasesItemResult]()
            for structure0 in resultListContainer {
                if let structure0 = structure0 {
                    resultListDecoded0?.append(structure0)
                }
            }
        }
        resultList = resultListDecoded0
        let errorListContainer = try containerValues.decodeIfPresent([BatchItemError?].self, forKey: .errorList)
        var errorListDecoded0:[BatchItemError]? = nil
        if let errorListContainer = errorListContainer {
            errorListDecoded0 = [BatchItemError]()
            for structure0 in errorListContainer {
                if let structure0 = structure0 {
                    errorListDecoded0?.append(structure0)
                }
            }
        }
        errorList = errorListDecoded0
    }
}

public struct BatchDetectSentimentInputBodyMiddleware: Middleware {
    public let id: String = "BatchDetectSentimentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectSentimentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectSentimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectSentimentInput>
    public typealias MOutput = OperationOutput<BatchDetectSentimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectSentimentOutputError>
}

extension BatchDetectSentimentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetectSentimentInput(languageCode: \(String(describing: languageCode)), textList: \(String(describing: textList)))"}
}

extension BatchDetectSentimentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case textList = "TextList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let textList = textList {
            var textListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textList)
            for customerinputstringlist0 in textList {
                try textListContainer.encode(customerinputstringlist0)
            }
        }
    }
}

public struct BatchDetectSentimentInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDetectSentimentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectSentimentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectSentimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectSentimentInput>
    public typealias MOutput = OperationOutput<BatchDetectSentimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectSentimentOutputError>
}

public struct BatchDetectSentimentInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDetectSentimentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectSentimentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectSentimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectSentimentInput>
    public typealias MOutput = OperationOutput<BatchDetectSentimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectSentimentOutputError>
}

public struct BatchDetectSentimentInput: Equatable {
    /// <p>The language of the input documents. You can specify any of the primary languages
    ///       supported by Amazon Comprehend. All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>A list containing the text of the input documents. The list can contain a maximum of 25
    ///       documents. Each document must contain fewer that 5,000 bytes of UTF-8 encoded
    ///       characters.</p>
    public let textList: [String]?

    public init (
        languageCode: LanguageCode? = nil,
        textList: [String]? = nil
    )
    {
        self.languageCode = languageCode
        self.textList = textList
    }
}

struct BatchDetectSentimentInputBody: Equatable {
    public let textList: [String]?
    public let languageCode: LanguageCode?
}

extension BatchDetectSentimentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case textList = "TextList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .textList)
        var textListDecoded0:[String]? = nil
        if let textListContainer = textListContainer {
            textListDecoded0 = [String]()
            for string0 in textListContainer {
                if let string0 = string0 {
                    textListDecoded0?.append(string0)
                }
            }
        }
        textList = textListDecoded0
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension BatchDetectSentimentItemResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case index = "Index"
        case sentiment = "Sentiment"
        case sentimentScore = "SentimentScore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let index = index {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let sentiment = sentiment {
            try encodeContainer.encode(sentiment.rawValue, forKey: .sentiment)
        }
        if let sentimentScore = sentimentScore {
            try encodeContainer.encode(sentimentScore, forKey: .sentimentScore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .index)
        index = indexDecoded
        let sentimentDecoded = try containerValues.decodeIfPresent(SentimentType.self, forKey: .sentiment)
        sentiment = sentimentDecoded
        let sentimentScoreDecoded = try containerValues.decodeIfPresent(SentimentScore.self, forKey: .sentimentScore)
        sentimentScore = sentimentScoreDecoded
    }
}

extension BatchDetectSentimentItemResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetectSentimentItemResult(index: \(String(describing: index)), sentiment: \(String(describing: sentiment)), sentimentScore: \(String(describing: sentimentScore)))"}
}

/// <p>The result of calling the  operation. The
///       operation returns one object for each document that is successfully processed by the
///       operation.</p>
public struct BatchDetectSentimentItemResult: Equatable {
    /// <p>The zero-based index of the document in the input list.</p>
    public let index: Int?
    /// <p>The sentiment detected in the document.</p>
    public let sentiment: SentimentType?
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its sentiment
    ///       detection.</p>
    public let sentimentScore: SentimentScore?

    public init (
        index: Int? = nil,
        sentiment: SentimentType? = nil,
        sentimentScore: SentimentScore? = nil
    )
    {
        self.index = index
        self.sentiment = sentiment
        self.sentimentScore = sentimentScore
    }
}

extension BatchDetectSentimentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDetectSentimentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BatchSizeLimitExceededException" : self = .batchSizeLimitExceededException(try BatchSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguageException" : self = .unsupportedLanguageException(try UnsupportedLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDetectSentimentOutputError: Swift.Error, Equatable {
    case batchSizeLimitExceededException(BatchSizeLimitExceededException)
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unsupportedLanguageException(UnsupportedLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDetectSentimentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

extension BatchDetectSentimentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDetectSentimentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorList = output.errorList
            self.resultList = output.resultList
        } else {
            self.errorList = nil
            self.resultList = nil
        }
    }
}

public struct BatchDetectSentimentOutputResponse: Equatable {
    /// <p>A list containing one  object for each document
    ///       that contained an error. The results are sorted in ascending order by the <code>Index</code>
    ///       field and match the order of the documents in the input list. If there are no errors in the
    ///       batch, the <code>ErrorList</code> is empty.</p>
    public let errorList: [BatchItemError]?
    /// <p>A list of  objects containing the
    ///       results of the operation. The results are sorted in ascending order by the <code>Index</code>
    ///       field and match the order of the documents in the input list. If all of the documents contain
    ///       an error, the <code>ResultList</code> is empty.</p>
    public let resultList: [BatchDetectSentimentItemResult]?

    public init (
        errorList: [BatchItemError]? = nil,
        resultList: [BatchDetectSentimentItemResult]? = nil
    )
    {
        self.errorList = errorList
        self.resultList = resultList
    }
}

struct BatchDetectSentimentOutputResponseBody: Equatable {
    public let resultList: [BatchDetectSentimentItemResult]?
    public let errorList: [BatchItemError]?
}

extension BatchDetectSentimentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorList = "ErrorList"
        case resultList = "ResultList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultListContainer = try containerValues.decodeIfPresent([BatchDetectSentimentItemResult?].self, forKey: .resultList)
        var resultListDecoded0:[BatchDetectSentimentItemResult]? = nil
        if let resultListContainer = resultListContainer {
            resultListDecoded0 = [BatchDetectSentimentItemResult]()
            for structure0 in resultListContainer {
                if let structure0 = structure0 {
                    resultListDecoded0?.append(structure0)
                }
            }
        }
        resultList = resultListDecoded0
        let errorListContainer = try containerValues.decodeIfPresent([BatchItemError?].self, forKey: .errorList)
        var errorListDecoded0:[BatchItemError]? = nil
        if let errorListContainer = errorListContainer {
            errorListDecoded0 = [BatchItemError]()
            for structure0 in errorListContainer {
                if let structure0 = structure0 {
                    errorListDecoded0?.append(structure0)
                }
            }
        }
        errorList = errorListDecoded0
    }
}

public struct BatchDetectSyntaxInputBodyMiddleware: Middleware {
    public let id: String = "BatchDetectSyntaxInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectSyntaxInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectSyntaxOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectSyntaxInput>
    public typealias MOutput = OperationOutput<BatchDetectSyntaxOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectSyntaxOutputError>
}

extension BatchDetectSyntaxInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetectSyntaxInput(languageCode: \(String(describing: languageCode)), textList: \(String(describing: textList)))"}
}

extension BatchDetectSyntaxInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case textList = "TextList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let textList = textList {
            var textListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textList)
            for customerinputstringlist0 in textList {
                try textListContainer.encode(customerinputstringlist0)
            }
        }
    }
}

public struct BatchDetectSyntaxInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDetectSyntaxInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectSyntaxInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectSyntaxOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectSyntaxInput>
    public typealias MOutput = OperationOutput<BatchDetectSyntaxOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectSyntaxOutputError>
}

public struct BatchDetectSyntaxInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDetectSyntaxInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDetectSyntaxInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDetectSyntaxOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDetectSyntaxInput>
    public typealias MOutput = OperationOutput<BatchDetectSyntaxOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDetectSyntaxOutputError>
}

public struct BatchDetectSyntaxInput: Equatable {
    /// <p>The language of the input documents. You can specify any of the following languages
    ///       supported by Amazon Comprehend: German ("de"), English ("en"), Spanish ("es"), French ("fr"),
    ///       Italian ("it"), or Portuguese ("pt"). All documents must be in the same language.</p>
    public let languageCode: SyntaxLanguageCode?
    /// <p>A list containing the text of the input documents. The list can contain a maximum of 25
    ///       documents. Each document must contain fewer that 5,000 bytes of UTF-8 encoded
    ///       characters.</p>
    public let textList: [String]?

    public init (
        languageCode: SyntaxLanguageCode? = nil,
        textList: [String]? = nil
    )
    {
        self.languageCode = languageCode
        self.textList = textList
    }
}

struct BatchDetectSyntaxInputBody: Equatable {
    public let textList: [String]?
    public let languageCode: SyntaxLanguageCode?
}

extension BatchDetectSyntaxInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case textList = "TextList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .textList)
        var textListDecoded0:[String]? = nil
        if let textListContainer = textListContainer {
            textListDecoded0 = [String]()
            for string0 in textListContainer {
                if let string0 = string0 {
                    textListDecoded0?.append(string0)
                }
            }
        }
        textList = textListDecoded0
        let languageCodeDecoded = try containerValues.decodeIfPresent(SyntaxLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension BatchDetectSyntaxItemResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case index = "Index"
        case syntaxTokens = "SyntaxTokens"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let index = index {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let syntaxTokens = syntaxTokens {
            var syntaxTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .syntaxTokens)
            for listofsyntaxtokens0 in syntaxTokens {
                try syntaxTokensContainer.encode(listofsyntaxtokens0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .index)
        index = indexDecoded
        let syntaxTokensContainer = try containerValues.decodeIfPresent([SyntaxToken?].self, forKey: .syntaxTokens)
        var syntaxTokensDecoded0:[SyntaxToken]? = nil
        if let syntaxTokensContainer = syntaxTokensContainer {
            syntaxTokensDecoded0 = [SyntaxToken]()
            for structure0 in syntaxTokensContainer {
                if let structure0 = structure0 {
                    syntaxTokensDecoded0?.append(structure0)
                }
            }
        }
        syntaxTokens = syntaxTokensDecoded0
    }
}

extension BatchDetectSyntaxItemResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDetectSyntaxItemResult(index: \(String(describing: index)), syntaxTokens: \(String(describing: syntaxTokens)))"}
}

/// <p>The result of calling the  operation. The operation
///       returns one object that is successfully processed by the operation.</p>
public struct BatchDetectSyntaxItemResult: Equatable {
    /// <p>The zero-based index of the document in the input list.</p>
    public let index: Int?
    /// <p>The syntax tokens for the words in the document, one token for each word.</p>
    public let syntaxTokens: [SyntaxToken]?

    public init (
        index: Int? = nil,
        syntaxTokens: [SyntaxToken]? = nil
    )
    {
        self.index = index
        self.syntaxTokens = syntaxTokens
    }
}

extension BatchDetectSyntaxOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDetectSyntaxOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BatchSizeLimitExceededException" : self = .batchSizeLimitExceededException(try BatchSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguageException" : self = .unsupportedLanguageException(try UnsupportedLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDetectSyntaxOutputError: Swift.Error, Equatable {
    case batchSizeLimitExceededException(BatchSizeLimitExceededException)
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unsupportedLanguageException(UnsupportedLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDetectSyntaxOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

extension BatchDetectSyntaxOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDetectSyntaxOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorList = output.errorList
            self.resultList = output.resultList
        } else {
            self.errorList = nil
            self.resultList = nil
        }
    }
}

public struct BatchDetectSyntaxOutputResponse: Equatable {
    /// <p>A list containing one  object for each document that
    ///       contained an error. The results are sorted in ascending order by the <code>Index</code> field
    ///       and match the order of the documents in the input list. If there are no errors in the batch,
    ///       the <code>ErrorList</code> is empty.</p>
    public let errorList: [BatchItemError]?
    /// <p>A list of  objects containing the results
    ///       of the operation. The results are sorted in ascending order by the <code>Index</code> field
    ///       and match the order of the documents in the input list. If all of the documents contain an
    ///       error, the <code>ResultList</code> is empty.</p>
    public let resultList: [BatchDetectSyntaxItemResult]?

    public init (
        errorList: [BatchItemError]? = nil,
        resultList: [BatchDetectSyntaxItemResult]? = nil
    )
    {
        self.errorList = errorList
        self.resultList = resultList
    }
}

struct BatchDetectSyntaxOutputResponseBody: Equatable {
    public let resultList: [BatchDetectSyntaxItemResult]?
    public let errorList: [BatchItemError]?
}

extension BatchDetectSyntaxOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorList = "ErrorList"
        case resultList = "ResultList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultListContainer = try containerValues.decodeIfPresent([BatchDetectSyntaxItemResult?].self, forKey: .resultList)
        var resultListDecoded0:[BatchDetectSyntaxItemResult]? = nil
        if let resultListContainer = resultListContainer {
            resultListDecoded0 = [BatchDetectSyntaxItemResult]()
            for structure0 in resultListContainer {
                if let structure0 = structure0 {
                    resultListDecoded0?.append(structure0)
                }
            }
        }
        resultList = resultListDecoded0
        let errorListContainer = try containerValues.decodeIfPresent([BatchItemError?].self, forKey: .errorList)
        var errorListDecoded0:[BatchItemError]? = nil
        if let errorListContainer = errorListContainer {
            errorListDecoded0 = [BatchItemError]()
            for structure0 in errorListContainer {
                if let structure0 = structure0 {
                    errorListDecoded0?.append(structure0)
                }
            }
        }
        errorList = errorListDecoded0
    }
}

extension BatchItemError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case index = "Index"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let index = index {
            try encodeContainer.encode(index, forKey: .index)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .index)
        index = indexDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchItemError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchItemError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), index: \(String(describing: index)))"}
}

/// <p>Describes an error that occurred while processing a document in a batch. The operation
///       returns on <code>BatchItemError</code> object for each document that contained an
///       error.</p>
public struct BatchItemError: Equatable {
    /// <p>The numeric error code of the error.</p>
    public let errorCode: String?
    /// <p>A text description of the error.</p>
    public let errorMessage: String?
    /// <p>The zero-based index of the document in the input list.</p>
    public let index: Int?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        index: Int? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.index = index
    }
}

extension BatchSizeLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchSizeLimitExceededException(message: \(String(describing: message)))"}
}

extension BatchSizeLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of documents in the request exceeds the limit of 25. Try your request again
///       with fewer documents.</p>
public struct BatchSizeLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BatchSizeLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension BatchSizeLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClassifierEvaluationMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accuracy = "Accuracy"
        case f1Score = "F1Score"
        case hammingLoss = "HammingLoss"
        case microF1Score = "MicroF1Score"
        case microPrecision = "MicroPrecision"
        case microRecall = "MicroRecall"
        case precision = "Precision"
        case recall = "Recall"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accuracy = accuracy {
            try encodeContainer.encode(accuracy, forKey: .accuracy)
        }
        if let f1Score = f1Score {
            try encodeContainer.encode(f1Score, forKey: .f1Score)
        }
        if let hammingLoss = hammingLoss {
            try encodeContainer.encode(hammingLoss, forKey: .hammingLoss)
        }
        if let microF1Score = microF1Score {
            try encodeContainer.encode(microF1Score, forKey: .microF1Score)
        }
        if let microPrecision = microPrecision {
            try encodeContainer.encode(microPrecision, forKey: .microPrecision)
        }
        if let microRecall = microRecall {
            try encodeContainer.encode(microRecall, forKey: .microRecall)
        }
        if let precision = precision {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if let recall = recall {
            try encodeContainer.encode(recall, forKey: .recall)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accuracyDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .accuracy)
        accuracy = accuracyDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .precision)
        precision = precisionDecoded
        let recallDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .recall)
        recall = recallDecoded
        let f1ScoreDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .f1Score)
        f1Score = f1ScoreDecoded
        let microPrecisionDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .microPrecision)
        microPrecision = microPrecisionDecoded
        let microRecallDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .microRecall)
        microRecall = microRecallDecoded
        let microF1ScoreDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .microF1Score)
        microF1Score = microF1ScoreDecoded
        let hammingLossDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .hammingLoss)
        hammingLoss = hammingLossDecoded
    }
}

extension ClassifierEvaluationMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClassifierEvaluationMetrics(accuracy: \(String(describing: accuracy)), f1Score: \(String(describing: f1Score)), hammingLoss: \(String(describing: hammingLoss)), microF1Score: \(String(describing: microF1Score)), microPrecision: \(String(describing: microPrecision)), microRecall: \(String(describing: microRecall)), precision: \(String(describing: precision)), recall: \(String(describing: recall)))"}
}

/// <p>Describes the result metrics for the test data associated with an documentation
///       classifier.</p>
public struct ClassifierEvaluationMetrics: Equatable {
    /// <p>The fraction of the labels that were correct recognized. It is computed by dividing the
    ///       number of labels in the test documents that were correctly recognized by the total number of
    ///       labels in the test documents.</p>
    public let accuracy: Double?
    /// <p>A measure of how accurate the classifier results are for the test data. It is derived from
    ///       the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the
    ///       harmonic average of the two scores. The highest score is 1, and the worst score is 0. </p>
    public let f1Score: Double?
    /// <p>Indicates the fraction of labels that are incorrectly predicted. Also seen as the fraction
    ///       of wrong labels compared to the total number of labels. Scores closer to zero are
    ///       better.</p>
    public let hammingLoss: Double?
    /// <p>A measure of how accurate the classifier results are for the test data. It is a
    ///       combination of the <code>Micro Precision</code> and <code>Micro Recall</code> values. The
    ///         <code>Micro F1Score</code> is the harmonic mean of the two scores. The highest score is 1,
    ///       and the worst score is 0.</p>
    public let microF1Score: Double?
    /// <p>A measure of the usefulness of the recognizer results in the test data. High precision
    ///       means that the recognizer returned substantially more relevant results than irrelevant ones.
    ///       Unlike the Precision metric which comes from averaging the precision of all available labels,
    ///       this is based on the overall score of all precision scores added together.</p>
    public let microPrecision: Double?
    /// <p>A measure of how complete the classifier results are for the test data. High recall means
    ///       that the classifier returned most of the relevant results. Specifically, this indicates how
    ///       many of the correct categories in the text that the model can predict. It is a percentage of
    ///       correct categories in the text that can found. Instead of averaging the recall scores of all
    ///       labels (as with Recall), micro Recall is based on the overall score of all recall scores added
    ///       together.</p>
    public let microRecall: Double?
    /// <p>A measure of the usefulness of the classifier results in the test data. High precision
    ///       means that the classifier returned substantially more relevant results than irrelevant
    ///       ones.</p>
    public let precision: Double?
    /// <p>A measure of how complete the classifier results are for the test data. High recall means
    ///       that the classifier returned most of the relevant results. </p>
    public let recall: Double?

    public init (
        accuracy: Double? = nil,
        f1Score: Double? = nil,
        hammingLoss: Double? = nil,
        microF1Score: Double? = nil,
        microPrecision: Double? = nil,
        microRecall: Double? = nil,
        precision: Double? = nil,
        recall: Double? = nil
    )
    {
        self.accuracy = accuracy
        self.f1Score = f1Score
        self.hammingLoss = hammingLoss
        self.microF1Score = microF1Score
        self.microPrecision = microPrecision
        self.microRecall = microRecall
        self.precision = precision
        self.recall = recall
    }
}

extension ClassifierMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evaluationMetrics = "EvaluationMetrics"
        case numberOfLabels = "NumberOfLabels"
        case numberOfTestDocuments = "NumberOfTestDocuments"
        case numberOfTrainedDocuments = "NumberOfTrainedDocuments"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationMetrics = evaluationMetrics {
            try encodeContainer.encode(evaluationMetrics, forKey: .evaluationMetrics)
        }
        if let numberOfLabels = numberOfLabels {
            try encodeContainer.encode(numberOfLabels, forKey: .numberOfLabels)
        }
        if let numberOfTestDocuments = numberOfTestDocuments {
            try encodeContainer.encode(numberOfTestDocuments, forKey: .numberOfTestDocuments)
        }
        if let numberOfTrainedDocuments = numberOfTrainedDocuments {
            try encodeContainer.encode(numberOfTrainedDocuments, forKey: .numberOfTrainedDocuments)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfLabelsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfLabels)
        numberOfLabels = numberOfLabelsDecoded
        let numberOfTrainedDocumentsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfTrainedDocuments)
        numberOfTrainedDocuments = numberOfTrainedDocumentsDecoded
        let numberOfTestDocumentsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfTestDocuments)
        numberOfTestDocuments = numberOfTestDocumentsDecoded
        let evaluationMetricsDecoded = try containerValues.decodeIfPresent(ClassifierEvaluationMetrics.self, forKey: .evaluationMetrics)
        evaluationMetrics = evaluationMetricsDecoded
    }
}

extension ClassifierMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>Provides information about a document classifier.</p>
public struct ClassifierMetadata: Equatable {
    /// <p> Describes the result metrics for the test data associated with an documentation
    ///       classifier.</p>
    public let evaluationMetrics: ClassifierEvaluationMetrics?
    /// <p>The number of labels in the input data. </p>
    public let numberOfLabels: Int?
    /// <p>The number of documents in the input data that were used to test the classifier. Typically
    ///       this is 10 to 20 percent of the input documents, up to 10,000 documents.</p>
    public let numberOfTestDocuments: Int?
    /// <p>The number of documents in the input data that were used to train the classifier.
    ///       Typically this is 80 to 90 percent of the input documents.</p>
    public let numberOfTrainedDocuments: Int?

    public init (
        evaluationMetrics: ClassifierEvaluationMetrics? = nil,
        numberOfLabels: Int? = nil,
        numberOfTestDocuments: Int? = nil,
        numberOfTrainedDocuments: Int? = nil
    )
    {
        self.evaluationMetrics = evaluationMetrics
        self.numberOfLabels = numberOfLabels
        self.numberOfTestDocuments = numberOfTestDocuments
        self.numberOfTrainedDocuments = numberOfTrainedDocuments
    }
}

public struct ClassifyDocumentInputBodyMiddleware: Middleware {
    public let id: String = "ClassifyDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ClassifyDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<ClassifyDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ClassifyDocumentInput>
    public typealias MOutput = OperationOutput<ClassifyDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ClassifyDocumentOutputError>
}

extension ClassifyDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClassifyDocumentInput(endpointArn: \(String(describing: endpointArn)), text: \(String(describing: text)))"}
}

extension ClassifyDocumentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct ClassifyDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "ClassifyDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ClassifyDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<ClassifyDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ClassifyDocumentInput>
    public typealias MOutput = OperationOutput<ClassifyDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ClassifyDocumentOutputError>
}

public struct ClassifyDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "ClassifyDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ClassifyDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<ClassifyDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ClassifyDocumentInput>
    public typealias MOutput = OperationOutput<ClassifyDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ClassifyDocumentOutputError>
}

public struct ClassifyDocumentInput: Equatable {
    /// <p>The Amazon Resource Number (ARN) of the endpoint.</p>
    public let endpointArn: String?
    /// <p>The document text to be analyzed.</p>
    public let text: String?

    public init (
        endpointArn: String? = nil,
        text: String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.text = text
    }
}

struct ClassifyDocumentInputBody: Equatable {
    public let text: String?
    public let endpointArn: String?
}

extension ClassifyDocumentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension ClassifyDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ClassifyDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ClassifyDocumentOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceUnavailableException(ResourceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ClassifyDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

extension ClassifyDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ClassifyDocumentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.classes = output.classes
            self.labels = output.labels
        } else {
            self.classes = nil
            self.labels = nil
        }
    }
}

public struct ClassifyDocumentOutputResponse: Equatable {
    /// <p>The classes used by the document being analyzed. These are used for multi-class trained
    ///       models. Individual classes are mutually exclusive and each document is expected to have only a
    ///       single class assigned to it. For example, an animal can be a dog or a cat, but not both at the
    ///       same time. </p>
    public let classes: [DocumentClass]?
    /// <p>The labels used the document being analyzed. These are used for multi-label trained
    ///       models. Individual labels represent different categories that are related in some manner and
    ///       are not mutually exclusive. For example, a movie can be just an action movie, or it can be an
    ///       action movie, a science fiction movie, and a comedy, all at the same time. </p>
    public let labels: [DocumentLabel]?

    public init (
        classes: [DocumentClass]? = nil,
        labels: [DocumentLabel]? = nil
    )
    {
        self.classes = classes
        self.labels = labels
    }
}

struct ClassifyDocumentOutputResponseBody: Equatable {
    public let classes: [DocumentClass]?
    public let labels: [DocumentLabel]?
}

extension ClassifyDocumentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case classes = "Classes"
        case labels = "Labels"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classesContainer = try containerValues.decodeIfPresent([DocumentClass?].self, forKey: .classes)
        var classesDecoded0:[DocumentClass]? = nil
        if let classesContainer = classesContainer {
            classesDecoded0 = [DocumentClass]()
            for structure0 in classesContainer {
                if let structure0 = structure0 {
                    classesDecoded0?.append(structure0)
                }
            }
        }
        classes = classesDecoded0
        let labelsContainer = try containerValues.decodeIfPresent([DocumentLabel?].self, forKey: .labels)
        var labelsDecoded0:[DocumentLabel]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [DocumentLabel]()
            for structure0 in labelsContainer {
                if let structure0 = structure0 {
                    labelsDecoded0?.append(structure0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Concurrent modification of the tags associated with an Amazon Comprehend resource is not
///       supported. </p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ContainsPiiEntitiesInputBodyMiddleware: Middleware {
    public let id: String = "ContainsPiiEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ContainsPiiEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ContainsPiiEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ContainsPiiEntitiesInput>
    public typealias MOutput = OperationOutput<ContainsPiiEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ContainsPiiEntitiesOutputError>
}

extension ContainsPiiEntitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContainsPiiEntitiesInput(languageCode: \(String(describing: languageCode)), text: \(String(describing: text)))"}
}

extension ContainsPiiEntitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct ContainsPiiEntitiesInputHeadersMiddleware: Middleware {
    public let id: String = "ContainsPiiEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ContainsPiiEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ContainsPiiEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ContainsPiiEntitiesInput>
    public typealias MOutput = OperationOutput<ContainsPiiEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ContainsPiiEntitiesOutputError>
}

public struct ContainsPiiEntitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ContainsPiiEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ContainsPiiEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ContainsPiiEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ContainsPiiEntitiesInput>
    public typealias MOutput = OperationOutput<ContainsPiiEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ContainsPiiEntitiesOutputError>
}

public struct ContainsPiiEntitiesInput: Equatable {
    /// <p>The language of the input documents.</p>
    public let languageCode: LanguageCode?
    /// <p>Creates a new document classification request to analyze a single document in real-time,
    ///       returning personally identifiable information (PII) entity labels.</p>
    public let text: String?

    public init (
        languageCode: LanguageCode? = nil,
        text: String? = nil
    )
    {
        self.languageCode = languageCode
        self.text = text
    }
}

struct ContainsPiiEntitiesInputBody: Equatable {
    public let text: String?
    public let languageCode: LanguageCode?
}

extension ContainsPiiEntitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension ContainsPiiEntitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ContainsPiiEntitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguageException" : self = .unsupportedLanguageException(try UnsupportedLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ContainsPiiEntitiesOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unsupportedLanguageException(UnsupportedLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ContainsPiiEntitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContainsPiiEntitiesOutputResponse(labels: \(String(describing: labels)))"}
}

extension ContainsPiiEntitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ContainsPiiEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.labels = output.labels
        } else {
            self.labels = nil
        }
    }
}

public struct ContainsPiiEntitiesOutputResponse: Equatable {
    /// <p>The labels used in the document being analyzed. Individual labels represent personally
    ///       identifiable information (PII) entity types.</p>
    public let labels: [EntityLabel]?

    public init (
        labels: [EntityLabel]? = nil
    )
    {
        self.labels = labels
    }
}

struct ContainsPiiEntitiesOutputResponseBody: Equatable {
    public let labels: [EntityLabel]?
}

extension ContainsPiiEntitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case labels = "Labels"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelsContainer = try containerValues.decodeIfPresent([EntityLabel?].self, forKey: .labels)
        var labelsDecoded0:[EntityLabel]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [EntityLabel]()
            for structure0 in labelsContainer {
                if let structure0 = structure0 {
                    labelsDecoded0?.append(structure0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

public struct CreateDocumentClassifierInputBodyMiddleware: Middleware {
    public let id: String = "CreateDocumentClassifierInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDocumentClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDocumentClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDocumentClassifierInput>
    public typealias MOutput = OperationOutput<CreateDocumentClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDocumentClassifierOutputError>
}

extension CreateDocumentClassifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDocumentClassifierInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), documentClassifierName: \(String(describing: documentClassifierName)), inputDataConfig: \(String(describing: inputDataConfig)), languageCode: \(String(describing: languageCode)), mode: \(String(describing: mode)), modelKmsKeyId: \(String(describing: modelKmsKeyId)), outputDataConfig: \(String(describing: outputDataConfig)), tags: \(String(describing: tags)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension CreateDocumentClassifierInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case documentClassifierName = "DocumentClassifierName"
        case inputDataConfig = "InputDataConfig"
        case languageCode = "LanguageCode"
        case mode = "Mode"
        case modelKmsKeyId = "ModelKmsKeyId"
        case outputDataConfig = "OutputDataConfig"
        case tags = "Tags"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let documentClassifierName = documentClassifierName {
            try encodeContainer.encode(documentClassifierName, forKey: .documentClassifierName)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let modelKmsKeyId = modelKmsKeyId {
            try encodeContainer.encode(modelKmsKeyId, forKey: .modelKmsKeyId)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateDocumentClassifierInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDocumentClassifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDocumentClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDocumentClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDocumentClassifierInput>
    public typealias MOutput = OperationOutput<CreateDocumentClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDocumentClassifierOutputError>
}

public struct CreateDocumentClassifierInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDocumentClassifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDocumentClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDocumentClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDocumentClassifierInput>
    public typealias MOutput = OperationOutput<CreateDocumentClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDocumentClassifierOutputError>
}

public struct CreateDocumentClassifierInput: Equatable {
    /// <p>A unique identifier for the request. If you don't set the client request token, Amazon
    ///       Comprehend generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants
    ///       Amazon Comprehend read access to your input data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The name of the document classifier.</p>
    public let documentClassifierName: String?
    /// <p>Specifies the format and location of the input data for the job.</p>
    public let inputDataConfig: DocumentClassifierInputDataConfig?
    /// <p>The language of the input documents. You can specify any of the following languages
    ///       supported by Amazon Comprehend: German ("de"), English ("en"), Spanish ("es"), French ("fr"),
    ///       Italian ("it"), or Portuguese ("pt"). All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>Indicates the mode in which the classifier will be trained. The classifier can be trained
    ///       in multi-class mode, which identifies one and only one class for each document, or multi-label
    ///       mode, which identifies one or more labels for each document. In multi-label mode, multiple
    ///       labels for an individual document are separated by a delimiter. The default delimiter between
    ///       labels is a pipe (|).</p>
    public let mode: DocumentClassifierMode?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       trained custom models. The ModelKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let modelKmsKeyId: String?
    /// <p>Enables the addition of output results configuration parameters for custom classifier
    ///       jobs.</p>
    public let outputDataConfig: DocumentClassifierOutputDataConfig?
    /// <p>Tags to be associated with the document classifier being created. A tag is a key-value
    ///       pair that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with
    ///       "Sales" as the key might be added to a resource to indicate its use by the sales department.
    ///     </p>
    public let tags: [Tag]?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    ///       the resources you are using for your custom classifier. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        documentClassifierName: String? = nil,
        inputDataConfig: DocumentClassifierInputDataConfig? = nil,
        languageCode: LanguageCode? = nil,
        mode: DocumentClassifierMode? = nil,
        modelKmsKeyId: String? = nil,
        outputDataConfig: DocumentClassifierOutputDataConfig? = nil,
        tags: [Tag]? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.documentClassifierName = documentClassifierName
        self.inputDataConfig = inputDataConfig
        self.languageCode = languageCode
        self.mode = mode
        self.modelKmsKeyId = modelKmsKeyId
        self.outputDataConfig = outputDataConfig
        self.tags = tags
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

struct CreateDocumentClassifierInputBody: Equatable {
    public let documentClassifierName: String?
    public let dataAccessRoleArn: String?
    public let tags: [Tag]?
    public let inputDataConfig: DocumentClassifierInputDataConfig?
    public let outputDataConfig: DocumentClassifierOutputDataConfig?
    public let clientRequestToken: String?
    public let languageCode: LanguageCode?
    public let volumeKmsKeyId: String?
    public let vpcConfig: VpcConfig?
    public let mode: DocumentClassifierMode?
    public let modelKmsKeyId: String?
}

extension CreateDocumentClassifierInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case documentClassifierName = "DocumentClassifierName"
        case inputDataConfig = "InputDataConfig"
        case languageCode = "LanguageCode"
        case mode = "Mode"
        case modelKmsKeyId = "ModelKmsKeyId"
        case outputDataConfig = "OutputDataConfig"
        case tags = "Tags"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentClassifierNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentClassifierName)
        documentClassifierName = documentClassifierNameDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(DocumentClassifierInputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(DocumentClassifierOutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let modeDecoded = try containerValues.decodeIfPresent(DocumentClassifierMode.self, forKey: .mode)
        mode = modeDecoded
        let modelKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelKmsKeyId)
        modelKmsKeyId = modelKmsKeyIdDecoded
    }
}

extension CreateDocumentClassifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDocumentClassifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyValidationException" : self = .kmsKeyValidationException(try KmsKeyValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguageException" : self = .unsupportedLanguageException(try UnsupportedLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDocumentClassifierOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case kmsKeyValidationException(KmsKeyValidationException)
    case resourceInUseException(ResourceInUseException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case tooManyTagsException(TooManyTagsException)
    case unsupportedLanguageException(UnsupportedLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDocumentClassifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDocumentClassifierOutputResponse(documentClassifierArn: \(String(describing: documentClassifierArn)))"}
}

extension CreateDocumentClassifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDocumentClassifierOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documentClassifierArn = output.documentClassifierArn
        } else {
            self.documentClassifierArn = nil
        }
    }
}

public struct CreateDocumentClassifierOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier.</p>
    public let documentClassifierArn: String?

    public init (
        documentClassifierArn: String? = nil
    )
    {
        self.documentClassifierArn = documentClassifierArn
    }
}

struct CreateDocumentClassifierOutputResponseBody: Equatable {
    public let documentClassifierArn: String?
}

extension CreateDocumentClassifierOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentClassifierArn = "DocumentClassifierArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentClassifierArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentClassifierArn)
        documentClassifierArn = documentClassifierArnDecoded
    }
}

public struct CreateEndpointInputBodyMiddleware: Middleware {
    public let id: String = "CreateEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEndpointInput>
    public typealias MOutput = OperationOutput<CreateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEndpointOutputError>
}

extension CreateEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEndpointInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), desiredInferenceUnits: \(String(describing: desiredInferenceUnits)), endpointName: \(String(describing: endpointName)), modelArn: \(String(describing: modelArn)), tags: \(String(describing: tags)))"}
}

extension CreateEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case desiredInferenceUnits = "DesiredInferenceUnits"
        case endpointName = "EndpointName"
        case modelArn = "ModelArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let desiredInferenceUnits = desiredInferenceUnits {
            try encodeContainer.encode(desiredInferenceUnits, forKey: .desiredInferenceUnits)
        }
        if let endpointName = endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
        if let modelArn = modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEndpointInput>
    public typealias MOutput = OperationOutput<CreateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEndpointOutputError>
}

public struct CreateEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEndpointInput>
    public typealias MOutput = OperationOutput<CreateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEndpointOutputError>
}

public struct CreateEndpointInput: Equatable {
    /// <p>An idempotency token provided by the customer. If this token matches a previous endpoint
    ///       creation request, Amazon Comprehend will not return a <code>ResourceInUseException</code>.
    ///     </p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend read access to trained custom models encrypted with a customer
    ///       managed key (ModelKmsKeyId).</p>
    public let dataAccessRoleArn: String?
    /// <p> The desired number of inference units to be used by the model using this endpoint.
    ///
    ///       Each inference unit represents of a throughput of 100 characters per second.</p>
    public let desiredInferenceUnits: Int?
    /// <p>This is the descriptive suffix that becomes part of the <code>EndpointArn</code> used for
    ///       all subsequent requests to this resource. </p>
    public let endpointName: String?
    /// <p>The Amazon Resource Number (ARN) of the model to which the endpoint will be
    ///       attached.</p>
    public let modelArn: String?
    /// <p>Tags associated with the endpoint being created. A tag is a key-value pair that adds
    ///       metadata to the endpoint. For example, a tag with "Sales" as the key might be added to an
    ///       endpoint to indicate its use by the sales department. </p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        desiredInferenceUnits: Int? = nil,
        endpointName: String? = nil,
        modelArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.desiredInferenceUnits = desiredInferenceUnits
        self.endpointName = endpointName
        self.modelArn = modelArn
        self.tags = tags
    }
}

struct CreateEndpointInputBody: Equatable {
    public let endpointName: String?
    public let modelArn: String?
    public let desiredInferenceUnits: Int?
    public let clientRequestToken: String?
    public let tags: [Tag]?
    public let dataAccessRoleArn: String?
}

extension CreateEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case desiredInferenceUnits = "DesiredInferenceUnits"
        case endpointName = "EndpointName"
        case modelArn = "ModelArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let desiredInferenceUnitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .desiredInferenceUnits)
        desiredInferenceUnits = desiredInferenceUnitsDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension CreateEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEndpointOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEndpointOutputResponse(endpointArn: \(String(describing: endpointArn)))"}
}

extension CreateEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointArn = output.endpointArn
        } else {
            self.endpointArn = nil
        }
    }
}

public struct CreateEndpointOutputResponse: Equatable {
    /// <p>The Amazon Resource Number (ARN) of the endpoint being created.</p>
    public let endpointArn: String?

    public init (
        endpointArn: String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct CreateEndpointOutputResponseBody: Equatable {
    public let endpointArn: String?
}

extension CreateEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

public struct CreateEntityRecognizerInputBodyMiddleware: Middleware {
    public let id: String = "CreateEntityRecognizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEntityRecognizerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEntityRecognizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEntityRecognizerInput>
    public typealias MOutput = OperationOutput<CreateEntityRecognizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEntityRecognizerOutputError>
}

extension CreateEntityRecognizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEntityRecognizerInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), inputDataConfig: \(String(describing: inputDataConfig)), languageCode: \(String(describing: languageCode)), modelKmsKeyId: \(String(describing: modelKmsKeyId)), recognizerName: \(String(describing: recognizerName)), tags: \(String(describing: tags)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension CreateEntityRecognizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case languageCode = "LanguageCode"
        case modelKmsKeyId = "ModelKmsKeyId"
        case recognizerName = "RecognizerName"
        case tags = "Tags"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let modelKmsKeyId = modelKmsKeyId {
            try encodeContainer.encode(modelKmsKeyId, forKey: .modelKmsKeyId)
        }
        if let recognizerName = recognizerName {
            try encodeContainer.encode(recognizerName, forKey: .recognizerName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateEntityRecognizerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEntityRecognizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEntityRecognizerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEntityRecognizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEntityRecognizerInput>
    public typealias MOutput = OperationOutput<CreateEntityRecognizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEntityRecognizerOutputError>
}

public struct CreateEntityRecognizerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEntityRecognizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEntityRecognizerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEntityRecognizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEntityRecognizerInput>
    public typealias MOutput = OperationOutput<CreateEntityRecognizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEntityRecognizerOutputError>
}

public struct CreateEntityRecognizerInput: Equatable {
    /// <p> A unique identifier for the request. If you don't set the client request token, Amazon
    ///       Comprehend generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants
    ///       Amazon Comprehend read access to your input data.</p>
    public let dataAccessRoleArn: String?
    /// <p>Specifies the format and location of the input data. The S3 bucket containing the input
    ///       data must be located in the same region as the entity recognizer being created. </p>
    public let inputDataConfig: EntityRecognizerInputDataConfig?
    /// <p> You can specify any of the following languages supported by Amazon Comprehend: English
    ///       ("en"), Spanish ("es"), French ("fr"), Italian ("it"), German ("de"), or Portuguese ("pt").
    ///       All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       trained custom models. The ModelKmsKeyId can be either of the following formats</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let modelKmsKeyId: String?
    /// <p>The name given to the newly created recognizer. Recognizer names can be a maximum of 256
    ///       characters. Alphanumeric characters, hyphens (-) and underscores (_) are allowed. The name
    ///       must be unique in the account/region.</p>
    public let recognizerName: String?
    /// <p>Tags to be associated with the entity recognizer being created. A tag is a key-value pair
    ///       that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with
    ///       "Sales" as the key might be added to a resource to indicate its use by the sales department.
    ///     </p>
    public let tags: [Tag]?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    ///       the resources you are using for your custom entity recognizer. For more information, see
    ///         <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        inputDataConfig: EntityRecognizerInputDataConfig? = nil,
        languageCode: LanguageCode? = nil,
        modelKmsKeyId: String? = nil,
        recognizerName: String? = nil,
        tags: [Tag]? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.languageCode = languageCode
        self.modelKmsKeyId = modelKmsKeyId
        self.recognizerName = recognizerName
        self.tags = tags
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

struct CreateEntityRecognizerInputBody: Equatable {
    public let recognizerName: String?
    public let dataAccessRoleArn: String?
    public let tags: [Tag]?
    public let inputDataConfig: EntityRecognizerInputDataConfig?
    public let clientRequestToken: String?
    public let languageCode: LanguageCode?
    public let volumeKmsKeyId: String?
    public let vpcConfig: VpcConfig?
    public let modelKmsKeyId: String?
}

extension CreateEntityRecognizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case languageCode = "LanguageCode"
        case modelKmsKeyId = "ModelKmsKeyId"
        case recognizerName = "RecognizerName"
        case tags = "Tags"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recognizerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recognizerName)
        recognizerName = recognizerNameDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(EntityRecognizerInputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let modelKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelKmsKeyId)
        modelKmsKeyId = modelKmsKeyIdDecoded
    }
}

extension CreateEntityRecognizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEntityRecognizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyValidationException" : self = .kmsKeyValidationException(try KmsKeyValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguageException" : self = .unsupportedLanguageException(try UnsupportedLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEntityRecognizerOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case kmsKeyValidationException(KmsKeyValidationException)
    case resourceInUseException(ResourceInUseException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case tooManyTagsException(TooManyTagsException)
    case unsupportedLanguageException(UnsupportedLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEntityRecognizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEntityRecognizerOutputResponse(entityRecognizerArn: \(String(describing: entityRecognizerArn)))"}
}

extension CreateEntityRecognizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEntityRecognizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entityRecognizerArn = output.entityRecognizerArn
        } else {
            self.entityRecognizerArn = nil
        }
    }
}

public struct CreateEntityRecognizerOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    public let entityRecognizerArn: String?

    public init (
        entityRecognizerArn: String? = nil
    )
    {
        self.entityRecognizerArn = entityRecognizerArn
    }
}

struct CreateEntityRecognizerOutputResponseBody: Equatable {
    public let entityRecognizerArn: String?
}

extension CreateEntityRecognizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityRecognizerArn = "EntityRecognizerArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityRecognizerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityRecognizerArn)
        entityRecognizerArn = entityRecognizerArnDecoded
    }
}

public struct DeleteDocumentClassifierInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDocumentClassifierInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDocumentClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDocumentClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDocumentClassifierInput>
    public typealias MOutput = OperationOutput<DeleteDocumentClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDocumentClassifierOutputError>
}

extension DeleteDocumentClassifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDocumentClassifierInput(documentClassifierArn: \(String(describing: documentClassifierArn)))"}
}

extension DeleteDocumentClassifierInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentClassifierArn = "DocumentClassifierArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentClassifierArn = documentClassifierArn {
            try encodeContainer.encode(documentClassifierArn, forKey: .documentClassifierArn)
        }
    }
}

public struct DeleteDocumentClassifierInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDocumentClassifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDocumentClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDocumentClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDocumentClassifierInput>
    public typealias MOutput = OperationOutput<DeleteDocumentClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDocumentClassifierOutputError>
}

public struct DeleteDocumentClassifierInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDocumentClassifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDocumentClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDocumentClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDocumentClassifierInput>
    public typealias MOutput = OperationOutput<DeleteDocumentClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDocumentClassifierOutputError>
}

public struct DeleteDocumentClassifierInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier. </p>
    public let documentClassifierArn: String?

    public init (
        documentClassifierArn: String? = nil
    )
    {
        self.documentClassifierArn = documentClassifierArn
    }
}

struct DeleteDocumentClassifierInputBody: Equatable {
    public let documentClassifierArn: String?
}

extension DeleteDocumentClassifierInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentClassifierArn = "DocumentClassifierArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentClassifierArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentClassifierArn)
        documentClassifierArn = documentClassifierArnDecoded
    }
}

extension DeleteDocumentClassifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDocumentClassifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDocumentClassifierOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDocumentClassifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDocumentClassifierOutputResponse()"}
}

extension DeleteDocumentClassifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDocumentClassifierOutputResponse: Equatable {

    public init() {}
}

struct DeleteDocumentClassifierOutputResponseBody: Equatable {
}

extension DeleteDocumentClassifierOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteEndpointInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointOutputError>
}

extension DeleteEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEndpointInput(endpointArn: \(String(describing: endpointArn)))"}
}

extension DeleteEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
    }
}

public struct DeleteEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointOutputError>
}

public struct DeleteEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointOutputError>
}

public struct DeleteEndpointInput: Equatable {
    /// <p>The Amazon Resource Number (ARN) of the endpoint being deleted.</p>
    public let endpointArn: String?

    public init (
        endpointArn: String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct DeleteEndpointInputBody: Equatable {
    public let endpointArn: String?
}

extension DeleteEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DeleteEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEndpointOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEndpointOutputResponse()"}
}

extension DeleteEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEndpointOutputResponse: Equatable {

    public init() {}
}

struct DeleteEndpointOutputResponseBody: Equatable {
}

extension DeleteEndpointOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteEntityRecognizerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEntityRecognizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEntityRecognizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEntityRecognizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEntityRecognizerInput>
    public typealias MOutput = OperationOutput<DeleteEntityRecognizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEntityRecognizerOutputError>
}

extension DeleteEntityRecognizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEntityRecognizerInput(entityRecognizerArn: \(String(describing: entityRecognizerArn)))"}
}

extension DeleteEntityRecognizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityRecognizerArn = "EntityRecognizerArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityRecognizerArn = entityRecognizerArn {
            try encodeContainer.encode(entityRecognizerArn, forKey: .entityRecognizerArn)
        }
    }
}

public struct DeleteEntityRecognizerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEntityRecognizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEntityRecognizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEntityRecognizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEntityRecognizerInput>
    public typealias MOutput = OperationOutput<DeleteEntityRecognizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEntityRecognizerOutputError>
}

public struct DeleteEntityRecognizerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEntityRecognizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEntityRecognizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEntityRecognizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEntityRecognizerInput>
    public typealias MOutput = OperationOutput<DeleteEntityRecognizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEntityRecognizerOutputError>
}

public struct DeleteEntityRecognizerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    public let entityRecognizerArn: String?

    public init (
        entityRecognizerArn: String? = nil
    )
    {
        self.entityRecognizerArn = entityRecognizerArn
    }
}

struct DeleteEntityRecognizerInputBody: Equatable {
    public let entityRecognizerArn: String?
}

extension DeleteEntityRecognizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityRecognizerArn = "EntityRecognizerArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityRecognizerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityRecognizerArn)
        entityRecognizerArn = entityRecognizerArnDecoded
    }
}

extension DeleteEntityRecognizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEntityRecognizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEntityRecognizerOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEntityRecognizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEntityRecognizerOutputResponse()"}
}

extension DeleteEntityRecognizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEntityRecognizerOutputResponse: Equatable {

    public init() {}
}

struct DeleteEntityRecognizerOutputResponseBody: Equatable {
}

extension DeleteEntityRecognizerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeDocumentClassificationJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDocumentClassificationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentClassificationJobInput>
    public typealias MOutput = OperationOutput<DescribeDocumentClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentClassificationJobOutputError>
}

extension DescribeDocumentClassificationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDocumentClassificationJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeDocumentClassificationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeDocumentClassificationJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDocumentClassificationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentClassificationJobInput>
    public typealias MOutput = OperationOutput<DescribeDocumentClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentClassificationJobOutputError>
}

public struct DescribeDocumentClassificationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDocumentClassificationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentClassificationJobInput>
    public typealias MOutput = OperationOutput<DescribeDocumentClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentClassificationJobOutputError>
}

public struct DescribeDocumentClassificationJobInput: Equatable {
    /// <p>The identifier that Amazon Comprehend generated for the job. The  operation returns this identifier in its
    ///       response.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeDocumentClassificationJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeDocumentClassificationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeDocumentClassificationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDocumentClassificationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDocumentClassificationJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDocumentClassificationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDocumentClassificationJobOutputResponse(documentClassificationJobProperties: \(String(describing: documentClassificationJobProperties)))"}
}

extension DescribeDocumentClassificationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDocumentClassificationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documentClassificationJobProperties = output.documentClassificationJobProperties
        } else {
            self.documentClassificationJobProperties = nil
        }
    }
}

public struct DescribeDocumentClassificationJobOutputResponse: Equatable {
    /// <p>An object that describes the properties associated with the document classification
    ///       job.</p>
    public let documentClassificationJobProperties: DocumentClassificationJobProperties?

    public init (
        documentClassificationJobProperties: DocumentClassificationJobProperties? = nil
    )
    {
        self.documentClassificationJobProperties = documentClassificationJobProperties
    }
}

struct DescribeDocumentClassificationJobOutputResponseBody: Equatable {
    public let documentClassificationJobProperties: DocumentClassificationJobProperties?
}

extension DescribeDocumentClassificationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentClassificationJobProperties = "DocumentClassificationJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentClassificationJobPropertiesDecoded = try containerValues.decodeIfPresent(DocumentClassificationJobProperties.self, forKey: .documentClassificationJobProperties)
        documentClassificationJobProperties = documentClassificationJobPropertiesDecoded
    }
}

public struct DescribeDocumentClassifierInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDocumentClassifierInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentClassifierInput>
    public typealias MOutput = OperationOutput<DescribeDocumentClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentClassifierOutputError>
}

extension DescribeDocumentClassifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDocumentClassifierInput(documentClassifierArn: \(String(describing: documentClassifierArn)))"}
}

extension DescribeDocumentClassifierInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentClassifierArn = "DocumentClassifierArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentClassifierArn = documentClassifierArn {
            try encodeContainer.encode(documentClassifierArn, forKey: .documentClassifierArn)
        }
    }
}

public struct DescribeDocumentClassifierInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDocumentClassifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentClassifierInput>
    public typealias MOutput = OperationOutput<DescribeDocumentClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentClassifierOutputError>
}

public struct DescribeDocumentClassifierInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDocumentClassifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentClassifierInput>
    public typealias MOutput = OperationOutput<DescribeDocumentClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentClassifierOutputError>
}

public struct DescribeDocumentClassifierInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier. The  operation returns this identifier in its
    ///       response.</p>
    public let documentClassifierArn: String?

    public init (
        documentClassifierArn: String? = nil
    )
    {
        self.documentClassifierArn = documentClassifierArn
    }
}

struct DescribeDocumentClassifierInputBody: Equatable {
    public let documentClassifierArn: String?
}

extension DescribeDocumentClassifierInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentClassifierArn = "DocumentClassifierArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentClassifierArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentClassifierArn)
        documentClassifierArn = documentClassifierArnDecoded
    }
}

extension DescribeDocumentClassifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDocumentClassifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDocumentClassifierOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDocumentClassifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDocumentClassifierOutputResponse(documentClassifierProperties: \(String(describing: documentClassifierProperties)))"}
}

extension DescribeDocumentClassifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDocumentClassifierOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documentClassifierProperties = output.documentClassifierProperties
        } else {
            self.documentClassifierProperties = nil
        }
    }
}

public struct DescribeDocumentClassifierOutputResponse: Equatable {
    /// <p>An object that contains the properties associated with a document classifier.</p>
    public let documentClassifierProperties: DocumentClassifierProperties?

    public init (
        documentClassifierProperties: DocumentClassifierProperties? = nil
    )
    {
        self.documentClassifierProperties = documentClassifierProperties
    }
}

struct DescribeDocumentClassifierOutputResponseBody: Equatable {
    public let documentClassifierProperties: DocumentClassifierProperties?
}

extension DescribeDocumentClassifierOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentClassifierProperties = "DocumentClassifierProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentClassifierPropertiesDecoded = try containerValues.decodeIfPresent(DocumentClassifierProperties.self, forKey: .documentClassifierProperties)
        documentClassifierProperties = documentClassifierPropertiesDecoded
    }
}

public struct DescribeDominantLanguageDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDominantLanguageDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDominantLanguageDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDominantLanguageDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDominantLanguageDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeDominantLanguageDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDominantLanguageDetectionJobOutputError>
}

extension DescribeDominantLanguageDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDominantLanguageDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeDominantLanguageDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeDominantLanguageDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDominantLanguageDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDominantLanguageDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDominantLanguageDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDominantLanguageDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeDominantLanguageDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDominantLanguageDetectionJobOutputError>
}

public struct DescribeDominantLanguageDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDominantLanguageDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDominantLanguageDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDominantLanguageDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDominantLanguageDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeDominantLanguageDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDominantLanguageDetectionJobOutputError>
}

public struct DescribeDominantLanguageDetectionJobInput: Equatable {
    /// <p>The identifier that Amazon Comprehend generated for the job. The  operation returns this identifier in its
    ///       response.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeDominantLanguageDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeDominantLanguageDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeDominantLanguageDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDominantLanguageDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDominantLanguageDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDominantLanguageDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDominantLanguageDetectionJobOutputResponse(dominantLanguageDetectionJobProperties: \(String(describing: dominantLanguageDetectionJobProperties)))"}
}

extension DescribeDominantLanguageDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDominantLanguageDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dominantLanguageDetectionJobProperties = output.dominantLanguageDetectionJobProperties
        } else {
            self.dominantLanguageDetectionJobProperties = nil
        }
    }
}

public struct DescribeDominantLanguageDetectionJobOutputResponse: Equatable {
    /// <p>An object that contains the properties associated with a dominant language detection
    ///       job.</p>
    public let dominantLanguageDetectionJobProperties: DominantLanguageDetectionJobProperties?

    public init (
        dominantLanguageDetectionJobProperties: DominantLanguageDetectionJobProperties? = nil
    )
    {
        self.dominantLanguageDetectionJobProperties = dominantLanguageDetectionJobProperties
    }
}

struct DescribeDominantLanguageDetectionJobOutputResponseBody: Equatable {
    public let dominantLanguageDetectionJobProperties: DominantLanguageDetectionJobProperties?
}

extension DescribeDominantLanguageDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dominantLanguageDetectionJobProperties = "DominantLanguageDetectionJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dominantLanguageDetectionJobPropertiesDecoded = try containerValues.decodeIfPresent(DominantLanguageDetectionJobProperties.self, forKey: .dominantLanguageDetectionJobProperties)
        dominantLanguageDetectionJobProperties = dominantLanguageDetectionJobPropertiesDecoded
    }
}

public struct DescribeEndpointInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointInput>
    public typealias MOutput = OperationOutput<DescribeEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointOutputError>
}

extension DescribeEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointInput(endpointArn: \(String(describing: endpointArn)))"}
}

extension DescribeEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
    }
}

public struct DescribeEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointInput>
    public typealias MOutput = OperationOutput<DescribeEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointOutputError>
}

public struct DescribeEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointInput>
    public typealias MOutput = OperationOutput<DescribeEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointOutputError>
}

public struct DescribeEndpointInput: Equatable {
    /// <p>The Amazon Resource Number (ARN) of the endpoint being described.</p>
    public let endpointArn: String?

    public init (
        endpointArn: String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct DescribeEndpointInputBody: Equatable {
    public let endpointArn: String?
}

extension DescribeEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DescribeEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointOutputResponse(endpointProperties: \(String(describing: endpointProperties)))"}
}

extension DescribeEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointProperties = output.endpointProperties
        } else {
            self.endpointProperties = nil
        }
    }
}

public struct DescribeEndpointOutputResponse: Equatable {
    /// <p>Describes information associated with the specific endpoint.</p>
    public let endpointProperties: EndpointProperties?

    public init (
        endpointProperties: EndpointProperties? = nil
    )
    {
        self.endpointProperties = endpointProperties
    }
}

struct DescribeEndpointOutputResponseBody: Equatable {
    public let endpointProperties: EndpointProperties?
}

extension DescribeEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointProperties = "EndpointProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointPropertiesDecoded = try containerValues.decodeIfPresent(EndpointProperties.self, forKey: .endpointProperties)
        endpointProperties = endpointPropertiesDecoded
    }
}

public struct DescribeEntitiesDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEntitiesDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntitiesDetectionJobOutputError>
}

extension DescribeEntitiesDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEntitiesDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeEntitiesDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeEntitiesDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEntitiesDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntitiesDetectionJobOutputError>
}

public struct DescribeEntitiesDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEntitiesDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntitiesDetectionJobOutputError>
}

public struct DescribeEntitiesDetectionJobInput: Equatable {
    /// <p>The identifier that Amazon Comprehend generated for the job. The  operation returns this identifier in its
    ///       response.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeEntitiesDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeEntitiesDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeEntitiesDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEntitiesDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEntitiesDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEntitiesDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEntitiesDetectionJobOutputResponse(entitiesDetectionJobProperties: \(String(describing: entitiesDetectionJobProperties)))"}
}

extension DescribeEntitiesDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEntitiesDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entitiesDetectionJobProperties = output.entitiesDetectionJobProperties
        } else {
            self.entitiesDetectionJobProperties = nil
        }
    }
}

public struct DescribeEntitiesDetectionJobOutputResponse: Equatable {
    /// <p>An object that contains the properties associated with an entities detection job.</p>
    public let entitiesDetectionJobProperties: EntitiesDetectionJobProperties?

    public init (
        entitiesDetectionJobProperties: EntitiesDetectionJobProperties? = nil
    )
    {
        self.entitiesDetectionJobProperties = entitiesDetectionJobProperties
    }
}

struct DescribeEntitiesDetectionJobOutputResponseBody: Equatable {
    public let entitiesDetectionJobProperties: EntitiesDetectionJobProperties?
}

extension DescribeEntitiesDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entitiesDetectionJobProperties = "EntitiesDetectionJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesDetectionJobPropertiesDecoded = try containerValues.decodeIfPresent(EntitiesDetectionJobProperties.self, forKey: .entitiesDetectionJobProperties)
        entitiesDetectionJobProperties = entitiesDetectionJobPropertiesDecoded
    }
}

public struct DescribeEntityRecognizerInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEntityRecognizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntityRecognizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntityRecognizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntityRecognizerInput>
    public typealias MOutput = OperationOutput<DescribeEntityRecognizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntityRecognizerOutputError>
}

extension DescribeEntityRecognizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEntityRecognizerInput(entityRecognizerArn: \(String(describing: entityRecognizerArn)))"}
}

extension DescribeEntityRecognizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityRecognizerArn = "EntityRecognizerArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityRecognizerArn = entityRecognizerArn {
            try encodeContainer.encode(entityRecognizerArn, forKey: .entityRecognizerArn)
        }
    }
}

public struct DescribeEntityRecognizerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEntityRecognizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntityRecognizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntityRecognizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntityRecognizerInput>
    public typealias MOutput = OperationOutput<DescribeEntityRecognizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntityRecognizerOutputError>
}

public struct DescribeEntityRecognizerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEntityRecognizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntityRecognizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntityRecognizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntityRecognizerInput>
    public typealias MOutput = OperationOutput<DescribeEntityRecognizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntityRecognizerOutputError>
}

public struct DescribeEntityRecognizerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    public let entityRecognizerArn: String?

    public init (
        entityRecognizerArn: String? = nil
    )
    {
        self.entityRecognizerArn = entityRecognizerArn
    }
}

struct DescribeEntityRecognizerInputBody: Equatable {
    public let entityRecognizerArn: String?
}

extension DescribeEntityRecognizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityRecognizerArn = "EntityRecognizerArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityRecognizerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityRecognizerArn)
        entityRecognizerArn = entityRecognizerArnDecoded
    }
}

extension DescribeEntityRecognizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEntityRecognizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEntityRecognizerOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEntityRecognizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEntityRecognizerOutputResponse(entityRecognizerProperties: \(String(describing: entityRecognizerProperties)))"}
}

extension DescribeEntityRecognizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEntityRecognizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entityRecognizerProperties = output.entityRecognizerProperties
        } else {
            self.entityRecognizerProperties = nil
        }
    }
}

public struct DescribeEntityRecognizerOutputResponse: Equatable {
    /// <p>Describes information associated with an entity recognizer.</p>
    public let entityRecognizerProperties: EntityRecognizerProperties?

    public init (
        entityRecognizerProperties: EntityRecognizerProperties? = nil
    )
    {
        self.entityRecognizerProperties = entityRecognizerProperties
    }
}

struct DescribeEntityRecognizerOutputResponseBody: Equatable {
    public let entityRecognizerProperties: EntityRecognizerProperties?
}

extension DescribeEntityRecognizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityRecognizerProperties = "EntityRecognizerProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityRecognizerPropertiesDecoded = try containerValues.decodeIfPresent(EntityRecognizerProperties.self, forKey: .entityRecognizerProperties)
        entityRecognizerProperties = entityRecognizerPropertiesDecoded
    }
}

public struct DescribeEventsDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventsDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeEventsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsDetectionJobOutputError>
}

extension DescribeEventsDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeEventsDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeEventsDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventsDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeEventsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsDetectionJobOutputError>
}

public struct DescribeEventsDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventsDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeEventsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsDetectionJobOutputError>
}

public struct DescribeEventsDetectionJobInput: Equatable {
    /// <p>The identifier of the events detection job.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeEventsDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeEventsDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeEventsDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsDetectionJobOutputResponse(eventsDetectionJobProperties: \(String(describing: eventsDetectionJobProperties)))"}
}

extension DescribeEventsDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventsDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventsDetectionJobProperties = output.eventsDetectionJobProperties
        } else {
            self.eventsDetectionJobProperties = nil
        }
    }
}

public struct DescribeEventsDetectionJobOutputResponse: Equatable {
    /// <p>An object that contains the properties associated with an event detection job.</p>
    public let eventsDetectionJobProperties: EventsDetectionJobProperties?

    public init (
        eventsDetectionJobProperties: EventsDetectionJobProperties? = nil
    )
    {
        self.eventsDetectionJobProperties = eventsDetectionJobProperties
    }
}

struct DescribeEventsDetectionJobOutputResponseBody: Equatable {
    public let eventsDetectionJobProperties: EventsDetectionJobProperties?
}

extension DescribeEventsDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventsDetectionJobProperties = "EventsDetectionJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsDetectionJobPropertiesDecoded = try containerValues.decodeIfPresent(EventsDetectionJobProperties.self, forKey: .eventsDetectionJobProperties)
        eventsDetectionJobProperties = eventsDetectionJobPropertiesDecoded
    }
}

public struct DescribeKeyPhrasesDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeKeyPhrasesDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeKeyPhrasesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeKeyPhrasesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeKeyPhrasesDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeKeyPhrasesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeKeyPhrasesDetectionJobOutputError>
}

extension DescribeKeyPhrasesDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeKeyPhrasesDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeKeyPhrasesDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeKeyPhrasesDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeKeyPhrasesDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeKeyPhrasesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeKeyPhrasesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeKeyPhrasesDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeKeyPhrasesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeKeyPhrasesDetectionJobOutputError>
}

public struct DescribeKeyPhrasesDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeKeyPhrasesDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeKeyPhrasesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeKeyPhrasesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeKeyPhrasesDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeKeyPhrasesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeKeyPhrasesDetectionJobOutputError>
}

public struct DescribeKeyPhrasesDetectionJobInput: Equatable {
    /// <p>The identifier that Amazon Comprehend generated for the job. The  operation returns this identifier in its
    ///       response.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeKeyPhrasesDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeKeyPhrasesDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeKeyPhrasesDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeKeyPhrasesDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeKeyPhrasesDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeKeyPhrasesDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeKeyPhrasesDetectionJobOutputResponse(keyPhrasesDetectionJobProperties: \(String(describing: keyPhrasesDetectionJobProperties)))"}
}

extension DescribeKeyPhrasesDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeKeyPhrasesDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyPhrasesDetectionJobProperties = output.keyPhrasesDetectionJobProperties
        } else {
            self.keyPhrasesDetectionJobProperties = nil
        }
    }
}

public struct DescribeKeyPhrasesDetectionJobOutputResponse: Equatable {
    /// <p>An object that contains the properties associated with a key phrases detection job.
    ///     </p>
    public let keyPhrasesDetectionJobProperties: KeyPhrasesDetectionJobProperties?

    public init (
        keyPhrasesDetectionJobProperties: KeyPhrasesDetectionJobProperties? = nil
    )
    {
        self.keyPhrasesDetectionJobProperties = keyPhrasesDetectionJobProperties
    }
}

struct DescribeKeyPhrasesDetectionJobOutputResponseBody: Equatable {
    public let keyPhrasesDetectionJobProperties: KeyPhrasesDetectionJobProperties?
}

extension DescribeKeyPhrasesDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyPhrasesDetectionJobProperties = "KeyPhrasesDetectionJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPhrasesDetectionJobPropertiesDecoded = try containerValues.decodeIfPresent(KeyPhrasesDetectionJobProperties.self, forKey: .keyPhrasesDetectionJobProperties)
        keyPhrasesDetectionJobProperties = keyPhrasesDetectionJobPropertiesDecoded
    }
}

public struct DescribePiiEntitiesDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribePiiEntitiesDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePiiEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePiiEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePiiEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribePiiEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePiiEntitiesDetectionJobOutputError>
}

extension DescribePiiEntitiesDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePiiEntitiesDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribePiiEntitiesDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribePiiEntitiesDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePiiEntitiesDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePiiEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePiiEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePiiEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribePiiEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePiiEntitiesDetectionJobOutputError>
}

public struct DescribePiiEntitiesDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePiiEntitiesDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePiiEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePiiEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePiiEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribePiiEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePiiEntitiesDetectionJobOutputError>
}

public struct DescribePiiEntitiesDetectionJobInput: Equatable {
    /// <p>The identifier that Amazon Comprehend generated for the job. The  operation returns this identifier in its
    ///       response.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribePiiEntitiesDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribePiiEntitiesDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribePiiEntitiesDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePiiEntitiesDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePiiEntitiesDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePiiEntitiesDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePiiEntitiesDetectionJobOutputResponse(piiEntitiesDetectionJobProperties: \(String(describing: piiEntitiesDetectionJobProperties)))"}
}

extension DescribePiiEntitiesDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePiiEntitiesDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.piiEntitiesDetectionJobProperties = output.piiEntitiesDetectionJobProperties
        } else {
            self.piiEntitiesDetectionJobProperties = nil
        }
    }
}

public struct DescribePiiEntitiesDetectionJobOutputResponse: Equatable {
    /// <p>Provides information about a PII entities detection job.</p>
    public let piiEntitiesDetectionJobProperties: PiiEntitiesDetectionJobProperties?

    public init (
        piiEntitiesDetectionJobProperties: PiiEntitiesDetectionJobProperties? = nil
    )
    {
        self.piiEntitiesDetectionJobProperties = piiEntitiesDetectionJobProperties
    }
}

struct DescribePiiEntitiesDetectionJobOutputResponseBody: Equatable {
    public let piiEntitiesDetectionJobProperties: PiiEntitiesDetectionJobProperties?
}

extension DescribePiiEntitiesDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case piiEntitiesDetectionJobProperties = "PiiEntitiesDetectionJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let piiEntitiesDetectionJobPropertiesDecoded = try containerValues.decodeIfPresent(PiiEntitiesDetectionJobProperties.self, forKey: .piiEntitiesDetectionJobProperties)
        piiEntitiesDetectionJobProperties = piiEntitiesDetectionJobPropertiesDecoded
    }
}

public struct DescribeSentimentDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSentimentDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSentimentDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSentimentDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSentimentDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeSentimentDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSentimentDetectionJobOutputError>
}

extension DescribeSentimentDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSentimentDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeSentimentDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeSentimentDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSentimentDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSentimentDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSentimentDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSentimentDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeSentimentDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSentimentDetectionJobOutputError>
}

public struct DescribeSentimentDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSentimentDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSentimentDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSentimentDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSentimentDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeSentimentDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSentimentDetectionJobOutputError>
}

public struct DescribeSentimentDetectionJobInput: Equatable {
    /// <p>The identifier that Amazon Comprehend generated for the job. The  operation returns this identifier in its
    ///       response.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeSentimentDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeSentimentDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeSentimentDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSentimentDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSentimentDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSentimentDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSentimentDetectionJobOutputResponse(sentimentDetectionJobProperties: \(String(describing: sentimentDetectionJobProperties)))"}
}

extension DescribeSentimentDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSentimentDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sentimentDetectionJobProperties = output.sentimentDetectionJobProperties
        } else {
            self.sentimentDetectionJobProperties = nil
        }
    }
}

public struct DescribeSentimentDetectionJobOutputResponse: Equatable {
    /// <p>An object that contains the properties associated with a sentiment detection job.</p>
    public let sentimentDetectionJobProperties: SentimentDetectionJobProperties?

    public init (
        sentimentDetectionJobProperties: SentimentDetectionJobProperties? = nil
    )
    {
        self.sentimentDetectionJobProperties = sentimentDetectionJobProperties
    }
}

struct DescribeSentimentDetectionJobOutputResponseBody: Equatable {
    public let sentimentDetectionJobProperties: SentimentDetectionJobProperties?
}

extension DescribeSentimentDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sentimentDetectionJobProperties = "SentimentDetectionJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sentimentDetectionJobPropertiesDecoded = try containerValues.decodeIfPresent(SentimentDetectionJobProperties.self, forKey: .sentimentDetectionJobProperties)
        sentimentDetectionJobProperties = sentimentDetectionJobPropertiesDecoded
    }
}

public struct DescribeTopicsDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTopicsDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTopicsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTopicsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTopicsDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeTopicsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTopicsDetectionJobOutputError>
}

extension DescribeTopicsDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTopicsDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeTopicsDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeTopicsDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTopicsDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTopicsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTopicsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTopicsDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeTopicsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTopicsDetectionJobOutputError>
}

public struct DescribeTopicsDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTopicsDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTopicsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTopicsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTopicsDetectionJobInput>
    public typealias MOutput = OperationOutput<DescribeTopicsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTopicsDetectionJobOutputError>
}

public struct DescribeTopicsDetectionJobInput: Equatable {
    /// <p>The identifier assigned by the user to the detection job.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeTopicsDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeTopicsDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeTopicsDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTopicsDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTopicsDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTopicsDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTopicsDetectionJobOutputResponse(topicsDetectionJobProperties: \(String(describing: topicsDetectionJobProperties)))"}
}

extension DescribeTopicsDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTopicsDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.topicsDetectionJobProperties = output.topicsDetectionJobProperties
        } else {
            self.topicsDetectionJobProperties = nil
        }
    }
}

public struct DescribeTopicsDetectionJobOutputResponse: Equatable {
    /// <p>The list of properties for the requested job.</p>
    public let topicsDetectionJobProperties: TopicsDetectionJobProperties?

    public init (
        topicsDetectionJobProperties: TopicsDetectionJobProperties? = nil
    )
    {
        self.topicsDetectionJobProperties = topicsDetectionJobProperties
    }
}

struct DescribeTopicsDetectionJobOutputResponseBody: Equatable {
    public let topicsDetectionJobProperties: TopicsDetectionJobProperties?
}

extension DescribeTopicsDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case topicsDetectionJobProperties = "TopicsDetectionJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicsDetectionJobPropertiesDecoded = try containerValues.decodeIfPresent(TopicsDetectionJobProperties.self, forKey: .topicsDetectionJobProperties)
        topicsDetectionJobProperties = topicsDetectionJobPropertiesDecoded
    }
}

public struct DetectDominantLanguageInputBodyMiddleware: Middleware {
    public let id: String = "DetectDominantLanguageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectDominantLanguageInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectDominantLanguageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectDominantLanguageInput>
    public typealias MOutput = OperationOutput<DetectDominantLanguageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectDominantLanguageOutputError>
}

extension DetectDominantLanguageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectDominantLanguageInput(text: \(String(describing: text)))"}
}

extension DetectDominantLanguageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct DetectDominantLanguageInputHeadersMiddleware: Middleware {
    public let id: String = "DetectDominantLanguageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectDominantLanguageInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectDominantLanguageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectDominantLanguageInput>
    public typealias MOutput = OperationOutput<DetectDominantLanguageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectDominantLanguageOutputError>
}

public struct DetectDominantLanguageInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectDominantLanguageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectDominantLanguageInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectDominantLanguageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectDominantLanguageInput>
    public typealias MOutput = OperationOutput<DetectDominantLanguageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectDominantLanguageOutputError>
}

public struct DetectDominantLanguageInput: Equatable {
    /// <p>A UTF-8 text string. Each string should contain at least 20 characters and must contain
    ///       fewer that 5,000 bytes of UTF-8 encoded characters.</p>
    public let text: String?

    public init (
        text: String? = nil
    )
    {
        self.text = text
    }
}

struct DetectDominantLanguageInputBody: Equatable {
    public let text: String?
}

extension DetectDominantLanguageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectDominantLanguageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectDominantLanguageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectDominantLanguageOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectDominantLanguageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

extension DetectDominantLanguageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectDominantLanguageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.languages = output.languages
        } else {
            self.languages = nil
        }
    }
}

public struct DetectDominantLanguageOutputResponse: Equatable {
    /// <p>The languages that Amazon Comprehend detected in the input text. For each language, the
    ///       response returns the RFC 5646 language code and the level of confidence that Amazon Comprehend
    ///       has in the accuracy of its inference. For more information about RFC 5646, see <a href="https://tools.ietf.org/html/rfc5646">Tags for Identifying Languages</a> on the
    ///         <i>IETF Tools</i> web site.</p>
    public let languages: [DominantLanguage]?

    public init (
        languages: [DominantLanguage]? = nil
    )
    {
        self.languages = languages
    }
}

struct DetectDominantLanguageOutputResponseBody: Equatable {
    public let languages: [DominantLanguage]?
}

extension DetectDominantLanguageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case languages = "Languages"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languagesContainer = try containerValues.decodeIfPresent([DominantLanguage?].self, forKey: .languages)
        var languagesDecoded0:[DominantLanguage]? = nil
        if let languagesContainer = languagesContainer {
            languagesDecoded0 = [DominantLanguage]()
            for structure0 in languagesContainer {
                if let structure0 = structure0 {
                    languagesDecoded0?.append(structure0)
                }
            }
        }
        languages = languagesDecoded0
    }
}

public struct DetectEntitiesInputBodyMiddleware: Middleware {
    public let id: String = "DetectEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectEntitiesInput>
    public typealias MOutput = OperationOutput<DetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectEntitiesOutputError>
}

extension DetectEntitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectEntitiesInput(endpointArn: \(String(describing: endpointArn)), languageCode: \(String(describing: languageCode)), text: \(String(describing: text)))"}
}

extension DetectEntitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case languageCode = "LanguageCode"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct DetectEntitiesInputHeadersMiddleware: Middleware {
    public let id: String = "DetectEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectEntitiesInput>
    public typealias MOutput = OperationOutput<DetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectEntitiesOutputError>
}

public struct DetectEntitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectEntitiesInput>
    public typealias MOutput = OperationOutput<DetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectEntitiesOutputError>
}

public struct DetectEntitiesInput: Equatable {
    /// <p>The Amazon Resource Name of an endpoint that is associated with a custom entity
    ///       recognition model. Provide an endpoint if you want to detect entities by using your own custom
    ///       model instead of the default model that is used by Amazon Comprehend.</p>
    ///          <p>If you specify an endpoint, Amazon Comprehend uses the language of your custom model, and
    ///       it ignores any language code that you provide in your request.</p>
    public let endpointArn: String?
    /// <p>The language of the input documents. You can specify any of the primary languages
    ///       supported by Amazon Comprehend. All documents must be in the same language.</p>
    ///          <p>If your request includes the endpoint for a custom entity recognition model, Amazon
    ///       Comprehend uses the language of your custom model, and it ignores any language code that you
    ///       specify here.</p>
    public let languageCode: LanguageCode?
    /// <p>A UTF-8 text string. Each string must contain fewer that 5,000 bytes of UTF-8 encoded
    ///       characters.</p>
    public let text: String?

    public init (
        endpointArn: String? = nil,
        languageCode: LanguageCode? = nil,
        text: String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.languageCode = languageCode
        self.text = text
    }
}

struct DetectEntitiesInputBody: Equatable {
    public let text: String?
    public let languageCode: LanguageCode?
    public let endpointArn: String?
}

extension DetectEntitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case languageCode = "LanguageCode"
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DetectEntitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectEntitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguageException" : self = .unsupportedLanguageException(try UnsupportedLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectEntitiesOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceUnavailableException(ResourceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unsupportedLanguageException(UnsupportedLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectEntitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

extension DetectEntitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entities = output.entities
        } else {
            self.entities = nil
        }
    }
}

public struct DetectEntitiesOutputResponse: Equatable {
    /// <p>A collection of entities identified in the input text. For each entity, the response
    ///       provides the entity text, entity type, where the entity text begins and ends, and the level of
    ///       confidence that Amazon Comprehend has in the detection. </p>
    ///          <p>If your request uses a custom entity recognition model, Amazon Comprehend detects the
    ///       entities that the model is trained to recognize. Otherwise, it detects the default entity
    ///       types. For a list of default entity types, see <a>how-entities</a>.</p>
    public let entities: [Entity]?

    public init (
        entities: [Entity]? = nil
    )
    {
        self.entities = entities
    }
}

struct DetectEntitiesOutputResponseBody: Equatable {
    public let entities: [Entity]?
}

extension DetectEntitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entities = "Entities"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([Entity?].self, forKey: .entities)
        var entitiesDecoded0:[Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
    }
}

public struct DetectKeyPhrasesInputBodyMiddleware: Middleware {
    public let id: String = "DetectKeyPhrasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectKeyPhrasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectKeyPhrasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectKeyPhrasesInput>
    public typealias MOutput = OperationOutput<DetectKeyPhrasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectKeyPhrasesOutputError>
}

extension DetectKeyPhrasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectKeyPhrasesInput(languageCode: \(String(describing: languageCode)), text: \(String(describing: text)))"}
}

extension DetectKeyPhrasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct DetectKeyPhrasesInputHeadersMiddleware: Middleware {
    public let id: String = "DetectKeyPhrasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectKeyPhrasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectKeyPhrasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectKeyPhrasesInput>
    public typealias MOutput = OperationOutput<DetectKeyPhrasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectKeyPhrasesOutputError>
}

public struct DetectKeyPhrasesInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectKeyPhrasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectKeyPhrasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectKeyPhrasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectKeyPhrasesInput>
    public typealias MOutput = OperationOutput<DetectKeyPhrasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectKeyPhrasesOutputError>
}

public struct DetectKeyPhrasesInput: Equatable {
    /// <p>The language of the input documents. You can specify any of the primary languages
    ///       supported by Amazon Comprehend. All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>A UTF-8 text string. Each string must contain fewer that 5,000 bytes of UTF-8 encoded
    ///       characters.</p>
    public let text: String?

    public init (
        languageCode: LanguageCode? = nil,
        text: String? = nil
    )
    {
        self.languageCode = languageCode
        self.text = text
    }
}

struct DetectKeyPhrasesInputBody: Equatable {
    public let text: String?
    public let languageCode: LanguageCode?
}

extension DetectKeyPhrasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension DetectKeyPhrasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectKeyPhrasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguageException" : self = .unsupportedLanguageException(try UnsupportedLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectKeyPhrasesOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unsupportedLanguageException(UnsupportedLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectKeyPhrasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

extension DetectKeyPhrasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectKeyPhrasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyPhrases = output.keyPhrases
        } else {
            self.keyPhrases = nil
        }
    }
}

public struct DetectKeyPhrasesOutputResponse: Equatable {
    /// <p>A collection of key phrases that Amazon Comprehend identified in the input text. For
    ///       each key phrase, the response provides the text of the key phrase, where the key phrase begins
    ///       and ends, and the level of confidence that Amazon Comprehend has in the accuracy of the
    ///       detection. </p>
    public let keyPhrases: [KeyPhrase]?

    public init (
        keyPhrases: [KeyPhrase]? = nil
    )
    {
        self.keyPhrases = keyPhrases
    }
}

struct DetectKeyPhrasesOutputResponseBody: Equatable {
    public let keyPhrases: [KeyPhrase]?
}

extension DetectKeyPhrasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyPhrases = "KeyPhrases"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPhrasesContainer = try containerValues.decodeIfPresent([KeyPhrase?].self, forKey: .keyPhrases)
        var keyPhrasesDecoded0:[KeyPhrase]? = nil
        if let keyPhrasesContainer = keyPhrasesContainer {
            keyPhrasesDecoded0 = [KeyPhrase]()
            for structure0 in keyPhrasesContainer {
                if let structure0 = structure0 {
                    keyPhrasesDecoded0?.append(structure0)
                }
            }
        }
        keyPhrases = keyPhrasesDecoded0
    }
}

public struct DetectPiiEntitiesInputBodyMiddleware: Middleware {
    public let id: String = "DetectPiiEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectPiiEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectPiiEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectPiiEntitiesInput>
    public typealias MOutput = OperationOutput<DetectPiiEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectPiiEntitiesOutputError>
}

extension DetectPiiEntitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectPiiEntitiesInput(languageCode: \(String(describing: languageCode)), text: \(String(describing: text)))"}
}

extension DetectPiiEntitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct DetectPiiEntitiesInputHeadersMiddleware: Middleware {
    public let id: String = "DetectPiiEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectPiiEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectPiiEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectPiiEntitiesInput>
    public typealias MOutput = OperationOutput<DetectPiiEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectPiiEntitiesOutputError>
}

public struct DetectPiiEntitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectPiiEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectPiiEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectPiiEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectPiiEntitiesInput>
    public typealias MOutput = OperationOutput<DetectPiiEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectPiiEntitiesOutputError>
}

public struct DetectPiiEntitiesInput: Equatable {
    /// <p>The language of the input documents.</p>
    public let languageCode: LanguageCode?
    /// <p>A UTF-8 text string. Each string must contain fewer that 5,000 bytes of UTF-8 encoded
    ///       characters.</p>
    public let text: String?

    public init (
        languageCode: LanguageCode? = nil,
        text: String? = nil
    )
    {
        self.languageCode = languageCode
        self.text = text
    }
}

struct DetectPiiEntitiesInputBody: Equatable {
    public let text: String?
    public let languageCode: LanguageCode?
}

extension DetectPiiEntitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension DetectPiiEntitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectPiiEntitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguageException" : self = .unsupportedLanguageException(try UnsupportedLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectPiiEntitiesOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unsupportedLanguageException(UnsupportedLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectPiiEntitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectPiiEntitiesOutputResponse(entities: \(String(describing: entities)))"}
}

extension DetectPiiEntitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectPiiEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entities = output.entities
        } else {
            self.entities = nil
        }
    }
}

public struct DetectPiiEntitiesOutputResponse: Equatable {
    /// <p>A collection of PII entities identified in the input text. For each entity, the response
    ///       provides the entity type, where the entity text begins and ends, and the level of confidence
    ///       that Amazon Comprehend has in the detection.</p>
    public let entities: [PiiEntity]?

    public init (
        entities: [PiiEntity]? = nil
    )
    {
        self.entities = entities
    }
}

struct DetectPiiEntitiesOutputResponseBody: Equatable {
    public let entities: [PiiEntity]?
}

extension DetectPiiEntitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entities = "Entities"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([PiiEntity?].self, forKey: .entities)
        var entitiesDecoded0:[PiiEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [PiiEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
    }
}

public struct DetectSentimentInputBodyMiddleware: Middleware {
    public let id: String = "DetectSentimentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectSentimentInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectSentimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectSentimentInput>
    public typealias MOutput = OperationOutput<DetectSentimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectSentimentOutputError>
}

extension DetectSentimentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectSentimentInput(languageCode: \(String(describing: languageCode)), text: \(String(describing: text)))"}
}

extension DetectSentimentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct DetectSentimentInputHeadersMiddleware: Middleware {
    public let id: String = "DetectSentimentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectSentimentInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectSentimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectSentimentInput>
    public typealias MOutput = OperationOutput<DetectSentimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectSentimentOutputError>
}

public struct DetectSentimentInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectSentimentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectSentimentInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectSentimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectSentimentInput>
    public typealias MOutput = OperationOutput<DetectSentimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectSentimentOutputError>
}

public struct DetectSentimentInput: Equatable {
    /// <p>The language of the input documents. You can specify any of the primary languages
    ///       supported by Amazon Comprehend. All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>A UTF-8 text string. Each string must contain fewer that 5,000 bytes of UTF-8 encoded
    ///       characters.</p>
    public let text: String?

    public init (
        languageCode: LanguageCode? = nil,
        text: String? = nil
    )
    {
        self.languageCode = languageCode
        self.text = text
    }
}

struct DetectSentimentInputBody: Equatable {
    public let text: String?
    public let languageCode: LanguageCode?
}

extension DetectSentimentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension DetectSentimentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectSentimentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguageException" : self = .unsupportedLanguageException(try UnsupportedLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectSentimentOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unsupportedLanguageException(UnsupportedLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectSentimentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

extension DetectSentimentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectSentimentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sentiment = output.sentiment
            self.sentimentScore = output.sentimentScore
        } else {
            self.sentiment = nil
            self.sentimentScore = nil
        }
    }
}

public struct DetectSentimentOutputResponse: Equatable {
    /// <p>The inferred sentiment that Amazon Comprehend has the highest level of confidence
    ///       in.</p>
    public let sentiment: SentimentType?
    /// <p>An object that lists the sentiments, and their corresponding confidence
    ///       levels.</p>
    public let sentimentScore: SentimentScore?

    public init (
        sentiment: SentimentType? = nil,
        sentimentScore: SentimentScore? = nil
    )
    {
        self.sentiment = sentiment
        self.sentimentScore = sentimentScore
    }
}

struct DetectSentimentOutputResponseBody: Equatable {
    public let sentiment: SentimentType?
    public let sentimentScore: SentimentScore?
}

extension DetectSentimentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sentiment = "Sentiment"
        case sentimentScore = "SentimentScore"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sentimentDecoded = try containerValues.decodeIfPresent(SentimentType.self, forKey: .sentiment)
        sentiment = sentimentDecoded
        let sentimentScoreDecoded = try containerValues.decodeIfPresent(SentimentScore.self, forKey: .sentimentScore)
        sentimentScore = sentimentScoreDecoded
    }
}

public struct DetectSyntaxInputBodyMiddleware: Middleware {
    public let id: String = "DetectSyntaxInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectSyntaxInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectSyntaxOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectSyntaxInput>
    public typealias MOutput = OperationOutput<DetectSyntaxOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectSyntaxOutputError>
}

extension DetectSyntaxInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectSyntaxInput(languageCode: \(String(describing: languageCode)), text: \(String(describing: text)))"}
}

extension DetectSyntaxInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct DetectSyntaxInputHeadersMiddleware: Middleware {
    public let id: String = "DetectSyntaxInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectSyntaxInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectSyntaxOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectSyntaxInput>
    public typealias MOutput = OperationOutput<DetectSyntaxOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectSyntaxOutputError>
}

public struct DetectSyntaxInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectSyntaxInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectSyntaxInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectSyntaxOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectSyntaxInput>
    public typealias MOutput = OperationOutput<DetectSyntaxOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectSyntaxOutputError>
}

public struct DetectSyntaxInput: Equatable {
    /// <p>The language code of the input documents. You can specify any of the following languages
    ///       supported by Amazon Comprehend: German ("de"), English ("en"), Spanish ("es"), French ("fr"),
    ///       Italian ("it"), or Portuguese ("pt").</p>
    public let languageCode: SyntaxLanguageCode?
    /// <p>A UTF-8 string. Each string must contain fewer that 5,000 bytes of UTF encoded
    ///       characters.</p>
    public let text: String?

    public init (
        languageCode: SyntaxLanguageCode? = nil,
        text: String? = nil
    )
    {
        self.languageCode = languageCode
        self.text = text
    }
}

struct DetectSyntaxInputBody: Equatable {
    public let text: String?
    public let languageCode: SyntaxLanguageCode?
}

extension DetectSyntaxInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(SyntaxLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension DetectSyntaxOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectSyntaxOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguageException" : self = .unsupportedLanguageException(try UnsupportedLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectSyntaxOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case unsupportedLanguageException(UnsupportedLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectSyntaxOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

extension DetectSyntaxOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectSyntaxOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.syntaxTokens = output.syntaxTokens
        } else {
            self.syntaxTokens = nil
        }
    }
}

public struct DetectSyntaxOutputResponse: Equatable {
    /// <p>A collection of syntax tokens describing the text. For each token, the response provides
    ///       the text, the token type, where the text begins and ends, and the level of confidence that
    ///       Amazon Comprehend has that the token is correct. For a list of token types, see <a>how-syntax</a>.</p>
    public let syntaxTokens: [SyntaxToken]?

    public init (
        syntaxTokens: [SyntaxToken]? = nil
    )
    {
        self.syntaxTokens = syntaxTokens
    }
}

struct DetectSyntaxOutputResponseBody: Equatable {
    public let syntaxTokens: [SyntaxToken]?
}

extension DetectSyntaxOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case syntaxTokens = "SyntaxTokens"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syntaxTokensContainer = try containerValues.decodeIfPresent([SyntaxToken?].self, forKey: .syntaxTokens)
        var syntaxTokensDecoded0:[SyntaxToken]? = nil
        if let syntaxTokensContainer = syntaxTokensContainer {
            syntaxTokensDecoded0 = [SyntaxToken]()
            for structure0 in syntaxTokensContainer {
                if let structure0 = structure0 {
                    syntaxTokensDecoded0?.append(structure0)
                }
            }
        }
        syntaxTokens = syntaxTokensDecoded0
    }
}

extension DocumentClass: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension DocumentClass: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentClass(name: \(String(describing: name)), score: \(String(describing: score)))"}
}

/// <p>Specifies the class that categorizes the document being analyzed</p>
public struct DocumentClass: Equatable {
    /// <p>The name of the class.</p>
    public let name: String?
    /// <p>The confidence score that Amazon Comprehend has this class correctly attributed.</p>
    public let score: Float?

    public init (
        name: String? = nil,
        score: Float? = nil
    )
    {
        self.name = name
        self.score = score
    }
}

extension DocumentClassificationJobFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension DocumentClassificationJobFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentClassificationJobFilter(jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), submitTimeAfter: \(String(describing: submitTimeAfter)), submitTimeBefore: \(String(describing: submitTimeBefore)))"}
}

/// <p>Provides information for filtering a list of document classification jobs. For more
///       information, see the  operation. You can
///       provide only one filter parameter in each request.</p>
public struct DocumentClassificationJobFilter: Equatable {
    /// <p>Filters on the name of the job.</p>
    public let jobName: String?
    /// <p>Filters the list based on job status. Returns only jobs with the specified status.</p>
    public let jobStatus: JobStatus?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted after the specified time. Jobs are returned in descending order,
    ///       newest to oldest.</p>
    public let submitTimeAfter: Date?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted before the specified time. Jobs are returned in ascending order,
    ///       oldest to newest.</p>
    public let submitTimeBefore: Date?

    public init (
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        submitTimeAfter: Date? = nil,
        submitTimeBefore: Date? = nil
    )
    {
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension DocumentClassificationJobProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case documentClassifierArn = "DocumentClassifierArn"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let documentClassifierArn = documentClassifierArn {
            try encodeContainer.encode(documentClassifierArn, forKey: .documentClassifierArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let documentClassifierArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentClassifierArn)
        documentClassifierArn = documentClassifierArnDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension DocumentClassificationJobProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentClassificationJobProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), documentClassifierArn: \(String(describing: documentClassifierArn)), endTime: \(String(describing: endTime)), inputDataConfig: \(String(describing: inputDataConfig)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), message: \(String(describing: message)), outputDataConfig: \(String(describing: outputDataConfig)), submitTime: \(String(describing: submitTime)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Provides information about a document classification job.</p>
public struct DocumentClassificationJobProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend read access to your input data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier. </p>
    public let documentClassifierArn: String?
    /// <p>The time that the document classification job completed.</p>
    public let endTime: Date?
    /// <p>The input data configuration that you supplied when you created the document
    ///       classification job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier assigned to the document classification job.</p>
    public let jobId: String?
    /// <p>The name that you assigned to the document classification job.</p>
    public let jobName: String?
    /// <p>The current status of the document classification job. If the status is
    ///         <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    public let jobStatus: JobStatus?
    /// <p>A description of the status of the job.</p>
    public let message: String?
    /// <p>The output data configuration that you supplied when you created the document
    ///       classification job.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>The time that the document classification job was submitted for processing.</p>
    public let submitTime: Date?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the
    ///       resources you are using for your document classification job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        dataAccessRoleArn: String? = nil,
        documentClassifierArn: String? = nil,
        endTime: Date? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobId: String? = nil,
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        message: String? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        submitTime: Date? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.documentClassifierArn = documentClassifierArn
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.message = message
        self.outputDataConfig = outputDataConfig
        self.submitTime = submitTime
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

public enum DocumentClassifierDataFormat {
    case augmentedManifest
    case comprehendCsv
    case sdkUnknown(String)
}

extension DocumentClassifierDataFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentClassifierDataFormat] {
        return [
            .augmentedManifest,
            .comprehendCsv,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .augmentedManifest: return "AUGMENTED_MANIFEST"
        case .comprehendCsv: return "COMPREHEND_CSV"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentClassifierDataFormat(rawValue: rawValue) ?? DocumentClassifierDataFormat.sdkUnknown(rawValue)
    }
}

extension DocumentClassifierFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ModelStatus.self, forKey: .status)
        status = statusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension DocumentClassifierFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentClassifierFilter(status: \(String(describing: status)), submitTimeAfter: \(String(describing: submitTimeAfter)), submitTimeBefore: \(String(describing: submitTimeBefore)))"}
}

/// <p>Provides information for filtering a list of document classifiers. You can only specify
///       one filtering parameter in a request. For more information, see the  operation.</p>
public struct DocumentClassifierFilter: Equatable {
    /// <p>Filters the list of classifiers based on status.</p>
    public let status: ModelStatus?
    /// <p>Filters the list of classifiers based on the time that the classifier was submitted for
    ///       processing. Returns only classifiers submitted after the specified time. Classifiers are
    ///       returned in descending order, newest to oldest.</p>
    public let submitTimeAfter: Date?
    /// <p>Filters the list of classifiers based on the time that the classifier was submitted for
    ///       processing. Returns only classifiers submitted before the specified time. Classifiers are
    ///       returned in ascending order, oldest to newest.</p>
    public let submitTimeBefore: Date?

    public init (
        status: ModelStatus? = nil,
        submitTimeAfter: Date? = nil,
        submitTimeBefore: Date? = nil
    )
    {
        self.status = status
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension DocumentClassifierInputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case augmentedManifests = "AugmentedManifests"
        case dataFormat = "DataFormat"
        case labelDelimiter = "LabelDelimiter"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let augmentedManifests = augmentedManifests {
            var augmentedManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .augmentedManifests)
            for documentclassifieraugmentedmanifestslist0 in augmentedManifests {
                try augmentedManifestsContainer.encode(documentclassifieraugmentedmanifestslist0)
            }
        }
        if let dataFormat = dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let labelDelimiter = labelDelimiter {
            try encodeContainer.encode(labelDelimiter, forKey: .labelDelimiter)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataFormatDecoded = try containerValues.decodeIfPresent(DocumentClassifierDataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let labelDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .labelDelimiter)
        labelDelimiter = labelDelimiterDecoded
        let augmentedManifestsContainer = try containerValues.decodeIfPresent([AugmentedManifestsListItem?].self, forKey: .augmentedManifests)
        var augmentedManifestsDecoded0:[AugmentedManifestsListItem]? = nil
        if let augmentedManifestsContainer = augmentedManifestsContainer {
            augmentedManifestsDecoded0 = [AugmentedManifestsListItem]()
            for structure0 in augmentedManifestsContainer {
                if let structure0 = structure0 {
                    augmentedManifestsDecoded0?.append(structure0)
                }
            }
        }
        augmentedManifests = augmentedManifestsDecoded0
    }
}

extension DocumentClassifierInputDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentClassifierInputDataConfig(augmentedManifests: \(String(describing: augmentedManifests)), dataFormat: \(String(describing: dataFormat)), labelDelimiter: \(String(describing: labelDelimiter)), s3Uri: \(String(describing: s3Uri)))"}
}

/// <p>The input properties for training a document classifier. </p>
///          <p>For more information on how the input file is formatted, see <a>how-document-classification-training-data</a>. </p>
public struct DocumentClassifierInputDataConfig: Equatable {
    /// <p>A list of augmented manifest files that provide training data for your custom model. An
    ///       augmented manifest file is a labeled dataset that is produced by Amazon SageMaker Ground
    ///       Truth.</p>
    ///          <p>This parameter is required if you set <code>DataFormat</code> to
    ///         <code>AUGMENTED_MANIFEST</code>.</p>
    public let augmentedManifests: [AugmentedManifestsListItem]?
    /// <p>The format of your training data:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>COMPREHEND_CSV</code>: A two-column CSV file, where labels are provided in the
    ///           first column, and documents are provided in the second. If you use this value, you must
    ///           provide the <code>S3Uri</code> parameter in your request.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AUGMENTED_MANIFEST</code>: A labeled dataset that is produced by Amazon
    ///           SageMaker Ground Truth. This file is in JSON lines format. Each line is a complete JSON
    ///           object that contains a training document and its associated labels. </p>
    ///                <p>If you use this value, you must provide the <code>AugmentedManifests</code> parameter
    ///           in your request.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't specify a value, Amazon Comprehend uses <code>COMPREHEND_CSV</code> as the
    ///       default.</p>
    public let dataFormat: DocumentClassifierDataFormat?
    /// <p>Indicates the delimiter used to separate each label for training a multi-label classifier.
    ///       The default delimiter between labels is a pipe (|). You can use a different character as a
    ///       delimiter (if it's an allowed character) by specifying it under Delimiter for labels. If the
    ///       training documents use a delimiter other than the default or the delimiter you specify, the
    ///       labels on that line will be combined to make a single unique label, such as
    ///       LABELLABELLABEL.</p>
    public let labelDelimiter: String?
    /// <p>The Amazon S3 URI for the input data. The S3 bucket must be in the same region as the API
    ///       endpoint that you are calling. The URI can point to a single input file or it can provide the
    ///       prefix for a collection of input files.</p>
    ///          <p>For example, if you use the URI <code>S3://bucketName/prefix</code>, if the prefix is a
    ///       single file, Amazon Comprehend uses that file as input. If more than one file begins with the
    ///       prefix, Amazon Comprehend uses all of them as input.</p>
    ///          <p>This parameter is required if you set <code>DataFormat</code> to
    ///         <code>COMPREHEND_CSV</code>.</p>
    public let s3Uri: String?

    public init (
        augmentedManifests: [AugmentedManifestsListItem]? = nil,
        dataFormat: DocumentClassifierDataFormat? = nil,
        labelDelimiter: String? = nil,
        s3Uri: String? = nil
    )
    {
        self.augmentedManifests = augmentedManifests
        self.dataFormat = dataFormat
        self.labelDelimiter = labelDelimiter
        self.s3Uri = s3Uri
    }
}

public enum DocumentClassifierMode {
    case multiClass
    case multiLabel
    case sdkUnknown(String)
}

extension DocumentClassifierMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentClassifierMode] {
        return [
            .multiClass,
            .multiLabel,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .multiClass: return "MULTI_CLASS"
        case .multiLabel: return "MULTI_LABEL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentClassifierMode(rawValue: rawValue) ?? DocumentClassifierMode.sdkUnknown(rawValue)
    }
}

extension DocumentClassifierOutputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension DocumentClassifierOutputDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentClassifierOutputDataConfig(kmsKeyId: \(String(describing: kmsKeyId)), s3Uri: \(String(describing: s3Uri)))"}
}

/// <p>Provides output results configuration parameters for custom classifier jobs. </p>
public struct DocumentClassifierOutputDataConfig: Equatable {
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the
    ///       output results from an analysis job. The KmsKeyId can be one of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>KMS Key Alias: <code>"alias/ExampleAlias"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>ARN of a KMS Key Alias:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let kmsKeyId: String?
    /// <p>When you use the <code>OutputDataConfig</code> object while creating a custom
    ///       classifier, you specify the Amazon S3 location where you want to write the confusion matrix.
    ///       The URI must be in the same region as the API endpoint that you are calling. The location is
    ///       used as the prefix for the actual location of this output file.</p>
    ///          <p>When the custom classifier job is finished, the service creates the output file in a
    ///       directory specific to the job. The <code>S3Uri</code> field contains the location of the
    ///       output file, called <code>output.tar.gz</code>. It is a compressed archive that contains the
    ///       confusion matrix.</p>
    public let s3Uri: String?

    public init (
        kmsKeyId: String? = nil,
        s3Uri: String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.s3Uri = s3Uri
    }
}

extension DocumentClassifierProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classifierMetadata = "ClassifierMetadata"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case documentClassifierArn = "DocumentClassifierArn"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case languageCode = "LanguageCode"
        case message = "Message"
        case mode = "Mode"
        case modelKmsKeyId = "ModelKmsKeyId"
        case outputDataConfig = "OutputDataConfig"
        case status = "Status"
        case submitTime = "SubmitTime"
        case trainingEndTime = "TrainingEndTime"
        case trainingStartTime = "TrainingStartTime"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classifierMetadata = classifierMetadata {
            try encodeContainer.encode(classifierMetadata, forKey: .classifierMetadata)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let documentClassifierArn = documentClassifierArn {
            try encodeContainer.encode(documentClassifierArn, forKey: .documentClassifierArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let modelKmsKeyId = modelKmsKeyId {
            try encodeContainer.encode(modelKmsKeyId, forKey: .modelKmsKeyId)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let trainingEndTime = trainingEndTime {
            try encodeContainer.encode(trainingEndTime.timeIntervalSince1970, forKey: .trainingEndTime)
        }
        if let trainingStartTime = trainingStartTime {
            try encodeContainer.encode(trainingStartTime.timeIntervalSince1970, forKey: .trainingStartTime)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentClassifierArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentClassifierArn)
        documentClassifierArn = documentClassifierArnDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ModelStatus.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let trainingStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .trainingStartTime)
        trainingStartTime = trainingStartTimeDecoded
        let trainingEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .trainingEndTime)
        trainingEndTime = trainingEndTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(DocumentClassifierInputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(DocumentClassifierOutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let classifierMetadataDecoded = try containerValues.decodeIfPresent(ClassifierMetadata.self, forKey: .classifierMetadata)
        classifierMetadata = classifierMetadataDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let modeDecoded = try containerValues.decodeIfPresent(DocumentClassifierMode.self, forKey: .mode)
        mode = modeDecoded
        let modelKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelKmsKeyId)
        modelKmsKeyId = modelKmsKeyIdDecoded
    }
}

extension DocumentClassifierProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentClassifierProperties(classifierMetadata: \(String(describing: classifierMetadata)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), documentClassifierArn: \(String(describing: documentClassifierArn)), endTime: \(String(describing: endTime)), inputDataConfig: \(String(describing: inputDataConfig)), languageCode: \(String(describing: languageCode)), message: \(String(describing: message)), mode: \(String(describing: mode)), modelKmsKeyId: \(String(describing: modelKmsKeyId)), outputDataConfig: \(String(describing: outputDataConfig)), status: \(String(describing: status)), submitTime: \(String(describing: submitTime)), trainingEndTime: \(String(describing: trainingEndTime)), trainingStartTime: \(String(describing: trainingStartTime)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Provides information about a document classifier.</p>
public struct DocumentClassifierProperties: Equatable {
    /// <p>Information about the document classifier, including the number of documents used for
    ///       training the classifier, the number of documents used for test the classifier, and an accuracy
    ///       rating.</p>
    public let classifierMetadata: ClassifierMetadata?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants
    ///       Amazon Comprehend read access to your input data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier.</p>
    public let documentClassifierArn: String?
    /// <p>The time that training the document classifier completed.</p>
    public let endTime: Date?
    /// <p>The input data configuration that you supplied when you created the document classifier
    ///       for training.</p>
    public let inputDataConfig: DocumentClassifierInputDataConfig?
    /// <p>The language code for the language of the documents that the classifier was trained
    ///       on.</p>
    public let languageCode: LanguageCode?
    /// <p>Additional information about the status of the classifier.</p>
    public let message: String?
    /// <p>Indicates the mode in which the specific classifier was trained. This also indicates the
    ///       format of input documents and the format of the confusion matrix. Each classifier can only be
    ///       trained in one mode and this cannot be changed once the classifier is trained.</p>
    public let mode: DocumentClassifierMode?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       trained custom models. The ModelKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let modelKmsKeyId: String?
    /// <p> Provides output results configuration parameters for custom classifier jobs.</p>
    public let outputDataConfig: DocumentClassifierOutputDataConfig?
    /// <p>The status of the document classifier. If the status is <code>TRAINED</code> the
    ///       classifier is ready to use. If the status is <code>FAILED</code> you can see additional
    ///       information about why the classifier wasn't trained in the <code>Message</code> field.</p>
    public let status: ModelStatus?
    /// <p>The time that the document classifier was submitted for training.</p>
    public let submitTime: Date?
    /// <p>The time that training of the document classifier was completed. Indicates the time when
    ///       the training completes on documentation classifiers. You are billed for the time interval
    ///       between this time and the value of TrainingStartTime.</p>
    public let trainingEndTime: Date?
    /// <p>Indicates the time when the training starts on documentation classifiers. You are billed
    ///       for the time interval between this time and the value of TrainingEndTime. </p>
    public let trainingStartTime: Date?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the
    ///       resources you are using for your custom classifier. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        classifierMetadata: ClassifierMetadata? = nil,
        dataAccessRoleArn: String? = nil,
        documentClassifierArn: String? = nil,
        endTime: Date? = nil,
        inputDataConfig: DocumentClassifierInputDataConfig? = nil,
        languageCode: LanguageCode? = nil,
        message: String? = nil,
        mode: DocumentClassifierMode? = nil,
        modelKmsKeyId: String? = nil,
        outputDataConfig: DocumentClassifierOutputDataConfig? = nil,
        status: ModelStatus? = nil,
        submitTime: Date? = nil,
        trainingEndTime: Date? = nil,
        trainingStartTime: Date? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.classifierMetadata = classifierMetadata
        self.dataAccessRoleArn = dataAccessRoleArn
        self.documentClassifierArn = documentClassifierArn
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.languageCode = languageCode
        self.message = message
        self.mode = mode
        self.modelKmsKeyId = modelKmsKeyId
        self.outputDataConfig = outputDataConfig
        self.status = status
        self.submitTime = submitTime
        self.trainingEndTime = trainingEndTime
        self.trainingStartTime = trainingStartTime
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

extension DocumentLabel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension DocumentLabel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentLabel(name: \(String(describing: name)), score: \(String(describing: score)))"}
}

/// <p>Specifies one of the label or labels that categorize the document being analyzed.</p>
public struct DocumentLabel: Equatable {
    /// <p>The name of the label.</p>
    public let name: String?
    /// <p>The confidence score that Amazon Comprehend has this label correctly attributed.</p>
    public let score: Float?

    public init (
        name: String? = nil,
        score: Float? = nil
    )
    {
        self.name = name
        self.score = score
    }
}

extension DominantLanguage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case score = "Score"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode, forKey: .languageCode)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension DominantLanguage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DominantLanguage(languageCode: \(String(describing: languageCode)), score: \(String(describing: score)))"}
}

/// <p>Returns the code for the dominant language in the input text and the level of
///       confidence that Amazon Comprehend has in the accuracy of the detection.</p>
public struct DominantLanguage: Equatable {
    /// <p>The RFC 5646 language code for the dominant language. For more information about RFC
    ///       5646, see <a href="https://tools.ietf.org/html/rfc5646">Tags for Identifying
    ///         Languages</a> on the <i>IETF Tools</i> web site.</p>
    public let languageCode: String?
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the
    ///       detection.</p>
    public let score: Float?

    public init (
        languageCode: String? = nil,
        score: Float? = nil
    )
    {
        self.languageCode = languageCode
        self.score = score
    }
}

extension DominantLanguageDetectionJobFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension DominantLanguageDetectionJobFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DominantLanguageDetectionJobFilter(jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), submitTimeAfter: \(String(describing: submitTimeAfter)), submitTimeBefore: \(String(describing: submitTimeBefore)))"}
}

/// <p>Provides information for filtering a list of dominant language detection jobs. For more
///       information, see the  operation.</p>
public struct DominantLanguageDetectionJobFilter: Equatable {
    /// <p>Filters on the name of the job.</p>
    public let jobName: String?
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified
    ///       status.</p>
    public let jobStatus: JobStatus?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted after the specified time. Jobs are returned in descending order,
    ///       newest to oldest.</p>
    public let submitTimeAfter: Date?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted before the specified time. Jobs are returned in ascending order,
    ///       oldest to newest.</p>
    public let submitTimeBefore: Date?

    public init (
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        submitTimeAfter: Date? = nil,
        submitTimeBefore: Date? = nil
    )
    {
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension DominantLanguageDetectionJobProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension DominantLanguageDetectionJobProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DominantLanguageDetectionJobProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), endTime: \(String(describing: endTime)), inputDataConfig: \(String(describing: inputDataConfig)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), message: \(String(describing: message)), outputDataConfig: \(String(describing: outputDataConfig)), submitTime: \(String(describing: submitTime)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Provides information about a dominant language detection job.</p>
public struct DominantLanguageDetectionJobProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input
    ///       data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The time that the dominant language detection job completed.</p>
    public let endTime: Date?
    /// <p>The input data configuration that you supplied when you created the dominant language
    ///       detection job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier assigned to the dominant language detection job.</p>
    public let jobId: String?
    /// <p>The name that you assigned to the dominant language detection job.</p>
    public let jobName: String?
    /// <p>The current status of the dominant language detection job. If the status is
    ///         <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    public let jobStatus: JobStatus?
    /// <p>A description for the status of a job.</p>
    public let message: String?
    /// <p>The output data configuration that you supplied when you created the dominant language
    ///       detection job.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>The time that the dominant language detection job was submitted for processing.</p>
    public let submitTime: Date?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the
    ///       resources you are using for your dominant language detection job. For more information, see
    ///         <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        dataAccessRoleArn: String? = nil,
        endTime: Date? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobId: String? = nil,
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        message: String? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        submitTime: Date? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.message = message
        self.outputDataConfig = outputDataConfig
        self.submitTime = submitTime
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

extension EndpointFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTimeAfter = "CreationTimeAfter"
        case creationTimeBefore = "CreationTimeBefore"
        case modelArn = "ModelArn"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimeAfter = creationTimeAfter {
            try encodeContainer.encode(creationTimeAfter.timeIntervalSince1970, forKey: .creationTimeAfter)
        }
        if let creationTimeBefore = creationTimeBefore {
            try encodeContainer.encode(creationTimeBefore.timeIntervalSince1970, forKey: .creationTimeBefore)
        }
        if let modelArn = modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EndpointStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimeBefore)
        creationTimeBefore = creationTimeBeforeDecoded
        let creationTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimeAfter)
        creationTimeAfter = creationTimeAfterDecoded
    }
}

extension EndpointFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointFilter(creationTimeAfter: \(String(describing: creationTimeAfter)), creationTimeBefore: \(String(describing: creationTimeBefore)), modelArn: \(String(describing: modelArn)), status: \(String(describing: status)))"}
}

/// <p>The filter used to determine which endpoints are returned. You can filter jobs on their
///       name, model, status, or the date and time that they were created. You can only set one filter
///       at a time. </p>
public struct EndpointFilter: Equatable {
    /// <p>Specifies a date after which the returned endpoint or endpoints were created.</p>
    public let creationTimeAfter: Date?
    /// <p>Specifies a date before which the returned endpoint or endpoints were created.</p>
    public let creationTimeBefore: Date?
    /// <p>The Amazon Resource Number (ARN) of the model to which the endpoint is attached.</p>
    public let modelArn: String?
    /// <p>Specifies the status of the endpoint being returned. Possible values are: Creating, Ready,
    ///       Updating, Deleting, Failed.</p>
    public let status: EndpointStatus?

    public init (
        creationTimeAfter: Date? = nil,
        creationTimeBefore: Date? = nil,
        modelArn: String? = nil,
        status: EndpointStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.modelArn = modelArn
        self.status = status
    }
}

extension EndpointProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case currentInferenceUnits = "CurrentInferenceUnits"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case desiredInferenceUnits = "DesiredInferenceUnits"
        case endpointArn = "EndpointArn"
        case lastModifiedTime = "LastModifiedTime"
        case message = "Message"
        case modelArn = "ModelArn"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let currentInferenceUnits = currentInferenceUnits {
            try encodeContainer.encode(currentInferenceUnits, forKey: .currentInferenceUnits)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let desiredInferenceUnits = desiredInferenceUnits {
            try encodeContainer.encode(desiredInferenceUnits, forKey: .desiredInferenceUnits)
        }
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let modelArn = modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EndpointStatus.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let desiredInferenceUnitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .desiredInferenceUnits)
        desiredInferenceUnits = desiredInferenceUnitsDecoded
        let currentInferenceUnitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentInferenceUnits)
        currentInferenceUnits = currentInferenceUnitsDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension EndpointProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointProperties(creationTime: \(String(describing: creationTime)), currentInferenceUnits: \(String(describing: currentInferenceUnits)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), desiredInferenceUnits: \(String(describing: desiredInferenceUnits)), endpointArn: \(String(describing: endpointArn)), lastModifiedTime: \(String(describing: lastModifiedTime)), message: \(String(describing: message)), modelArn: \(String(describing: modelArn)), status: \(String(describing: status)))"}
}

/// <p>Specifies information about the specified endpoint.</p>
public struct EndpointProperties: Equatable {
    /// <p>The creation date and time of the endpoint.</p>
    public let creationTime: Date?
    /// <p>The number of inference units currently used by the model using this endpoint.</p>
    public let currentInferenceUnits: Int?
    /// <p>The Amazon Resource Name (ARN) of the AWS identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend read access to trained custom models encrypted with a customer
    ///       managed key (ModelKmsKeyId).</p>
    public let dataAccessRoleArn: String?
    /// <p>The desired number of inference units to be used by the model using this endpoint.
    ///
    ///       Each inference unit represents of a throughput of 100 characters per second.</p>
    public let desiredInferenceUnits: Int?
    /// <p>The Amazon Resource Number (ARN) of the endpoint.</p>
    public let endpointArn: String?
    /// <p>The date and time that the endpoint was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>Specifies a reason for failure in cases of <code>Failed</code> status.</p>
    public let message: String?
    /// <p>The Amazon Resource Number (ARN) of the model to which the endpoint is attached.</p>
    public let modelArn: String?
    /// <p>Specifies the status of the endpoint. Because the endpoint updates and creation are
    ///       asynchronous, so customers will need to wait for the endpoint to be <code>Ready</code> status
    ///       before making inference requests.</p>
    public let status: EndpointStatus?

    public init (
        creationTime: Date? = nil,
        currentInferenceUnits: Int? = nil,
        dataAccessRoleArn: String? = nil,
        desiredInferenceUnits: Int? = nil,
        endpointArn: String? = nil,
        lastModifiedTime: Date? = nil,
        message: String? = nil,
        modelArn: String? = nil,
        status: EndpointStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.currentInferenceUnits = currentInferenceUnits
        self.dataAccessRoleArn = dataAccessRoleArn
        self.desiredInferenceUnits = desiredInferenceUnits
        self.endpointArn = endpointArn
        self.lastModifiedTime = lastModifiedTime
        self.message = message
        self.modelArn = modelArn
        self.status = status
    }
}

public enum EndpointStatus {
    case creating
    case deleting
    case failed
    case inService
    case updating
    case sdkUnknown(String)
}

extension EndpointStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EndpointStatus] {
        return [
            .creating,
            .deleting,
            .failed,
            .inService,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .inService: return "IN_SERVICE"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EndpointStatus(rawValue: rawValue) ?? EndpointStatus.sdkUnknown(rawValue)
    }
}

extension EntitiesDetectionJobFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension EntitiesDetectionJobFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntitiesDetectionJobFilter(jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), submitTimeAfter: \(String(describing: submitTimeAfter)), submitTimeBefore: \(String(describing: submitTimeBefore)))"}
}

/// <p>Provides information for filtering a list of dominant language detection jobs. For more
///       information, see the  operation.</p>
public struct EntitiesDetectionJobFilter: Equatable {
    /// <p>Filters on the name of the job.</p>
    public let jobName: String?
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified
    ///       status.</p>
    public let jobStatus: JobStatus?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted after the specified time. Jobs are returned in descending order,
    ///       newest to oldest.</p>
    public let submitTimeAfter: Date?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted before the specified time. Jobs are returned in ascending order,
    ///       oldest to newest.</p>
    public let submitTimeBefore: Date?

    public init (
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        submitTimeAfter: Date? = nil,
        submitTimeBefore: Date? = nil
    )
    {
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension EntitiesDetectionJobProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case entityRecognizerArn = "EntityRecognizerArn"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case languageCode = "LanguageCode"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let entityRecognizerArn = entityRecognizerArn {
            try encodeContainer.encode(entityRecognizerArn, forKey: .entityRecognizerArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let entityRecognizerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityRecognizerArn)
        entityRecognizerArn = entityRecognizerArnDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension EntitiesDetectionJobProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntitiesDetectionJobProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), endTime: \(String(describing: endTime)), entityRecognizerArn: \(String(describing: entityRecognizerArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), languageCode: \(String(describing: languageCode)), message: \(String(describing: message)), outputDataConfig: \(String(describing: outputDataConfig)), submitTime: \(String(describing: submitTime)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Provides information about an entities detection job.</p>
public struct EntitiesDetectionJobProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input
    ///       data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The time that the entities detection job completed</p>
    public let endTime: Date?
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    public let entityRecognizerArn: String?
    /// <p>The input data configuration that you supplied when you created the entities detection
    ///       job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier assigned to the entities detection job.</p>
    public let jobId: String?
    /// <p>The name that you assigned the entities detection job.</p>
    public let jobName: String?
    /// <p>The current status of the entities detection job. If the status is <code>FAILED</code>,
    ///       the <code>Message</code> field shows the reason for the failure.</p>
    public let jobStatus: JobStatus?
    /// <p>The language code of the input documents.</p>
    public let languageCode: LanguageCode?
    /// <p>A description of the status of a job.</p>
    public let message: String?
    /// <p>The output data configuration that you supplied when you created the entities detection
    ///       job. </p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>The time that the entities detection job was submitted for processing.</p>
    public let submitTime: Date?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the
    ///       resources you are using for your entity detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        dataAccessRoleArn: String? = nil,
        endTime: Date? = nil,
        entityRecognizerArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobId: String? = nil,
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        languageCode: LanguageCode? = nil,
        message: String? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        submitTime: Date? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.endTime = endTime
        self.entityRecognizerArn = entityRecognizerArn
        self.inputDataConfig = inputDataConfig
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.languageCode = languageCode
        self.message = message
        self.outputDataConfig = outputDataConfig
        self.submitTime = submitTime
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

extension Entity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginOffset = "BeginOffset"
        case endOffset = "EndOffset"
        case score = "Score"
        case text = "Text"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EntityType.self, forKey: .type)
        type = typeDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
    }
}

extension Entity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Entity(beginOffset: \(String(describing: beginOffset)), endOffset: \(String(describing: endOffset)), score: \(String(describing: score)), text: \(String(describing: text)), type: \(String(describing: type)))"}
}

/// <p>Provides information about an entity. </p>
///          <p> </p>
public struct Entity: Equatable {
    /// <p>A character offset in the input text that shows where the entity begins (the first
    ///       character is at position 0). The offset returns the position of each UTF-8 code point in the
    ///       string. A <i>code point</i> is the abstract character from a particular
    ///       graphical representation. For example, a multi-byte UTF-8 character maps to a single code
    ///       point.</p>
    public let beginOffset: Int?
    /// <p>A character offset in the input text that shows where the entity ends. The offset
    ///       returns the position of each UTF-8 code point in the string. A <i>code point</i>
    ///       is the abstract character from a particular graphical representation. For example, a
    ///       multi-byte UTF-8 character maps to a single code point. </p>
    public let endOffset: Int?
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the
    ///       detection.</p>
    public let score: Float?
    /// <p>The text of the entity.</p>
    public let text: String?
    /// <p>The entity's type.</p>
    public let type: EntityType?

    public init (
        beginOffset: Int? = nil,
        endOffset: Int? = nil,
        score: Float? = nil,
        text: String? = nil,
        type: EntityType? = nil
    )
    {
        self.beginOffset = beginOffset
        self.endOffset = endOffset
        self.score = score
        self.text = text
        self.type = type
    }
}

extension EntityLabel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PiiEntityType.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension EntityLabel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityLabel(name: \(String(describing: name)), score: \(String(describing: score)))"}
}

/// <p>Specifies one of the label or labels that categorize the personally identifiable
///       information (PII) entity being analyzed.</p>
public struct EntityLabel: Equatable {
    /// <p>The name of the label.</p>
    public let name: PiiEntityType?
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the
    ///       detection.</p>
    public let score: Float?

    public init (
        name: PiiEntityType? = nil,
        score: Float? = nil
    )
    {
        self.name = name
        self.score = score
    }
}

extension EntityRecognizerAnnotations: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension EntityRecognizerAnnotations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityRecognizerAnnotations(s3Uri: \(String(describing: s3Uri)))"}
}

/// <p>Describes the annotations associated with a entity recognizer.</p>
public struct EntityRecognizerAnnotations: Equatable {
    /// <p> Specifies the Amazon S3 location where the annotations for an entity recognizer are
    ///       located. The URI must be in the same region as the API endpoint that you are calling.</p>
    public let s3Uri: String?

    public init (
        s3Uri: String? = nil
    )
    {
        self.s3Uri = s3Uri
    }
}

public enum EntityRecognizerDataFormat {
    case augmentedManifest
    case comprehendCsv
    case sdkUnknown(String)
}

extension EntityRecognizerDataFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntityRecognizerDataFormat] {
        return [
            .augmentedManifest,
            .comprehendCsv,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .augmentedManifest: return "AUGMENTED_MANIFEST"
        case .comprehendCsv: return "COMPREHEND_CSV"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntityRecognizerDataFormat(rawValue: rawValue) ?? EntityRecognizerDataFormat.sdkUnknown(rawValue)
    }
}

extension EntityRecognizerDocuments: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension EntityRecognizerDocuments: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityRecognizerDocuments(s3Uri: \(String(describing: s3Uri)))"}
}

/// <p>Describes the training documents submitted with an entity recognizer.</p>
public struct EntityRecognizerDocuments: Equatable {
    /// <p> Specifies the Amazon S3 location where the training documents for an entity recognizer
    ///       are located. The URI must be in the same region as the API endpoint that you are
    ///       calling.</p>
    public let s3Uri: String?

    public init (
        s3Uri: String? = nil
    )
    {
        self.s3Uri = s3Uri
    }
}

extension EntityRecognizerEntityList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension EntityRecognizerEntityList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityRecognizerEntityList(s3Uri: \(String(describing: s3Uri)))"}
}

/// <p>Describes the entity recognizer submitted with an entity recognizer.</p>
public struct EntityRecognizerEntityList: Equatable {
    /// <p>Specifies the Amazon S3 location where the entity list is located. The URI must be in the
    ///       same region as the API endpoint that you are calling.</p>
    public let s3Uri: String?

    public init (
        s3Uri: String? = nil
    )
    {
        self.s3Uri = s3Uri
    }
}

extension EntityRecognizerEvaluationMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case f1Score = "F1Score"
        case precision = "Precision"
        case recall = "Recall"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let f1Score = f1Score {
            try encodeContainer.encode(f1Score, forKey: .f1Score)
        }
        if let precision = precision {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if let recall = recall {
            try encodeContainer.encode(recall, forKey: .recall)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let precisionDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .precision)
        precision = precisionDecoded
        let recallDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .recall)
        recall = recallDecoded
        let f1ScoreDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .f1Score)
        f1Score = f1ScoreDecoded
    }
}

extension EntityRecognizerEvaluationMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityRecognizerEvaluationMetrics(f1Score: \(String(describing: f1Score)), precision: \(String(describing: precision)), recall: \(String(describing: recall)))"}
}

/// <p>Detailed information about the accuracy of an entity recognizer. </p>
public struct EntityRecognizerEvaluationMetrics: Equatable {
    /// <p>A measure of how accurate the recognizer results are for the test data. It is derived from
    ///       the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the
    ///       harmonic average of the two scores. The highest score is 1, and the worst score is 0. </p>
    public let f1Score: Double?
    /// <p>A measure of the usefulness of the recognizer results in the test data. High precision
    ///       means that the recognizer returned substantially more relevant results than irrelevant ones.
    ///     </p>
    public let precision: Double?
    /// <p>A measure of how complete the recognizer results are for the test data. High recall means
    ///       that the recognizer returned most of the relevant results.</p>
    public let recall: Double?

    public init (
        f1Score: Double? = nil,
        precision: Double? = nil,
        recall: Double? = nil
    )
    {
        self.f1Score = f1Score
        self.precision = precision
        self.recall = recall
    }
}

extension EntityRecognizerFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ModelStatus.self, forKey: .status)
        status = statusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension EntityRecognizerFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityRecognizerFilter(status: \(String(describing: status)), submitTimeAfter: \(String(describing: submitTimeAfter)), submitTimeBefore: \(String(describing: submitTimeBefore)))"}
}

/// <p>Provides information for filtering a list of entity recognizers. You can only specify one
///       filtering parameter in a request. For more information, see the  operation./></p>
public struct EntityRecognizerFilter: Equatable {
    /// <p>The status of an entity recognizer.</p>
    public let status: ModelStatus?
    /// <p>Filters the list of entities based on the time that the list was submitted for processing.
    ///       Returns only jobs submitted after the specified time. Jobs are returned in ascending order,
    ///       oldest to newest.</p>
    public let submitTimeAfter: Date?
    /// <p>Filters the list of entities based on the time that the list was submitted for processing.
    ///       Returns only jobs submitted before the specified time. Jobs are returned in descending order,
    ///       newest to oldest.</p>
    public let submitTimeBefore: Date?

    public init (
        status: ModelStatus? = nil,
        submitTimeAfter: Date? = nil,
        submitTimeBefore: Date? = nil
    )
    {
        self.status = status
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension EntityRecognizerInputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case annotations = "Annotations"
        case augmentedManifests = "AugmentedManifests"
        case dataFormat = "DataFormat"
        case documents = "Documents"
        case entityList = "EntityList"
        case entityTypes = "EntityTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotations = annotations {
            try encodeContainer.encode(annotations, forKey: .annotations)
        }
        if let augmentedManifests = augmentedManifests {
            var augmentedManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .augmentedManifests)
            for entityrecognizeraugmentedmanifestslist0 in augmentedManifests {
                try augmentedManifestsContainer.encode(entityrecognizeraugmentedmanifestslist0)
            }
        }
        if let dataFormat = dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let documents = documents {
            try encodeContainer.encode(documents, forKey: .documents)
        }
        if let entityList = entityList {
            try encodeContainer.encode(entityList, forKey: .entityList)
        }
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for entitytypeslist0 in entityTypes {
                try entityTypesContainer.encode(entitytypeslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataFormatDecoded = try containerValues.decodeIfPresent(EntityRecognizerDataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let entityTypesContainer = try containerValues.decodeIfPresent([EntityTypesListItem?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[EntityTypesListItem]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [EntityTypesListItem]()
            for structure0 in entityTypesContainer {
                if let structure0 = structure0 {
                    entityTypesDecoded0?.append(structure0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let documentsDecoded = try containerValues.decodeIfPresent(EntityRecognizerDocuments.self, forKey: .documents)
        documents = documentsDecoded
        let annotationsDecoded = try containerValues.decodeIfPresent(EntityRecognizerAnnotations.self, forKey: .annotations)
        annotations = annotationsDecoded
        let entityListDecoded = try containerValues.decodeIfPresent(EntityRecognizerEntityList.self, forKey: .entityList)
        entityList = entityListDecoded
        let augmentedManifestsContainer = try containerValues.decodeIfPresent([AugmentedManifestsListItem?].self, forKey: .augmentedManifests)
        var augmentedManifestsDecoded0:[AugmentedManifestsListItem]? = nil
        if let augmentedManifestsContainer = augmentedManifestsContainer {
            augmentedManifestsDecoded0 = [AugmentedManifestsListItem]()
            for structure0 in augmentedManifestsContainer {
                if let structure0 = structure0 {
                    augmentedManifestsDecoded0?.append(structure0)
                }
            }
        }
        augmentedManifests = augmentedManifestsDecoded0
    }
}

extension EntityRecognizerInputDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityRecognizerInputDataConfig(annotations: \(String(describing: annotations)), augmentedManifests: \(String(describing: augmentedManifests)), dataFormat: \(String(describing: dataFormat)), documents: \(String(describing: documents)), entityList: \(String(describing: entityList)), entityTypes: \(String(describing: entityTypes)))"}
}

/// <p>Specifies the format and location of the input data.</p>
public struct EntityRecognizerInputDataConfig: Equatable {
    /// <p>The S3 location of the CSV file that annotates your training documents.</p>
    public let annotations: EntityRecognizerAnnotations?
    /// <p>A list of augmented manifest files that provide training data for your custom model. An
    ///       augmented manifest file is a labeled dataset that is produced by Amazon SageMaker Ground
    ///       Truth.</p>
    ///          <p>This parameter is required if you set <code>DataFormat</code> to
    ///         <code>AUGMENTED_MANIFEST</code>.</p>
    public let augmentedManifests: [AugmentedManifestsListItem]?
    /// <p>The format of your training data:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>COMPREHEND_CSV</code>: A CSV file that supplements your training documents. The
    ///           CSV file contains information about the custom entities that your trained model will
    ///           detect. The required format of the file depends on whether you are providing annotations
    ///           or an entity list.</p>
    ///                <p>If you use this value, you must provide your CSV file by using either the
    ///             <code>Annotations</code> or <code>EntityList</code> parameters. You must provide your
    ///           training documents by using the <code>Documents</code> parameter.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AUGMENTED_MANIFEST</code>: A labeled dataset that is produced by Amazon
    ///           SageMaker Ground Truth. This file is in JSON lines format. Each line is a complete JSON
    ///           object that contains a training document and its labels. Each label annotates a named
    ///           entity in the training document. </p>
    ///                <p>If you use this value, you must provide the <code>AugmentedManifests</code> parameter
    ///           in your request.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't specify a value, Amazon Comprehend uses <code>COMPREHEND_CSV</code> as the
    ///       default.</p>
    public let dataFormat: EntityRecognizerDataFormat?
    /// <p>The S3 location of the folder that contains the training documents for your custom entity
    ///       recognizer.</p>
    ///          <p>This parameter is required if you set <code>DataFormat</code> to
    ///         <code>COMPREHEND_CSV</code>.</p>
    public let documents: EntityRecognizerDocuments?
    /// <p>The S3 location of the CSV file that has the entity list for your custom entity
    ///       recognizer.</p>
    public let entityList: EntityRecognizerEntityList?
    /// <p>The entity types in the labeled training data that Amazon Comprehend uses to train the
    ///       custom entity recognizer. Any entity types that you don't specify are ignored.</p>
    ///          <p>A maximum of 25 entity types can be used at one time to train an entity recognizer. Entity
    ///       types must not contain the following invalid characters: \n (line break), \\n (escaped line
    ///       break), \r (carriage return), \\r (escaped carriage return), \t (tab), \\t (escaped tab),
    ///       space, and , (comma). </p>
    public let entityTypes: [EntityTypesListItem]?

    public init (
        annotations: EntityRecognizerAnnotations? = nil,
        augmentedManifests: [AugmentedManifestsListItem]? = nil,
        dataFormat: EntityRecognizerDataFormat? = nil,
        documents: EntityRecognizerDocuments? = nil,
        entityList: EntityRecognizerEntityList? = nil,
        entityTypes: [EntityTypesListItem]? = nil
    )
    {
        self.annotations = annotations
        self.augmentedManifests = augmentedManifests
        self.dataFormat = dataFormat
        self.documents = documents
        self.entityList = entityList
        self.entityTypes = entityTypes
    }
}

extension EntityRecognizerMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityTypes = "EntityTypes"
        case evaluationMetrics = "EvaluationMetrics"
        case numberOfTestDocuments = "NumberOfTestDocuments"
        case numberOfTrainedDocuments = "NumberOfTrainedDocuments"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for entityrecognizermetadataentitytypeslist0 in entityTypes {
                try entityTypesContainer.encode(entityrecognizermetadataentitytypeslist0)
            }
        }
        if let evaluationMetrics = evaluationMetrics {
            try encodeContainer.encode(evaluationMetrics, forKey: .evaluationMetrics)
        }
        if let numberOfTestDocuments = numberOfTestDocuments {
            try encodeContainer.encode(numberOfTestDocuments, forKey: .numberOfTestDocuments)
        }
        if let numberOfTrainedDocuments = numberOfTrainedDocuments {
            try encodeContainer.encode(numberOfTrainedDocuments, forKey: .numberOfTrainedDocuments)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfTrainedDocumentsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfTrainedDocuments)
        numberOfTrainedDocuments = numberOfTrainedDocumentsDecoded
        let numberOfTestDocumentsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfTestDocuments)
        numberOfTestDocuments = numberOfTestDocumentsDecoded
        let evaluationMetricsDecoded = try containerValues.decodeIfPresent(EntityRecognizerEvaluationMetrics.self, forKey: .evaluationMetrics)
        evaluationMetrics = evaluationMetricsDecoded
        let entityTypesContainer = try containerValues.decodeIfPresent([EntityRecognizerMetadataEntityTypesListItem?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[EntityRecognizerMetadataEntityTypesListItem]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [EntityRecognizerMetadataEntityTypesListItem]()
            for structure0 in entityTypesContainer {
                if let structure0 = structure0 {
                    entityTypesDecoded0?.append(structure0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
    }
}

extension EntityRecognizerMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>Detailed information about an entity recognizer.</p>
public struct EntityRecognizerMetadata: Equatable {
    /// <p>Entity types from the metadata of an entity recognizer.</p>
    public let entityTypes: [EntityRecognizerMetadataEntityTypesListItem]?
    /// <p>Detailed information about the accuracy of an entity recognizer.</p>
    public let evaluationMetrics: EntityRecognizerEvaluationMetrics?
    /// <p> The number of documents in the input data that were used to test the entity recognizer.
    ///       Typically this is 10 to 20 percent of the input documents.</p>
    public let numberOfTestDocuments: Int?
    /// <p> The number of documents in the input data that were used to train the entity recognizer.
    ///       Typically this is 80 to 90 percent of the input documents.</p>
    public let numberOfTrainedDocuments: Int?

    public init (
        entityTypes: [EntityRecognizerMetadataEntityTypesListItem]? = nil,
        evaluationMetrics: EntityRecognizerEvaluationMetrics? = nil,
        numberOfTestDocuments: Int? = nil,
        numberOfTrainedDocuments: Int? = nil
    )
    {
        self.entityTypes = entityTypes
        self.evaluationMetrics = evaluationMetrics
        self.numberOfTestDocuments = numberOfTestDocuments
        self.numberOfTrainedDocuments = numberOfTrainedDocuments
    }
}

extension EntityRecognizerMetadataEntityTypesListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evaluationMetrics = "EvaluationMetrics"
        case numberOfTrainMentions = "NumberOfTrainMentions"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationMetrics = evaluationMetrics {
            try encodeContainer.encode(evaluationMetrics, forKey: .evaluationMetrics)
        }
        if let numberOfTrainMentions = numberOfTrainMentions {
            try encodeContainer.encode(numberOfTrainMentions, forKey: .numberOfTrainMentions)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let evaluationMetricsDecoded = try containerValues.decodeIfPresent(EntityTypesEvaluationMetrics.self, forKey: .evaluationMetrics)
        evaluationMetrics = evaluationMetricsDecoded
        let numberOfTrainMentionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfTrainMentions)
        numberOfTrainMentions = numberOfTrainMentionsDecoded
    }
}

extension EntityRecognizerMetadataEntityTypesListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityRecognizerMetadataEntityTypesListItem(evaluationMetrics: \(String(describing: evaluationMetrics)), numberOfTrainMentions: \(String(describing: numberOfTrainMentions)), type: \(String(describing: type)))"}
}

/// <p>Individual item from the list of entity types in the metadata of an entity
///       recognizer.</p>
public struct EntityRecognizerMetadataEntityTypesListItem: Equatable {
    /// <p>Detailed information about the accuracy of the entity recognizer for a specific item on
    ///       the list of entity types. </p>
    public let evaluationMetrics: EntityTypesEvaluationMetrics?
    /// <p>Indicates the number of times the given entity type was seen in the training data. </p>
    public let numberOfTrainMentions: Int?
    /// <p>Type of entity from the list of entity types in the metadata of an entity recognizer.
    ///     </p>
    public let type: String?

    public init (
        evaluationMetrics: EntityTypesEvaluationMetrics? = nil,
        numberOfTrainMentions: Int? = nil,
        type: String? = nil
    )
    {
        self.evaluationMetrics = evaluationMetrics
        self.numberOfTrainMentions = numberOfTrainMentions
        self.type = type
    }
}

extension EntityRecognizerProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case entityRecognizerArn = "EntityRecognizerArn"
        case inputDataConfig = "InputDataConfig"
        case languageCode = "LanguageCode"
        case message = "Message"
        case modelKmsKeyId = "ModelKmsKeyId"
        case recognizerMetadata = "RecognizerMetadata"
        case status = "Status"
        case submitTime = "SubmitTime"
        case trainingEndTime = "TrainingEndTime"
        case trainingStartTime = "TrainingStartTime"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let entityRecognizerArn = entityRecognizerArn {
            try encodeContainer.encode(entityRecognizerArn, forKey: .entityRecognizerArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let modelKmsKeyId = modelKmsKeyId {
            try encodeContainer.encode(modelKmsKeyId, forKey: .modelKmsKeyId)
        }
        if let recognizerMetadata = recognizerMetadata {
            try encodeContainer.encode(recognizerMetadata, forKey: .recognizerMetadata)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let trainingEndTime = trainingEndTime {
            try encodeContainer.encode(trainingEndTime.timeIntervalSince1970, forKey: .trainingEndTime)
        }
        if let trainingStartTime = trainingStartTime {
            try encodeContainer.encode(trainingStartTime.timeIntervalSince1970, forKey: .trainingStartTime)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityRecognizerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityRecognizerArn)
        entityRecognizerArn = entityRecognizerArnDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ModelStatus.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let trainingStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .trainingStartTime)
        trainingStartTime = trainingStartTimeDecoded
        let trainingEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .trainingEndTime)
        trainingEndTime = trainingEndTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(EntityRecognizerInputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let recognizerMetadataDecoded = try containerValues.decodeIfPresent(EntityRecognizerMetadata.self, forKey: .recognizerMetadata)
        recognizerMetadata = recognizerMetadataDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let modelKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelKmsKeyId)
        modelKmsKeyId = modelKmsKeyIdDecoded
    }
}

extension EntityRecognizerProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityRecognizerProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), endTime: \(String(describing: endTime)), entityRecognizerArn: \(String(describing: entityRecognizerArn)), inputDataConfig: \(String(describing: inputDataConfig)), languageCode: \(String(describing: languageCode)), message: \(String(describing: message)), modelKmsKeyId: \(String(describing: modelKmsKeyId)), recognizerMetadata: \(String(describing: recognizerMetadata)), status: \(String(describing: status)), submitTime: \(String(describing: submitTime)), trainingEndTime: \(String(describing: trainingEndTime)), trainingStartTime: \(String(describing: trainingStartTime)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Describes information about an entity recognizer.</p>
public struct EntityRecognizerProperties: Equatable {
    /// <p> The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants
    ///       Amazon Comprehend read access to your input data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The time that the recognizer creation completed.</p>
    public let endTime: Date?
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    public let entityRecognizerArn: String?
    /// <p>The input data properties of an entity recognizer.</p>
    public let inputDataConfig: EntityRecognizerInputDataConfig?
    /// <p> The language of the input documents. All documents must be in the same language. Only
    ///       English ("en") is currently supported.</p>
    public let languageCode: LanguageCode?
    /// <p> A description of the status of the recognizer.</p>
    public let message: String?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       trained custom models. The ModelKmsKeyId can be either of the following formats: </p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let modelKmsKeyId: String?
    /// <p> Provides information about an entity recognizer.</p>
    public let recognizerMetadata: EntityRecognizerMetadata?
    /// <p>Provides the status of the entity recognizer.</p>
    public let status: ModelStatus?
    /// <p>The time that the recognizer was submitted for processing.</p>
    public let submitTime: Date?
    /// <p>The time that training of the entity recognizer was completed.</p>
    public let trainingEndTime: Date?
    /// <p>The time that training of the entity recognizer started.</p>
    public let trainingStartTime: Date?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the
    ///       resources you are using for your custom entity recognizer. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        dataAccessRoleArn: String? = nil,
        endTime: Date? = nil,
        entityRecognizerArn: String? = nil,
        inputDataConfig: EntityRecognizerInputDataConfig? = nil,
        languageCode: LanguageCode? = nil,
        message: String? = nil,
        modelKmsKeyId: String? = nil,
        recognizerMetadata: EntityRecognizerMetadata? = nil,
        status: ModelStatus? = nil,
        submitTime: Date? = nil,
        trainingEndTime: Date? = nil,
        trainingStartTime: Date? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.endTime = endTime
        self.entityRecognizerArn = entityRecognizerArn
        self.inputDataConfig = inputDataConfig
        self.languageCode = languageCode
        self.message = message
        self.modelKmsKeyId = modelKmsKeyId
        self.recognizerMetadata = recognizerMetadata
        self.status = status
        self.submitTime = submitTime
        self.trainingEndTime = trainingEndTime
        self.trainingStartTime = trainingStartTime
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

public enum EntityType {
    case commercialItem
    case date
    case event
    case location
    case organization
    case other
    case person
    case quantity
    case title
    case sdkUnknown(String)
}

extension EntityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntityType] {
        return [
            .commercialItem,
            .date,
            .event,
            .location,
            .organization,
            .other,
            .person,
            .quantity,
            .title,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .commercialItem: return "COMMERCIAL_ITEM"
        case .date: return "DATE"
        case .event: return "EVENT"
        case .location: return "LOCATION"
        case .organization: return "ORGANIZATION"
        case .other: return "OTHER"
        case .person: return "PERSON"
        case .quantity: return "QUANTITY"
        case .title: return "TITLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
    }
}

extension EntityTypesEvaluationMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case f1Score = "F1Score"
        case precision = "Precision"
        case recall = "Recall"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let f1Score = f1Score {
            try encodeContainer.encode(f1Score, forKey: .f1Score)
        }
        if let precision = precision {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if let recall = recall {
            try encodeContainer.encode(recall, forKey: .recall)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let precisionDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .precision)
        precision = precisionDecoded
        let recallDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .recall)
        recall = recallDecoded
        let f1ScoreDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .f1Score)
        f1Score = f1ScoreDecoded
    }
}

extension EntityTypesEvaluationMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityTypesEvaluationMetrics(f1Score: \(String(describing: f1Score)), precision: \(String(describing: precision)), recall: \(String(describing: recall)))"}
}

/// <p>Detailed information about the accuracy of an entity recognizer for a specific entity
///       type. </p>
public struct EntityTypesEvaluationMetrics: Equatable {
    /// <p>A measure of how accurate the recognizer results are for a specific entity type in the
    ///       test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The
    ///         <code>F1Score</code> is the harmonic average of the two scores. The highest score is 1, and
    ///       the worst score is 0. </p>
    public let f1Score: Double?
    /// <p>A measure of the usefulness of the recognizer results for a specific entity type in the
    ///       test data. High precision means that the recognizer returned substantially more relevant
    ///       results than irrelevant ones. </p>
    public let precision: Double?
    /// <p>A measure of how complete the recognizer results are for a specific entity type in the
    ///       test data. High recall means that the recognizer returned most of the relevant results.</p>
    public let recall: Double?

    public init (
        f1Score: Double? = nil,
        precision: Double? = nil,
        recall: Double? = nil
    )
    {
        self.f1Score = f1Score
        self.precision = precision
        self.recall = recall
    }
}

extension EntityTypesListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension EntityTypesListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityTypesListItem(type: \(String(describing: type)))"}
}

/// <p>An entity type within a labeled training dataset that Amazon Comprehend uses to train a
///       custom entity recognizer.</p>
public struct EntityTypesListItem: Equatable {
    /// <p>An entity type within a labeled training dataset that Amazon Comprehend uses to train a
    ///       custom entity recognizer.</p>
    ///          <p>Entity types must not contain the following invalid characters: \n (line break), \\n
    ///       (escaped line break, \r (carriage return), \\r (escaped carriage return), \t (tab), \\t
    ///       (escaped tab), space, and , (comma).</p>
    public let type: String?

    public init (
        type: String? = nil
    )
    {
        self.type = type
    }
}

extension EventsDetectionJobFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension EventsDetectionJobFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventsDetectionJobFilter(jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), submitTimeAfter: \(String(describing: submitTimeAfter)), submitTimeBefore: \(String(describing: submitTimeBefore)))"}
}

/// <p>Provides information for filtering a list of event detection jobs.</p>
public struct EventsDetectionJobFilter: Equatable {
    /// <p>Filters on the name of the events detection job.</p>
    public let jobName: String?
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified
    ///       status.</p>
    public let jobStatus: JobStatus?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted after the specified time. Jobs are returned in descending order,
    ///       newest to oldest.</p>
    public let submitTimeAfter: Date?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted before the specified time. Jobs are returned in ascending order,
    ///       oldest to newest.</p>
    public let submitTimeBefore: Date?

    public init (
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        submitTimeAfter: Date? = nil,
        submitTimeBefore: Date? = nil
    )
    {
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension EventsDetectionJobProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case languageCode = "LanguageCode"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
        case targetEventTypes = "TargetEventTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let targetEventTypes = targetEventTypes {
            var targetEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetEventTypes)
            for targeteventtypes0 in targetEventTypes {
                try targetEventTypesContainer.encode(targeteventtypes0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let targetEventTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetEventTypes)
        var targetEventTypesDecoded0:[String]? = nil
        if let targetEventTypesContainer = targetEventTypesContainer {
            targetEventTypesDecoded0 = [String]()
            for string0 in targetEventTypesContainer {
                if let string0 = string0 {
                    targetEventTypesDecoded0?.append(string0)
                }
            }
        }
        targetEventTypes = targetEventTypesDecoded0
    }
}

extension EventsDetectionJobProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventsDetectionJobProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), endTime: \(String(describing: endTime)), inputDataConfig: \(String(describing: inputDataConfig)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), languageCode: \(String(describing: languageCode)), message: \(String(describing: message)), outputDataConfig: \(String(describing: outputDataConfig)), submitTime: \(String(describing: submitTime)), targetEventTypes: \(String(describing: targetEventTypes)))"}
}

/// <p>Provides information about an events detection job.</p>
public struct EventsDetectionJobProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Identify and Access Management (IAM) role that
    ///       grants Amazon Comprehend read access to your input data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The time that the events detection job completed.</p>
    public let endTime: Date?
    /// <p>The input data configuration that you supplied when you created the events detection
    ///       job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier assigned to the events detection job.</p>
    public let jobId: String?
    /// <p>The name you assigned the events detection job.</p>
    public let jobName: String?
    /// <p>The current status of the events detection job.</p>
    public let jobStatus: JobStatus?
    /// <p>The language code of the input documents.</p>
    public let languageCode: LanguageCode?
    /// <p>A description of the status of the events detection job.</p>
    public let message: String?
    /// <p>The output data configuration that you supplied when you created the events detection
    ///       job.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>The time that the events detection job was submitted for processing.</p>
    public let submitTime: Date?
    /// <p>The types of events that are detected by the job.</p>
    public let targetEventTypes: [String]?

    public init (
        dataAccessRoleArn: String? = nil,
        endTime: Date? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobId: String? = nil,
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        languageCode: LanguageCode? = nil,
        message: String? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        submitTime: Date? = nil,
        targetEventTypes: [String]? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.languageCode = languageCode
        self.message = message
        self.outputDataConfig = outputDataConfig
        self.submitTime = submitTime
        self.targetEventTypes = targetEventTypes
    }
}

extension InputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputFormat = "InputFormat"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputFormat = inputFormat {
            try encodeContainer.encode(inputFormat.rawValue, forKey: .inputFormat)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let inputFormatDecoded = try containerValues.decodeIfPresent(InputFormat.self, forKey: .inputFormat)
        inputFormat = inputFormatDecoded
    }
}

extension InputDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputDataConfig(inputFormat: \(String(describing: inputFormat)), s3Uri: \(String(describing: s3Uri)))"}
}

/// <p>The input properties for a topic detection job.</p>
public struct InputDataConfig: Equatable {
    /// <p>Specifies how the text in an input file should be processed:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ONE_DOC_PER_FILE</code> - Each file is considered a separate document. Use
    ///           this option when you are processing large documents, such as newspaper articles or
    ///           scientific papers.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ONE_DOC_PER_LINE</code> - Each line in a file is considered a separate
    ///           document. Use this option when you are processing many short documents, such as text
    ///           messages.</p>
    ///             </li>
    ///          </ul>
    public let inputFormat: InputFormat?
    /// <p>The Amazon S3 URI for the input data. The URI must be in same region as the API
    ///       endpoint that you are calling. The URI can point to a single input file or it can provide the
    ///       prefix for a collection of data files. </p>
    ///          <p>For example, if you use the URI <code>S3://bucketName/prefix</code>, if the prefix is a
    ///       single file, Amazon Comprehend uses that file as input. If more than one file begins with the
    ///       prefix, Amazon Comprehend uses all of them as input.</p>
    public let s3Uri: String?

    public init (
        inputFormat: InputFormat? = nil,
        s3Uri: String? = nil
    )
    {
        self.inputFormat = inputFormat
        self.s3Uri = s3Uri
    }
}

public enum InputFormat {
    case oneDocPerFile
    case oneDocPerLine
    case sdkUnknown(String)
}

extension InputFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InputFormat] {
        return [
            .oneDocPerFile,
            .oneDocPerLine,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .oneDocPerFile: return "ONE_DOC_PER_FILE"
        case .oneDocPerLine: return "ONE_DOC_PER_LINE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InputFormat(rawValue: rawValue) ?? InputFormat.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal server error occurred. Retry your request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidFilterException(message: \(String(describing: message)))"}
}

extension InvalidFilterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidFilterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The filter specified for the operation is invalid. Specify a different
///       filter.</p>
public struct InvalidFilterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidFilterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is invalid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JobNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobNotFoundException(message: \(String(describing: message)))"}
}

extension JobNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: JobNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified job was not found. Check the job ID and try again.</p>
public struct JobNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct JobNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension JobNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum JobStatus {
    case completed
    case failed
    case inProgress
    case stopped
    case stopRequested
    case submitted
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .completed,
            .failed,
            .inProgress,
            .stopped,
            .stopRequested,
            .submitted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .stopped: return "STOPPED"
        case .stopRequested: return "STOP_REQUESTED"
        case .submitted: return "SUBMITTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

extension KeyPhrase: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginOffset = "BeginOffset"
        case endOffset = "EndOffset"
        case score = "Score"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
    }
}

extension KeyPhrase: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyPhrase(beginOffset: \(String(describing: beginOffset)), endOffset: \(String(describing: endOffset)), score: \(String(describing: score)), text: \(String(describing: text)))"}
}

/// <p>Describes a key noun phrase.</p>
public struct KeyPhrase: Equatable {
    /// <p>A character offset in the input text that shows where the key phrase begins (the first
    ///       character is at position 0). The offset returns the position of each UTF-8 code point in the
    ///       string. A <i>code point</i> is the abstract character from a particular
    ///       graphical representation. For example, a multi-byte UTF-8 character maps to a single code
    ///       point.</p>
    public let beginOffset: Int?
    /// <p>A character offset in the input text where the key phrase ends. The offset returns the
    ///       position of each UTF-8 code point in the string. A <code>code point</code> is the abstract
    ///       character from a particular graphical representation. For example, a multi-byte UTF-8
    ///       character maps to a single code point.</p>
    public let endOffset: Int?
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the
    ///       detection.</p>
    public let score: Float?
    /// <p>The text of a key noun phrase.</p>
    public let text: String?

    public init (
        beginOffset: Int? = nil,
        endOffset: Int? = nil,
        score: Float? = nil,
        text: String? = nil
    )
    {
        self.beginOffset = beginOffset
        self.endOffset = endOffset
        self.score = score
        self.text = text
    }
}

extension KeyPhrasesDetectionJobFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension KeyPhrasesDetectionJobFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyPhrasesDetectionJobFilter(jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), submitTimeAfter: \(String(describing: submitTimeAfter)), submitTimeBefore: \(String(describing: submitTimeBefore)))"}
}

/// <p>Provides information for filtering a list of dominant language detection jobs. For more
///       information, see the  operation.</p>
public struct KeyPhrasesDetectionJobFilter: Equatable {
    /// <p>Filters on the name of the job.</p>
    public let jobName: String?
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified
    ///       status.</p>
    public let jobStatus: JobStatus?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted after the specified time. Jobs are returned in descending order,
    ///       newest to oldest.</p>
    public let submitTimeAfter: Date?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted before the specified time. Jobs are returned in ascending order,
    ///       oldest to newest.</p>
    public let submitTimeBefore: Date?

    public init (
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        submitTimeAfter: Date? = nil,
        submitTimeBefore: Date? = nil
    )
    {
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension KeyPhrasesDetectionJobProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case languageCode = "LanguageCode"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension KeyPhrasesDetectionJobProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyPhrasesDetectionJobProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), endTime: \(String(describing: endTime)), inputDataConfig: \(String(describing: inputDataConfig)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), languageCode: \(String(describing: languageCode)), message: \(String(describing: message)), outputDataConfig: \(String(describing: outputDataConfig)), submitTime: \(String(describing: submitTime)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Provides information about a key phrases detection job.</p>
public struct KeyPhrasesDetectionJobProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input
    ///       data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The time that the key phrases detection job completed.</p>
    public let endTime: Date?
    /// <p>The input data configuration that you supplied when you created the key phrases detection
    ///       job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier assigned to the key phrases detection job.</p>
    public let jobId: String?
    /// <p>The name that you assigned the key phrases detection job.</p>
    public let jobName: String?
    /// <p>The current status of the key phrases detection job. If the status is <code>FAILED</code>,
    ///       the <code>Message</code> field shows the reason for the failure.</p>
    public let jobStatus: JobStatus?
    /// <p>The language code of the input documents.</p>
    public let languageCode: LanguageCode?
    /// <p>A description of the status of a job.</p>
    public let message: String?
    /// <p>The output data configuration that you supplied when you created the key phrases detection
    ///       job.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>The time that the key phrases detection job was submitted for processing.</p>
    public let submitTime: Date?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the
    ///       resources you are using for your key phrases detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        dataAccessRoleArn: String? = nil,
        endTime: Date? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobId: String? = nil,
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        languageCode: LanguageCode? = nil,
        message: String? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        submitTime: Date? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.languageCode = languageCode
        self.message = message
        self.outputDataConfig = outputDataConfig
        self.submitTime = submitTime
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

extension KmsKeyValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KmsKeyValidationException(message: \(String(describing: message)))"}
}

extension KmsKeyValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KmsKeyValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The KMS customer managed key (CMK) entered cannot be validated. Verify the key and
///       re-enter it.</p>
public struct KmsKeyValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KmsKeyValidationExceptionBody: Equatable {
    public let message: String?
}

extension KmsKeyValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum LanguageCode {
    case ar
    case de
    case en
    case es
    case fr
    case hi
    case it
    case ja
    case ko
    case pt
    case zh
    case zhTw
    case sdkUnknown(String)
}

extension LanguageCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LanguageCode] {
        return [
            .ar,
            .de,
            .en,
            .es,
            .fr,
            .hi,
            .it,
            .ja,
            .ko,
            .pt,
            .zh,
            .zhTw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ar: return "ar"
        case .de: return "de"
        case .en: return "en"
        case .es: return "es"
        case .fr: return "fr"
        case .hi: return "hi"
        case .it: return "it"
        case .ja: return "ja"
        case .ko: return "ko"
        case .pt: return "pt"
        case .zh: return "zh"
        case .zhTw: return "zh-TW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
    }
}

public struct ListDocumentClassificationJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListDocumentClassificationJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentClassificationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentClassificationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentClassificationJobsInput>
    public typealias MOutput = OperationOutput<ListDocumentClassificationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentClassificationJobsOutputError>
}

extension ListDocumentClassificationJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDocumentClassificationJobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDocumentClassificationJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDocumentClassificationJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDocumentClassificationJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentClassificationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentClassificationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentClassificationJobsInput>
    public typealias MOutput = OperationOutput<ListDocumentClassificationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentClassificationJobsOutputError>
}

public struct ListDocumentClassificationJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDocumentClassificationJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentClassificationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentClassificationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentClassificationJobsInput>
    public typealias MOutput = OperationOutput<ListDocumentClassificationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentClassificationJobsOutputError>
}

public struct ListDocumentClassificationJobsInput: Equatable {
    /// <p>Filters the jobs that are returned. You can filter jobs on their names, status, or the
    ///       date and time that they were submitted. You can only set one filter at a time.</p>
    public let filter: DocumentClassificationJobFilter?
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: DocumentClassificationJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDocumentClassificationJobsInputBody: Equatable {
    public let filter: DocumentClassificationJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDocumentClassificationJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(DocumentClassificationJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDocumentClassificationJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDocumentClassificationJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterException" : self = .invalidFilterException(try InvalidFilterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDocumentClassificationJobsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidFilterException(InvalidFilterException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDocumentClassificationJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDocumentClassificationJobsOutputResponse(documentClassificationJobPropertiesList: \(String(describing: documentClassificationJobPropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDocumentClassificationJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDocumentClassificationJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documentClassificationJobPropertiesList = output.documentClassificationJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.documentClassificationJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDocumentClassificationJobsOutputResponse: Equatable {
    /// <p>A list containing the properties of each job returned.</p>
    public let documentClassificationJobPropertiesList: [DocumentClassificationJobProperties]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        documentClassificationJobPropertiesList: [DocumentClassificationJobProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.documentClassificationJobPropertiesList = documentClassificationJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListDocumentClassificationJobsOutputResponseBody: Equatable {
    public let documentClassificationJobPropertiesList: [DocumentClassificationJobProperties]?
    public let nextToken: String?
}

extension ListDocumentClassificationJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentClassificationJobPropertiesList = "DocumentClassificationJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentClassificationJobPropertiesListContainer = try containerValues.decodeIfPresent([DocumentClassificationJobProperties?].self, forKey: .documentClassificationJobPropertiesList)
        var documentClassificationJobPropertiesListDecoded0:[DocumentClassificationJobProperties]? = nil
        if let documentClassificationJobPropertiesListContainer = documentClassificationJobPropertiesListContainer {
            documentClassificationJobPropertiesListDecoded0 = [DocumentClassificationJobProperties]()
            for structure0 in documentClassificationJobPropertiesListContainer {
                if let structure0 = structure0 {
                    documentClassificationJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        documentClassificationJobPropertiesList = documentClassificationJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDocumentClassifiersInputBodyMiddleware: Middleware {
    public let id: String = "ListDocumentClassifiersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentClassifiersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentClassifiersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentClassifiersInput>
    public typealias MOutput = OperationOutput<ListDocumentClassifiersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentClassifiersOutputError>
}

extension ListDocumentClassifiersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDocumentClassifiersInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDocumentClassifiersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDocumentClassifiersInputHeadersMiddleware: Middleware {
    public let id: String = "ListDocumentClassifiersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentClassifiersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentClassifiersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentClassifiersInput>
    public typealias MOutput = OperationOutput<ListDocumentClassifiersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentClassifiersOutputError>
}

public struct ListDocumentClassifiersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDocumentClassifiersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentClassifiersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentClassifiersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentClassifiersInput>
    public typealias MOutput = OperationOutput<ListDocumentClassifiersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentClassifiersOutputError>
}

public struct ListDocumentClassifiersInput: Equatable {
    /// <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    ///       and time that they were submitted. You can only set one filter at a time.</p>
    public let filter: DocumentClassifierFilter?
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: DocumentClassifierFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDocumentClassifiersInputBody: Equatable {
    public let filter: DocumentClassifierFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDocumentClassifiersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(DocumentClassifierFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDocumentClassifiersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDocumentClassifiersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterException" : self = .invalidFilterException(try InvalidFilterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDocumentClassifiersOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidFilterException(InvalidFilterException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDocumentClassifiersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDocumentClassifiersOutputResponse(documentClassifierPropertiesList: \(String(describing: documentClassifierPropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDocumentClassifiersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDocumentClassifiersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documentClassifierPropertiesList = output.documentClassifierPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.documentClassifierPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDocumentClassifiersOutputResponse: Equatable {
    /// <p>A list containing the properties of each job returned.</p>
    public let documentClassifierPropertiesList: [DocumentClassifierProperties]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        documentClassifierPropertiesList: [DocumentClassifierProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.documentClassifierPropertiesList = documentClassifierPropertiesList
        self.nextToken = nextToken
    }
}

struct ListDocumentClassifiersOutputResponseBody: Equatable {
    public let documentClassifierPropertiesList: [DocumentClassifierProperties]?
    public let nextToken: String?
}

extension ListDocumentClassifiersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentClassifierPropertiesList = "DocumentClassifierPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentClassifierPropertiesListContainer = try containerValues.decodeIfPresent([DocumentClassifierProperties?].self, forKey: .documentClassifierPropertiesList)
        var documentClassifierPropertiesListDecoded0:[DocumentClassifierProperties]? = nil
        if let documentClassifierPropertiesListContainer = documentClassifierPropertiesListContainer {
            documentClassifierPropertiesListDecoded0 = [DocumentClassifierProperties]()
            for structure0 in documentClassifierPropertiesListContainer {
                if let structure0 = structure0 {
                    documentClassifierPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        documentClassifierPropertiesList = documentClassifierPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDominantLanguageDetectionJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListDominantLanguageDetectionJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDominantLanguageDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDominantLanguageDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDominantLanguageDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListDominantLanguageDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDominantLanguageDetectionJobsOutputError>
}

extension ListDominantLanguageDetectionJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDominantLanguageDetectionJobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDominantLanguageDetectionJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDominantLanguageDetectionJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDominantLanguageDetectionJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDominantLanguageDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDominantLanguageDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDominantLanguageDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListDominantLanguageDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDominantLanguageDetectionJobsOutputError>
}

public struct ListDominantLanguageDetectionJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDominantLanguageDetectionJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDominantLanguageDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDominantLanguageDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDominantLanguageDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListDominantLanguageDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDominantLanguageDetectionJobsOutputError>
}

public struct ListDominantLanguageDetectionJobsInput: Equatable {
    /// <p>Filters that jobs that are returned. You can filter jobs on their name, status, or the
    ///       date and time that they were submitted. You can only set one filter at a time.</p>
    public let filter: DominantLanguageDetectionJobFilter?
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: DominantLanguageDetectionJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDominantLanguageDetectionJobsInputBody: Equatable {
    public let filter: DominantLanguageDetectionJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDominantLanguageDetectionJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(DominantLanguageDetectionJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDominantLanguageDetectionJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDominantLanguageDetectionJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterException" : self = .invalidFilterException(try InvalidFilterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDominantLanguageDetectionJobsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidFilterException(InvalidFilterException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDominantLanguageDetectionJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDominantLanguageDetectionJobsOutputResponse(dominantLanguageDetectionJobPropertiesList: \(String(describing: dominantLanguageDetectionJobPropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDominantLanguageDetectionJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDominantLanguageDetectionJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dominantLanguageDetectionJobPropertiesList = output.dominantLanguageDetectionJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.dominantLanguageDetectionJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDominantLanguageDetectionJobsOutputResponse: Equatable {
    /// <p>A list containing the properties of each job that is returned.</p>
    public let dominantLanguageDetectionJobPropertiesList: [DominantLanguageDetectionJobProperties]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        dominantLanguageDetectionJobPropertiesList: [DominantLanguageDetectionJobProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.dominantLanguageDetectionJobPropertiesList = dominantLanguageDetectionJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListDominantLanguageDetectionJobsOutputResponseBody: Equatable {
    public let dominantLanguageDetectionJobPropertiesList: [DominantLanguageDetectionJobProperties]?
    public let nextToken: String?
}

extension ListDominantLanguageDetectionJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dominantLanguageDetectionJobPropertiesList = "DominantLanguageDetectionJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dominantLanguageDetectionJobPropertiesListContainer = try containerValues.decodeIfPresent([DominantLanguageDetectionJobProperties?].self, forKey: .dominantLanguageDetectionJobPropertiesList)
        var dominantLanguageDetectionJobPropertiesListDecoded0:[DominantLanguageDetectionJobProperties]? = nil
        if let dominantLanguageDetectionJobPropertiesListContainer = dominantLanguageDetectionJobPropertiesListContainer {
            dominantLanguageDetectionJobPropertiesListDecoded0 = [DominantLanguageDetectionJobProperties]()
            for structure0 in dominantLanguageDetectionJobPropertiesListContainer {
                if let structure0 = structure0 {
                    dominantLanguageDetectionJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        dominantLanguageDetectionJobPropertiesList = dominantLanguageDetectionJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEndpointsInputBodyMiddleware: Middleware {
    public let id: String = "ListEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEndpointsInput>
    public typealias MOutput = OperationOutput<ListEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEndpointsOutputError>
}

extension ListEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEndpointsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEndpointsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEndpointsInput>
    public typealias MOutput = OperationOutput<ListEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEndpointsOutputError>
}

public struct ListEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEndpointsInput>
    public typealias MOutput = OperationOutput<ListEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEndpointsOutputError>
}

public struct ListEndpointsInput: Equatable {
    /// <p>Filters the endpoints that are returned. You can filter endpoints on their name, model,
    ///       status, or the date and time that they were created. You can only set one filter at a time.
    ///     </p>
    public let filter: EndpointFilter?
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: EndpointFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEndpointsInputBody: Equatable {
    public let filter: EndpointFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListEndpointsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(EndpointFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEndpointsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEndpointsOutputResponse(endpointPropertiesList: \(String(describing: endpointPropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointPropertiesList = output.endpointPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.endpointPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEndpointsOutputResponse: Equatable {
    /// <p>Displays a list of endpoint properties being retrieved by the service in response to the
    ///       request.</p>
    public let endpointPropertiesList: [EndpointProperties]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        endpointPropertiesList: [EndpointProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.endpointPropertiesList = endpointPropertiesList
        self.nextToken = nextToken
    }
}

struct ListEndpointsOutputResponseBody: Equatable {
    public let endpointPropertiesList: [EndpointProperties]?
    public let nextToken: String?
}

extension ListEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointPropertiesList = "EndpointPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointPropertiesListContainer = try containerValues.decodeIfPresent([EndpointProperties?].self, forKey: .endpointPropertiesList)
        var endpointPropertiesListDecoded0:[EndpointProperties]? = nil
        if let endpointPropertiesListContainer = endpointPropertiesListContainer {
            endpointPropertiesListDecoded0 = [EndpointProperties]()
            for structure0 in endpointPropertiesListContainer {
                if let structure0 = structure0 {
                    endpointPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        endpointPropertiesList = endpointPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEntitiesDetectionJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListEntitiesDetectionJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitiesDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitiesDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitiesDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListEntitiesDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitiesDetectionJobsOutputError>
}

extension ListEntitiesDetectionJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEntitiesDetectionJobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEntitiesDetectionJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEntitiesDetectionJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEntitiesDetectionJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitiesDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitiesDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitiesDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListEntitiesDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitiesDetectionJobsOutputError>
}

public struct ListEntitiesDetectionJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEntitiesDetectionJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitiesDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitiesDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitiesDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListEntitiesDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitiesDetectionJobsOutputError>
}

public struct ListEntitiesDetectionJobsInput: Equatable {
    /// <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    ///       and time that they were submitted. You can only set one filter at a time.</p>
    public let filter: EntitiesDetectionJobFilter?
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: EntitiesDetectionJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEntitiesDetectionJobsInputBody: Equatable {
    public let filter: EntitiesDetectionJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListEntitiesDetectionJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(EntitiesDetectionJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEntitiesDetectionJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEntitiesDetectionJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterException" : self = .invalidFilterException(try InvalidFilterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEntitiesDetectionJobsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidFilterException(InvalidFilterException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntitiesDetectionJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEntitiesDetectionJobsOutputResponse(entitiesDetectionJobPropertiesList: \(String(describing: entitiesDetectionJobPropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEntitiesDetectionJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEntitiesDetectionJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entitiesDetectionJobPropertiesList = output.entitiesDetectionJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.entitiesDetectionJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitiesDetectionJobsOutputResponse: Equatable {
    /// <p>A list containing the properties of each job that is returned.</p>
    public let entitiesDetectionJobPropertiesList: [EntitiesDetectionJobProperties]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        entitiesDetectionJobPropertiesList: [EntitiesDetectionJobProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.entitiesDetectionJobPropertiesList = entitiesDetectionJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListEntitiesDetectionJobsOutputResponseBody: Equatable {
    public let entitiesDetectionJobPropertiesList: [EntitiesDetectionJobProperties]?
    public let nextToken: String?
}

extension ListEntitiesDetectionJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entitiesDetectionJobPropertiesList = "EntitiesDetectionJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesDetectionJobPropertiesListContainer = try containerValues.decodeIfPresent([EntitiesDetectionJobProperties?].self, forKey: .entitiesDetectionJobPropertiesList)
        var entitiesDetectionJobPropertiesListDecoded0:[EntitiesDetectionJobProperties]? = nil
        if let entitiesDetectionJobPropertiesListContainer = entitiesDetectionJobPropertiesListContainer {
            entitiesDetectionJobPropertiesListDecoded0 = [EntitiesDetectionJobProperties]()
            for structure0 in entitiesDetectionJobPropertiesListContainer {
                if let structure0 = structure0 {
                    entitiesDetectionJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        entitiesDetectionJobPropertiesList = entitiesDetectionJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEntityRecognizersInputBodyMiddleware: Middleware {
    public let id: String = "ListEntityRecognizersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntityRecognizersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntityRecognizersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntityRecognizersInput>
    public typealias MOutput = OperationOutput<ListEntityRecognizersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntityRecognizersOutputError>
}

extension ListEntityRecognizersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEntityRecognizersInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEntityRecognizersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEntityRecognizersInputHeadersMiddleware: Middleware {
    public let id: String = "ListEntityRecognizersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntityRecognizersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntityRecognizersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntityRecognizersInput>
    public typealias MOutput = OperationOutput<ListEntityRecognizersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntityRecognizersOutputError>
}

public struct ListEntityRecognizersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEntityRecognizersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntityRecognizersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntityRecognizersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntityRecognizersInput>
    public typealias MOutput = OperationOutput<ListEntityRecognizersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntityRecognizersOutputError>
}

public struct ListEntityRecognizersInput: Equatable {
    /// <p>Filters the list of entities returned. You can filter on <code>Status</code>,
    ///         <code>SubmitTimeBefore</code>, or <code>SubmitTimeAfter</code>. You can only set one filter
    ///       at a time.</p>
    public let filter: EntityRecognizerFilter?
    /// <p> The maximum number of results to return on each page. The default is 100.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: EntityRecognizerFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEntityRecognizersInputBody: Equatable {
    public let filter: EntityRecognizerFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListEntityRecognizersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(EntityRecognizerFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEntityRecognizersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEntityRecognizersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterException" : self = .invalidFilterException(try InvalidFilterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEntityRecognizersOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidFilterException(InvalidFilterException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntityRecognizersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEntityRecognizersOutputResponse(entityRecognizerPropertiesList: \(String(describing: entityRecognizerPropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEntityRecognizersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEntityRecognizersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entityRecognizerPropertiesList = output.entityRecognizerPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.entityRecognizerPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntityRecognizersOutputResponse: Equatable {
    /// <p>The list of properties of an entity recognizer.</p>
    public let entityRecognizerPropertiesList: [EntityRecognizerProperties]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        entityRecognizerPropertiesList: [EntityRecognizerProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.entityRecognizerPropertiesList = entityRecognizerPropertiesList
        self.nextToken = nextToken
    }
}

struct ListEntityRecognizersOutputResponseBody: Equatable {
    public let entityRecognizerPropertiesList: [EntityRecognizerProperties]?
    public let nextToken: String?
}

extension ListEntityRecognizersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityRecognizerPropertiesList = "EntityRecognizerPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityRecognizerPropertiesListContainer = try containerValues.decodeIfPresent([EntityRecognizerProperties?].self, forKey: .entityRecognizerPropertiesList)
        var entityRecognizerPropertiesListDecoded0:[EntityRecognizerProperties]? = nil
        if let entityRecognizerPropertiesListContainer = entityRecognizerPropertiesListContainer {
            entityRecognizerPropertiesListDecoded0 = [EntityRecognizerProperties]()
            for structure0 in entityRecognizerPropertiesListContainer {
                if let structure0 = structure0 {
                    entityRecognizerPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        entityRecognizerPropertiesList = entityRecognizerPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEventsDetectionJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListEventsDetectionJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventsDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventsDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventsDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListEventsDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventsDetectionJobsOutputError>
}

extension ListEventsDetectionJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventsDetectionJobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventsDetectionJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEventsDetectionJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEventsDetectionJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventsDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventsDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventsDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListEventsDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventsDetectionJobsOutputError>
}

public struct ListEventsDetectionJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEventsDetectionJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventsDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventsDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventsDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListEventsDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventsDetectionJobsOutputError>
}

public struct ListEventsDetectionJobsInput: Equatable {
    /// <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    ///       and time that they were submitted. You can only set one filter at a time.</p>
    public let filter: EventsDetectionJobFilter?
    /// <p>The maximum number of results to return in each page.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: EventsDetectionJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventsDetectionJobsInputBody: Equatable {
    public let filter: EventsDetectionJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListEventsDetectionJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(EventsDetectionJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventsDetectionJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventsDetectionJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterException" : self = .invalidFilterException(try InvalidFilterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventsDetectionJobsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidFilterException(InvalidFilterException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventsDetectionJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventsDetectionJobsOutputResponse(eventsDetectionJobPropertiesList: \(String(describing: eventsDetectionJobPropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventsDetectionJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEventsDetectionJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventsDetectionJobPropertiesList = output.eventsDetectionJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.eventsDetectionJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventsDetectionJobsOutputResponse: Equatable {
    /// <p>A list containing the properties of each job that is returned.</p>
    public let eventsDetectionJobPropertiesList: [EventsDetectionJobProperties]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        eventsDetectionJobPropertiesList: [EventsDetectionJobProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.eventsDetectionJobPropertiesList = eventsDetectionJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListEventsDetectionJobsOutputResponseBody: Equatable {
    public let eventsDetectionJobPropertiesList: [EventsDetectionJobProperties]?
    public let nextToken: String?
}

extension ListEventsDetectionJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventsDetectionJobPropertiesList = "EventsDetectionJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsDetectionJobPropertiesListContainer = try containerValues.decodeIfPresent([EventsDetectionJobProperties?].self, forKey: .eventsDetectionJobPropertiesList)
        var eventsDetectionJobPropertiesListDecoded0:[EventsDetectionJobProperties]? = nil
        if let eventsDetectionJobPropertiesListContainer = eventsDetectionJobPropertiesListContainer {
            eventsDetectionJobPropertiesListDecoded0 = [EventsDetectionJobProperties]()
            for structure0 in eventsDetectionJobPropertiesListContainer {
                if let structure0 = structure0 {
                    eventsDetectionJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        eventsDetectionJobPropertiesList = eventsDetectionJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListKeyPhrasesDetectionJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListKeyPhrasesDetectionJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeyPhrasesDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeyPhrasesDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeyPhrasesDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListKeyPhrasesDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeyPhrasesDetectionJobsOutputError>
}

extension ListKeyPhrasesDetectionJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListKeyPhrasesDetectionJobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListKeyPhrasesDetectionJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListKeyPhrasesDetectionJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListKeyPhrasesDetectionJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeyPhrasesDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeyPhrasesDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeyPhrasesDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListKeyPhrasesDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeyPhrasesDetectionJobsOutputError>
}

public struct ListKeyPhrasesDetectionJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListKeyPhrasesDetectionJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeyPhrasesDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeyPhrasesDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeyPhrasesDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListKeyPhrasesDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeyPhrasesDetectionJobsOutputError>
}

public struct ListKeyPhrasesDetectionJobsInput: Equatable {
    /// <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    ///       and time that they were submitted. You can only set one filter at a time.</p>
    public let filter: KeyPhrasesDetectionJobFilter?
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: KeyPhrasesDetectionJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKeyPhrasesDetectionJobsInputBody: Equatable {
    public let filter: KeyPhrasesDetectionJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListKeyPhrasesDetectionJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(KeyPhrasesDetectionJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListKeyPhrasesDetectionJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListKeyPhrasesDetectionJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterException" : self = .invalidFilterException(try InvalidFilterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListKeyPhrasesDetectionJobsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidFilterException(InvalidFilterException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKeyPhrasesDetectionJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListKeyPhrasesDetectionJobsOutputResponse(keyPhrasesDetectionJobPropertiesList: \(String(describing: keyPhrasesDetectionJobPropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListKeyPhrasesDetectionJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListKeyPhrasesDetectionJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyPhrasesDetectionJobPropertiesList = output.keyPhrasesDetectionJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.keyPhrasesDetectionJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListKeyPhrasesDetectionJobsOutputResponse: Equatable {
    /// <p>A list containing the properties of each job that is returned.</p>
    public let keyPhrasesDetectionJobPropertiesList: [KeyPhrasesDetectionJobProperties]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        keyPhrasesDetectionJobPropertiesList: [KeyPhrasesDetectionJobProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.keyPhrasesDetectionJobPropertiesList = keyPhrasesDetectionJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListKeyPhrasesDetectionJobsOutputResponseBody: Equatable {
    public let keyPhrasesDetectionJobPropertiesList: [KeyPhrasesDetectionJobProperties]?
    public let nextToken: String?
}

extension ListKeyPhrasesDetectionJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyPhrasesDetectionJobPropertiesList = "KeyPhrasesDetectionJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPhrasesDetectionJobPropertiesListContainer = try containerValues.decodeIfPresent([KeyPhrasesDetectionJobProperties?].self, forKey: .keyPhrasesDetectionJobPropertiesList)
        var keyPhrasesDetectionJobPropertiesListDecoded0:[KeyPhrasesDetectionJobProperties]? = nil
        if let keyPhrasesDetectionJobPropertiesListContainer = keyPhrasesDetectionJobPropertiesListContainer {
            keyPhrasesDetectionJobPropertiesListDecoded0 = [KeyPhrasesDetectionJobProperties]()
            for structure0 in keyPhrasesDetectionJobPropertiesListContainer {
                if let structure0 = structure0 {
                    keyPhrasesDetectionJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        keyPhrasesDetectionJobPropertiesList = keyPhrasesDetectionJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPiiEntitiesDetectionJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListPiiEntitiesDetectionJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPiiEntitiesDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPiiEntitiesDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPiiEntitiesDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListPiiEntitiesDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPiiEntitiesDetectionJobsOutputError>
}

extension ListPiiEntitiesDetectionJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPiiEntitiesDetectionJobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPiiEntitiesDetectionJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPiiEntitiesDetectionJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPiiEntitiesDetectionJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPiiEntitiesDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPiiEntitiesDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPiiEntitiesDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListPiiEntitiesDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPiiEntitiesDetectionJobsOutputError>
}

public struct ListPiiEntitiesDetectionJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPiiEntitiesDetectionJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPiiEntitiesDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPiiEntitiesDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPiiEntitiesDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListPiiEntitiesDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPiiEntitiesDetectionJobsOutputError>
}

public struct ListPiiEntitiesDetectionJobsInput: Equatable {
    /// <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    ///       and time that they were submitted. You can only set one filter at a time.</p>
    public let filter: PiiEntitiesDetectionJobFilter?
    /// <p>The maximum number of results to return in each page.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: PiiEntitiesDetectionJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPiiEntitiesDetectionJobsInputBody: Equatable {
    public let filter: PiiEntitiesDetectionJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPiiEntitiesDetectionJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(PiiEntitiesDetectionJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPiiEntitiesDetectionJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPiiEntitiesDetectionJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterException" : self = .invalidFilterException(try InvalidFilterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPiiEntitiesDetectionJobsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidFilterException(InvalidFilterException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPiiEntitiesDetectionJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPiiEntitiesDetectionJobsOutputResponse(nextToken: \(String(describing: nextToken)), piiEntitiesDetectionJobPropertiesList: \(String(describing: piiEntitiesDetectionJobPropertiesList)))"}
}

extension ListPiiEntitiesDetectionJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPiiEntitiesDetectionJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.piiEntitiesDetectionJobPropertiesList = output.piiEntitiesDetectionJobPropertiesList
        } else {
            self.nextToken = nil
            self.piiEntitiesDetectionJobPropertiesList = nil
        }
    }
}

public struct ListPiiEntitiesDetectionJobsOutputResponse: Equatable {
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?
    /// <p>A list containing the properties of each job that is returned.</p>
    public let piiEntitiesDetectionJobPropertiesList: [PiiEntitiesDetectionJobProperties]?

    public init (
        nextToken: String? = nil,
        piiEntitiesDetectionJobPropertiesList: [PiiEntitiesDetectionJobProperties]? = nil
    )
    {
        self.nextToken = nextToken
        self.piiEntitiesDetectionJobPropertiesList = piiEntitiesDetectionJobPropertiesList
    }
}

struct ListPiiEntitiesDetectionJobsOutputResponseBody: Equatable {
    public let piiEntitiesDetectionJobPropertiesList: [PiiEntitiesDetectionJobProperties]?
    public let nextToken: String?
}

extension ListPiiEntitiesDetectionJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case piiEntitiesDetectionJobPropertiesList = "PiiEntitiesDetectionJobPropertiesList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let piiEntitiesDetectionJobPropertiesListContainer = try containerValues.decodeIfPresent([PiiEntitiesDetectionJobProperties?].self, forKey: .piiEntitiesDetectionJobPropertiesList)
        var piiEntitiesDetectionJobPropertiesListDecoded0:[PiiEntitiesDetectionJobProperties]? = nil
        if let piiEntitiesDetectionJobPropertiesListContainer = piiEntitiesDetectionJobPropertiesListContainer {
            piiEntitiesDetectionJobPropertiesListDecoded0 = [PiiEntitiesDetectionJobProperties]()
            for structure0 in piiEntitiesDetectionJobPropertiesListContainer {
                if let structure0 = structure0 {
                    piiEntitiesDetectionJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        piiEntitiesDetectionJobPropertiesList = piiEntitiesDetectionJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSentimentDetectionJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListSentimentDetectionJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSentimentDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSentimentDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSentimentDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListSentimentDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSentimentDetectionJobsOutputError>
}

extension ListSentimentDetectionJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSentimentDetectionJobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSentimentDetectionJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSentimentDetectionJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSentimentDetectionJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSentimentDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSentimentDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSentimentDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListSentimentDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSentimentDetectionJobsOutputError>
}

public struct ListSentimentDetectionJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSentimentDetectionJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSentimentDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSentimentDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSentimentDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListSentimentDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSentimentDetectionJobsOutputError>
}

public struct ListSentimentDetectionJobsInput: Equatable {
    /// <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    ///       and time that they were submitted. You can only set one filter at a time.</p>
    public let filter: SentimentDetectionJobFilter?
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: SentimentDetectionJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSentimentDetectionJobsInputBody: Equatable {
    public let filter: SentimentDetectionJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListSentimentDetectionJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(SentimentDetectionJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSentimentDetectionJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSentimentDetectionJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterException" : self = .invalidFilterException(try InvalidFilterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSentimentDetectionJobsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidFilterException(InvalidFilterException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSentimentDetectionJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSentimentDetectionJobsOutputResponse(nextToken: \(String(describing: nextToken)), sentimentDetectionJobPropertiesList: \(String(describing: sentimentDetectionJobPropertiesList)))"}
}

extension ListSentimentDetectionJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSentimentDetectionJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.sentimentDetectionJobPropertiesList = output.sentimentDetectionJobPropertiesList
        } else {
            self.nextToken = nil
            self.sentimentDetectionJobPropertiesList = nil
        }
    }
}

public struct ListSentimentDetectionJobsOutputResponse: Equatable {
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?
    /// <p>A list containing the properties of each job that is returned.</p>
    public let sentimentDetectionJobPropertiesList: [SentimentDetectionJobProperties]?

    public init (
        nextToken: String? = nil,
        sentimentDetectionJobPropertiesList: [SentimentDetectionJobProperties]? = nil
    )
    {
        self.nextToken = nextToken
        self.sentimentDetectionJobPropertiesList = sentimentDetectionJobPropertiesList
    }
}

struct ListSentimentDetectionJobsOutputResponseBody: Equatable {
    public let sentimentDetectionJobPropertiesList: [SentimentDetectionJobProperties]?
    public let nextToken: String?
}

extension ListSentimentDetectionJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case sentimentDetectionJobPropertiesList = "SentimentDetectionJobPropertiesList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sentimentDetectionJobPropertiesListContainer = try containerValues.decodeIfPresent([SentimentDetectionJobProperties?].self, forKey: .sentimentDetectionJobPropertiesList)
        var sentimentDetectionJobPropertiesListDecoded0:[SentimentDetectionJobProperties]? = nil
        if let sentimentDetectionJobPropertiesListContainer = sentimentDetectionJobPropertiesListContainer {
            sentimentDetectionJobPropertiesListDecoded0 = [SentimentDetectionJobProperties]()
            for structure0 in sentimentDetectionJobPropertiesListContainer {
                if let structure0 = structure0 {
                    sentimentDetectionJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        sentimentDetectionJobPropertiesList = sentimentDetectionJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the given Amazon Comprehend resource you are querying.
    ///     </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceArn = output.resourceArn
            self.tags = output.tags
        } else {
            self.resourceArn = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the given Amazon Comprehend resource you are
    ///       querying.</p>
    public let resourceArn: String?
    /// <p>Tags associated with the Amazon Comprehend resource being queried. A tag is a key-value
    ///       pair that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with
    ///       "Sales" as the key might be added to a resource to indicate its use by the sales department.
    ///     </p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTopicsDetectionJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListTopicsDetectionJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTopicsDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTopicsDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTopicsDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListTopicsDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTopicsDetectionJobsOutputError>
}

extension ListTopicsDetectionJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTopicsDetectionJobsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTopicsDetectionJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTopicsDetectionJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTopicsDetectionJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTopicsDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTopicsDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTopicsDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListTopicsDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTopicsDetectionJobsOutputError>
}

public struct ListTopicsDetectionJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTopicsDetectionJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTopicsDetectionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTopicsDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTopicsDetectionJobsInput>
    public typealias MOutput = OperationOutput<ListTopicsDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTopicsDetectionJobsOutputError>
}

public struct ListTopicsDetectionJobsInput: Equatable {
    /// <p>Filters the jobs that are returned. Jobs can be filtered on their name, status, or the
    ///       date and time that they were submitted. You can set only one filter at a time.</p>
    public let filter: TopicsDetectionJobFilter?
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        filter: TopicsDetectionJobFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTopicsDetectionJobsInputBody: Equatable {
    public let filter: TopicsDetectionJobFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTopicsDetectionJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(TopicsDetectionJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTopicsDetectionJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTopicsDetectionJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterException" : self = .invalidFilterException(try InvalidFilterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTopicsDetectionJobsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidFilterException(InvalidFilterException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTopicsDetectionJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTopicsDetectionJobsOutputResponse(nextToken: \(String(describing: nextToken)), topicsDetectionJobPropertiesList: \(String(describing: topicsDetectionJobPropertiesList)))"}
}

extension ListTopicsDetectionJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTopicsDetectionJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.topicsDetectionJobPropertiesList = output.topicsDetectionJobPropertiesList
        } else {
            self.nextToken = nil
            self.topicsDetectionJobPropertiesList = nil
        }
    }
}

public struct ListTopicsDetectionJobsOutputResponse: Equatable {
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?
    /// <p>A list containing the properties of each job that is returned.</p>
    public let topicsDetectionJobPropertiesList: [TopicsDetectionJobProperties]?

    public init (
        nextToken: String? = nil,
        topicsDetectionJobPropertiesList: [TopicsDetectionJobProperties]? = nil
    )
    {
        self.nextToken = nextToken
        self.topicsDetectionJobPropertiesList = topicsDetectionJobPropertiesList
    }
}

struct ListTopicsDetectionJobsOutputResponseBody: Equatable {
    public let topicsDetectionJobPropertiesList: [TopicsDetectionJobProperties]?
    public let nextToken: String?
}

extension ListTopicsDetectionJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case topicsDetectionJobPropertiesList = "TopicsDetectionJobPropertiesList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicsDetectionJobPropertiesListContainer = try containerValues.decodeIfPresent([TopicsDetectionJobProperties?].self, forKey: .topicsDetectionJobPropertiesList)
        var topicsDetectionJobPropertiesListDecoded0:[TopicsDetectionJobProperties]? = nil
        if let topicsDetectionJobPropertiesListContainer = topicsDetectionJobPropertiesListContainer {
            topicsDetectionJobPropertiesListDecoded0 = [TopicsDetectionJobProperties]()
            for structure0 in topicsDetectionJobPropertiesListContainer {
                if let structure0 = structure0 {
                    topicsDetectionJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        topicsDetectionJobPropertiesList = topicsDetectionJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum ModelStatus {
    case deleting
    case inError
    case stopped
    case stopRequested
    case submitted
    case trained
    case training
    case sdkUnknown(String)
}

extension ModelStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModelStatus] {
        return [
            .deleting,
            .inError,
            .stopped,
            .stopRequested,
            .submitted,
            .trained,
            .training,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleting: return "DELETING"
        case .inError: return "IN_ERROR"
        case .stopped: return "STOPPED"
        case .stopRequested: return "STOP_REQUESTED"
        case .submitted: return "SUBMITTED"
        case .trained: return "TRAINED"
        case .training: return "TRAINING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModelStatus(rawValue: rawValue) ?? ModelStatus.sdkUnknown(rawValue)
    }
}

extension OutputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension OutputDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputDataConfig(kmsKeyId: \(String(describing: kmsKeyId)), s3Uri: \(String(describing: s3Uri)))"}
}

/// <p>Provides configuration parameters for the output of topic detection jobs.</p>
///          <p></p>
public struct OutputDataConfig: Equatable {
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the
    ///       output results from an analysis job. The KmsKeyId can be one of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>KMS Key Alias: <code>"alias/ExampleAlias"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>ARN of a KMS Key Alias:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let kmsKeyId: String?
    /// <p>When you use the <code>OutputDataConfig</code> object with asynchronous operations, you
    ///       specify the Amazon S3 location where you want to write the output data. The URI must be in the
    ///       same region as the API endpoint that you are calling. The location is used as the prefix for
    ///       the actual location of the output file.</p>
    ///          <p>When the topic detection job is finished, the service creates an output file in a
    ///       directory specific to the job. The <code>S3Uri</code> field contains the location of the
    ///       output file, called <code>output.tar.gz</code>. It is a compressed archive that contains the
    ///       ouput of the operation.</p>
    public let s3Uri: String?

    public init (
        kmsKeyId: String? = nil,
        s3Uri: String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.s3Uri = s3Uri
    }
}

extension PartOfSpeechTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case score = "Score"
        case tag = "Tag"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let tag = tag {
            try encodeContainer.encode(tag.rawValue, forKey: .tag)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagDecoded = try containerValues.decodeIfPresent(PartOfSpeechTagType.self, forKey: .tag)
        tag = tagDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension PartOfSpeechTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PartOfSpeechTag(score: \(String(describing: score)), tag: \(String(describing: tag)))"}
}

/// <p>Identifies the part of speech represented by the token and gives the confidence that
///       Amazon Comprehend has that the part of speech was correctly identified. For more information
///       about the parts of speech that Amazon Comprehend can identify, see <a>how-syntax</a>.</p>
public struct PartOfSpeechTag: Equatable {
    /// <p>The confidence that Amazon Comprehend has that the part of speech was correctly
    ///       identified.</p>
    public let score: Float?
    /// <p>Identifies the part of speech that the token represents.</p>
    public let tag: PartOfSpeechTagType?

    public init (
        score: Float? = nil,
        tag: PartOfSpeechTagType? = nil
    )
    {
        self.score = score
        self.tag = tag
    }
}

public enum PartOfSpeechTagType {
    case adj
    case adp
    case adv
    case aux
    case cconj
    case conj
    case det
    case intj
    case noun
    case num
    case o
    case part
    case pron
    case propn
    case punct
    case sconj
    case sym
    case verb
    case sdkUnknown(String)
}

extension PartOfSpeechTagType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PartOfSpeechTagType] {
        return [
            .adj,
            .adp,
            .adv,
            .aux,
            .cconj,
            .conj,
            .det,
            .intj,
            .noun,
            .num,
            .o,
            .part,
            .pron,
            .propn,
            .punct,
            .sconj,
            .sym,
            .verb,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adj: return "ADJ"
        case .adp: return "ADP"
        case .adv: return "ADV"
        case .aux: return "AUX"
        case .cconj: return "CCONJ"
        case .conj: return "CONJ"
        case .det: return "DET"
        case .intj: return "INTJ"
        case .noun: return "NOUN"
        case .num: return "NUM"
        case .o: return "O"
        case .part: return "PART"
        case .pron: return "PRON"
        case .propn: return "PROPN"
        case .punct: return "PUNCT"
        case .sconj: return "SCONJ"
        case .sym: return "SYM"
        case .verb: return "VERB"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PartOfSpeechTagType(rawValue: rawValue) ?? PartOfSpeechTagType.sdkUnknown(rawValue)
    }
}

extension PiiEntitiesDetectionJobFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension PiiEntitiesDetectionJobFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PiiEntitiesDetectionJobFilter(jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), submitTimeAfter: \(String(describing: submitTimeAfter)), submitTimeBefore: \(String(describing: submitTimeBefore)))"}
}

/// <p>Provides information for filtering a list of PII entity detection jobs.</p>
public struct PiiEntitiesDetectionJobFilter: Equatable {
    /// <p>Filters on the name of the job.</p>
    public let jobName: String?
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified
    ///       status.</p>
    public let jobStatus: JobStatus?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted after the specified time. Jobs are returned in descending order,
    ///       newest to oldest.</p>
    public let submitTimeAfter: Date?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted before the specified time. Jobs are returned in ascending order,
    ///       oldest to newest.</p>
    public let submitTimeBefore: Date?

    public init (
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        submitTimeAfter: Date? = nil,
        submitTimeBefore: Date? = nil
    )
    {
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension PiiEntitiesDetectionJobProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case languageCode = "LanguageCode"
        case message = "Message"
        case mode = "Mode"
        case outputDataConfig = "OutputDataConfig"
        case redactionConfig = "RedactionConfig"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let redactionConfig = redactionConfig {
            try encodeContainer.encode(redactionConfig, forKey: .redactionConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(PiiOutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let redactionConfigDecoded = try containerValues.decodeIfPresent(RedactionConfig.self, forKey: .redactionConfig)
        redactionConfig = redactionConfigDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(PiiEntitiesDetectionMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension PiiEntitiesDetectionJobProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PiiEntitiesDetectionJobProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), endTime: \(String(describing: endTime)), inputDataConfig: \(String(describing: inputDataConfig)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), languageCode: \(String(describing: languageCode)), message: \(String(describing: message)), mode: \(String(describing: mode)), outputDataConfig: \(String(describing: outputDataConfig)), redactionConfig: \(String(describing: redactionConfig)), submitTime: \(String(describing: submitTime)))"}
}

/// <p>Provides information about a PII entities detection job.</p>
public struct PiiEntitiesDetectionJobProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input
    ///       data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The time that the PII entities detection job completed.</p>
    public let endTime: Date?
    /// <p>The input properties for a PII entities detection job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier assigned to the PII entities detection job.</p>
    public let jobId: String?
    /// <p>The name that you assigned the PII entities detection job.</p>
    public let jobName: String?
    /// <p>The current status of the PII entities detection job. If the status is
    ///       <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    public let jobStatus: JobStatus?
    /// <p>The language code of the input documents</p>
    public let languageCode: LanguageCode?
    /// <p>A description of the status of a job.</p>
    public let message: String?
    /// <p>Specifies whether the output provides the locations (offsets) of PII entities or a file in
    ///       which PII entities are redacted.</p>
    public let mode: PiiEntitiesDetectionMode?
    /// <p>The output data configuration that you supplied when you created the PII entities
    ///       detection job.</p>
    public let outputDataConfig: PiiOutputDataConfig?
    /// <p>Provides configuration parameters for PII entity redaction.</p>
    ///          <p>This parameter is required if you set the <code>Mode</code> parameter to
    ///         <code>ONLY_REDACTION</code>. In that case, you must provide a <code>RedactionConfig</code>
    ///       definition that includes the <code>PiiEntityTypes</code> parameter.</p>
    public let redactionConfig: RedactionConfig?
    /// <p>The time that the PII entities detection job was submitted for processing.</p>
    public let submitTime: Date?

    public init (
        dataAccessRoleArn: String? = nil,
        endTime: Date? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobId: String? = nil,
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        languageCode: LanguageCode? = nil,
        message: String? = nil,
        mode: PiiEntitiesDetectionMode? = nil,
        outputDataConfig: PiiOutputDataConfig? = nil,
        redactionConfig: RedactionConfig? = nil,
        submitTime: Date? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.languageCode = languageCode
        self.message = message
        self.mode = mode
        self.outputDataConfig = outputDataConfig
        self.redactionConfig = redactionConfig
        self.submitTime = submitTime
    }
}

public enum PiiEntitiesDetectionMaskMode {
    case mask
    case replaceWithPiiEntityType
    case sdkUnknown(String)
}

extension PiiEntitiesDetectionMaskMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PiiEntitiesDetectionMaskMode] {
        return [
            .mask,
            .replaceWithPiiEntityType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .mask: return "MASK"
        case .replaceWithPiiEntityType: return "REPLACE_WITH_PII_ENTITY_TYPE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PiiEntitiesDetectionMaskMode(rawValue: rawValue) ?? PiiEntitiesDetectionMaskMode.sdkUnknown(rawValue)
    }
}

public enum PiiEntitiesDetectionMode {
    case onlyOffsets
    case onlyRedaction
    case sdkUnknown(String)
}

extension PiiEntitiesDetectionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PiiEntitiesDetectionMode] {
        return [
            .onlyOffsets,
            .onlyRedaction,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .onlyOffsets: return "ONLY_OFFSETS"
        case .onlyRedaction: return "ONLY_REDACTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PiiEntitiesDetectionMode(rawValue: rawValue) ?? PiiEntitiesDetectionMode.sdkUnknown(rawValue)
    }
}

extension PiiEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginOffset = "BeginOffset"
        case endOffset = "EndOffset"
        case score = "Score"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .score)
        score = scoreDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PiiEntityType.self, forKey: .type)
        type = typeDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
    }
}

extension PiiEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PiiEntity(beginOffset: \(String(describing: beginOffset)), endOffset: \(String(describing: endOffset)), score: \(String(describing: score)), type: \(String(describing: type)))"}
}

/// <p>Provides information about a PII entity.</p>
public struct PiiEntity: Equatable {
    /// <p>A character offset in the input text that shows where the PII entity begins (the first
    ///       character is at position 0). The offset returns the position of each UTF-8 code point in the
    ///       string. A <i>code point</i> is the abstract character from a particular
    ///       graphical representation. For example, a multi-byte UTF-8 character maps to a single code
    ///       point.</p>
    public let beginOffset: Int?
    /// <p>A character offset in the input text that shows where the PII entity ends. The offset
    ///       returns the position of each UTF-8 code point in the string. A <i>code point</i>
    ///       is the abstract character from a particular graphical representation. For example, a
    ///       multi-byte UTF-8 character maps to a single code point.</p>
    public let endOffset: Int?
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the
    ///       detection.</p>
    public let score: Float?
    /// <p>The entity's type.</p>
    public let type: PiiEntityType?

    public init (
        beginOffset: Int? = nil,
        endOffset: Int? = nil,
        score: Float? = nil,
        type: PiiEntityType? = nil
    )
    {
        self.beginOffset = beginOffset
        self.endOffset = endOffset
        self.score = score
        self.type = type
    }
}

public enum PiiEntityType {
    case address
    case age
    case all
    case awsAccessKey
    case awsSecretKey
    case bankAccountNumber
    case bankRouting
    case creditDebitCvv
    case creditDebitExpiry
    case creditDebitNumber
    case dateTime
    case driverId
    case email
    case ipAddress
    case macAddress
    case name
    case passportNumber
    case password
    case phone
    case pin
    case ssn
    case url
    case username
    case sdkUnknown(String)
}

extension PiiEntityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PiiEntityType] {
        return [
            .address,
            .age,
            .all,
            .awsAccessKey,
            .awsSecretKey,
            .bankAccountNumber,
            .bankRouting,
            .creditDebitCvv,
            .creditDebitExpiry,
            .creditDebitNumber,
            .dateTime,
            .driverId,
            .email,
            .ipAddress,
            .macAddress,
            .name,
            .passportNumber,
            .password,
            .phone,
            .pin,
            .ssn,
            .url,
            .username,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .address: return "ADDRESS"
        case .age: return "AGE"
        case .all: return "ALL"
        case .awsAccessKey: return "AWS_ACCESS_KEY"
        case .awsSecretKey: return "AWS_SECRET_KEY"
        case .bankAccountNumber: return "BANK_ACCOUNT_NUMBER"
        case .bankRouting: return "BANK_ROUTING"
        case .creditDebitCvv: return "CREDIT_DEBIT_CVV"
        case .creditDebitExpiry: return "CREDIT_DEBIT_EXPIRY"
        case .creditDebitNumber: return "CREDIT_DEBIT_NUMBER"
        case .dateTime: return "DATE_TIME"
        case .driverId: return "DRIVER_ID"
        case .email: return "EMAIL"
        case .ipAddress: return "IP_ADDRESS"
        case .macAddress: return "MAC_ADDRESS"
        case .name: return "NAME"
        case .passportNumber: return "PASSPORT_NUMBER"
        case .password: return "PASSWORD"
        case .phone: return "PHONE"
        case .pin: return "PIN"
        case .ssn: return "SSN"
        case .url: return "URL"
        case .username: return "USERNAME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PiiEntityType(rawValue: rawValue) ?? PiiEntityType.sdkUnknown(rawValue)
    }
}

extension PiiOutputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension PiiOutputDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PiiOutputDataConfig(kmsKeyId: \(String(describing: kmsKeyId)), s3Uri: \(String(describing: s3Uri)))"}
}

/// <p>Provides configuration parameters for the output of PII entity detection jobs.</p>
public struct PiiOutputDataConfig: Equatable {
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the
    ///       output results from an analysis job.</p>
    public let kmsKeyId: String?
    /// <p>When you use the <code>PiiOutputDataConfig</code> object with asynchronous operations,
    ///       you specify the Amazon S3 location where you want to write the output data. </p>
    public let s3Uri: String?

    public init (
        kmsKeyId: String? = nil,
        s3Uri: String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.s3Uri = s3Uri
    }
}

extension RedactionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maskCharacter = "MaskCharacter"
        case maskMode = "MaskMode"
        case piiEntityTypes = "PiiEntityTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maskCharacter = maskCharacter {
            try encodeContainer.encode(maskCharacter, forKey: .maskCharacter)
        }
        if let maskMode = maskMode {
            try encodeContainer.encode(maskMode.rawValue, forKey: .maskMode)
        }
        if let piiEntityTypes = piiEntityTypes {
            var piiEntityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .piiEntityTypes)
            for listofpiientitytypes0 in piiEntityTypes {
                try piiEntityTypesContainer.encode(listofpiientitytypes0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let piiEntityTypesContainer = try containerValues.decodeIfPresent([PiiEntityType?].self, forKey: .piiEntityTypes)
        var piiEntityTypesDecoded0:[PiiEntityType]? = nil
        if let piiEntityTypesContainer = piiEntityTypesContainer {
            piiEntityTypesDecoded0 = [PiiEntityType]()
            for string0 in piiEntityTypesContainer {
                if let string0 = string0 {
                    piiEntityTypesDecoded0?.append(string0)
                }
            }
        }
        piiEntityTypes = piiEntityTypesDecoded0
        let maskModeDecoded = try containerValues.decodeIfPresent(PiiEntitiesDetectionMaskMode.self, forKey: .maskMode)
        maskMode = maskModeDecoded
        let maskCharacterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maskCharacter)
        maskCharacter = maskCharacterDecoded
    }
}

extension RedactionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedactionConfig(maskCharacter: \(String(describing: maskCharacter)), maskMode: \(String(describing: maskMode)), piiEntityTypes: \(String(describing: piiEntityTypes)))"}
}

/// <p>Provides configuration parameters for PII entity redaction.</p>
public struct RedactionConfig: Equatable {
    /// <p>A character that replaces each character in the redacted PII entity.</p>
    public let maskCharacter: String?
    /// <p>Specifies whether the PII entity is redacted with the mask character or the entity
    ///       type.</p>
    public let maskMode: PiiEntitiesDetectionMaskMode?
    /// <p>An array of the types of PII entities that Amazon Comprehend detects in the input text for
    ///       your request.</p>
    public let piiEntityTypes: [PiiEntityType]?

    public init (
        maskCharacter: String? = nil,
        maskMode: PiiEntitiesDetectionMaskMode? = nil,
        piiEntityTypes: [PiiEntityType]? = nil
    )
    {
        self.maskCharacter = maskCharacter
        self.maskMode = maskMode
        self.piiEntityTypes = piiEntityTypes
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource name is already in use. Use a different name and try your request
///       again.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceLimitExceededException(message: \(String(describing: message)))"}
}

extension ResourceLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of resources per account has been exceeded. Review the resources, and
///       then try your request again.</p>
public struct ResourceLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ResourceLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource ARN was not found. Check the ARN and try your request again.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceUnavailableException(message: \(String(describing: message)))"}
}

extension ResourceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource is not available. Check the resource and try your request
///       again.</p>
public struct ResourceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ResourceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SentimentDetectionJobFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension SentimentDetectionJobFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SentimentDetectionJobFilter(jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), submitTimeAfter: \(String(describing: submitTimeAfter)), submitTimeBefore: \(String(describing: submitTimeBefore)))"}
}

/// <p>Provides information for filtering a list of dominant language detection jobs. For more
///       information, see the  operation.</p>
public struct SentimentDetectionJobFilter: Equatable {
    /// <p>Filters on the name of the job.</p>
    public let jobName: String?
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified
    ///       status.</p>
    public let jobStatus: JobStatus?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted after the specified time. Jobs are returned in descending order,
    ///       newest to oldest.</p>
    public let submitTimeAfter: Date?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Returns only jobs submitted before the specified time. Jobs are returned in ascending order,
    ///       oldest to newest.</p>
    public let submitTimeBefore: Date?

    public init (
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        submitTimeAfter: Date? = nil,
        submitTimeBefore: Date? = nil
    )
    {
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension SentimentDetectionJobProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case languageCode = "LanguageCode"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension SentimentDetectionJobProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SentimentDetectionJobProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), endTime: \(String(describing: endTime)), inputDataConfig: \(String(describing: inputDataConfig)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), languageCode: \(String(describing: languageCode)), message: \(String(describing: message)), outputDataConfig: \(String(describing: outputDataConfig)), submitTime: \(String(describing: submitTime)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Provides information about a sentiment detection job.</p>
public struct SentimentDetectionJobProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input
    ///       data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The time that the sentiment detection job ended.</p>
    public let endTime: Date?
    /// <p>The input data configuration that you supplied when you created the sentiment detection
    ///       job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier assigned to the sentiment detection job.</p>
    public let jobId: String?
    /// <p>The name that you assigned to the sentiment detection job</p>
    public let jobName: String?
    /// <p>The current status of the sentiment detection job. If the status is <code>FAILED</code>,
    ///       the <code>Messages</code> field shows the reason for the failure.</p>
    public let jobStatus: JobStatus?
    /// <p>The language code of the input documents.</p>
    public let languageCode: LanguageCode?
    /// <p>A description of the status of a job.</p>
    public let message: String?
    /// <p>The output data configuration that you supplied when you created the sentiment detection
    ///       job.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>The time that the sentiment detection job was submitted for processing.</p>
    public let submitTime: Date?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the
    ///       resources you are using for your sentiment detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        dataAccessRoleArn: String? = nil,
        endTime: Date? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobId: String? = nil,
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        languageCode: LanguageCode? = nil,
        message: String? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        submitTime: Date? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.languageCode = languageCode
        self.message = message
        self.outputDataConfig = outputDataConfig
        self.submitTime = submitTime
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

extension SentimentScore: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mixed = "Mixed"
        case negative = "Negative"
        case neutral = "Neutral"
        case positive = "Positive"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mixed = mixed {
            try encodeContainer.encode(mixed, forKey: .mixed)
        }
        if let negative = negative {
            try encodeContainer.encode(negative, forKey: .negative)
        }
        if let neutral = neutral {
            try encodeContainer.encode(neutral, forKey: .neutral)
        }
        if let positive = positive {
            try encodeContainer.encode(positive, forKey: .positive)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positiveDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .positive)
        positive = positiveDecoded
        let negativeDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .negative)
        negative = negativeDecoded
        let neutralDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .neutral)
        neutral = neutralDecoded
        let mixedDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .mixed)
        mixed = mixedDecoded
    }
}

extension SentimentScore: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SentimentScore(mixed: \(String(describing: mixed)), negative: \(String(describing: negative)), neutral: \(String(describing: neutral)), positive: \(String(describing: positive)))"}
}

/// <p>Describes the level of confidence that Amazon Comprehend has in the accuracy of its
///       detection of sentiments.</p>
public struct SentimentScore: Equatable {
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of
    ///       the <code>MIXED</code> sentiment.</p>
    public let mixed: Float?
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of
    ///       the <code>NEGATIVE</code> sentiment.</p>
    public let negative: Float?
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of
    ///       the <code>NEUTRAL</code> sentiment.</p>
    public let neutral: Float?
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of
    ///       the <code>POSITIVE</code> sentiment.</p>
    public let positive: Float?

    public init (
        mixed: Float? = nil,
        negative: Float? = nil,
        neutral: Float? = nil,
        positive: Float? = nil
    )
    {
        self.mixed = mixed
        self.negative = negative
        self.neutral = neutral
        self.positive = positive
    }
}

public enum SentimentType {
    case mixed
    case negative
    case neutral
    case positive
    case sdkUnknown(String)
}

extension SentimentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SentimentType] {
        return [
            .mixed,
            .negative,
            .neutral,
            .positive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .mixed: return "MIXED"
        case .negative: return "NEGATIVE"
        case .neutral: return "NEUTRAL"
        case .positive: return "POSITIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SentimentType(rawValue: rawValue) ?? SentimentType.sdkUnknown(rawValue)
    }
}

public struct StartDocumentClassificationJobInputBodyMiddleware: Middleware {
    public let id: String = "StartDocumentClassificationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDocumentClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDocumentClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDocumentClassificationJobInput>
    public typealias MOutput = OperationOutput<StartDocumentClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDocumentClassificationJobOutputError>
}

extension StartDocumentClassificationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDocumentClassificationJobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), documentClassifierArn: \(String(describing: documentClassifierArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), outputDataConfig: \(String(describing: outputDataConfig)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension StartDocumentClassificationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case documentClassifierArn = "DocumentClassifierArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let documentClassifierArn = documentClassifierArn {
            try encodeContainer.encode(documentClassifierArn, forKey: .documentClassifierArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct StartDocumentClassificationJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartDocumentClassificationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDocumentClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDocumentClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDocumentClassificationJobInput>
    public typealias MOutput = OperationOutput<StartDocumentClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDocumentClassificationJobOutputError>
}

public struct StartDocumentClassificationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDocumentClassificationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDocumentClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDocumentClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDocumentClassificationJobInput>
    public typealias MOutput = OperationOutput<StartDocumentClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDocumentClassificationJobOutputError>
}

public struct StartDocumentClassificationJobInput: Equatable {
    /// <p>A unique identifier for the request. If you do not set the client request token, Amazon
    ///       Comprehend generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend read access to your input data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the document classifier to use to process the
    ///       job.</p>
    public let documentClassifierArn: String?
    /// <p>Specifies the format and location of the input data for the job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier of the job.</p>
    public let jobName: String?
    /// <p>Specifies where to send the output files.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    ///       the resources you are using for your document classification job. For more information, see
    ///         <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        documentClassifierArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.documentClassifierArn = documentClassifierArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

struct StartDocumentClassificationJobInputBody: Equatable {
    public let jobName: String?
    public let documentClassifierArn: String?
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let dataAccessRoleArn: String?
    public let clientRequestToken: String?
    public let volumeKmsKeyId: String?
    public let vpcConfig: VpcConfig?
}

extension StartDocumentClassificationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case documentClassifierArn = "DocumentClassifierArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let documentClassifierArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentClassifierArn)
        documentClassifierArn = documentClassifierArnDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension StartDocumentClassificationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDocumentClassificationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyValidationException" : self = .kmsKeyValidationException(try KmsKeyValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDocumentClassificationJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case kmsKeyValidationException(KmsKeyValidationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDocumentClassificationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDocumentClassificationJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StartDocumentClassificationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDocumentClassificationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartDocumentClassificationJobOutputResponse: Equatable {
    /// <p>The identifier generated for the job. To get the status of the job, use this identifier
    ///       with the  operation.</p>
    public let jobId: String?
    /// <p>The status of the job:</p>
    ///          <ul>
    ///             <li>
    ///                <p>SUBMITTED - The job has been received and queued for processing.</p>
    ///             </li>
    ///             <li>
    ///                <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
    ///             </li>
    ///             <li>
    ///                <p>COMPLETED - The job was successfully completed and the output is available.</p>
    ///             </li>
    ///             <li>
    ///                <p>FAILED - The job did not complete. For details, use the  operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is
    ///           processing the request.</p>
    ///             </li>
    ///             <li>
    ///                <p>STOPPED - The job was successfully stopped without completing.</p>
    ///             </li>
    ///          </ul>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartDocumentClassificationJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StartDocumentClassificationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StartDominantLanguageDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StartDominantLanguageDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDominantLanguageDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDominantLanguageDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDominantLanguageDetectionJobInput>
    public typealias MOutput = OperationOutput<StartDominantLanguageDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDominantLanguageDetectionJobOutputError>
}

extension StartDominantLanguageDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDominantLanguageDetectionJobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), outputDataConfig: \(String(describing: outputDataConfig)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension StartDominantLanguageDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct StartDominantLanguageDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartDominantLanguageDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDominantLanguageDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDominantLanguageDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDominantLanguageDetectionJobInput>
    public typealias MOutput = OperationOutput<StartDominantLanguageDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDominantLanguageDetectionJobOutputError>
}

public struct StartDominantLanguageDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDominantLanguageDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDominantLanguageDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDominantLanguageDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDominantLanguageDetectionJobInput>
    public typealias MOutput = OperationOutput<StartDominantLanguageDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDominantLanguageDetectionJobOutputError>
}

public struct StartDominantLanguageDetectionJobInput: Equatable {
    /// <p>A unique identifier for the request. If you do not set the client request token, Amazon
    ///       Comprehend generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions.html#auth-role-permissions">https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions.html#auth-role-permissions</a>.</p>
    public let dataAccessRoleArn: String?
    /// <p>Specifies the format and location of the input data for the job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>An identifier for the job.</p>
    public let jobName: String?
    /// <p>Specifies where to send the output files.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    ///       the resources you are using for your dominant language detection job. For more information,
    ///       see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

struct StartDominantLanguageDetectionJobInputBody: Equatable {
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let dataAccessRoleArn: String?
    public let jobName: String?
    public let clientRequestToken: String?
    public let volumeKmsKeyId: String?
    public let vpcConfig: VpcConfig?
}

extension StartDominantLanguageDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension StartDominantLanguageDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDominantLanguageDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyValidationException" : self = .kmsKeyValidationException(try KmsKeyValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDominantLanguageDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case kmsKeyValidationException(KmsKeyValidationException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDominantLanguageDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDominantLanguageDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StartDominantLanguageDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDominantLanguageDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartDominantLanguageDetectionJobOutputResponse: Equatable {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
    ///       the  operation.</p>
    public let jobId: String?
    /// <p>The status of the job. </p>
    ///          <ul>
    ///             <li>
    ///                <p>SUBMITTED - The job has been received and is queued for processing.</p>
    ///             </li>
    ///             <li>
    ///                <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
    ///             </li>
    ///             <li>
    ///                <p>COMPLETED - The job was successfully completed and the output is available.</p>
    ///             </li>
    ///             <li>
    ///                <p>FAILED - The job did not complete. To get details, use the  operation.</p>
    ///             </li>
    ///          </ul>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartDominantLanguageDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StartDominantLanguageDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StartEntitiesDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StartEntitiesDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<StartEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartEntitiesDetectionJobOutputError>
}

extension StartEntitiesDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartEntitiesDetectionJobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), entityRecognizerArn: \(String(describing: entityRecognizerArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), languageCode: \(String(describing: languageCode)), outputDataConfig: \(String(describing: outputDataConfig)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension StartEntitiesDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case entityRecognizerArn = "EntityRecognizerArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let entityRecognizerArn = entityRecognizerArn {
            try encodeContainer.encode(entityRecognizerArn, forKey: .entityRecognizerArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct StartEntitiesDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartEntitiesDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<StartEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartEntitiesDetectionJobOutputError>
}

public struct StartEntitiesDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartEntitiesDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<StartEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartEntitiesDetectionJobOutputError>
}

public struct StartEntitiesDetectionJobInput: Equatable {
    /// <p>A unique identifier for the request. If you don't set the client request token, Amazon
    ///       Comprehend generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions.html#auth-role-permissions">https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions.html#auth-role-permissions</a>.</p>
    public let dataAccessRoleArn: String?
    /// <p>The Amazon Resource Name (ARN) that identifies the specific entity recognizer to be used
    ///       by the <code>StartEntitiesDetectionJob</code>. This ARN is optional and is only used for a
    ///       custom entity recognition job.</p>
    public let entityRecognizerArn: String?
    /// <p>Specifies the format and location of the input data for the job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier of the job.</p>
    public let jobName: String?
    /// <p>The language of the input documents. All documents must be in the same language. You can
    ///       specify any of the languages supported by Amazon Comprehend. If custom entities recognition is
    ///       used, this parameter is ignored and the language used for training the model is used
    ///       instead.</p>
    public let languageCode: LanguageCode?
    /// <p>Specifies where to send the output files.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    ///       the resources you are using for your entity detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        entityRecognizerArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        languageCode: LanguageCode? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.entityRecognizerArn = entityRecognizerArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

struct StartEntitiesDetectionJobInputBody: Equatable {
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let dataAccessRoleArn: String?
    public let jobName: String?
    public let entityRecognizerArn: String?
    public let languageCode: LanguageCode?
    public let clientRequestToken: String?
    public let volumeKmsKeyId: String?
    public let vpcConfig: VpcConfig?
}

extension StartEntitiesDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case entityRecognizerArn = "EntityRecognizerArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let entityRecognizerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityRecognizerArn)
        entityRecognizerArn = entityRecognizerArnDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension StartEntitiesDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartEntitiesDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyValidationException" : self = .kmsKeyValidationException(try KmsKeyValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartEntitiesDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case kmsKeyValidationException(KmsKeyValidationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartEntitiesDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartEntitiesDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StartEntitiesDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartEntitiesDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartEntitiesDetectionJobOutputResponse: Equatable {
    /// <p>The identifier generated for the job. To get the status of job, use this identifier with
    ///       the  operation.</p>
    public let jobId: String?
    /// <p>The status of the job. </p>
    ///          <ul>
    ///             <li>
    ///                <p>SUBMITTED - The job has been received and is queued for processing.</p>
    ///             </li>
    ///             <li>
    ///                <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
    ///             </li>
    ///             <li>
    ///                <p>COMPLETED - The job was successfully completed and the output is available.</p>
    ///             </li>
    ///             <li>
    ///                <p>FAILED - The job did not complete. To get details, use the  operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is
    ///           processing the request.</p>
    ///             </li>
    ///             <li>
    ///                <p>STOPPED - The job was successfully stopped without completing.</p>
    ///             </li>
    ///          </ul>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartEntitiesDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StartEntitiesDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StartEventsDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StartEventsDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartEventsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartEventsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartEventsDetectionJobInput>
    public typealias MOutput = OperationOutput<StartEventsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartEventsDetectionJobOutputError>
}

extension StartEventsDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartEventsDetectionJobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), languageCode: \(String(describing: languageCode)), outputDataConfig: \(String(describing: outputDataConfig)), targetEventTypes: \(String(describing: targetEventTypes)))"}
}

extension StartEventsDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
        case targetEventTypes = "TargetEventTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let targetEventTypes = targetEventTypes {
            var targetEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetEventTypes)
            for targeteventtypes0 in targetEventTypes {
                try targetEventTypesContainer.encode(targeteventtypes0)
            }
        }
    }
}

public struct StartEventsDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartEventsDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartEventsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartEventsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartEventsDetectionJobInput>
    public typealias MOutput = OperationOutput<StartEventsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartEventsDetectionJobOutputError>
}

public struct StartEventsDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartEventsDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartEventsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartEventsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartEventsDetectionJobInput>
    public typealias MOutput = OperationOutput<StartEventsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartEventsDetectionJobOutputError>
}

public struct StartEventsDetectionJobInput: Equatable {
    /// <p>An unique identifier for the request. If you don't set the client request token, Amazon
    ///       Comprehend generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend read access to your input data.</p>
    public let dataAccessRoleArn: String?
    /// <p>Specifies the format and location of the input data for the job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier of the events detection job.</p>
    public let jobName: String?
    /// <p>The language code of the input documents.</p>
    public let languageCode: LanguageCode?
    /// <p>Specifies where to send the output files.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>The types of events to detect in the input documents.</p>
    public let targetEventTypes: [String]?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        languageCode: LanguageCode? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        targetEventTypes: [String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
        self.targetEventTypes = targetEventTypes
    }
}

struct StartEventsDetectionJobInputBody: Equatable {
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let dataAccessRoleArn: String?
    public let jobName: String?
    public let languageCode: LanguageCode?
    public let clientRequestToken: String?
    public let targetEventTypes: [String]?
}

extension StartEventsDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
        case targetEventTypes = "TargetEventTypes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let targetEventTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetEventTypes)
        var targetEventTypesDecoded0:[String]? = nil
        if let targetEventTypesContainer = targetEventTypesContainer {
            targetEventTypesDecoded0 = [String]()
            for string0 in targetEventTypesContainer {
                if let string0 = string0 {
                    targetEventTypesDecoded0?.append(string0)
                }
            }
        }
        targetEventTypes = targetEventTypesDecoded0
    }
}

extension StartEventsDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartEventsDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyValidationException" : self = .kmsKeyValidationException(try KmsKeyValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartEventsDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case kmsKeyValidationException(KmsKeyValidationException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartEventsDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartEventsDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StartEventsDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartEventsDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartEventsDetectionJobOutputResponse: Equatable {
    /// <p>An unique identifier for the request. If you don't set the client request token, Amazon
    ///       Comprehend generates one.</p>
    public let jobId: String?
    /// <p>The status of the events detection job.</p>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartEventsDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StartEventsDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StartKeyPhrasesDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StartKeyPhrasesDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartKeyPhrasesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartKeyPhrasesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartKeyPhrasesDetectionJobInput>
    public typealias MOutput = OperationOutput<StartKeyPhrasesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartKeyPhrasesDetectionJobOutputError>
}

extension StartKeyPhrasesDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartKeyPhrasesDetectionJobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), languageCode: \(String(describing: languageCode)), outputDataConfig: \(String(describing: outputDataConfig)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension StartKeyPhrasesDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct StartKeyPhrasesDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartKeyPhrasesDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartKeyPhrasesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartKeyPhrasesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartKeyPhrasesDetectionJobInput>
    public typealias MOutput = OperationOutput<StartKeyPhrasesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartKeyPhrasesDetectionJobOutputError>
}

public struct StartKeyPhrasesDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartKeyPhrasesDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartKeyPhrasesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartKeyPhrasesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartKeyPhrasesDetectionJobInput>
    public typealias MOutput = OperationOutput<StartKeyPhrasesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartKeyPhrasesDetectionJobOutputError>
}

public struct StartKeyPhrasesDetectionJobInput: Equatable {
    /// <p>A unique identifier for the request. If you don't set the client request token, Amazon
    ///       Comprehend generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions.html#auth-role-permissions">https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions.html#auth-role-permissions</a>.</p>
    public let dataAccessRoleArn: String?
    /// <p>Specifies the format and location of the input data for the job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier of the job.</p>
    public let jobName: String?
    /// <p>The language of the input documents. You can specify any of the primary languages
    ///       supported by Amazon Comprehend. All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>Specifies where to send the output files.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p> Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    ///       the resources you are using for your key phrases detection job. For more information, see
    ///         <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        languageCode: LanguageCode? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

struct StartKeyPhrasesDetectionJobInputBody: Equatable {
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let dataAccessRoleArn: String?
    public let jobName: String?
    public let languageCode: LanguageCode?
    public let clientRequestToken: String?
    public let volumeKmsKeyId: String?
    public let vpcConfig: VpcConfig?
}

extension StartKeyPhrasesDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension StartKeyPhrasesDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartKeyPhrasesDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyValidationException" : self = .kmsKeyValidationException(try KmsKeyValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartKeyPhrasesDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case kmsKeyValidationException(KmsKeyValidationException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartKeyPhrasesDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartKeyPhrasesDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StartKeyPhrasesDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartKeyPhrasesDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartKeyPhrasesDetectionJobOutputResponse: Equatable {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
    ///       the  operation.</p>
    public let jobId: String?
    /// <p>The status of the job. </p>
    ///          <ul>
    ///             <li>
    ///                <p>SUBMITTED - The job has been received and is queued for processing.</p>
    ///             </li>
    ///             <li>
    ///                <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
    ///             </li>
    ///             <li>
    ///                <p>COMPLETED - The job was successfully completed and the output is available.</p>
    ///             </li>
    ///             <li>
    ///                <p>FAILED - The job did not complete. To get details, use the  operation.</p>
    ///             </li>
    ///          </ul>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartKeyPhrasesDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StartKeyPhrasesDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StartPiiEntitiesDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StartPiiEntitiesDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPiiEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPiiEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPiiEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<StartPiiEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPiiEntitiesDetectionJobOutputError>
}

extension StartPiiEntitiesDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartPiiEntitiesDetectionJobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), languageCode: \(String(describing: languageCode)), mode: \(String(describing: mode)), outputDataConfig: \(String(describing: outputDataConfig)), redactionConfig: \(String(describing: redactionConfig)))"}
}

extension StartPiiEntitiesDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case languageCode = "LanguageCode"
        case mode = "Mode"
        case outputDataConfig = "OutputDataConfig"
        case redactionConfig = "RedactionConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let redactionConfig = redactionConfig {
            try encodeContainer.encode(redactionConfig, forKey: .redactionConfig)
        }
    }
}

public struct StartPiiEntitiesDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartPiiEntitiesDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPiiEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPiiEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPiiEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<StartPiiEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPiiEntitiesDetectionJobOutputError>
}

public struct StartPiiEntitiesDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartPiiEntitiesDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPiiEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPiiEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPiiEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<StartPiiEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPiiEntitiesDetectionJobOutputError>
}

public struct StartPiiEntitiesDetectionJobInput: Equatable {
    /// <p>A unique identifier for the request. If you don't set the client request token, Amazon
    ///       Comprehend generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend read access to your input data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The input properties for a PII entities detection job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier of the job.</p>
    public let jobName: String?
    /// <p>The language of the input documents.</p>
    public let languageCode: LanguageCode?
    /// <p>Specifies whether the output provides the locations (offsets) of PII entities or a file in
    ///       which PII entities are redacted.</p>
    public let mode: PiiEntitiesDetectionMode?
    /// <p>Provides conguration parameters for the output of PII entity detection jobs.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>Provides configuration parameters for PII entity redaction.</p>
    ///          <p>This parameter is required if you set the <code>Mode</code> parameter to
    ///         <code>ONLY_REDACTION</code>. In that case, you must provide a <code>RedactionConfig</code>
    ///       definition that includes the <code>PiiEntityTypes</code> parameter.</p>
    public let redactionConfig: RedactionConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        languageCode: LanguageCode? = nil,
        mode: PiiEntitiesDetectionMode? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        redactionConfig: RedactionConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.languageCode = languageCode
        self.mode = mode
        self.outputDataConfig = outputDataConfig
        self.redactionConfig = redactionConfig
    }
}

struct StartPiiEntitiesDetectionJobInputBody: Equatable {
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let mode: PiiEntitiesDetectionMode?
    public let redactionConfig: RedactionConfig?
    public let dataAccessRoleArn: String?
    public let jobName: String?
    public let languageCode: LanguageCode?
    public let clientRequestToken: String?
}

extension StartPiiEntitiesDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case languageCode = "LanguageCode"
        case mode = "Mode"
        case outputDataConfig = "OutputDataConfig"
        case redactionConfig = "RedactionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let modeDecoded = try containerValues.decodeIfPresent(PiiEntitiesDetectionMode.self, forKey: .mode)
        mode = modeDecoded
        let redactionConfigDecoded = try containerValues.decodeIfPresent(RedactionConfig.self, forKey: .redactionConfig)
        redactionConfig = redactionConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartPiiEntitiesDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartPiiEntitiesDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyValidationException" : self = .kmsKeyValidationException(try KmsKeyValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartPiiEntitiesDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case kmsKeyValidationException(KmsKeyValidationException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartPiiEntitiesDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartPiiEntitiesDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StartPiiEntitiesDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartPiiEntitiesDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartPiiEntitiesDetectionJobOutputResponse: Equatable {
    /// <p>The identifier generated for the job.</p>
    public let jobId: String?
    /// <p>The status of the job.</p>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartPiiEntitiesDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StartPiiEntitiesDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StartSentimentDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StartSentimentDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSentimentDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSentimentDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSentimentDetectionJobInput>
    public typealias MOutput = OperationOutput<StartSentimentDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSentimentDetectionJobOutputError>
}

extension StartSentimentDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSentimentDetectionJobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), languageCode: \(String(describing: languageCode)), outputDataConfig: \(String(describing: outputDataConfig)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension StartSentimentDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct StartSentimentDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartSentimentDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSentimentDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSentimentDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSentimentDetectionJobInput>
    public typealias MOutput = OperationOutput<StartSentimentDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSentimentDetectionJobOutputError>
}

public struct StartSentimentDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartSentimentDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSentimentDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSentimentDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSentimentDetectionJobInput>
    public typealias MOutput = OperationOutput<StartSentimentDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSentimentDetectionJobOutputError>
}

public struct StartSentimentDetectionJobInput: Equatable {
    /// <p>A unique identifier for the request. If you don't set the client request token, Amazon
    ///       Comprehend generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    ///       grants Amazon Comprehend read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions.html#auth-role-permissions">https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions.html#auth-role-permissions</a>.</p>
    public let dataAccessRoleArn: String?
    /// <p>Specifies the format and location of the input data for the job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier of the job.</p>
    public let jobName: String?
    /// <p>The language of the input documents. You can specify any of the primary languages
    ///       supported by Amazon Comprehend. All documents must be in the same language.</p>
    public let languageCode: LanguageCode?
    /// <p>Specifies where to send the output files. </p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    ///       the resources you are using for your sentiment detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        languageCode: LanguageCode? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

struct StartSentimentDetectionJobInputBody: Equatable {
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let dataAccessRoleArn: String?
    public let jobName: String?
    public let languageCode: LanguageCode?
    public let clientRequestToken: String?
    public let volumeKmsKeyId: String?
    public let vpcConfig: VpcConfig?
}

extension StartSentimentDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension StartSentimentDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSentimentDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyValidationException" : self = .kmsKeyValidationException(try KmsKeyValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSentimentDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case kmsKeyValidationException(KmsKeyValidationException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSentimentDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSentimentDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StartSentimentDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartSentimentDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartSentimentDetectionJobOutputResponse: Equatable {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
    ///       the  operation.</p>
    public let jobId: String?
    /// <p>The status of the job. </p>
    ///          <ul>
    ///             <li>
    ///                <p>SUBMITTED - The job has been received and is queued for processing.</p>
    ///             </li>
    ///             <li>
    ///                <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
    ///             </li>
    ///             <li>
    ///                <p>COMPLETED - The job was successfully completed and the output is available.</p>
    ///             </li>
    ///             <li>
    ///                <p>FAILED - The job did not complete. To get details, use the  operation.</p>
    ///             </li>
    ///          </ul>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartSentimentDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StartSentimentDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StartTopicsDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StartTopicsDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTopicsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTopicsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTopicsDetectionJobInput>
    public typealias MOutput = OperationOutput<StartTopicsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTopicsDetectionJobOutputError>
}

extension StartTopicsDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTopicsDetectionJobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)), numberOfTopics: \(String(describing: numberOfTopics)), outputDataConfig: \(String(describing: outputDataConfig)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension StartTopicsDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case numberOfTopics = "NumberOfTopics"
        case outputDataConfig = "OutputDataConfig"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let numberOfTopics = numberOfTopics {
            try encodeContainer.encode(numberOfTopics, forKey: .numberOfTopics)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct StartTopicsDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartTopicsDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTopicsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTopicsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTopicsDetectionJobInput>
    public typealias MOutput = OperationOutput<StartTopicsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTopicsDetectionJobOutputError>
}

public struct StartTopicsDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartTopicsDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTopicsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTopicsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTopicsDetectionJobInput>
    public typealias MOutput = OperationOutput<StartTopicsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTopicsDetectionJobOutputError>
}

public struct StartTopicsDetectionJobInput: Equatable {
    /// <p>A unique identifier for the request. If you do not set the client request token, Amazon
    ///       Comprehend generates one.</p>
    public var clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role
    ///       that grants Amazon Comprehend read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions.html#auth-role-permissions">https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions.html#auth-role-permissions</a>.</p>
    public let dataAccessRoleArn: String?
    /// <p>Specifies the format and location of the input data for the job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier of the job.</p>
    public let jobName: String?
    /// <p>The number of topics to detect.</p>
    public let numberOfTopics: Int?
    /// <p>Specifies where to send the output files. The output is a compressed archive with two
    ///       files, <code>topic-terms.csv</code> that lists the terms associated with each topic, and
    ///         <code>doc-topics.csv</code> that lists the documents associated with each topic</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    ///       the resources you are using for your topic detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        clientRequestToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil,
        numberOfTopics: Int? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.numberOfTopics = numberOfTopics
        self.outputDataConfig = outputDataConfig
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

struct StartTopicsDetectionJobInputBody: Equatable {
    public let inputDataConfig: InputDataConfig?
    public let outputDataConfig: OutputDataConfig?
    public let dataAccessRoleArn: String?
    public let jobName: String?
    public let numberOfTopics: Int?
    public let clientRequestToken: String?
    public let volumeKmsKeyId: String?
    public let vpcConfig: VpcConfig?
}

extension StartTopicsDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case numberOfTopics = "NumberOfTopics"
        case outputDataConfig = "OutputDataConfig"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let numberOfTopicsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfTopics)
        numberOfTopics = numberOfTopicsDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension StartTopicsDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartTopicsDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyValidationException" : self = .kmsKeyValidationException(try KmsKeyValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartTopicsDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case kmsKeyValidationException(KmsKeyValidationException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartTopicsDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTopicsDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StartTopicsDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartTopicsDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartTopicsDetectionJobOutputResponse: Equatable {
    /// <p>The identifier generated for the job. To get the status of the job, use this identifier
    ///       with the <code>DescribeTopicDetectionJob</code> operation.</p>
    public let jobId: String?
    /// <p>The status of the job: </p>
    ///          <ul>
    ///             <li>
    ///                <p>SUBMITTED - The job has been received and is queued for processing.</p>
    ///             </li>
    ///             <li>
    ///                <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
    ///             </li>
    ///             <li>
    ///                <p>COMPLETED - The job was successfully completed and the output is
    ///           available.</p>
    ///             </li>
    ///             <li>
    ///                <p>FAILED - The job did not complete. To get details, use the
    ///             <code>DescribeTopicDetectionJob</code> operation.</p>
    ///             </li>
    ///          </ul>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartTopicsDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StartTopicsDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StopDominantLanguageDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StopDominantLanguageDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDominantLanguageDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDominantLanguageDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDominantLanguageDetectionJobInput>
    public typealias MOutput = OperationOutput<StopDominantLanguageDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDominantLanguageDetectionJobOutputError>
}

extension StopDominantLanguageDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDominantLanguageDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension StopDominantLanguageDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopDominantLanguageDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopDominantLanguageDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDominantLanguageDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDominantLanguageDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDominantLanguageDetectionJobInput>
    public typealias MOutput = OperationOutput<StopDominantLanguageDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDominantLanguageDetectionJobOutputError>
}

public struct StopDominantLanguageDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopDominantLanguageDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDominantLanguageDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDominantLanguageDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDominantLanguageDetectionJobInput>
    public typealias MOutput = OperationOutput<StopDominantLanguageDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDominantLanguageDetectionJobOutputError>
}

public struct StopDominantLanguageDetectionJobInput: Equatable {
    /// <p>The identifier of the dominant language detection job to stop.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopDominantLanguageDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension StopDominantLanguageDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopDominantLanguageDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopDominantLanguageDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDominantLanguageDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDominantLanguageDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDominantLanguageDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StopDominantLanguageDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopDominantLanguageDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StopDominantLanguageDetectionJobOutputResponse: Equatable {
    /// <p>The identifier of the dominant language detection job to stop.</p>
    public let jobId: String?
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or
    ///         <code>STOPPED</code> if the job was previously stopped with the
    ///         <code>StopDominantLanguageDetectionJob</code> operation.</p>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StopDominantLanguageDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StopDominantLanguageDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StopEntitiesDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StopEntitiesDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<StopEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopEntitiesDetectionJobOutputError>
}

extension StopEntitiesDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopEntitiesDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension StopEntitiesDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopEntitiesDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopEntitiesDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<StopEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopEntitiesDetectionJobOutputError>
}

public struct StopEntitiesDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopEntitiesDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<StopEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopEntitiesDetectionJobOutputError>
}

public struct StopEntitiesDetectionJobInput: Equatable {
    /// <p>The identifier of the entities detection job to stop.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopEntitiesDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension StopEntitiesDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopEntitiesDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopEntitiesDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopEntitiesDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopEntitiesDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopEntitiesDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StopEntitiesDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopEntitiesDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StopEntitiesDetectionJobOutputResponse: Equatable {
    /// <p>The identifier of the entities detection job to stop.</p>
    public let jobId: String?
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or
    ///         <code>STOPPED</code> if the job was previously stopped with the
    ///         <code>StopEntitiesDetectionJob</code> operation.</p>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StopEntitiesDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StopEntitiesDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StopEventsDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StopEventsDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopEventsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopEventsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopEventsDetectionJobInput>
    public typealias MOutput = OperationOutput<StopEventsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopEventsDetectionJobOutputError>
}

extension StopEventsDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopEventsDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension StopEventsDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopEventsDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopEventsDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopEventsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopEventsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopEventsDetectionJobInput>
    public typealias MOutput = OperationOutput<StopEventsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopEventsDetectionJobOutputError>
}

public struct StopEventsDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopEventsDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopEventsDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopEventsDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopEventsDetectionJobInput>
    public typealias MOutput = OperationOutput<StopEventsDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopEventsDetectionJobOutputError>
}

public struct StopEventsDetectionJobInput: Equatable {
    /// <p>The identifier of the events detection job to stop.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopEventsDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension StopEventsDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopEventsDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopEventsDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopEventsDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopEventsDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopEventsDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StopEventsDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopEventsDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StopEventsDetectionJobOutputResponse: Equatable {
    /// <p>The identifier of the events detection job to stop.</p>
    public let jobId: String?
    /// <p>The status of the events detection job.</p>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StopEventsDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StopEventsDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StopKeyPhrasesDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StopKeyPhrasesDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopKeyPhrasesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopKeyPhrasesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopKeyPhrasesDetectionJobInput>
    public typealias MOutput = OperationOutput<StopKeyPhrasesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopKeyPhrasesDetectionJobOutputError>
}

extension StopKeyPhrasesDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopKeyPhrasesDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension StopKeyPhrasesDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopKeyPhrasesDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopKeyPhrasesDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopKeyPhrasesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopKeyPhrasesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopKeyPhrasesDetectionJobInput>
    public typealias MOutput = OperationOutput<StopKeyPhrasesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopKeyPhrasesDetectionJobOutputError>
}

public struct StopKeyPhrasesDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopKeyPhrasesDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopKeyPhrasesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopKeyPhrasesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopKeyPhrasesDetectionJobInput>
    public typealias MOutput = OperationOutput<StopKeyPhrasesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopKeyPhrasesDetectionJobOutputError>
}

public struct StopKeyPhrasesDetectionJobInput: Equatable {
    /// <p>The identifier of the key phrases detection job to stop.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopKeyPhrasesDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension StopKeyPhrasesDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopKeyPhrasesDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopKeyPhrasesDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopKeyPhrasesDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopKeyPhrasesDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopKeyPhrasesDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StopKeyPhrasesDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopKeyPhrasesDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StopKeyPhrasesDetectionJobOutputResponse: Equatable {
    /// <p>The identifier of the key phrases detection job to stop.</p>
    public let jobId: String?
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or
    ///         <code>STOPPED</code> if the job was previously stopped with the
    ///         <code>StopKeyPhrasesDetectionJob</code> operation.</p>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StopKeyPhrasesDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StopKeyPhrasesDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StopPiiEntitiesDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StopPiiEntitiesDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopPiiEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopPiiEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopPiiEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<StopPiiEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopPiiEntitiesDetectionJobOutputError>
}

extension StopPiiEntitiesDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopPiiEntitiesDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension StopPiiEntitiesDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopPiiEntitiesDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopPiiEntitiesDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopPiiEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopPiiEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopPiiEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<StopPiiEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopPiiEntitiesDetectionJobOutputError>
}

public struct StopPiiEntitiesDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopPiiEntitiesDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopPiiEntitiesDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopPiiEntitiesDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopPiiEntitiesDetectionJobInput>
    public typealias MOutput = OperationOutput<StopPiiEntitiesDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopPiiEntitiesDetectionJobOutputError>
}

public struct StopPiiEntitiesDetectionJobInput: Equatable {
    /// <p>The identifier of the PII entities detection job to stop.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopPiiEntitiesDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension StopPiiEntitiesDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopPiiEntitiesDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopPiiEntitiesDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopPiiEntitiesDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopPiiEntitiesDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopPiiEntitiesDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StopPiiEntitiesDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopPiiEntitiesDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StopPiiEntitiesDetectionJobOutputResponse: Equatable {
    /// <p>The identifier of the PII entities detection job to stop.</p>
    public let jobId: String?
    /// <p>The status of the PII entities detection job.</p>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StopPiiEntitiesDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StopPiiEntitiesDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StopSentimentDetectionJobInputBodyMiddleware: Middleware {
    public let id: String = "StopSentimentDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopSentimentDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopSentimentDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopSentimentDetectionJobInput>
    public typealias MOutput = OperationOutput<StopSentimentDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopSentimentDetectionJobOutputError>
}

extension StopSentimentDetectionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopSentimentDetectionJobInput(jobId: \(String(describing: jobId)))"}
}

extension StopSentimentDetectionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopSentimentDetectionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopSentimentDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopSentimentDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopSentimentDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopSentimentDetectionJobInput>
    public typealias MOutput = OperationOutput<StopSentimentDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopSentimentDetectionJobOutputError>
}

public struct StopSentimentDetectionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopSentimentDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopSentimentDetectionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopSentimentDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopSentimentDetectionJobInput>
    public typealias MOutput = OperationOutput<StopSentimentDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopSentimentDetectionJobOutputError>
}

public struct StopSentimentDetectionJobInput: Equatable {
    /// <p>The identifier of the sentiment detection job to stop.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopSentimentDetectionJobInputBody: Equatable {
    public let jobId: String?
}

extension StopSentimentDetectionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopSentimentDetectionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopSentimentDetectionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopSentimentDetectionJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case jobNotFoundException(JobNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopSentimentDetectionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopSentimentDetectionJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StopSentimentDetectionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopSentimentDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StopSentimentDetectionJobOutputResponse: Equatable {
    /// <p>The identifier of the sentiment detection job to stop.</p>
    public let jobId: String?
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or
    ///         <code>STOPPED</code> if the job was previously stopped with the
    ///         <code>StopSentimentDetectionJob</code> operation.</p>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StopSentimentDetectionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
}

extension StopSentimentDetectionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StopTrainingDocumentClassifierInputBodyMiddleware: Middleware {
    public let id: String = "StopTrainingDocumentClassifierInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopTrainingDocumentClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<StopTrainingDocumentClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopTrainingDocumentClassifierInput>
    public typealias MOutput = OperationOutput<StopTrainingDocumentClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopTrainingDocumentClassifierOutputError>
}

extension StopTrainingDocumentClassifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopTrainingDocumentClassifierInput(documentClassifierArn: \(String(describing: documentClassifierArn)))"}
}

extension StopTrainingDocumentClassifierInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentClassifierArn = "DocumentClassifierArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentClassifierArn = documentClassifierArn {
            try encodeContainer.encode(documentClassifierArn, forKey: .documentClassifierArn)
        }
    }
}

public struct StopTrainingDocumentClassifierInputHeadersMiddleware: Middleware {
    public let id: String = "StopTrainingDocumentClassifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopTrainingDocumentClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<StopTrainingDocumentClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopTrainingDocumentClassifierInput>
    public typealias MOutput = OperationOutput<StopTrainingDocumentClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopTrainingDocumentClassifierOutputError>
}

public struct StopTrainingDocumentClassifierInputQueryItemMiddleware: Middleware {
    public let id: String = "StopTrainingDocumentClassifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopTrainingDocumentClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<StopTrainingDocumentClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopTrainingDocumentClassifierInput>
    public typealias MOutput = OperationOutput<StopTrainingDocumentClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopTrainingDocumentClassifierOutputError>
}

public struct StopTrainingDocumentClassifierInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier currently being
    ///       trained.</p>
    public let documentClassifierArn: String?

    public init (
        documentClassifierArn: String? = nil
    )
    {
        self.documentClassifierArn = documentClassifierArn
    }
}

struct StopTrainingDocumentClassifierInputBody: Equatable {
    public let documentClassifierArn: String?
}

extension StopTrainingDocumentClassifierInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentClassifierArn = "DocumentClassifierArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentClassifierArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentClassifierArn)
        documentClassifierArn = documentClassifierArnDecoded
    }
}

extension StopTrainingDocumentClassifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopTrainingDocumentClassifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopTrainingDocumentClassifierOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopTrainingDocumentClassifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopTrainingDocumentClassifierOutputResponse()"}
}

extension StopTrainingDocumentClassifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopTrainingDocumentClassifierOutputResponse: Equatable {

    public init() {}
}

struct StopTrainingDocumentClassifierOutputResponseBody: Equatable {
}

extension StopTrainingDocumentClassifierOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StopTrainingEntityRecognizerInputBodyMiddleware: Middleware {
    public let id: String = "StopTrainingEntityRecognizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopTrainingEntityRecognizerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopTrainingEntityRecognizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopTrainingEntityRecognizerInput>
    public typealias MOutput = OperationOutput<StopTrainingEntityRecognizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopTrainingEntityRecognizerOutputError>
}

extension StopTrainingEntityRecognizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopTrainingEntityRecognizerInput(entityRecognizerArn: \(String(describing: entityRecognizerArn)))"}
}

extension StopTrainingEntityRecognizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityRecognizerArn = "EntityRecognizerArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityRecognizerArn = entityRecognizerArn {
            try encodeContainer.encode(entityRecognizerArn, forKey: .entityRecognizerArn)
        }
    }
}

public struct StopTrainingEntityRecognizerInputHeadersMiddleware: Middleware {
    public let id: String = "StopTrainingEntityRecognizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopTrainingEntityRecognizerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopTrainingEntityRecognizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopTrainingEntityRecognizerInput>
    public typealias MOutput = OperationOutput<StopTrainingEntityRecognizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopTrainingEntityRecognizerOutputError>
}

public struct StopTrainingEntityRecognizerInputQueryItemMiddleware: Middleware {
    public let id: String = "StopTrainingEntityRecognizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopTrainingEntityRecognizerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopTrainingEntityRecognizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopTrainingEntityRecognizerInput>
    public typealias MOutput = OperationOutput<StopTrainingEntityRecognizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopTrainingEntityRecognizerOutputError>
}

public struct StopTrainingEntityRecognizerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer currently being
    ///       trained.</p>
    public let entityRecognizerArn: String?

    public init (
        entityRecognizerArn: String? = nil
    )
    {
        self.entityRecognizerArn = entityRecognizerArn
    }
}

struct StopTrainingEntityRecognizerInputBody: Equatable {
    public let entityRecognizerArn: String?
}

extension StopTrainingEntityRecognizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityRecognizerArn = "EntityRecognizerArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityRecognizerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityRecognizerArn)
        entityRecognizerArn = entityRecognizerArnDecoded
    }
}

extension StopTrainingEntityRecognizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopTrainingEntityRecognizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopTrainingEntityRecognizerOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopTrainingEntityRecognizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopTrainingEntityRecognizerOutputResponse()"}
}

extension StopTrainingEntityRecognizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopTrainingEntityRecognizerOutputResponse: Equatable {

    public init() {}
}

struct StopTrainingEntityRecognizerOutputResponseBody: Equatable {
}

extension StopTrainingEntityRecognizerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum SyntaxLanguageCode {
    case de
    case en
    case es
    case fr
    case it
    case pt
    case sdkUnknown(String)
}

extension SyntaxLanguageCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SyntaxLanguageCode] {
        return [
            .de,
            .en,
            .es,
            .fr,
            .it,
            .pt,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .de: return "de"
        case .en: return "en"
        case .es: return "es"
        case .fr: return "fr"
        case .it: return "it"
        case .pt: return "pt"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SyntaxLanguageCode(rawValue: rawValue) ?? SyntaxLanguageCode.sdkUnknown(rawValue)
    }
}

extension SyntaxToken: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginOffset = "BeginOffset"
        case endOffset = "EndOffset"
        case partOfSpeech = "PartOfSpeech"
        case text = "Text"
        case tokenId = "TokenId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let partOfSpeech = partOfSpeech {
            try encodeContainer.encode(partOfSpeech, forKey: .partOfSpeech)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let tokenId = tokenId {
            try encodeContainer.encode(tokenId, forKey: .tokenId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let partOfSpeechDecoded = try containerValues.decodeIfPresent(PartOfSpeechTag.self, forKey: .partOfSpeech)
        partOfSpeech = partOfSpeechDecoded
    }
}

extension SyntaxToken: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SyntaxToken(beginOffset: \(String(describing: beginOffset)), endOffset: \(String(describing: endOffset)), partOfSpeech: \(String(describing: partOfSpeech)), text: \(String(describing: text)), tokenId: \(String(describing: tokenId)))"}
}

/// <p>Represents a work in the input text that was recognized and assigned a part of speech.
///       There is one syntax token record for each word in the source text.</p>
public struct SyntaxToken: Equatable {
    /// <p>The zero-based offset from the beginning of the source text to the first character in the
    ///       word.</p>
    public let beginOffset: Int?
    /// <p>The zero-based offset from the beginning of the source text to the last character in the
    ///       word.</p>
    public let endOffset: Int?
    /// <p>Provides the part of speech label and the confidence level that Amazon Comprehend has that
    ///       the part of speech was correctly identified. For more information, see <a>how-syntax</a>.</p>
    public let partOfSpeech: PartOfSpeechTag?
    /// <p>The word that was recognized in the source text.</p>
    public let text: String?
    /// <p>A unique identifier for a token.</p>
    public let tokenId: Int?

    public init (
        beginOffset: Int? = nil,
        endOffset: Int? = nil,
        partOfSpeech: PartOfSpeechTag? = nil,
        text: String? = nil,
        tokenId: Int? = nil
    )
    {
        self.beginOffset = beginOffset
        self.endOffset = endOffset
        self.partOfSpeech = partOfSpeech
        self.text = text
        self.tokenId = tokenId
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A key-value pair that adds as a metadata to a resource used by Amazon Comprehend. For
///       example, a tag with the key-value pair Department:Sales might be added to a resource to
///       indicate its use by a particular department. </p>
public struct Tag: Equatable {
    /// <p>The initial part of a key-value pair that forms a tag associated with a given resource.
    ///       For instance, if you want to show which resources are used by which departments, you might use
    ///       Department as the key portion of the pair, with multiple possible values such as sales,
    ///       legal, and administration. </p>
    public let key: String?
    /// <p> The second part of a key-value pair that forms a tag associated with a given resource.
    ///       For instance, if you want to show which resources are used by which departments, you might use
    ///       Department as the initial (key) portion of the pair, with a value of sales to indicate the
    ///       sales department. </p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the given Amazon Comprehend resource to which you want
    ///       to associate the tags. </p>
    public let resourceArn: String?
    /// <p>Tags being associated with a specific Amazon Comprehend resource. There can be a maximum
    ///       of 50 tags (both existing and pending) associated with a specific resource. </p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TextSizeLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextSizeLimitExceededException(message: \(String(describing: message)))"}
}

extension TextSizeLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TextSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The size of the input text exceeds the limit. Use a smaller document.</p>
public struct TextSizeLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TextSizeLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension TextSizeLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of requests exceeds the limit. Resubmit your request later.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagKeysException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagKeysException(message: \(String(describing: message)))"}
}

extension TooManyTagKeysException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagKeysExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request contains more tag keys than can be associated with a resource (50 tag keys per
///       resource).</p>
public struct TooManyTagKeysException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagKeysExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagKeysExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request contains more tags than can be associated with a resource (50 tags per
///       resource). The maximum number of tags includes both existing tags and those included in your
///       current request. </p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TopicsDetectionJobFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension TopicsDetectionJobFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TopicsDetectionJobFilter(jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), submitTimeAfter: \(String(describing: submitTimeAfter)), submitTimeBefore: \(String(describing: submitTimeBefore)))"}
}

/// <p>Provides information for filtering topic detection jobs. For more information, see
///         .</p>
public struct TopicsDetectionJobFilter: Equatable {
    /// <p></p>
    public let jobName: String?
    /// <p>Filters the list of topic detection jobs based on job status. Returns only jobs with
    ///       the specified status.</p>
    public let jobStatus: JobStatus?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Only returns jobs submitted after the specified time. Jobs are returned in ascending order,
    ///       oldest to newest.</p>
    public let submitTimeAfter: Date?
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing.
    ///       Only returns jobs submitted before the specified time. Jobs are returned in descending order,
    ///       newest to oldest.</p>
    public let submitTimeBefore: Date?

    public init (
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        submitTimeAfter: Date? = nil,
        submitTimeBefore: Date? = nil
    )
    {
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension TopicsDetectionJobProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case message = "Message"
        case numberOfTopics = "NumberOfTopics"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
        case volumeKmsKeyId = "VolumeKmsKeyId"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let numberOfTopics = numberOfTopics {
            try encodeContainer.encode(numberOfTopics, forKey: .numberOfTopics)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let volumeKmsKeyId = volumeKmsKeyId {
            try encodeContainer.encode(volumeKmsKeyId, forKey: .volumeKmsKeyId)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let numberOfTopicsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfTopics)
        numberOfTopics = numberOfTopicsDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let volumeKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeKmsKeyId)
        volumeKmsKeyId = volumeKmsKeyIdDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension TopicsDetectionJobProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TopicsDetectionJobProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), endTime: \(String(describing: endTime)), inputDataConfig: \(String(describing: inputDataConfig)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), message: \(String(describing: message)), numberOfTopics: \(String(describing: numberOfTopics)), outputDataConfig: \(String(describing: outputDataConfig)), submitTime: \(String(describing: submitTime)), volumeKmsKeyId: \(String(describing: volumeKmsKeyId)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Provides information about a topic detection job.</p>
public struct TopicsDetectionJobProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants
    ///       Amazon Comprehend read access to your job data. </p>
    public let dataAccessRoleArn: String?
    /// <p>The time that the topic detection job was completed.</p>
    public let endTime: Date?
    /// <p>The input data configuration supplied when you created the topic detection
    ///       job.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The identifier assigned to the topic detection job.</p>
    public let jobId: String?
    /// <p>The name of the topic detection job.</p>
    public let jobName: String?
    /// <p>The current status of the topic detection job. If the status is <code>Failed</code>,
    ///       the reason for the failure is shown in the <code>Message</code> field.</p>
    public let jobStatus: JobStatus?
    /// <p>A description for the status of a job.</p>
    public let message: String?
    /// <p>The number of topics to detect supplied when you created the topic detection job. The
    ///       default is 10. </p>
    public let numberOfTopics: Int?
    /// <p>The output data configuration supplied when you created the topic detection
    ///       job.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>The time that the topic detection job was submitted for processing.</p>
    public let submitTime: Date?
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    ///       data on the storage volume attached to the ML compute instance(s) that process the analysis
    ///       job. The VolumeKmsKeyId can be either of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Resource Name (ARN) of a KMS Key:
    ///             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let volumeKmsKeyId: String?
    /// <p>Configuration parameters for a private Virtual Private Cloud (VPC) containing the
    ///       resources you are using for your topic detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    ///         VPC</a>. </p>
    public let vpcConfig: VpcConfig?

    public init (
        dataAccessRoleArn: String? = nil,
        endTime: Date? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobId: String? = nil,
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        message: String? = nil,
        numberOfTopics: Int? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        submitTime: Date? = nil,
        volumeKmsKeyId: String? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.message = message
        self.numberOfTopics = numberOfTopics
        self.outputDataConfig = outputDataConfig
        self.submitTime = submitTime
        self.volumeKmsKeyId = volumeKmsKeyId
        self.vpcConfig = vpcConfig
    }
}

extension UnsupportedLanguageException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedLanguageException(message: \(String(describing: message)))"}
}

extension UnsupportedLanguageException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedLanguageExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Comprehend can't process the language of the input text. For custom entity
///       recognition APIs, only English, Spanish, French, Italian, German, or Portuguese are accepted.
///       For a list of supported languages, see <a>supported-languages</a>. </p>
public struct UnsupportedLanguageException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedLanguageExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedLanguageExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p> The Amazon Resource Name (ARN) of the given Amazon Comprehend resource from which you
    ///       want to remove the tags. </p>
    public let resourceArn: String?
    /// <p>The initial part of a key-value pair that forms a tag being removed from a given resource.
    ///       For example, a tag with "Sales" as the key might be added to a resource to indicate its use by
    ///       the sales department. Keys must be unique and cannot be duplicated for a particular resource.
    ///     </p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagKeysException" : self = .tooManyTagKeysException(try TooManyTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagKeysException(TooManyTagKeysException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateEndpointInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEndpointInput>
    public typealias MOutput = OperationOutput<UpdateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEndpointOutputError>
}

extension UpdateEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEndpointInput(desiredInferenceUnits: \(String(describing: desiredInferenceUnits)), endpointArn: \(String(describing: endpointArn)))"}
}

extension UpdateEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case desiredInferenceUnits = "DesiredInferenceUnits"
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredInferenceUnits = desiredInferenceUnits {
            try encodeContainer.encode(desiredInferenceUnits, forKey: .desiredInferenceUnits)
        }
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
    }
}

public struct UpdateEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEndpointInput>
    public typealias MOutput = OperationOutput<UpdateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEndpointOutputError>
}

public struct UpdateEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEndpointInput>
    public typealias MOutput = OperationOutput<UpdateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEndpointOutputError>
}

public struct UpdateEndpointInput: Equatable {
    /// <p> The desired number of inference units to be used by the model using this endpoint.
    ///
    ///       Each inference unit represents of a throughput of 100 characters per second.</p>
    public let desiredInferenceUnits: Int?
    /// <p>The Amazon Resource Number (ARN) of the endpoint being updated.</p>
    public let endpointArn: String?

    public init (
        desiredInferenceUnits: Int? = nil,
        endpointArn: String? = nil
    )
    {
        self.desiredInferenceUnits = desiredInferenceUnits
        self.endpointArn = endpointArn
    }
}

struct UpdateEndpointInputBody: Equatable {
    public let endpointArn: String?
    public let desiredInferenceUnits: Int?
}

extension UpdateEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case desiredInferenceUnits = "DesiredInferenceUnits"
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let desiredInferenceUnitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .desiredInferenceUnits)
        desiredInferenceUnits = desiredInferenceUnitsDecoded
    }
}

extension UpdateEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEndpointOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEndpointOutputResponse()"}
}

extension UpdateEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateEndpointOutputResponse: Equatable {

    public init() {}
}

struct UpdateEndpointOutputResponseBody: Equatable {
}

extension UpdateEndpointOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension VpcConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnets = "Subnets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnets0 in subnets {
                try subnetsContainer.encode(subnets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnets)
        var subnetsDecoded0:[String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
    }
}

extension VpcConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfig(securityGroupIds: \(String(describing: securityGroupIds)), subnets: \(String(describing: subnets)))"}
}

/// <p> Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
///       the resources you are using for the job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
///         VPC</a>. </p>
public struct VpcConfig: Equatable {
    /// <p>The ID number for a security group on an instance of your private VPC. Security groups on
    ///       your VPC function serve as a virtual firewall to control inbound and outbound traffic and
    ///       provides security for the resources that youll be accessing on the VPC. This ID number is
    ///       preceded by "sg-", for instance: "sg-03b388029b0a285ea". For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html">Security
    ///         Groups for your VPC</a>. </p>
    public let securityGroupIds: [String]?
    /// <p>The ID for each subnet being used in your private VPC. This subnet is a subset of the a
    ///       range of IPv4 addresses used by the VPC and is specific to a given availability zone in the
    ///       VPCs region. This ID number is preceded by "subnet-", for instance:
    ///       "subnet-04ccf456919e69055". For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">VPCs and
    ///         Subnets</a>. </p>
    public let subnets: [String]?

    public init (
        securityGroupIds: [String]? = nil,
        subnets: [String]? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnets = subnets
    }
}
