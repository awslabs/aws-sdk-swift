// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ComprehendMedicalClientTypes.Attribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case relationshipType = "RelationshipType"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let relationshipType = relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for traitlist0 in traits {
                try traitsContainer.encode(traitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntitySubType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntityType.self, forKey: .category)
        category = categoryDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Trait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.Trait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.Trait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the dosage of a medication taken. It contains information about the attribute such as id, begin and end offset within the input text, and the segment of the input text.
    public struct Attribute: Swift.Equatable {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of attribute.
        public var category: ComprehendMedicalClientTypes.EntityType?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Comprehend Medical; has that this attribute is correctly related to this entity.
        public var relationshipScore: Swift.Float?
        /// The type of relationship between the entity and attribute. Type for the relationship is OVERLAP, indicating that the entity occurred at the same time as the Date_Expression.
        public var relationshipType: ComprehendMedicalClientTypes.RelationshipType?
        /// The level of confidence that Comprehend Medical; has that the segment of text is correctly recognized as an attribute.
        public var score: Swift.Float?
        /// The segment of input text extracted as this attribute.
        public var text: Swift.String?
        /// Contextual information for this attribute.
        public var traits: [ComprehendMedicalClientTypes.Trait]?
        /// The type of attribute.
        public var type: ComprehendMedicalClientTypes.EntitySubType?

        public init (
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.EntityType? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            relationshipScore: Swift.Float? = nil,
            relationshipType: ComprehendMedicalClientTypes.RelationshipType? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.Trait]? = nil,
            type: ComprehendMedicalClientTypes.EntitySubType? = nil
        )
        {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum AttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case diagnosis
        case negation
        case sign
        case symptom
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeName] {
            return [
                .diagnosis,
                .negation,
                .sign,
                .symptom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .diagnosis: return "DIAGNOSIS"
            case .negation: return "NEGATION"
            case .sign: return "SIGN"
            case .symptom: return "SYMPTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeName(rawValue: rawValue) ?? AttributeName.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.Characters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originalTextCharacters = "OriginalTextCharacters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let originalTextCharacters = originalTextCharacters {
            try encodeContainer.encode(originalTextCharacters, forKey: .originalTextCharacters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originalTextCharactersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originalTextCharacters)
        originalTextCharacters = originalTextCharactersDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The number of characters in the input text to be analyzed.
    public struct Characters: Swift.Equatable {
        /// The number of characters present in the input text document as processed by Comprehend Medical.
        public var originalTextCharacters: Swift.Int?

        public init (
            originalTextCharacters: Swift.Int? = nil
        )
        {
            self.originalTextCharacters = originalTextCharacters
        }
    }

}

extension ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// Provides information for filtering a list of detection jobs.
    public struct ComprehendMedicalAsyncJobFilter: Swift.Equatable {
        /// Filters on the name of the job.
        public var jobName: Swift.String?
        /// Filters the list of jobs based on job status. Returns only jobs with the specified status.
        public var jobStatus: ComprehendMedicalClientTypes.JobStatus?
        /// Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.
        public var submitTimeAfter: ClientRuntime.Date?
        /// Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.
        public var submitTimeBefore: ClientRuntime.Date?

        public init (
            jobName: Swift.String? = nil,
            jobStatus: ComprehendMedicalClientTypes.JobStatus? = nil,
            submitTimeAfter: ClientRuntime.Date? = nil,
            submitTimeBefore: ClientRuntime.Date? = nil
        )
        {
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.submitTimeAfter = submitTimeAfter
            self.submitTimeBefore = submitTimeBefore
        }
    }

}

extension ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case expirationTime = "ExpirationTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case manifestFilePath = "ManifestFilePath"
        case message = "Message"
        case modelVersion = "ModelVersion"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let expirationTime = expirationTime {
            try encodeContainer.encode(expirationTime.timeIntervalSince1970, forKey: .expirationTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let manifestFilePath = manifestFilePath {
            try encodeContainer.encode(manifestFilePath, forKey: .manifestFilePath)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let modelVersion = modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let manifestFilePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestFilePath)
        manifestFilePath = manifestFilePathDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// Provides information about a detection job.
    public struct ComprehendMedicalAsyncJobProperties: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that gives Comprehend Medical; read access to your input data.
        public var dataAccessRoleArn: Swift.String?
        /// The time that the detection job completed.
        public var endTime: ClientRuntime.Date?
        /// The date and time that job metadata is deleted from the server. Output files in your S3 bucket will not be deleted. After the metadata is deleted, the job will no longer appear in the results of the ListEntitiesDetectionV2Job or the ListPHIDetectionJobs operation.
        public var expirationTime: ClientRuntime.Date?
        /// The input data configuration that you supplied when you created the detection job.
        public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
        /// The identifier assigned to the detection job.
        public var jobId: Swift.String?
        /// The name that you assigned to the detection job.
        public var jobName: Swift.String?
        /// The current status of the detection job. If the status is FAILED, the Message field shows the reason for the failure.
        public var jobStatus: ComprehendMedicalClientTypes.JobStatus?
        /// The AWS Key Management Service key, if any, used to encrypt the output files.
        public var kMSKey: Swift.String?
        /// The language code of the input documents.
        public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
        /// The path to the file that describes the results of a batch job.
        public var manifestFilePath: Swift.String?
        /// A description of the status of a job.
        public var message: Swift.String?
        /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
        public var modelVersion: Swift.String?
        /// The output data configuration that you supplied when you created the detection job.
        public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
        /// The time that the detection job was submitted for processing.
        public var submitTime: ClientRuntime.Date?

        public init (
            dataAccessRoleArn: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: ComprehendMedicalClientTypes.JobStatus? = nil,
            kMSKey: Swift.String? = nil,
            languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
            manifestFilePath: Swift.String? = nil,
            message: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil,
            submitTime: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.endTime = endTime
            self.expirationTime = expirationTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.kMSKey = kMSKey
            self.languageCode = languageCode
            self.manifestFilePath = manifestFilePath
            self.message = message
            self.modelVersion = modelVersion
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }
    }

}

extension DescribeEntitiesDetectionV2JobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeEntitiesDetectionV2JobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEntitiesDetectionV2JobInput: Swift.Equatable {
    /// The identifier that Comprehend Medical; generated for the job. The StartEntitiesDetectionV2Job operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeEntitiesDetectionV2JobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribeEntitiesDetectionV2JobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeEntitiesDetectionV2JobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEntitiesDetectionV2JobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEntitiesDetectionV2JobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEntitiesDetectionV2JobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEntitiesDetectionV2JobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeEntitiesDetectionV2JobOutputResponse: Swift.Equatable {
    /// An object that contains the properties associated with a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeEntitiesDetectionV2JobOutputResponseBody: Swift.Equatable {
    let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribeEntitiesDetectionV2JobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

extension DescribeICD10CMInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeICD10CMInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeICD10CMInferenceJobInput: Swift.Equatable {
    /// The identifier that Amazon Comprehend Medical generated for the job. The StartICD10CMInferenceJob operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeICD10CMInferenceJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribeICD10CMInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeICD10CMInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeICD10CMInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeICD10CMInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeICD10CMInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeICD10CMInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeICD10CMInferenceJobOutputResponse: Swift.Equatable {
    /// An object that contains the properties associated with a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeICD10CMInferenceJobOutputResponseBody: Swift.Equatable {
    let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribeICD10CMInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

extension DescribePHIDetectionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribePHIDetectionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePHIDetectionJobInput: Swift.Equatable {
    /// The identifier that Comprehend Medical; generated for the job. The StartPHIDetectionJob operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribePHIDetectionJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribePHIDetectionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribePHIDetectionJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePHIDetectionJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePHIDetectionJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePHIDetectionJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePHIDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribePHIDetectionJobOutputResponse: Swift.Equatable {
    /// An object that contains the properties associated with a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribePHIDetectionJobOutputResponseBody: Swift.Equatable {
    let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribePHIDetectionJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

extension DescribeRxNormInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeRxNormInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRxNormInferenceJobInput: Swift.Equatable {
    /// The identifier that Amazon Comprehend Medical generated for the job. The StartRxNormInferenceJob operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeRxNormInferenceJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribeRxNormInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeRxNormInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRxNormInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRxNormInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRxNormInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRxNormInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeRxNormInferenceJobOutputResponse: Swift.Equatable {
    /// An object that contains the properties associated with a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeRxNormInferenceJobOutputResponseBody: Swift.Equatable {
    let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribeRxNormInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

extension DescribeSNOMEDCTInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeSNOMEDCTInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSNOMEDCTInferenceJobInput: Swift.Equatable {
    /// The identifier that Amazon Comprehend Medical generated for the job. The StartSNOMEDCTInferenceJob operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeSNOMEDCTInferenceJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribeSNOMEDCTInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeSNOMEDCTInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSNOMEDCTInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSNOMEDCTInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSNOMEDCTInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSNOMEDCTInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeSNOMEDCTInferenceJobOutputResponse: Swift.Equatable {
    /// Provides information about a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeSNOMEDCTInferenceJobOutputResponseBody: Swift.Equatable {
    let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribeSNOMEDCTInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

extension DetectEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension DetectEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetectEntitiesInput: Swift.Equatable {
    /// A UTF-8 text string containing the clinical content being examined for entities. Each string must contain fewer than 20,000 bytes of characters.
    /// This member is required.
    public var text: Swift.String?

    public init (
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct DetectEntitiesInputBody: Swift.Equatable {
    let text: Swift.String?
}

extension DetectEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectEntitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectEntitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectEntitiesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectEntitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DetectEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
            self.unmappedAttributes = output.unmappedAttributes
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
            self.unmappedAttributes = nil
        }
    }
}

public struct DetectEntitiesOutputResponse: Swift.Equatable {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical; has in the detection and analysis. Attributes and traits of the entity are also returned.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.Entity]?
    /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// If the result of the previous request to DetectEntities was truncated, include the PaginationToken to fetch the next page of entities.
    public var paginationToken: Swift.String?
    /// Attributes extracted from the input text that we were unable to relate to an entity.
    public var unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]?

    public init (
        entities: [ComprehendMedicalClientTypes.Entity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil,
        unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
        self.unmappedAttributes = unmappedAttributes
    }
}

struct DetectEntitiesOutputResponseBody: Swift.Equatable {
    let entities: [ComprehendMedicalClientTypes.Entity]?
    let unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]?
    let paginationToken: Swift.String?
    let modelVersion: Swift.String?
}

extension DetectEntitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
        case unmappedAttributes = "UnmappedAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let unmappedAttributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.UnmappedAttribute?].self, forKey: .unmappedAttributes)
        var unmappedAttributesDecoded0:[ComprehendMedicalClientTypes.UnmappedAttribute]? = nil
        if let unmappedAttributesContainer = unmappedAttributesContainer {
            unmappedAttributesDecoded0 = [ComprehendMedicalClientTypes.UnmappedAttribute]()
            for structure0 in unmappedAttributesContainer {
                if let structure0 = structure0 {
                    unmappedAttributesDecoded0?.append(structure0)
                }
            }
        }
        unmappedAttributes = unmappedAttributesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension DetectEntitiesV2Input: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension DetectEntitiesV2Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetectEntitiesV2Input: Swift.Equatable {
    /// A UTF-8 string containing the clinical content being examined for entities. Each string must contain fewer than 20,000 bytes of characters.
    /// This member is required.
    public var text: Swift.String?

    public init (
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct DetectEntitiesV2InputBody: Swift.Equatable {
    let text: Swift.String?
}

extension DetectEntitiesV2InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectEntitiesV2OutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectEntitiesV2OutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectEntitiesV2OutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectEntitiesV2OutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DetectEntitiesV2OutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
            self.unmappedAttributes = output.unmappedAttributes
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
            self.unmappedAttributes = nil
        }
    }
}

public struct DetectEntitiesV2OutputResponse: Swift.Equatable {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence in the detection and analysis. Attributes and traits of the entity are also returned.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.Entity]?
    /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// If the result to the DetectEntitiesV2 operation was truncated, include the PaginationToken to fetch the next page of entities.
    public var paginationToken: Swift.String?
    /// Attributes extracted from the input text that couldn't be related to an entity.
    public var unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]?

    public init (
        entities: [ComprehendMedicalClientTypes.Entity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil,
        unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
        self.unmappedAttributes = unmappedAttributes
    }
}

struct DetectEntitiesV2OutputResponseBody: Swift.Equatable {
    let entities: [ComprehendMedicalClientTypes.Entity]?
    let unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]?
    let paginationToken: Swift.String?
    let modelVersion: Swift.String?
}

extension DetectEntitiesV2OutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
        case unmappedAttributes = "UnmappedAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let unmappedAttributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.UnmappedAttribute?].self, forKey: .unmappedAttributes)
        var unmappedAttributesDecoded0:[ComprehendMedicalClientTypes.UnmappedAttribute]? = nil
        if let unmappedAttributesContainer = unmappedAttributesContainer {
            unmappedAttributesDecoded0 = [ComprehendMedicalClientTypes.UnmappedAttribute]()
            for structure0 in unmappedAttributesContainer {
                if let structure0 = structure0 {
                    unmappedAttributesDecoded0?.append(structure0)
                }
            }
        }
        unmappedAttributes = unmappedAttributesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension DetectPHIInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension DetectPHIInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetectPHIInput: Swift.Equatable {
    /// A UTF-8 text string containing the clinical content being examined for PHI entities. Each string must contain fewer than 20,000 bytes of characters.
    /// This member is required.
    public var text: Swift.String?

    public init (
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct DetectPHIInputBody: Swift.Equatable {
    let text: Swift.String?
}

extension DetectPHIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectPHIOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectPHIOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectPHIOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectPHIOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DetectPHIOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
        }
    }
}

public struct DetectPHIOutputResponse: Swift.Equatable {
    /// The collection of PHI entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical; has in its detection.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.Entity]?
    /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// If the result of the previous request to DetectPHI was truncated, include the PaginationToken to fetch the next page of PHI entities.
    public var paginationToken: Swift.String?

    public init (
        entities: [ComprehendMedicalClientTypes.Entity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
    }
}

struct DetectPHIOutputResponseBody: Swift.Equatable {
    let entities: [ComprehendMedicalClientTypes.Entity]?
    let paginationToken: Swift.String?
    let modelVersion: Swift.String?
}

extension DetectPHIOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension ComprehendMedicalClientTypes.Entity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for traitlist0 in traits {
                try traitsContainer.encode(traitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntityType.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntitySubType.self, forKey: .type)
        type = typeDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Trait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.Trait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.Trait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[ComprehendMedicalClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ComprehendMedicalClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// Provides information about an extracted medical entity.
    public struct Entity: Swift.Equatable {
        /// The extracted attributes that relate to this entity.
        public var attributes: [ComprehendMedicalClientTypes.Attribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the entity.
        public var category: ComprehendMedicalClientTypes.EntityType?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Comprehend Medical; has in the accuracy of the detection.
        public var score: Swift.Float?
        /// The segment of input text extracted as this entity.
        public var text: Swift.String?
        /// Contextual information for the entity.
        public var traits: [ComprehendMedicalClientTypes.Trait]?
        /// Describes the specific type of entity with category of entities.
        public var type: ComprehendMedicalClientTypes.EntitySubType?

        public init (
            attributes: [ComprehendMedicalClientTypes.Attribute]? = nil,
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.EntityType? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.Trait]? = nil,
            type: ComprehendMedicalClientTypes.EntitySubType? = nil
        )
        {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum EntitySubType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case address
        case age
        case brandName
        case contactPoint
        case date
        case direction
        case dosage
        case duration
        case dxName
        case email
        case form
        case frequency
        case genericName
        case id
        case identifier
        case name
        case phoneOrFax
        case procedureName
        case profession
        case quality
        case quantity
        case rate
        case routeOrMode
        case strength
        case systemOrganSite
        case testName
        case testUnit
        case testUnits
        case testValue
        case timeExpression
        case timeToDxName
        case timeToMedicationName
        case timeToProcedureName
        case timeToTestName
        case timeToTreatmentName
        case treatmentName
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitySubType] {
            return [
                .acuity,
                .address,
                .age,
                .brandName,
                .contactPoint,
                .date,
                .direction,
                .dosage,
                .duration,
                .dxName,
                .email,
                .form,
                .frequency,
                .genericName,
                .id,
                .identifier,
                .name,
                .phoneOrFax,
                .procedureName,
                .profession,
                .quality,
                .quantity,
                .rate,
                .routeOrMode,
                .strength,
                .systemOrganSite,
                .testName,
                .testUnit,
                .testUnits,
                .testValue,
                .timeExpression,
                .timeToDxName,
                .timeToMedicationName,
                .timeToProcedureName,
                .timeToTestName,
                .timeToTreatmentName,
                .treatmentName,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .address: return "ADDRESS"
            case .age: return "AGE"
            case .brandName: return "BRAND_NAME"
            case .contactPoint: return "CONTACT_POINT"
            case .date: return "DATE"
            case .direction: return "DIRECTION"
            case .dosage: return "DOSAGE"
            case .duration: return "DURATION"
            case .dxName: return "DX_NAME"
            case .email: return "EMAIL"
            case .form: return "FORM"
            case .frequency: return "FREQUENCY"
            case .genericName: return "GENERIC_NAME"
            case .id: return "ID"
            case .identifier: return "IDENTIFIER"
            case .name: return "NAME"
            case .phoneOrFax: return "PHONE_OR_FAX"
            case .procedureName: return "PROCEDURE_NAME"
            case .profession: return "PROFESSION"
            case .quality: return "QUALITY"
            case .quantity: return "QUANTITY"
            case .rate: return "RATE"
            case .routeOrMode: return "ROUTE_OR_MODE"
            case .strength: return "STRENGTH"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .testName: return "TEST_NAME"
            case .testUnit: return "TEST_UNIT"
            case .testUnits: return "TEST_UNITS"
            case .testValue: return "TEST_VALUE"
            case .timeExpression: return "TIME_EXPRESSION"
            case .timeToDxName: return "TIME_TO_DX_NAME"
            case .timeToMedicationName: return "TIME_TO_MEDICATION_NAME"
            case .timeToProcedureName: return "TIME_TO_PROCEDURE_NAME"
            case .timeToTestName: return "TIME_TO_TEST_NAME"
            case .timeToTreatmentName: return "TIME_TO_TREATMENT_NAME"
            case .treatmentName: return "TREATMENT_NAME"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntitySubType(rawValue: rawValue) ?? EntitySubType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anatomy
        case medicalCondition
        case medication
        case protectedHealthInformation
        case testTreatmentProcedure
        case timeExpression
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .anatomy,
                .medicalCondition,
                .medication,
                .protectedHealthInformation,
                .testTreatmentProcedure,
                .timeExpression,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anatomy: return "ANATOMY"
            case .medicalCondition: return "MEDICAL_CONDITION"
            case .medication: return "MEDICATION"
            case .protectedHealthInformation: return "PROTECTED_HEALTH_INFORMATION"
            case .testTreatmentProcedure: return "TEST_TREATMENT_PROCEDURE"
            case .timeExpression: return "TIME_EXPRESSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.ICD10CMAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case relationshipType = "RelationshipType"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let relationshipType = relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for icd10cmtraitlist0 in traits {
                try traitsContainer.encode(icd10cmtraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMAttributeType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.ICD10CMTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.ICD10CMTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMEntityType.self, forKey: .category)
        category = categoryDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMRelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The detected attributes that relate to an entity. This includes an extracted segment of the text that is an attribute of an entity, or otherwise related to an entity. InferICD10CM detects the following attributes: Direction, System, Organ or Site, and Acuity.
    public struct ICD10CMAttribute: Swift.Equatable {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of attribute. Can be either of DX_NAME or TIME_EXPRESSION.
        public var category: ComprehendMedicalClientTypes.ICD10CMEntityType?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.
        public var relationshipScore: Swift.Float?
        /// The type of relationship between the entity and attribute. Type for the relationship can be either of OVERLAP or SYSTEM_ORGAN_SITE.
        public var relationshipType: ComprehendMedicalClientTypes.ICD10CMRelationshipType?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public var score: Swift.Float?
        /// The segment of input text which contains the detected attribute.
        public var text: Swift.String?
        /// The contextual information for the attribute. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
        public var traits: [ComprehendMedicalClientTypes.ICD10CMTrait]?
        /// The type of attribute. InferICD10CM detects entities of the type DX_NAME.
        public var type: ComprehendMedicalClientTypes.ICD10CMAttributeType?

        public init (
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.ICD10CMEntityType? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            relationshipScore: Swift.Float? = nil,
            relationshipType: ComprehendMedicalClientTypes.ICD10CMRelationshipType? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.ICD10CMTrait]? = nil,
            type: ComprehendMedicalClientTypes.ICD10CMAttributeType? = nil
        )
        {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case direction
        case quality
        case quantity
        case systemOrganSite
        case timeExpression
        case timeToDxName
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMAttributeType] {
            return [
                .acuity,
                .direction,
                .quality,
                .quantity,
                .systemOrganSite,
                .timeExpression,
                .timeToDxName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .direction: return "DIRECTION"
            case .quality: return "QUALITY"
            case .quantity: return "QUANTITY"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .timeExpression: return "TIME_EXPRESSION"
            case .timeToDxName: return "TIME_TO_DX_NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMAttributeType(rawValue: rawValue) ?? ICD10CMAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.ICD10CMConcept: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case description = "Description"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.
    public struct ICD10CMConcept: Swift.Equatable {
        /// The ICD-10-CM code that identifies the concept found in the knowledge base from the Centers for Disease Control.
        public var code: Swift.String?
        /// The long description of the ICD-10-CM code in the ontology.
        public var description: Swift.String?
        /// The level of confidence that Amazon Comprehend Medical has that the entity is accurately linked to an ICD-10-CM concept.
        public var score: Swift.Float?

        public init (
            code: Swift.String? = nil,
            description: Swift.String? = nil,
            score: Swift.Float? = nil
        )
        {
            self.code = code
            self.description = description
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes.ICD10CMEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case iCD10CMConcepts = "ICD10CMConcepts"
        case id = "Id"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for icd10cmattributelist0 in attributes {
                try attributesContainer.encode(icd10cmattributelist0)
            }
        }
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let iCD10CMConcepts = iCD10CMConcepts {
            var iCD10CMConceptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iCD10CMConcepts)
            for icd10cmconceptlist0 in iCD10CMConcepts {
                try iCD10CMConceptsContainer.encode(icd10cmconceptlist0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for icd10cmtraitlist0 in traits {
                try traitsContainer.encode(icd10cmtraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMEntityCategory.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMEntityType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ComprehendMedicalClientTypes.ICD10CMAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ComprehendMedicalClientTypes.ICD10CMAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.ICD10CMTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.ICD10CMTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let iCD10CMConceptsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMConcept?].self, forKey: .iCD10CMConcepts)
        var iCD10CMConceptsDecoded0:[ComprehendMedicalClientTypes.ICD10CMConcept]? = nil
        if let iCD10CMConceptsContainer = iCD10CMConceptsContainer {
            iCD10CMConceptsDecoded0 = [ComprehendMedicalClientTypes.ICD10CMConcept]()
            for structure0 in iCD10CMConceptsContainer {
                if let structure0 = structure0 {
                    iCD10CMConceptsDecoded0?.append(structure0)
                }
            }
        }
        iCD10CMConcepts = iCD10CMConceptsDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
    public struct ICD10CMEntity: Swift.Equatable {
        /// The detected attributes that relate to the entity. An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the nature of a medical condition.
        public var attributes: [ComprehendMedicalClientTypes.ICD10CMAttribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the entity. InferICD10CM detects entities in the MEDICAL_CONDITION category.
        public var category: ComprehendMedicalClientTypes.ICD10CMEntityCategory?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public var iCD10CMConcepts: [ComprehendMedicalClientTypes.ICD10CMConcept]?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.
        public var score: Swift.Float?
        /// The segment of input text that is matched to the detected entity.
        public var text: Swift.String?
        /// Provides Contextual information for the entity. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
        public var traits: [ComprehendMedicalClientTypes.ICD10CMTrait]?
        /// Describes the specific type of entity with category of entities. InferICD10CM detects entities of the type DX_NAME and TIME_EXPRESSION.
        public var type: ComprehendMedicalClientTypes.ICD10CMEntityType?

        public init (
            attributes: [ComprehendMedicalClientTypes.ICD10CMAttribute]? = nil,
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.ICD10CMEntityCategory? = nil,
            endOffset: Swift.Int? = nil,
            iCD10CMConcepts: [ComprehendMedicalClientTypes.ICD10CMConcept]? = nil,
            id: Swift.Int? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.ICD10CMTrait]? = nil,
            type: ComprehendMedicalClientTypes.ICD10CMEntityType? = nil
        )
        {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.iCD10CMConcepts = iCD10CMConcepts
            self.id = id
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMEntityCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case medicalCondition
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMEntityCategory] {
            return [
                .medicalCondition,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .medicalCondition: return "MEDICAL_CONDITION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMEntityCategory(rawValue: rawValue) ?? ICD10CMEntityCategory.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dxName
        case timeExpression
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMEntityType] {
            return [
                .dxName,
                .timeExpression,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dxName: return "DX_NAME"
            case .timeExpression: return "TIME_EXPRESSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMEntityType(rawValue: rawValue) ?? ICD10CMEntityType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMRelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case overlap
        case systemOrganSite
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMRelationshipType] {
            return [
                .overlap,
                .systemOrganSite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .overlap: return "OVERLAP"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMRelationshipType(rawValue: rawValue) ?? ICD10CMRelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.ICD10CMTrait: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMTraitName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// Contextual information for the entity. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
    public struct ICD10CMTrait: Swift.Equatable {
        /// Provides a name or contextual description about the trait.
        public var name: ComprehendMedicalClientTypes.ICD10CMTraitName?
        /// The level of confidence that Comprehend Medical; has that the segment of text is correctly recognized as a trait.
        public var score: Swift.Float?

        public init (
            name: ComprehendMedicalClientTypes.ICD10CMTraitName? = nil,
            score: Swift.Float? = nil
        )
        {
            self.name = name
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMTraitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case diagnosis
        case negation
        case sign
        case symptom
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMTraitName] {
            return [
                .diagnosis,
                .negation,
                .sign,
                .symptom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .diagnosis: return "DIAGNOSIS"
            case .negation: return "NEGATION"
            case .sign: return "SIGN"
            case .symptom: return "SYMPTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMTraitName(rawValue: rawValue) ?? ICD10CMTraitName.sdkUnknown(rawValue)
        }
    }
}

extension InferICD10CMInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension InferICD10CMInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct InferICD10CMInput: Swift.Equatable {
    /// The input text used for analysis. The input for InferICD10CM is a string from 1 to 10000 characters.
    /// This member is required.
    public var text: Swift.String?

    public init (
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct InferICD10CMInputBody: Swift.Equatable {
    let text: Swift.String?
}

extension InferICD10CMInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension InferICD10CMOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InferICD10CMOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InferICD10CMOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InferICD10CMOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InferICD10CMOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
        }
    }
}

public struct InferICD10CMOutputResponse: Swift.Equatable {
    /// The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.ICD10CMEntity]?
    /// The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
    public var modelVersion: Swift.String?
    /// If the result of the previous request to InferICD10CM was truncated, include the PaginationToken to fetch the next page of medical condition entities.
    public var paginationToken: Swift.String?

    public init (
        entities: [ComprehendMedicalClientTypes.ICD10CMEntity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
    }
}

struct InferICD10CMOutputResponseBody: Swift.Equatable {
    let entities: [ComprehendMedicalClientTypes.ICD10CMEntity]?
    let paginationToken: Swift.String?
    let modelVersion: Swift.String?
}

extension InferICD10CMOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMEntity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.ICD10CMEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.ICD10CMEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension InferRxNormInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension InferRxNormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct InferRxNormInput: Swift.Equatable {
    /// The input text used for analysis. The input for InferRxNorm is a string from 1 to 10000 characters.
    /// This member is required.
    public var text: Swift.String?

    public init (
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct InferRxNormInputBody: Swift.Equatable {
    let text: Swift.String?
}

extension InferRxNormInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension InferRxNormOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InferRxNormOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InferRxNormOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InferRxNormOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InferRxNormOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
        }
    }
}

public struct InferRxNormOutputResponse: Swift.Equatable {
    /// The medication entities detected in the text linked to RxNorm concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.RxNormEntity]?
    /// The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
    public var modelVersion: Swift.String?
    /// If the result of the previous request to InferRxNorm was truncated, include the PaginationToken to fetch the next page of medication entities.
    public var paginationToken: Swift.String?

    public init (
        entities: [ComprehendMedicalClientTypes.RxNormEntity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
    }
}

struct InferRxNormOutputResponseBody: Swift.Equatable {
    let entities: [ComprehendMedicalClientTypes.RxNormEntity]?
    let paginationToken: Swift.String?
    let modelVersion: Swift.String?
}

extension InferRxNormOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormEntity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.RxNormEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.RxNormEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension InferSNOMEDCTInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension InferSNOMEDCTInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct InferSNOMEDCTInput: Swift.Equatable {
    /// The input text to be analyzed using InferSNOMEDCT. The text should be a string with 1 to 10000 characters.
    /// This member is required.
    public var text: Swift.String?

    public init (
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct InferSNOMEDCTInputBody: Swift.Equatable {
    let text: Swift.String?
}

extension InferSNOMEDCTInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension InferSNOMEDCTOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InferSNOMEDCTOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InferSNOMEDCTOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InferSNOMEDCTOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InferSNOMEDCTOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.characters = output.characters
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
            self.sNOMEDCTDetails = output.sNOMEDCTDetails
        } else {
            self.characters = nil
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
            self.sNOMEDCTDetails = nil
        }
    }
}

public struct InferSNOMEDCTOutputResponse: Swift.Equatable {
    /// The number of characters in the input request documentation.
    public var characters: ComprehendMedicalClientTypes.Characters?
    /// The collection of medical concept entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.SNOMEDCTEntity]?
    /// The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
    public var modelVersion: Swift.String?
    /// If the result of the request is truncated, the pagination token can be used to fetch the next page of entities.
    public var paginationToken: Swift.String?
    /// The details of the SNOMED-CT revision, including the edition, language, and version date.
    public var sNOMEDCTDetails: ComprehendMedicalClientTypes.SNOMEDCTDetails?

    public init (
        characters: ComprehendMedicalClientTypes.Characters? = nil,
        entities: [ComprehendMedicalClientTypes.SNOMEDCTEntity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil,
        sNOMEDCTDetails: ComprehendMedicalClientTypes.SNOMEDCTDetails? = nil
    )
    {
        self.characters = characters
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
        self.sNOMEDCTDetails = sNOMEDCTDetails
    }
}

struct InferSNOMEDCTOutputResponseBody: Swift.Equatable {
    let entities: [ComprehendMedicalClientTypes.SNOMEDCTEntity]?
    let paginationToken: Swift.String?
    let modelVersion: Swift.String?
    let sNOMEDCTDetails: ComprehendMedicalClientTypes.SNOMEDCTDetails?
    let characters: ComprehendMedicalClientTypes.Characters?
}

extension InferSNOMEDCTOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case characters = "Characters"
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
        case sNOMEDCTDetails = "SNOMEDCTDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.SNOMEDCTEntity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.SNOMEDCTEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.SNOMEDCTEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let sNOMEDCTDetailsDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTDetails.self, forKey: .sNOMEDCTDetails)
        sNOMEDCTDetails = sNOMEDCTDetailsDecoded
        let charactersDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.Characters.self, forKey: .characters)
        characters = charactersDecoded
    }
}

extension ComprehendMedicalClientTypes.InputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The input properties for an entities detection job. This includes the name of the S3 bucket and the path to the files to be analyzed.
    public struct InputDataConfig: Swift.Equatable {
        /// The URI of the S3 bucket that contains the input data. The bucket must be in the same region as the API endpoint that you are calling. Each file in the document collection must be less than 40 KB. You can store a maximum of 30 GB in the bucket.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The path to the input data files in the S3 bucket.
        public var s3Key: Swift.String?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEncodingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidEncodingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input text was not in valid UTF-8 character encoding. Check your text then retry your request.
public struct InvalidEncodingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEncodingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEncodingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request that you made is invalid. Check your request to determine why it's invalid and then retry the request.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ComprehendMedicalClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case partialSuccess
        case stopped
        case stopRequested
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .partialSuccess,
                .stopped,
                .stopRequested,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .partialSuccess: return "PARTIAL_SUCCESS"
            case .stopped: return "STOPPED"
            case .stopRequested: return "STOP_REQUESTED"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum LanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case en
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .en,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .en: return "en"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ListEntitiesDetectionV2JobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEntitiesDetectionV2JobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEntitiesDetectionV2JobsInput: Swift.Equatable {
    /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// The maximum number of results to return in each page. The default is 100.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEntitiesDetectionV2JobsInputBody: Swift.Equatable {
    let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEntitiesDetectionV2JobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEntitiesDetectionV2JobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEntitiesDetectionV2JobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEntitiesDetectionV2JobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntitiesDetectionV2JobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEntitiesDetectionV2JobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitiesDetectionV2JobsOutputResponse: Swift.Equatable {
    /// A list containing the properties of each job returned.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListEntitiesDetectionV2JobsOutputResponseBody: Swift.Equatable {
    let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    let nextToken: Swift.String?
}

extension ListEntitiesDetectionV2JobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListICD10CMInferenceJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListICD10CMInferenceJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListICD10CMInferenceJobsInput: Swift.Equatable {
    /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// The maximum number of results to return in each page. The default is 100.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListICD10CMInferenceJobsInputBody: Swift.Equatable {
    let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListICD10CMInferenceJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListICD10CMInferenceJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListICD10CMInferenceJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListICD10CMInferenceJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListICD10CMInferenceJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListICD10CMInferenceJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListICD10CMInferenceJobsOutputResponse: Swift.Equatable {
    /// A list containing the properties of each job that is returned.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListICD10CMInferenceJobsOutputResponseBody: Swift.Equatable {
    let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    let nextToken: Swift.String?
}

extension ListICD10CMInferenceJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPHIDetectionJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPHIDetectionJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPHIDetectionJobsInput: Swift.Equatable {
    /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// The maximum number of results to return in each page. The default is 100.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPHIDetectionJobsInputBody: Swift.Equatable {
    let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPHIDetectionJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPHIDetectionJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPHIDetectionJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPHIDetectionJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPHIDetectionJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPHIDetectionJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListPHIDetectionJobsOutputResponse: Swift.Equatable {
    /// A list containing the properties of each job returned.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListPHIDetectionJobsOutputResponseBody: Swift.Equatable {
    let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    let nextToken: Swift.String?
}

extension ListPHIDetectionJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRxNormInferenceJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRxNormInferenceJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRxNormInferenceJobsInput: Swift.Equatable {
    /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// Identifies the next page of results to return.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRxNormInferenceJobsInputBody: Swift.Equatable {
    let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRxNormInferenceJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRxNormInferenceJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRxNormInferenceJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRxNormInferenceJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRxNormInferenceJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRxNormInferenceJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListRxNormInferenceJobsOutputResponse: Swift.Equatable {
    /// The maximum number of results to return in each page. The default is 100.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListRxNormInferenceJobsOutputResponseBody: Swift.Equatable {
    let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    let nextToken: Swift.String?
}

extension ListRxNormInferenceJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSNOMEDCTInferenceJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSNOMEDCTInferenceJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSNOMEDCTInferenceJobsInput: Swift.Equatable {
    /// Provides information for filtering a list of detection jobs.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// The maximum number of results to return in each page. The default is 100.
    public var maxResults: Swift.Int?
    /// Identifies the next page of InferSNOMEDCT results to return.
    public var nextToken: Swift.String?

    public init (
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSNOMEDCTInferenceJobsInputBody: Swift.Equatable {
    let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSNOMEDCTInferenceJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSNOMEDCTInferenceJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSNOMEDCTInferenceJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSNOMEDCTInferenceJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSNOMEDCTInferenceJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSNOMEDCTInferenceJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListSNOMEDCTInferenceJobsOutputResponse: Swift.Equatable {
    /// A list containing the properties of each job that is returned.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListSNOMEDCTInferenceJobsOutputResponseBody: Swift.Equatable {
    let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    let nextToken: Swift.String?
}

extension ListSNOMEDCTInferenceJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ComprehendMedicalClientTypes.OutputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The output properties for a detection job.
    public struct OutputDataConfig: Swift.Equatable {
        /// When you use the OutputDataConfig object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of the output.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The path to the output data files in the S3 bucket. Comprehend Medical; creates an output directory using the job ID so that the output from one job does not overwrite the output of another.
        public var s3Key: Swift.String?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum RelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case administeredVia
        case direction
        case dosage
        case duration
        case every
        case `for`
        case form
        case frequency
        case negative
        case overlap
        case rate
        case routeOrMode
        case strength
        case systemOrganSite
        case testUnit
        case testUnits
        case testValue
        case withDosage
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationshipType] {
            return [
                .acuity,
                .administeredVia,
                .direction,
                .dosage,
                .duration,
                .every,
                .for,
                .form,
                .frequency,
                .negative,
                .overlap,
                .rate,
                .routeOrMode,
                .strength,
                .systemOrganSite,
                .testUnit,
                .testUnits,
                .testValue,
                .withDosage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .administeredVia: return "ADMINISTERED_VIA"
            case .direction: return "DIRECTION"
            case .dosage: return "DOSAGE"
            case .duration: return "DURATION"
            case .every: return "EVERY"
            case .for: return "FOR"
            case .form: return "FORM"
            case .frequency: return "FREQUENCY"
            case .negative: return "NEGATIVE"
            case .overlap: return "OVERLAP"
            case .rate: return "RATE"
            case .routeOrMode: return "ROUTE_OR_MODE"
            case .strength: return "STRENGTH"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .testUnit: return "TEST_UNIT"
            case .testUnits: return "TEST_UNITS"
            case .testValue: return "TEST_VALUE"
            case .withDosage: return "WITH_DOSAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelationshipType(rawValue: rawValue) ?? RelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource identified by the specified Amazon Resource Name (ARN) was not found. Check the ARN and try your request again.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ComprehendMedicalClientTypes.RxNormAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for rxnormtraitlist0 in traits {
                try traitsContainer.encode(rxnormtraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RxNormAttributeType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.RxNormTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.RxNormTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// The extracted attributes that relate to this entity. The attributes recognized by InferRxNorm are DOSAGE, DURATION, FORM, FREQUENCY, RATE, ROUTE_OR_MODE.
    public struct RxNormAttribute: Swift.Equatable {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has that the attribute is accurately linked to an entity.
        public var relationshipScore: Swift.Float?
        /// The level of confidence that Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public var score: Swift.Float?
        /// The segment of input text which corresponds to the detected attribute.
        public var text: Swift.String?
        /// Contextual information for the attribute. InferRxNorm recognizes the trait NEGATION for attributes, i.e. that the patient is not taking a specific dose or form of a medication.
        public var traits: [ComprehendMedicalClientTypes.RxNormTrait]?
        /// The type of attribute. The types of attributes recognized by InferRxNorm are BRAND_NAME and GENERIC_NAME.
        public var type: ComprehendMedicalClientTypes.RxNormAttributeType?

        public init (
            beginOffset: Swift.Int? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            relationshipScore: Swift.Float? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.RxNormTrait]? = nil,
            type: ComprehendMedicalClientTypes.RxNormAttributeType? = nil
        )
        {
            self.beginOffset = beginOffset
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum RxNormAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dosage
        case duration
        case form
        case frequency
        case rate
        case routeOrMode
        case strength
        case sdkUnknown(Swift.String)

        public static var allCases: [RxNormAttributeType] {
            return [
                .dosage,
                .duration,
                .form,
                .frequency,
                .rate,
                .routeOrMode,
                .strength,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dosage: return "DOSAGE"
            case .duration: return "DURATION"
            case .form: return "FORM"
            case .frequency: return "FREQUENCY"
            case .rate: return "RATE"
            case .routeOrMode: return "ROUTE_OR_MODE"
            case .strength: return "STRENGTH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RxNormAttributeType(rawValue: rawValue) ?? RxNormAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.RxNormConcept: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case description = "Description"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The RxNorm concept that the entity could refer to, along with a score indicating the likelihood of the match.
    public struct RxNormConcept: Swift.Equatable {
        /// RxNorm concept ID, also known as the RxCUI.
        public var code: Swift.String?
        /// The description of the RxNorm concept.
        public var description: Swift.String?
        /// The level of confidence that Amazon Comprehend Medical has that the entity is accurately linked to the reported RxNorm concept.
        public var score: Swift.Float?

        public init (
            code: Swift.String? = nil,
            description: Swift.String? = nil,
            score: Swift.Float? = nil
        )
        {
            self.code = code
            self.description = description
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes.RxNormEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case rxNormConcepts = "RxNormConcepts"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for rxnormattributelist0 in attributes {
                try attributesContainer.encode(rxnormattributelist0)
            }
        }
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let rxNormConcepts = rxNormConcepts {
            var rxNormConceptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rxNormConcepts)
            for rxnormconceptlist0 in rxNormConcepts {
                try rxNormConceptsContainer.encode(rxnormconceptlist0)
            }
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for rxnormtraitlist0 in traits {
                try traitsContainer.encode(rxnormtraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RxNormEntityCategory.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RxNormEntityType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ComprehendMedicalClientTypes.RxNormAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ComprehendMedicalClientTypes.RxNormAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.RxNormTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.RxNormTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let rxNormConceptsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormConcept?].self, forKey: .rxNormConcepts)
        var rxNormConceptsDecoded0:[ComprehendMedicalClientTypes.RxNormConcept]? = nil
        if let rxNormConceptsContainer = rxNormConceptsContainer {
            rxNormConceptsDecoded0 = [ComprehendMedicalClientTypes.RxNormConcept]()
            for structure0 in rxNormConceptsContainer {
                if let structure0 = structure0 {
                    rxNormConceptsDecoded0?.append(structure0)
                }
            }
        }
        rxNormConcepts = rxNormConceptsDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
    public struct RxNormEntity: Swift.Equatable {
        /// The extracted attributes that relate to the entity. The attributes recognized by InferRxNorm are DOSAGE, DURATION, FORM, FREQUENCY, RATE, ROUTE_OR_MODE, and STRENGTH.
        public var attributes: [ComprehendMedicalClientTypes.RxNormAttribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the entity. The recognized categories are GENERIC or BRAND_NAME.
        public var category: ComprehendMedicalClientTypes.RxNormEntityCategory?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The RxNorm concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public var rxNormConcepts: [ComprehendMedicalClientTypes.RxNormConcept]?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected entity.
        public var score: Swift.Float?
        /// The segment of input text extracted from which the entity was detected.
        public var text: Swift.String?
        /// Contextual information for the entity.
        public var traits: [ComprehendMedicalClientTypes.RxNormTrait]?
        /// Describes the specific type of entity. For InferRxNorm, the recognized entity type is MEDICATION.
        public var type: ComprehendMedicalClientTypes.RxNormEntityType?

        public init (
            attributes: [ComprehendMedicalClientTypes.RxNormAttribute]? = nil,
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.RxNormEntityCategory? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            rxNormConcepts: [ComprehendMedicalClientTypes.RxNormConcept]? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.RxNormTrait]? = nil,
            type: ComprehendMedicalClientTypes.RxNormEntityType? = nil
        )
        {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.rxNormConcepts = rxNormConcepts
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum RxNormEntityCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case medication
        case sdkUnknown(Swift.String)

        public static var allCases: [RxNormEntityCategory] {
            return [
                .medication,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .medication: return "MEDICATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RxNormEntityCategory(rawValue: rawValue) ?? RxNormEntityCategory.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum RxNormEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case brandName
        case genericName
        case sdkUnknown(Swift.String)

        public static var allCases: [RxNormEntityType] {
            return [
                .brandName,
                .genericName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .brandName: return "BRAND_NAME"
            case .genericName: return "GENERIC_NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RxNormEntityType(rawValue: rawValue) ?? RxNormEntityType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.RxNormTrait: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RxNormTraitName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The contextual information for the entity. InferRxNorm recognizes the trait NEGATION, which is any indication that the patient is not taking a medication.
    public struct RxNormTrait: Swift.Equatable {
        /// Provides a name or contextual description about the trait.
        public var name: ComprehendMedicalClientTypes.RxNormTraitName?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected trait.
        public var score: Swift.Float?

        public init (
            name: ComprehendMedicalClientTypes.RxNormTraitName? = nil,
            score: Swift.Float? = nil
        )
        {
            self.name = name
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum RxNormTraitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case negation
        case sdkUnknown(Swift.String)

        public static var allCases: [RxNormTraitName] {
            return [
                .negation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .negation: return "NEGATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RxNormTraitName(rawValue: rawValue) ?? RxNormTraitName.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.SNOMEDCTAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case relationshipType = "RelationshipType"
        case sNOMEDCTConcepts = "SNOMEDCTConcepts"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let relationshipType = relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
        if let sNOMEDCTConcepts = sNOMEDCTConcepts {
            var sNOMEDCTConceptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sNOMEDCTConcepts)
            for snomedctconceptlist0 in sNOMEDCTConcepts {
                try sNOMEDCTConceptsContainer.encode(snomedctconceptlist0)
            }
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for snomedcttraitlist0 in traits {
                try traitsContainer.encode(snomedcttraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTEntityCategory.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTAttributeType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTRelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.SNOMEDCTTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.SNOMEDCTTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.SNOMEDCTTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let sNOMEDCTConceptsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.SNOMEDCTConcept?].self, forKey: .sNOMEDCTConcepts)
        var sNOMEDCTConceptsDecoded0:[ComprehendMedicalClientTypes.SNOMEDCTConcept]? = nil
        if let sNOMEDCTConceptsContainer = sNOMEDCTConceptsContainer {
            sNOMEDCTConceptsDecoded0 = [ComprehendMedicalClientTypes.SNOMEDCTConcept]()
            for structure0 in sNOMEDCTConceptsContainer {
                if let structure0 = structure0 {
                    sNOMEDCTConceptsDecoded0?.append(structure0)
                }
            }
        }
        sNOMEDCTConcepts = sNOMEDCTConceptsDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// The extracted attributes that relate to an entity. An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the dosage of a medication taken.
    public struct SNOMEDCTAttribute: Swift.Equatable {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the detected attribute. Possible categories include MEDICAL_CONDITION, ANATOMY, and TEST_TREATMENT_PROCEDURE.
        public var category: ComprehendMedicalClientTypes.SNOMEDCTEntityCategory?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Comprehend Medical has that this attribute is correctly related to this entity.
        public var relationshipScore: Swift.Float?
        /// The type of relationship that exists between the entity and the related attribute.
        public var relationshipType: ComprehendMedicalClientTypes.SNOMEDCTRelationshipType?
        /// The SNOMED-CT concepts specific to an attribute, along with a score indicating the likelihood of the match.
        public var sNOMEDCTConcepts: [ComprehendMedicalClientTypes.SNOMEDCTConcept]?
        /// The level of confidence that Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public var score: Swift.Float?
        /// The segment of input text extracted as this attribute.
        public var text: Swift.String?
        /// Contextual information for an attribute. Examples include signs, symptoms, diagnosis, and negation.
        public var traits: [ComprehendMedicalClientTypes.SNOMEDCTTrait]?
        /// The type of attribute. Possible types include DX_NAME, ACUITY, DIRECTION, SYSTEM_ORGAN_SITE,TEST_NAME, TEST_VALUE, TEST_UNIT, PROCEDURE_NAME, and TREATMENT_NAME.
        public var type: ComprehendMedicalClientTypes.SNOMEDCTAttributeType?

        public init (
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.SNOMEDCTEntityCategory? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            relationshipScore: Swift.Float? = nil,
            relationshipType: ComprehendMedicalClientTypes.SNOMEDCTRelationshipType? = nil,
            sNOMEDCTConcepts: [ComprehendMedicalClientTypes.SNOMEDCTConcept]? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.SNOMEDCTTrait]? = nil,
            type: ComprehendMedicalClientTypes.SNOMEDCTAttributeType? = nil
        )
        {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.sNOMEDCTConcepts = sNOMEDCTConcepts
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum SNOMEDCTAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case direction
        case quality
        case systemOrganSite
        case testUnit
        case testValue
        case sdkUnknown(Swift.String)

        public static var allCases: [SNOMEDCTAttributeType] {
            return [
                .acuity,
                .direction,
                .quality,
                .systemOrganSite,
                .testUnit,
                .testValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .direction: return "DIRECTION"
            case .quality: return "QUALITY"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .testUnit: return "TEST_UNIT"
            case .testValue: return "TEST_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SNOMEDCTAttributeType(rawValue: rawValue) ?? SNOMEDCTAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.SNOMEDCTConcept: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case description = "Description"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The SNOMED-CT concepts that the entity could refer to, along with a score indicating the likelihood of the match.
    public struct SNOMEDCTConcept: Swift.Equatable {
        /// The numeric ID for the SNOMED-CT concept.
        public var code: Swift.String?
        /// The description of the SNOMED-CT concept.
        public var description: Swift.String?
        /// The level of confidence Comprehend Medical has that the entity should be linked to the identified SNOMED-CT concept.
        public var score: Swift.Float?

        public init (
            code: Swift.String? = nil,
            description: Swift.String? = nil,
            score: Swift.Float? = nil
        )
        {
            self.code = code
            self.description = description
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes.SNOMEDCTDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edition = "Edition"
        case language = "Language"
        case versionDate = "VersionDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let edition = edition {
            try encodeContainer.encode(edition, forKey: .edition)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let versionDate = versionDate {
            try encodeContainer.encode(versionDate, forKey: .versionDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let editionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edition)
        edition = editionDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let versionDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDate)
        versionDate = versionDateDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The information about the revision of the SNOMED-CT ontology in the response. Specifically, the details include the SNOMED-CT edition, language, and version date.
    public struct SNOMEDCTDetails: Swift.Equatable {
        /// The edition of SNOMED-CT used. The edition used for the InferSNOMEDCT editions is the US edition.
        public var edition: Swift.String?
        /// The language used in the SNOMED-CT ontology. All Amazon Comprehend Medical operations are US English (en).
        public var language: Swift.String?
        /// The version date of the SNOMED-CT ontology used.
        public var versionDate: Swift.String?

        public init (
            edition: Swift.String? = nil,
            language: Swift.String? = nil,
            versionDate: Swift.String? = nil
        )
        {
            self.edition = edition
            self.language = language
            self.versionDate = versionDate
        }
    }

}

extension ComprehendMedicalClientTypes.SNOMEDCTEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case sNOMEDCTConcepts = "SNOMEDCTConcepts"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for snomedctattributelist0 in attributes {
                try attributesContainer.encode(snomedctattributelist0)
            }
        }
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let sNOMEDCTConcepts = sNOMEDCTConcepts {
            var sNOMEDCTConceptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sNOMEDCTConcepts)
            for snomedctconceptlist0 in sNOMEDCTConcepts {
                try sNOMEDCTConceptsContainer.encode(snomedctconceptlist0)
            }
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for snomedcttraitlist0 in traits {
                try traitsContainer.encode(snomedcttraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTEntityCategory.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTEntityType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.SNOMEDCTAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ComprehendMedicalClientTypes.SNOMEDCTAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ComprehendMedicalClientTypes.SNOMEDCTAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.SNOMEDCTTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.SNOMEDCTTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.SNOMEDCTTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let sNOMEDCTConceptsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.SNOMEDCTConcept?].self, forKey: .sNOMEDCTConcepts)
        var sNOMEDCTConceptsDecoded0:[ComprehendMedicalClientTypes.SNOMEDCTConcept]? = nil
        if let sNOMEDCTConceptsContainer = sNOMEDCTConceptsContainer {
            sNOMEDCTConceptsDecoded0 = [ComprehendMedicalClientTypes.SNOMEDCTConcept]()
            for structure0 in sNOMEDCTConceptsContainer {
                if let structure0 = structure0 {
                    sNOMEDCTConceptsDecoded0?.append(structure0)
                }
            }
        }
        sNOMEDCTConcepts = sNOMEDCTConceptsDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
    public struct SNOMEDCTEntity: Swift.Equatable {
        /// An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the dosage of a medication taken.
        public var attributes: [ComprehendMedicalClientTypes.SNOMEDCTAttribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the detected entity. Possible categories are MEDICAL_CONDITION, ANATOMY, or TEST_TREATMENT_PROCEDURE.
        public var category: ComprehendMedicalClientTypes.SNOMEDCTEntityCategory?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The SNOMED concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public var sNOMEDCTConcepts: [ComprehendMedicalClientTypes.SNOMEDCTConcept]?
        /// The level of confidence that Comprehend Medical has in the accuracy of the detected entity.
        public var score: Swift.Float?
        /// The segment of input text extracted as this entity.
        public var text: Swift.String?
        /// Contextual information for the entity.
        public var traits: [ComprehendMedicalClientTypes.SNOMEDCTTrait]?
        /// Describes the specific type of entity with category of entities. Possible types include DX_NAME, ACUITY, DIRECTION, SYSTEM_ORGAN_SITE, TEST_NAME, TEST_VALUE, TEST_UNIT, PROCEDURE_NAME, or TREATMENT_NAME.
        public var type: ComprehendMedicalClientTypes.SNOMEDCTEntityType?

        public init (
            attributes: [ComprehendMedicalClientTypes.SNOMEDCTAttribute]? = nil,
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.SNOMEDCTEntityCategory? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            sNOMEDCTConcepts: [ComprehendMedicalClientTypes.SNOMEDCTConcept]? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.SNOMEDCTTrait]? = nil,
            type: ComprehendMedicalClientTypes.SNOMEDCTEntityType? = nil
        )
        {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.sNOMEDCTConcepts = sNOMEDCTConcepts
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum SNOMEDCTEntityCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anatomy
        case medicalCondition
        case testTreatmentProcedure
        case sdkUnknown(Swift.String)

        public static var allCases: [SNOMEDCTEntityCategory] {
            return [
                .anatomy,
                .medicalCondition,
                .testTreatmentProcedure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anatomy: return "ANATOMY"
            case .medicalCondition: return "MEDICAL_CONDITION"
            case .testTreatmentProcedure: return "TEST_TREATMENT_PROCEDURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SNOMEDCTEntityCategory(rawValue: rawValue) ?? SNOMEDCTEntityCategory.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum SNOMEDCTEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dxName
        case procedureName
        case testName
        case treatmentName
        case sdkUnknown(Swift.String)

        public static var allCases: [SNOMEDCTEntityType] {
            return [
                .dxName,
                .procedureName,
                .testName,
                .treatmentName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dxName: return "DX_NAME"
            case .procedureName: return "PROCEDURE_NAME"
            case .testName: return "TEST_NAME"
            case .treatmentName: return "TREATMENT_NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SNOMEDCTEntityType(rawValue: rawValue) ?? SNOMEDCTEntityType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum SNOMEDCTRelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case direction
        case quality
        case systemOrganSite
        case testUnits
        case testValue
        case sdkUnknown(Swift.String)

        public static var allCases: [SNOMEDCTRelationshipType] {
            return [
                .acuity,
                .direction,
                .quality,
                .systemOrganSite,
                .testUnits,
                .testValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .direction: return "DIRECTION"
            case .quality: return "QUALITY"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .testUnits: return "TEST_UNITS"
            case .testValue: return "TEST_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SNOMEDCTRelationshipType(rawValue: rawValue) ?? SNOMEDCTRelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.SNOMEDCTTrait: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTTraitName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// Contextual information for an entity.
    public struct SNOMEDCTTrait: Swift.Equatable {
        /// The name or contextual description of a detected trait.
        public var name: ComprehendMedicalClientTypes.SNOMEDCTTraitName?
        /// The level of confidence that Comprehend Medical has in the accuracy of a detected trait.
        public var score: Swift.Float?

        public init (
            name: ComprehendMedicalClientTypes.SNOMEDCTTraitName? = nil,
            score: Swift.Float? = nil
        )
        {
            self.name = name
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum SNOMEDCTTraitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case diagnosis
        case negation
        case sign
        case symptom
        case sdkUnknown(Swift.String)

        public static var allCases: [SNOMEDCTTraitName] {
            return [
                .diagnosis,
                .negation,
                .sign,
                .symptom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .diagnosis: return "DIAGNOSIS"
            case .negation: return "NEGATION"
            case .sign: return "SIGN"
            case .symptom: return "SYMPTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SNOMEDCTTraitName(rawValue: rawValue) ?? SNOMEDCTTraitName.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Comprehend Medical; service is temporarily unavailable. Please wait and then retry your request.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartEntitiesDetectionV2JobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartEntitiesDetectionV2JobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartEntitiesDetectionV2JobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Comprehend Medical; generates one for you.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Comprehend Medical; read access to your input data. For more information, see [ Role-Based Permissions Required for Asynchronous Operations](https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The input configuration that specifies the format and location of the input data for the job.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The identifier of the job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kMSKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language. Comprehend Medical; processes files in US English (en).
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// The output configuration that specifies where to send the output files.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kMSKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartEntitiesDetectionV2JobInputBody: Swift.Equatable {
    let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    let dataAccessRoleArn: Swift.String?
    let jobName: Swift.String?
    let clientRequestToken: Swift.String?
    let kMSKey: Swift.String?
    let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartEntitiesDetectionV2JobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartEntitiesDetectionV2JobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartEntitiesDetectionV2JobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartEntitiesDetectionV2JobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartEntitiesDetectionV2JobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartEntitiesDetectionV2JobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartEntitiesDetectionV2JobOutputResponse: Swift.Equatable {
    /// The identifier generated for the job. To get the status of a job, use this identifier with the DescribeEntitiesDetectionV2Job operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartEntitiesDetectionV2JobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartEntitiesDetectionV2JobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StartICD10CMInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartICD10CMInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartICD10CMInferenceJobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Comprehend Medical; generates one.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Comprehend Medical; read access to your input data. For more information, see [ Role-Based Permissions Required for Asynchronous Operations](https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// Specifies the format and location of the input data for the job.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The identifier of the job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kMSKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language.
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// Specifies where to send the output files.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kMSKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartICD10CMInferenceJobInputBody: Swift.Equatable {
    let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    let dataAccessRoleArn: Swift.String?
    let jobName: Swift.String?
    let clientRequestToken: Swift.String?
    let kMSKey: Swift.String?
    let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartICD10CMInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartICD10CMInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartICD10CMInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartICD10CMInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartICD10CMInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartICD10CMInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartICD10CMInferenceJobOutputResponse: Swift.Equatable {
    /// The identifier generated for the job. To get the status of a job, use this identifier with the StartICD10CMInferenceJob operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartICD10CMInferenceJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartICD10CMInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StartPHIDetectionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartPHIDetectionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartPHIDetectionJobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Comprehend Medical; generates one.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Comprehend Medical; read access to your input data. For more information, see [ Role-Based Permissions Required for Asynchronous Operations](https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// Specifies the format and location of the input data for the job.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The identifier of the job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kMSKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language.
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// Specifies where to send the output files.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kMSKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartPHIDetectionJobInputBody: Swift.Equatable {
    let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    let dataAccessRoleArn: Swift.String?
    let jobName: Swift.String?
    let clientRequestToken: Swift.String?
    let kMSKey: Swift.String?
    let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartPHIDetectionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartPHIDetectionJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartPHIDetectionJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartPHIDetectionJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartPHIDetectionJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartPHIDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartPHIDetectionJobOutputResponse: Swift.Equatable {
    /// The identifier generated for the job. To get the status of a job, use this identifier with the DescribePHIDetectionJob operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartPHIDetectionJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartPHIDetectionJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StartRxNormInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartRxNormInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartRxNormInferenceJobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Comprehend Medical; generates one.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Comprehend Medical; read access to your input data. For more information, see [ Role-Based Permissions Required for Asynchronous Operations](https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// Specifies the format and location of the input data for the job.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The identifier of the job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kMSKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language.
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// Specifies where to send the output files.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kMSKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartRxNormInferenceJobInputBody: Swift.Equatable {
    let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    let dataAccessRoleArn: Swift.String?
    let jobName: Swift.String?
    let clientRequestToken: Swift.String?
    let kMSKey: Swift.String?
    let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartRxNormInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartRxNormInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRxNormInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartRxNormInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRxNormInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartRxNormInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartRxNormInferenceJobOutputResponse: Swift.Equatable {
    /// The identifier of the job.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartRxNormInferenceJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartRxNormInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StartSNOMEDCTInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartSNOMEDCTInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSNOMEDCTInferenceJobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The input properties for an entities detection job. This includes the name of the S3 bucket and the path to the files to be analyzed.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The user generated name the asynchronous InferSNOMEDCT job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key used to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kMSKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language.
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// The output properties for a detection job.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kMSKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartSNOMEDCTInferenceJobInputBody: Swift.Equatable {
    let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    let dataAccessRoleArn: Swift.String?
    let jobName: Swift.String?
    let clientRequestToken: Swift.String?
    let kMSKey: Swift.String?
    let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartSNOMEDCTInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartSNOMEDCTInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSNOMEDCTInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSNOMEDCTInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSNOMEDCTInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSNOMEDCTInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartSNOMEDCTInferenceJobOutputResponse: Swift.Equatable {
    /// The identifier generated for the job. To get the status of a job, use this identifier with the StartSNOMEDCTInferenceJob operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartSNOMEDCTInferenceJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartSNOMEDCTInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopEntitiesDetectionV2JobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension StopEntitiesDetectionV2JobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopEntitiesDetectionV2JobInput: Swift.Equatable {
    /// The identifier of the medical entities job to stop.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopEntitiesDetectionV2JobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopEntitiesDetectionV2JobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopEntitiesDetectionV2JobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopEntitiesDetectionV2JobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopEntitiesDetectionV2JobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopEntitiesDetectionV2JobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopEntitiesDetectionV2JobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopEntitiesDetectionV2JobOutputResponse: Swift.Equatable {
    /// The identifier of the medical entities detection job that was stopped.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopEntitiesDetectionV2JobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopEntitiesDetectionV2JobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopICD10CMInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension StopICD10CMInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopICD10CMInferenceJobInput: Swift.Equatable {
    /// The identifier of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopICD10CMInferenceJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopICD10CMInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopICD10CMInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopICD10CMInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopICD10CMInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopICD10CMInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopICD10CMInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopICD10CMInferenceJobOutputResponse: Swift.Equatable {
    /// The identifier generated for the job. To get the status of job, use this identifier with the DescribeICD10CMInferenceJob operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopICD10CMInferenceJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopICD10CMInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopPHIDetectionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension StopPHIDetectionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopPHIDetectionJobInput: Swift.Equatable {
    /// The identifier of the PHI detection job to stop.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopPHIDetectionJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopPHIDetectionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopPHIDetectionJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopPHIDetectionJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopPHIDetectionJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopPHIDetectionJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopPHIDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopPHIDetectionJobOutputResponse: Swift.Equatable {
    /// The identifier of the PHI detection job that was stopped.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopPHIDetectionJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopPHIDetectionJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopRxNormInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension StopRxNormInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopRxNormInferenceJobInput: Swift.Equatable {
    /// The identifier of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopRxNormInferenceJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopRxNormInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopRxNormInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopRxNormInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopRxNormInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopRxNormInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopRxNormInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopRxNormInferenceJobOutputResponse: Swift.Equatable {
    /// The identifier generated for the job. To get the status of job, use this identifier with the DescribeRxNormInferenceJob operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopRxNormInferenceJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopRxNormInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopSNOMEDCTInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension StopSNOMEDCTInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopSNOMEDCTInferenceJobInput: Swift.Equatable {
    /// The job id of the asynchronous InferSNOMEDCT job to be stopped.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopSNOMEDCTInferenceJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopSNOMEDCTInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopSNOMEDCTInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopSNOMEDCTInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopSNOMEDCTInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopSNOMEDCTInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopSNOMEDCTInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopSNOMEDCTInferenceJobOutputResponse: Swift.Equatable {
    /// The identifier generated for the job. To get the status of job, use this identifier with the DescribeSNOMEDCTInferenceJob operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopSNOMEDCTInferenceJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopSNOMEDCTInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension TextSizeLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TextSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The size of the text you submitted exceeds the size limit. Reduce the size of the text or use a smaller document and then retry your request.
public struct TextSizeLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TextSizeLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TextSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have made too many requests within a short period of time. Wait for a short time and then try your request again. Contact customer support for more information about a service limit increase.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ComprehendMedicalClientTypes.Trait: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.AttributeName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// Provides contextual information about the extracted entity.
    public struct Trait: Swift.Equatable {
        /// Provides a name or contextual description about the trait.
        public var name: ComprehendMedicalClientTypes.AttributeName?
        /// The level of confidence that Comprehend Medical; has in the accuracy of this trait.
        public var score: Swift.Float?

        public init (
            name: ComprehendMedicalClientTypes.AttributeName? = nil,
            score: Swift.Float? = nil
        )
        {
            self.name = name
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes.UnmappedAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute = "Attribute"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntityType.self, forKey: .type)
        type = typeDecoded
        let attributeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.Attribute.self, forKey: .attribute)
        attribute = attributeDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// An attribute that was extracted, but Comprehend Medical; was unable to relate to an entity.
    public struct UnmappedAttribute: Swift.Equatable {
        /// The specific attribute that has been extracted but not mapped to an entity.
        public var attribute: ComprehendMedicalClientTypes.Attribute?
        /// The type of the unmapped attribute, could be one of the following values: "MEDICATION", "MEDICAL_CONDITION", "ANATOMY", "TEST_AND_TREATMENT_PROCEDURE" or "PROTECTED_HEALTH_INFORMATION".
        public var type: ComprehendMedicalClientTypes.EntityType?

        public init (
            attribute: ComprehendMedicalClientTypes.Attribute? = nil,
            type: ComprehendMedicalClientTypes.EntityType? = nil
        )
        {
            self.attribute = attribute
            self.type = type
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The filter that you specified for the operation is invalid. Check the filter values that you entered and try your request again.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
