// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListAssignmentsForHITOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAssignmentsForHITInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAssignmentsForHITOutputResponse`
extension MTurkClient {
    public func listAssignmentsForHITPaginated(input: ListAssignmentsForHITInput) -> ClientRuntime.PaginatorSequence<ListAssignmentsForHITInput, ListAssignmentsForHITOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAssignmentsForHITInput, ListAssignmentsForHITOutputResponse>(input: input, inputKey: \ListAssignmentsForHITInput.nextToken, outputKey: \ListAssignmentsForHITOutputResponse.nextToken, paginationFunction: self.listAssignmentsForHIT(input:))
    }
}

extension ListAssignmentsForHITInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssignmentsForHITInput {
        return ListAssignmentsForHITInput(
            assignmentStatuses: self.assignmentStatuses,
            hITId: self.hITId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListBonusPaymentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBonusPaymentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBonusPaymentsOutputResponse`
extension MTurkClient {
    public func listBonusPaymentsPaginated(input: ListBonusPaymentsInput) -> ClientRuntime.PaginatorSequence<ListBonusPaymentsInput, ListBonusPaymentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBonusPaymentsInput, ListBonusPaymentsOutputResponse>(input: input, inputKey: \ListBonusPaymentsInput.nextToken, outputKey: \ListBonusPaymentsOutputResponse.nextToken, paginationFunction: self.listBonusPayments(input:))
    }
}

extension ListBonusPaymentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBonusPaymentsInput {
        return ListBonusPaymentsInput(
            assignmentId: self.assignmentId,
            hITId: self.hITId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListHITsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListHITsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListHITsOutputResponse`
extension MTurkClient {
    public func listHITsPaginated(input: ListHITsInput) -> ClientRuntime.PaginatorSequence<ListHITsInput, ListHITsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListHITsInput, ListHITsOutputResponse>(input: input, inputKey: \ListHITsInput.nextToken, outputKey: \ListHITsOutputResponse.nextToken, paginationFunction: self.listHITs(input:))
    }
}

extension ListHITsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHITsInput {
        return ListHITsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListHITsForQualificationTypeOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListHITsForQualificationTypeInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListHITsForQualificationTypeOutputResponse`
extension MTurkClient {
    public func listHITsForQualificationTypePaginated(input: ListHITsForQualificationTypeInput) -> ClientRuntime.PaginatorSequence<ListHITsForQualificationTypeInput, ListHITsForQualificationTypeOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListHITsForQualificationTypeInput, ListHITsForQualificationTypeOutputResponse>(input: input, inputKey: \ListHITsForQualificationTypeInput.nextToken, outputKey: \ListHITsForQualificationTypeOutputResponse.nextToken, paginationFunction: self.listHITsForQualificationType(input:))
    }
}

extension ListHITsForQualificationTypeInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHITsForQualificationTypeInput {
        return ListHITsForQualificationTypeInput(
            maxResults: self.maxResults,
            nextToken: token,
            qualificationTypeId: self.qualificationTypeId
        )}
}

/// Paginate over `[ListQualificationRequestsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListQualificationRequestsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListQualificationRequestsOutputResponse`
extension MTurkClient {
    public func listQualificationRequestsPaginated(input: ListQualificationRequestsInput) -> ClientRuntime.PaginatorSequence<ListQualificationRequestsInput, ListQualificationRequestsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListQualificationRequestsInput, ListQualificationRequestsOutputResponse>(input: input, inputKey: \ListQualificationRequestsInput.nextToken, outputKey: \ListQualificationRequestsOutputResponse.nextToken, paginationFunction: self.listQualificationRequests(input:))
    }
}

extension ListQualificationRequestsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQualificationRequestsInput {
        return ListQualificationRequestsInput(
            maxResults: self.maxResults,
            nextToken: token,
            qualificationTypeId: self.qualificationTypeId
        )}
}

/// Paginate over `[ListQualificationTypesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListQualificationTypesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListQualificationTypesOutputResponse`
extension MTurkClient {
    public func listQualificationTypesPaginated(input: ListQualificationTypesInput) -> ClientRuntime.PaginatorSequence<ListQualificationTypesInput, ListQualificationTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListQualificationTypesInput, ListQualificationTypesOutputResponse>(input: input, inputKey: \ListQualificationTypesInput.nextToken, outputKey: \ListQualificationTypesOutputResponse.nextToken, paginationFunction: self.listQualificationTypes(input:))
    }
}

extension ListQualificationTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQualificationTypesInput {
        return ListQualificationTypesInput(
            maxResults: self.maxResults,
            mustBeOwnedByCaller: self.mustBeOwnedByCaller,
            mustBeRequestable: self.mustBeRequestable,
            nextToken: token,
            query: self.query
        )}
}

/// Paginate over `[ListReviewableHITsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListReviewableHITsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListReviewableHITsOutputResponse`
extension MTurkClient {
    public func listReviewableHITsPaginated(input: ListReviewableHITsInput) -> ClientRuntime.PaginatorSequence<ListReviewableHITsInput, ListReviewableHITsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListReviewableHITsInput, ListReviewableHITsOutputResponse>(input: input, inputKey: \ListReviewableHITsInput.nextToken, outputKey: \ListReviewableHITsOutputResponse.nextToken, paginationFunction: self.listReviewableHITs(input:))
    }
}

extension ListReviewableHITsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReviewableHITsInput {
        return ListReviewableHITsInput(
            hITTypeId: self.hITTypeId,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )}
}

/// Paginate over `[ListReviewPolicyResultsForHITOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListReviewPolicyResultsForHITInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListReviewPolicyResultsForHITOutputResponse`
extension MTurkClient {
    public func listReviewPolicyResultsForHITPaginated(input: ListReviewPolicyResultsForHITInput) -> ClientRuntime.PaginatorSequence<ListReviewPolicyResultsForHITInput, ListReviewPolicyResultsForHITOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListReviewPolicyResultsForHITInput, ListReviewPolicyResultsForHITOutputResponse>(input: input, inputKey: \ListReviewPolicyResultsForHITInput.nextToken, outputKey: \ListReviewPolicyResultsForHITOutputResponse.nextToken, paginationFunction: self.listReviewPolicyResultsForHIT(input:))
    }
}

extension ListReviewPolicyResultsForHITInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReviewPolicyResultsForHITInput {
        return ListReviewPolicyResultsForHITInput(
            hITId: self.hITId,
            maxResults: self.maxResults,
            nextToken: token,
            policyLevels: self.policyLevels,
            retrieveActions: self.retrieveActions,
            retrieveResults: self.retrieveResults
        )}
}

/// Paginate over `[ListWorkerBlocksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListWorkerBlocksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListWorkerBlocksOutputResponse`
extension MTurkClient {
    public func listWorkerBlocksPaginated(input: ListWorkerBlocksInput) -> ClientRuntime.PaginatorSequence<ListWorkerBlocksInput, ListWorkerBlocksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListWorkerBlocksInput, ListWorkerBlocksOutputResponse>(input: input, inputKey: \ListWorkerBlocksInput.nextToken, outputKey: \ListWorkerBlocksOutputResponse.nextToken, paginationFunction: self.listWorkerBlocks(input:))
    }
}

extension ListWorkerBlocksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkerBlocksInput {
        return ListWorkerBlocksInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListWorkersWithQualificationTypeOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListWorkersWithQualificationTypeInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListWorkersWithQualificationTypeOutputResponse`
extension MTurkClient {
    public func listWorkersWithQualificationTypePaginated(input: ListWorkersWithQualificationTypeInput) -> ClientRuntime.PaginatorSequence<ListWorkersWithQualificationTypeInput, ListWorkersWithQualificationTypeOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListWorkersWithQualificationTypeInput, ListWorkersWithQualificationTypeOutputResponse>(input: input, inputKey: \ListWorkersWithQualificationTypeInput.nextToken, outputKey: \ListWorkersWithQualificationTypeOutputResponse.nextToken, paginationFunction: self.listWorkersWithQualificationType(input:))
    }
}

extension ListWorkersWithQualificationTypeInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkersWithQualificationTypeInput {
        return ListWorkersWithQualificationTypeInput(
            maxResults: self.maxResults,
            nextToken: token,
            qualificationTypeId: self.qualificationTypeId,
            status: self.status
        )}
}
