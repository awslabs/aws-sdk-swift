// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Decision: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cancelTimerDecisionAttributes
        case cancelWorkflowExecutionDecisionAttributes
        case completeWorkflowExecutionDecisionAttributes
        case continueAsNewWorkflowExecutionDecisionAttributes
        case decisionType
        case failWorkflowExecutionDecisionAttributes
        case recordMarkerDecisionAttributes
        case requestCancelActivityTaskDecisionAttributes
        case requestCancelExternalWorkflowExecutionDecisionAttributes
        case scheduleActivityTaskDecisionAttributes
        case scheduleLambdaFunctionDecisionAttributes
        case signalExternalWorkflowExecutionDecisionAttributes
        case startChildWorkflowExecutionDecisionAttributes
        case startTimerDecisionAttributes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cancelTimerDecisionAttributes = cancelTimerDecisionAttributes {
            try encodeContainer.encode(cancelTimerDecisionAttributes, forKey: .cancelTimerDecisionAttributes)
        }
        if let cancelWorkflowExecutionDecisionAttributes = cancelWorkflowExecutionDecisionAttributes {
            try encodeContainer.encode(cancelWorkflowExecutionDecisionAttributes, forKey: .cancelWorkflowExecutionDecisionAttributes)
        }
        if let completeWorkflowExecutionDecisionAttributes = completeWorkflowExecutionDecisionAttributes {
            try encodeContainer.encode(completeWorkflowExecutionDecisionAttributes, forKey: .completeWorkflowExecutionDecisionAttributes)
        }
        if let continueAsNewWorkflowExecutionDecisionAttributes = continueAsNewWorkflowExecutionDecisionAttributes {
            try encodeContainer.encode(continueAsNewWorkflowExecutionDecisionAttributes, forKey: .continueAsNewWorkflowExecutionDecisionAttributes)
        }
        if let decisionType = decisionType {
            try encodeContainer.encode(decisionType.rawValue, forKey: .decisionType)
        }
        if let failWorkflowExecutionDecisionAttributes = failWorkflowExecutionDecisionAttributes {
            try encodeContainer.encode(failWorkflowExecutionDecisionAttributes, forKey: .failWorkflowExecutionDecisionAttributes)
        }
        if let recordMarkerDecisionAttributes = recordMarkerDecisionAttributes {
            try encodeContainer.encode(recordMarkerDecisionAttributes, forKey: .recordMarkerDecisionAttributes)
        }
        if let requestCancelActivityTaskDecisionAttributes = requestCancelActivityTaskDecisionAttributes {
            try encodeContainer.encode(requestCancelActivityTaskDecisionAttributes, forKey: .requestCancelActivityTaskDecisionAttributes)
        }
        if let requestCancelExternalWorkflowExecutionDecisionAttributes = requestCancelExternalWorkflowExecutionDecisionAttributes {
            try encodeContainer.encode(requestCancelExternalWorkflowExecutionDecisionAttributes, forKey: .requestCancelExternalWorkflowExecutionDecisionAttributes)
        }
        if let scheduleActivityTaskDecisionAttributes = scheduleActivityTaskDecisionAttributes {
            try encodeContainer.encode(scheduleActivityTaskDecisionAttributes, forKey: .scheduleActivityTaskDecisionAttributes)
        }
        if let scheduleLambdaFunctionDecisionAttributes = scheduleLambdaFunctionDecisionAttributes {
            try encodeContainer.encode(scheduleLambdaFunctionDecisionAttributes, forKey: .scheduleLambdaFunctionDecisionAttributes)
        }
        if let signalExternalWorkflowExecutionDecisionAttributes = signalExternalWorkflowExecutionDecisionAttributes {
            try encodeContainer.encode(signalExternalWorkflowExecutionDecisionAttributes, forKey: .signalExternalWorkflowExecutionDecisionAttributes)
        }
        if let startChildWorkflowExecutionDecisionAttributes = startChildWorkflowExecutionDecisionAttributes {
            try encodeContainer.encode(startChildWorkflowExecutionDecisionAttributes, forKey: .startChildWorkflowExecutionDecisionAttributes)
        }
        if let startTimerDecisionAttributes = startTimerDecisionAttributes {
            try encodeContainer.encode(startTimerDecisionAttributes, forKey: .startTimerDecisionAttributes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decisionTypeDecoded = try containerValues.decodeIfPresent(DecisionType.self, forKey: .decisionType)
        decisionType = decisionTypeDecoded
        let scheduleActivityTaskDecisionAttributesDecoded = try containerValues.decodeIfPresent(ScheduleActivityTaskDecisionAttributes.self, forKey: .scheduleActivityTaskDecisionAttributes)
        scheduleActivityTaskDecisionAttributes = scheduleActivityTaskDecisionAttributesDecoded
        let requestCancelActivityTaskDecisionAttributesDecoded = try containerValues.decodeIfPresent(RequestCancelActivityTaskDecisionAttributes.self, forKey: .requestCancelActivityTaskDecisionAttributes)
        requestCancelActivityTaskDecisionAttributes = requestCancelActivityTaskDecisionAttributesDecoded
        let completeWorkflowExecutionDecisionAttributesDecoded = try containerValues.decodeIfPresent(CompleteWorkflowExecutionDecisionAttributes.self, forKey: .completeWorkflowExecutionDecisionAttributes)
        completeWorkflowExecutionDecisionAttributes = completeWorkflowExecutionDecisionAttributesDecoded
        let failWorkflowExecutionDecisionAttributesDecoded = try containerValues.decodeIfPresent(FailWorkflowExecutionDecisionAttributes.self, forKey: .failWorkflowExecutionDecisionAttributes)
        failWorkflowExecutionDecisionAttributes = failWorkflowExecutionDecisionAttributesDecoded
        let cancelWorkflowExecutionDecisionAttributesDecoded = try containerValues.decodeIfPresent(CancelWorkflowExecutionDecisionAttributes.self, forKey: .cancelWorkflowExecutionDecisionAttributes)
        cancelWorkflowExecutionDecisionAttributes = cancelWorkflowExecutionDecisionAttributesDecoded
        let continueAsNewWorkflowExecutionDecisionAttributesDecoded = try containerValues.decodeIfPresent(ContinueAsNewWorkflowExecutionDecisionAttributes.self, forKey: .continueAsNewWorkflowExecutionDecisionAttributes)
        continueAsNewWorkflowExecutionDecisionAttributes = continueAsNewWorkflowExecutionDecisionAttributesDecoded
        let recordMarkerDecisionAttributesDecoded = try containerValues.decodeIfPresent(RecordMarkerDecisionAttributes.self, forKey: .recordMarkerDecisionAttributes)
        recordMarkerDecisionAttributes = recordMarkerDecisionAttributesDecoded
        let startTimerDecisionAttributesDecoded = try containerValues.decodeIfPresent(StartTimerDecisionAttributes.self, forKey: .startTimerDecisionAttributes)
        startTimerDecisionAttributes = startTimerDecisionAttributesDecoded
        let cancelTimerDecisionAttributesDecoded = try containerValues.decodeIfPresent(CancelTimerDecisionAttributes.self, forKey: .cancelTimerDecisionAttributes)
        cancelTimerDecisionAttributes = cancelTimerDecisionAttributesDecoded
        let signalExternalWorkflowExecutionDecisionAttributesDecoded = try containerValues.decodeIfPresent(SignalExternalWorkflowExecutionDecisionAttributes.self, forKey: .signalExternalWorkflowExecutionDecisionAttributes)
        signalExternalWorkflowExecutionDecisionAttributes = signalExternalWorkflowExecutionDecisionAttributesDecoded
        let requestCancelExternalWorkflowExecutionDecisionAttributesDecoded = try containerValues.decodeIfPresent(RequestCancelExternalWorkflowExecutionDecisionAttributes.self, forKey: .requestCancelExternalWorkflowExecutionDecisionAttributes)
        requestCancelExternalWorkflowExecutionDecisionAttributes = requestCancelExternalWorkflowExecutionDecisionAttributesDecoded
        let startChildWorkflowExecutionDecisionAttributesDecoded = try containerValues.decodeIfPresent(StartChildWorkflowExecutionDecisionAttributes.self, forKey: .startChildWorkflowExecutionDecisionAttributes)
        startChildWorkflowExecutionDecisionAttributes = startChildWorkflowExecutionDecisionAttributesDecoded
        let scheduleLambdaFunctionDecisionAttributesDecoded = try containerValues.decodeIfPresent(ScheduleLambdaFunctionDecisionAttributes.self, forKey: .scheduleLambdaFunctionDecisionAttributes)
        scheduleLambdaFunctionDecisionAttributes = scheduleLambdaFunctionDecisionAttributesDecoded
    }
}
