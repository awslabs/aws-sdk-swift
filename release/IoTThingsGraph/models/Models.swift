// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssociateEntityToThingInputBodyMiddleware: Middleware {
    public let id: String = "AssociateEntityToThingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateEntityToThingInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateEntityToThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateEntityToThingInput>
    public typealias MOutput = OperationOutput<AssociateEntityToThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateEntityToThingOutputError>
}

extension AssociateEntityToThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateEntityToThingInput(entityId: \(String(describing: entityId)), namespaceVersion: \(String(describing: namespaceVersion)), thingName: \(String(describing: thingName)))"}
}

extension AssociateEntityToThingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityId
        case namespaceVersion
        case thingName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let namespaceVersion = namespaceVersion {
            try encodeContainer.encode(namespaceVersion, forKey: .namespaceVersion)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

public struct AssociateEntityToThingInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateEntityToThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateEntityToThingInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateEntityToThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateEntityToThingInput>
    public typealias MOutput = OperationOutput<AssociateEntityToThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateEntityToThingOutputError>
}

public struct AssociateEntityToThingInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateEntityToThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateEntityToThingInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateEntityToThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateEntityToThingInput>
    public typealias MOutput = OperationOutput<AssociateEntityToThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateEntityToThingOutputError>
}

public struct AssociateEntityToThingInput: Equatable {
    /// <p>The ID of the device to be associated with the thing.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME</code>
    ///          </p>
    public let entityId: String?
    /// <p>The version of the user's namespace. Defaults to the latest version of the user's namespace.</p>
    public let namespaceVersion: Int?
    /// <p>The name of the thing to which the entity is to be associated.</p>
    public let thingName: String?

    public init (
        entityId: String? = nil,
        namespaceVersion: Int? = nil,
        thingName: String? = nil
    )
    {
        self.entityId = entityId
        self.namespaceVersion = namespaceVersion
        self.thingName = thingName
    }
}

struct AssociateEntityToThingInputBody: Equatable {
    public let thingName: String?
    public let entityId: String?
    public let namespaceVersion: Int?
}

extension AssociateEntityToThingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityId
        case namespaceVersion
        case thingName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension AssociateEntityToThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateEntityToThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateEntityToThingOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateEntityToThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateEntityToThingOutputResponse()"}
}

extension AssociateEntityToThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateEntityToThingOutputResponse: Equatable {

    public init() {}
}

struct AssociateEntityToThingOutputResponseBody: Equatable {
}

extension AssociateEntityToThingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateFlowTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateFlowTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFlowTemplateInput>
    public typealias MOutput = OperationOutput<CreateFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFlowTemplateOutputError>
}

extension CreateFlowTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFlowTemplateInput(compatibleNamespaceVersion: \(String(describing: compatibleNamespaceVersion)), definition: \(String(describing: definition)))"}
}

extension CreateFlowTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compatibleNamespaceVersion
        case definition
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleNamespaceVersion = compatibleNamespaceVersion {
            try encodeContainer.encode(compatibleNamespaceVersion, forKey: .compatibleNamespaceVersion)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
    }
}

public struct CreateFlowTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFlowTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFlowTemplateInput>
    public typealias MOutput = OperationOutput<CreateFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFlowTemplateOutputError>
}

public struct CreateFlowTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFlowTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFlowTemplateInput>
    public typealias MOutput = OperationOutput<CreateFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFlowTemplateOutputError>
}

public struct CreateFlowTemplateInput: Equatable {
    /// <p>The namespace version in which the workflow is to be created.</p>
    ///          <p>If no value is specified, the latest version is used by default.</p>
    public let compatibleNamespaceVersion: Int?
    /// <p>The workflow <code>DefinitionDocument</code>.</p>
    public let definition: DefinitionDocument?

    public init (
        compatibleNamespaceVersion: Int? = nil,
        definition: DefinitionDocument? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
    }
}

struct CreateFlowTemplateInputBody: Equatable {
    public let definition: DefinitionDocument?
    public let compatibleNamespaceVersion: Int?
}

extension CreateFlowTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibleNamespaceVersion
        case definition
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let compatibleNamespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .compatibleNamespaceVersion)
        compatibleNamespaceVersion = compatibleNamespaceVersionDecoded
    }
}

extension CreateFlowTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFlowTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFlowTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFlowTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFlowTemplateOutputResponse(summary: \(String(describing: summary)))"}
}

extension CreateFlowTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFlowTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateFlowTemplateOutputResponse: Equatable {
    /// <p>The summary object that describes the created workflow.</p>
    public let summary: FlowTemplateSummary?

    public init (
        summary: FlowTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateFlowTemplateOutputResponseBody: Equatable {
    public let summary: FlowTemplateSummary?
}

extension CreateFlowTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case summary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(FlowTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

public struct CreateSystemInstanceInputBodyMiddleware: Middleware {
    public let id: String = "CreateSystemInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSystemInstanceInput>
    public typealias MOutput = OperationOutput<CreateSystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSystemInstanceOutputError>
}

extension CreateSystemInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSystemInstanceInput(definition: \(String(describing: definition)), flowActionsRoleArn: \(String(describing: flowActionsRoleArn)), greengrassGroupName: \(String(describing: greengrassGroupName)), metricsConfiguration: \(String(describing: metricsConfiguration)), s3BucketName: \(String(describing: s3BucketName)), tags: \(String(describing: tags)), target: \(String(describing: target)))"}
}

extension CreateSystemInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definition
        case flowActionsRoleArn
        case greengrassGroupName
        case metricsConfiguration
        case s3BucketName
        case tags
        case target
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let flowActionsRoleArn = flowActionsRoleArn {
            try encodeContainer.encode(flowActionsRoleArn, forKey: .flowActionsRoleArn)
        }
        if let greengrassGroupName = greengrassGroupName {
            try encodeContainer.encode(greengrassGroupName, forKey: .greengrassGroupName)
        }
        if let metricsConfiguration = metricsConfiguration {
            try encodeContainer.encode(metricsConfiguration, forKey: .metricsConfiguration)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let target = target {
            try encodeContainer.encode(target.rawValue, forKey: .target)
        }
    }
}

public struct CreateSystemInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSystemInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSystemInstanceInput>
    public typealias MOutput = OperationOutput<CreateSystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSystemInstanceOutputError>
}

public struct CreateSystemInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSystemInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSystemInstanceInput>
    public typealias MOutput = OperationOutput<CreateSystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSystemInstanceOutputError>
}

public struct CreateSystemInstanceInput: Equatable {
    /// <p>A document that defines an entity. </p>
    public let definition: DefinitionDocument?
    /// <p>The ARN of the IAM role that AWS IoT Things Graph will assume when it executes the flow. This role must have
    ///       read and write access to AWS Lambda and AWS IoT and any other AWS services that the flow uses when it executes.  This
    ///       value is required if the value of the <code>target</code> parameter is <code>CLOUD</code>.</p>
    public let flowActionsRoleArn: String?
    /// <p>The name of the Greengrass group where the system instance will be deployed. This value is required if
    ///       the value of the <code>target</code> parameter is <code>GREENGRASS</code>.</p>
    public let greengrassGroupName: String?
    /// <p>An object that specifies whether cloud metrics are collected in a deployment and, if so, what role is used to collect metrics.</p>
    public let metricsConfiguration: MetricsConfiguration?
    /// <p>The name of the Amazon Simple Storage Service bucket that will be used to store and deploy the system instance's resource file. This value is required if
    ///          the value of the <code>target</code> parameter is <code>GREENGRASS</code>.</p>
    public let s3BucketName: String?
    /// <p>Metadata, consisting of key-value pairs, that can be used to categorize your system instances.</p>
    public let tags: [Tag]?
    /// <p>The target type of the deployment. Valid values are <code>GREENGRASS</code> and <code>CLOUD</code>.</p>
    public let target: DeploymentTarget?

    public init (
        definition: DefinitionDocument? = nil,
        flowActionsRoleArn: String? = nil,
        greengrassGroupName: String? = nil,
        metricsConfiguration: MetricsConfiguration? = nil,
        s3BucketName: String? = nil,
        tags: [Tag]? = nil,
        target: DeploymentTarget? = nil
    )
    {
        self.definition = definition
        self.flowActionsRoleArn = flowActionsRoleArn
        self.greengrassGroupName = greengrassGroupName
        self.metricsConfiguration = metricsConfiguration
        self.s3BucketName = s3BucketName
        self.tags = tags
        self.target = target
    }
}

struct CreateSystemInstanceInputBody: Equatable {
    public let tags: [Tag]?
    public let definition: DefinitionDocument?
    public let target: DeploymentTarget?
    public let greengrassGroupName: String?
    public let s3BucketName: String?
    public let metricsConfiguration: MetricsConfiguration?
    public let flowActionsRoleArn: String?
}

extension CreateSystemInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definition
        case flowActionsRoleArn
        case greengrassGroupName
        case metricsConfiguration
        case s3BucketName
        case tags
        case target
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let definitionDecoded = try containerValues.decodeIfPresent(DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(DeploymentTarget.self, forKey: .target)
        target = targetDecoded
        let greengrassGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .greengrassGroupName)
        greengrassGroupName = greengrassGroupNameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let metricsConfigurationDecoded = try containerValues.decodeIfPresent(MetricsConfiguration.self, forKey: .metricsConfiguration)
        metricsConfiguration = metricsConfigurationDecoded
        let flowActionsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowActionsRoleArn)
        flowActionsRoleArn = flowActionsRoleArnDecoded
    }
}

extension CreateSystemInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSystemInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSystemInstanceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSystemInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSystemInstanceOutputResponse(summary: \(String(describing: summary)))"}
}

extension CreateSystemInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSystemInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateSystemInstanceOutputResponse: Equatable {
    /// <p>The summary object that describes the new system instance.</p>
    public let summary: SystemInstanceSummary?

    public init (
        summary: SystemInstanceSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateSystemInstanceOutputResponseBody: Equatable {
    public let summary: SystemInstanceSummary?
}

extension CreateSystemInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case summary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(SystemInstanceSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

public struct CreateSystemTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateSystemTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSystemTemplateInput>
    public typealias MOutput = OperationOutput<CreateSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSystemTemplateOutputError>
}

extension CreateSystemTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSystemTemplateInput(compatibleNamespaceVersion: \(String(describing: compatibleNamespaceVersion)), definition: \(String(describing: definition)))"}
}

extension CreateSystemTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compatibleNamespaceVersion
        case definition
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleNamespaceVersion = compatibleNamespaceVersion {
            try encodeContainer.encode(compatibleNamespaceVersion, forKey: .compatibleNamespaceVersion)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
    }
}

public struct CreateSystemTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSystemTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSystemTemplateInput>
    public typealias MOutput = OperationOutput<CreateSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSystemTemplateOutputError>
}

public struct CreateSystemTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSystemTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSystemTemplateInput>
    public typealias MOutput = OperationOutput<CreateSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSystemTemplateOutputError>
}

public struct CreateSystemTemplateInput: Equatable {
    /// <p>The namespace version in which the system is to be created.</p>
    ///          <p>If no value is specified, the latest version is used by default.</p>
    public let compatibleNamespaceVersion: Int?
    /// <p>The <code>DefinitionDocument</code> used to create the system.</p>
    public let definition: DefinitionDocument?

    public init (
        compatibleNamespaceVersion: Int? = nil,
        definition: DefinitionDocument? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
    }
}

struct CreateSystemTemplateInputBody: Equatable {
    public let definition: DefinitionDocument?
    public let compatibleNamespaceVersion: Int?
}

extension CreateSystemTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibleNamespaceVersion
        case definition
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let compatibleNamespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .compatibleNamespaceVersion)
        compatibleNamespaceVersion = compatibleNamespaceVersionDecoded
    }
}

extension CreateSystemTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSystemTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSystemTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSystemTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSystemTemplateOutputResponse(summary: \(String(describing: summary)))"}
}

extension CreateSystemTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSystemTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateSystemTemplateOutputResponse: Equatable {
    /// <p>The summary object that describes the created system.</p>
    public let summary: SystemTemplateSummary?

    public init (
        summary: SystemTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateSystemTemplateOutputResponseBody: Equatable {
    public let summary: SystemTemplateSummary?
}

extension CreateSystemTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case summary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(SystemTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension DefinitionDocument: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case language
        case text
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageDecoded = try containerValues.decodeIfPresent(DefinitionLanguage.self, forKey: .language)
        language = languageDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
    }
}

extension DefinitionDocument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefinitionDocument(language: \(String(describing: language)), text: \(String(describing: text)))"}
}

/// <p>A document that defines an entity. </p>
public struct DefinitionDocument: Equatable {
    /// <p>The language used to define the entity. <code>GRAPHQL</code> is the only valid value.</p>
    public let language: DefinitionLanguage?
    /// <p>The GraphQL text that defines the entity.</p>
    public let text: String?

    public init (
        language: DefinitionLanguage? = nil,
        text: String? = nil
    )
    {
        self.language = language
        self.text = text
    }
}

public enum DefinitionLanguage {
    case graphql
    case sdkUnknown(String)
}

extension DefinitionLanguage : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DefinitionLanguage] {
        return [
            .graphql,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .graphql: return "GRAPHQL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DefinitionLanguage(rawValue: rawValue) ?? DefinitionLanguage.sdkUnknown(rawValue)
    }
}

public struct DeleteFlowTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFlowTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFlowTemplateInput>
    public typealias MOutput = OperationOutput<DeleteFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFlowTemplateOutputError>
}

extension DeleteFlowTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFlowTemplateInput(id: \(String(describing: id)))"}
}

extension DeleteFlowTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteFlowTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFlowTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFlowTemplateInput>
    public typealias MOutput = OperationOutput<DeleteFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFlowTemplateOutputError>
}

public struct DeleteFlowTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFlowTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFlowTemplateInput>
    public typealias MOutput = OperationOutput<DeleteFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFlowTemplateOutputError>
}

public struct DeleteFlowTemplateInput: Equatable {
    /// <p>The ID of the workflow to be deleted.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME</code>
    ///          </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteFlowTemplateInputBody: Equatable {
    public let id: String?
}

extension DeleteFlowTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteFlowTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFlowTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFlowTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFlowTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFlowTemplateOutputResponse()"}
}

extension DeleteFlowTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFlowTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteFlowTemplateOutputResponseBody: Equatable {
}

extension DeleteFlowTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteNamespaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNamespaceInput()"}
}

extension DeleteNamespaceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteNamespaceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNamespaceOutputError>
}

public struct DeleteNamespaceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNamespaceOutputError>
}

public struct DeleteNamespaceInput: Equatable {

    public init() {}
}

struct DeleteNamespaceInputBody: Equatable {
}

extension DeleteNamespaceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteNamespaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNamespaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNamespaceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNamespaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNamespaceOutputResponse(namespaceArn: \(String(describing: namespaceArn)), namespaceName: \(String(describing: namespaceName)))"}
}

extension DeleteNamespaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.namespaceArn = output.namespaceArn
            self.namespaceName = output.namespaceName
        } else {
            self.namespaceArn = nil
            self.namespaceName = nil
        }
    }
}

public struct DeleteNamespaceOutputResponse: Equatable {
    /// <p>The ARN of the namespace to be deleted.</p>
    public let namespaceArn: String?
    /// <p>The name of the namespace to be deleted.</p>
    public let namespaceName: String?

    public init (
        namespaceArn: String? = nil,
        namespaceName: String? = nil
    )
    {
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
    }
}

struct DeleteNamespaceOutputResponseBody: Equatable {
    public let namespaceArn: String?
    public let namespaceName: String?
}

extension DeleteNamespaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namespaceArn
        case namespaceName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
    }
}

public struct DeleteSystemInstanceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSystemInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSystemInstanceInput>
    public typealias MOutput = OperationOutput<DeleteSystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSystemInstanceOutputError>
}

extension DeleteSystemInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSystemInstanceInput(id: \(String(describing: id)))"}
}

extension DeleteSystemInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteSystemInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSystemInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSystemInstanceInput>
    public typealias MOutput = OperationOutput<DeleteSystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSystemInstanceOutputError>
}

public struct DeleteSystemInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSystemInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSystemInstanceInput>
    public typealias MOutput = OperationOutput<DeleteSystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSystemInstanceOutputError>
}

public struct DeleteSystemInstanceInput: Equatable {
    /// <p>The ID of the system instance to be deleted.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteSystemInstanceInputBody: Equatable {
    public let id: String?
}

extension DeleteSystemInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteSystemInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSystemInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSystemInstanceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSystemInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSystemInstanceOutputResponse()"}
}

extension DeleteSystemInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSystemInstanceOutputResponse: Equatable {

    public init() {}
}

struct DeleteSystemInstanceOutputResponseBody: Equatable {
}

extension DeleteSystemInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSystemTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSystemTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSystemTemplateInput>
    public typealias MOutput = OperationOutput<DeleteSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSystemTemplateOutputError>
}

extension DeleteSystemTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSystemTemplateInput(id: \(String(describing: id)))"}
}

extension DeleteSystemTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteSystemTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSystemTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSystemTemplateInput>
    public typealias MOutput = OperationOutput<DeleteSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSystemTemplateOutputError>
}

public struct DeleteSystemTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSystemTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSystemTemplateInput>
    public typealias MOutput = OperationOutput<DeleteSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSystemTemplateOutputError>
}

public struct DeleteSystemTemplateInput: Equatable {
    /// <p>The ID of the system to be deleted.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME</code>
    ///          </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteSystemTemplateInputBody: Equatable {
    public let id: String?
}

extension DeleteSystemTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteSystemTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSystemTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSystemTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSystemTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSystemTemplateOutputResponse()"}
}

extension DeleteSystemTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSystemTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteSystemTemplateOutputResponseBody: Equatable {
}

extension DeleteSystemTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DependencyRevision: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case revisionNumber
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
    }
}

extension DependencyRevision: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DependencyRevision(id: \(String(describing: id)), revisionNumber: \(String(describing: revisionNumber)))"}
}

/// <p>An object that contains the ID and revision number of a workflow or system that is part of a deployment.</p>
public struct DependencyRevision: Equatable {
    /// <p>The ID of the workflow or system.</p>
    public let id: String?
    /// <p>The revision number of the workflow or system.</p>
    public let revisionNumber: Int?

    public init (
        id: String? = nil,
        revisionNumber: Int? = nil
    )
    {
        self.id = id
        self.revisionNumber = revisionNumber
    }
}

public struct DeploySystemInstanceInputBodyMiddleware: Middleware {
    public let id: String = "DeploySystemInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeploySystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeploySystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeploySystemInstanceInput>
    public typealias MOutput = OperationOutput<DeploySystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeploySystemInstanceOutputError>
}

extension DeploySystemInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploySystemInstanceInput(id: \(String(describing: id)))"}
}

extension DeploySystemInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeploySystemInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DeploySystemInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeploySystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeploySystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeploySystemInstanceInput>
    public typealias MOutput = OperationOutput<DeploySystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeploySystemInstanceOutputError>
}

public struct DeploySystemInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeploySystemInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeploySystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeploySystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeploySystemInstanceInput>
    public typealias MOutput = OperationOutput<DeploySystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeploySystemInstanceOutputError>
}

public struct DeploySystemInstanceInput: Equatable {
    /// <p>The ID of the system instance. This value is returned by the <code>CreateSystemInstance</code> action.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:deployment:DEPLOYMENTNAME</code>
    ///          </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeploySystemInstanceInputBody: Equatable {
    public let id: String?
}

extension DeploySystemInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeploySystemInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeploySystemInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeploySystemInstanceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeploySystemInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploySystemInstanceOutputResponse(greengrassDeploymentId: \(String(describing: greengrassDeploymentId)), summary: \(String(describing: summary)))"}
}

extension DeploySystemInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeploySystemInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.greengrassDeploymentId = output.greengrassDeploymentId
            self.summary = output.summary
        } else {
            self.greengrassDeploymentId = nil
            self.summary = nil
        }
    }
}

public struct DeploySystemInstanceOutputResponse: Equatable {
    /// <p>The ID of the Greengrass deployment used to deploy the system instance.</p>
    public let greengrassDeploymentId: String?
    /// <p>An object that contains summary information about a system instance that was deployed. </p>
    public let summary: SystemInstanceSummary?

    public init (
        greengrassDeploymentId: String? = nil,
        summary: SystemInstanceSummary? = nil
    )
    {
        self.greengrassDeploymentId = greengrassDeploymentId
        self.summary = summary
    }
}

struct DeploySystemInstanceOutputResponseBody: Equatable {
    public let summary: SystemInstanceSummary?
    public let greengrassDeploymentId: String?
}

extension DeploySystemInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case greengrassDeploymentId
        case summary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(SystemInstanceSummary.self, forKey: .summary)
        summary = summaryDecoded
        let greengrassDeploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .greengrassDeploymentId)
        greengrassDeploymentId = greengrassDeploymentIdDecoded
    }
}

public enum DeploymentTarget {
    case cloud
    case greengrass
    case sdkUnknown(String)
}

extension DeploymentTarget : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentTarget] {
        return [
            .cloud,
            .greengrass,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloud: return "CLOUD"
        case .greengrass: return "GREENGRASS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentTarget(rawValue: rawValue) ?? DeploymentTarget.sdkUnknown(rawValue)
    }
}

public struct DeprecateFlowTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DeprecateFlowTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeprecateFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeprecateFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeprecateFlowTemplateInput>
    public typealias MOutput = OperationOutput<DeprecateFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeprecateFlowTemplateOutputError>
}

extension DeprecateFlowTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeprecateFlowTemplateInput(id: \(String(describing: id)))"}
}

extension DeprecateFlowTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeprecateFlowTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeprecateFlowTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeprecateFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeprecateFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeprecateFlowTemplateInput>
    public typealias MOutput = OperationOutput<DeprecateFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeprecateFlowTemplateOutputError>
}

public struct DeprecateFlowTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeprecateFlowTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeprecateFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeprecateFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeprecateFlowTemplateInput>
    public typealias MOutput = OperationOutput<DeprecateFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeprecateFlowTemplateOutputError>
}

public struct DeprecateFlowTemplateInput: Equatable {
    /// <p>The ID of the workflow to be deleted.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME</code>
    ///          </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeprecateFlowTemplateInputBody: Equatable {
    public let id: String?
}

extension DeprecateFlowTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeprecateFlowTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeprecateFlowTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeprecateFlowTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeprecateFlowTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeprecateFlowTemplateOutputResponse()"}
}

extension DeprecateFlowTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeprecateFlowTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeprecateFlowTemplateOutputResponseBody: Equatable {
}

extension DeprecateFlowTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeprecateSystemTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DeprecateSystemTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeprecateSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeprecateSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeprecateSystemTemplateInput>
    public typealias MOutput = OperationOutput<DeprecateSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeprecateSystemTemplateOutputError>
}

extension DeprecateSystemTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeprecateSystemTemplateInput(id: \(String(describing: id)))"}
}

extension DeprecateSystemTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeprecateSystemTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeprecateSystemTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeprecateSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeprecateSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeprecateSystemTemplateInput>
    public typealias MOutput = OperationOutput<DeprecateSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeprecateSystemTemplateOutputError>
}

public struct DeprecateSystemTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeprecateSystemTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeprecateSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeprecateSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeprecateSystemTemplateInput>
    public typealias MOutput = OperationOutput<DeprecateSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeprecateSystemTemplateOutputError>
}

public struct DeprecateSystemTemplateInput: Equatable {
    /// <p>The ID of the system to delete.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME</code>
    ///          </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeprecateSystemTemplateInputBody: Equatable {
    public let id: String?
}

extension DeprecateSystemTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeprecateSystemTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeprecateSystemTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeprecateSystemTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeprecateSystemTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeprecateSystemTemplateOutputResponse()"}
}

extension DeprecateSystemTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeprecateSystemTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeprecateSystemTemplateOutputResponseBody: Equatable {
}

extension DeprecateSystemTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeNamespaceInputBodyMiddleware: Middleware {
    public let id: String = "DescribeNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNamespaceInput>
    public typealias MOutput = OperationOutput<DescribeNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNamespaceOutputError>
}

extension DescribeNamespaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNamespaceInput(namespaceName: \(String(describing: namespaceName)))"}
}

extension DescribeNamespaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case namespaceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
    }
}

public struct DescribeNamespaceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNamespaceInput>
    public typealias MOutput = OperationOutput<DescribeNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNamespaceOutputError>
}

public struct DescribeNamespaceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNamespaceInput>
    public typealias MOutput = OperationOutput<DescribeNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNamespaceOutputError>
}

public struct DescribeNamespaceInput: Equatable {
    /// <p>The name of the user's namespace. Set this to <code>aws</code> to get the public namespace.</p>
    public let namespaceName: String?

    public init (
        namespaceName: String? = nil
    )
    {
        self.namespaceName = namespaceName
    }
}

struct DescribeNamespaceInputBody: Equatable {
    public let namespaceName: String?
}

extension DescribeNamespaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namespaceName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
    }
}

extension DescribeNamespaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNamespaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNamespaceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNamespaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNamespaceOutputResponse(namespaceArn: \(String(describing: namespaceArn)), namespaceName: \(String(describing: namespaceName)), namespaceVersion: \(String(describing: namespaceVersion)), trackingNamespaceName: \(String(describing: trackingNamespaceName)), trackingNamespaceVersion: \(String(describing: trackingNamespaceVersion)))"}
}

extension DescribeNamespaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.namespaceArn = output.namespaceArn
            self.namespaceName = output.namespaceName
            self.namespaceVersion = output.namespaceVersion
            self.trackingNamespaceName = output.trackingNamespaceName
            self.trackingNamespaceVersion = output.trackingNamespaceVersion
        } else {
            self.namespaceArn = nil
            self.namespaceName = nil
            self.namespaceVersion = nil
            self.trackingNamespaceName = nil
            self.trackingNamespaceVersion = nil
        }
    }
}

public struct DescribeNamespaceOutputResponse: Equatable {
    /// <p>The ARN of the namespace.</p>
    public let namespaceArn: String?
    /// <p>The name of the namespace.</p>
    public let namespaceName: String?
    /// <p>The version of the user's namespace to describe.</p>
    public let namespaceVersion: Int?
    /// <p>The name of the public namespace that the latest namespace version is tracking.</p>
    public let trackingNamespaceName: String?
    /// <p>The version of the public namespace that the latest version is tracking.</p>
    public let trackingNamespaceVersion: Int?

    public init (
        namespaceArn: String? = nil,
        namespaceName: String? = nil,
        namespaceVersion: Int? = nil,
        trackingNamespaceName: String? = nil,
        trackingNamespaceVersion: Int? = nil
    )
    {
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.namespaceVersion = namespaceVersion
        self.trackingNamespaceName = trackingNamespaceName
        self.trackingNamespaceVersion = trackingNamespaceVersion
    }
}

struct DescribeNamespaceOutputResponseBody: Equatable {
    public let namespaceArn: String?
    public let namespaceName: String?
    public let trackingNamespaceName: String?
    public let trackingNamespaceVersion: Int?
    public let namespaceVersion: Int?
}

extension DescribeNamespaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namespaceArn
        case namespaceName
        case namespaceVersion
        case trackingNamespaceName
        case trackingNamespaceVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let trackingNamespaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trackingNamespaceName)
        trackingNamespaceName = trackingNamespaceNameDecoded
        let trackingNamespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .trackingNamespaceVersion)
        trackingNamespaceVersion = trackingNamespaceVersionDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

public struct DissociateEntityFromThingInputBodyMiddleware: Middleware {
    public let id: String = "DissociateEntityFromThingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DissociateEntityFromThingInput>,
                  next: H) -> Swift.Result<OperationOutput<DissociateEntityFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DissociateEntityFromThingInput>
    public typealias MOutput = OperationOutput<DissociateEntityFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DissociateEntityFromThingOutputError>
}

extension DissociateEntityFromThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DissociateEntityFromThingInput(entityType: \(String(describing: entityType)), thingName: \(String(describing: thingName)))"}
}

extension DissociateEntityFromThingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityType
        case thingName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityType = entityType {
            try encodeContainer.encode(entityType.rawValue, forKey: .entityType)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

public struct DissociateEntityFromThingInputHeadersMiddleware: Middleware {
    public let id: String = "DissociateEntityFromThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DissociateEntityFromThingInput>,
                  next: H) -> Swift.Result<OperationOutput<DissociateEntityFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DissociateEntityFromThingInput>
    public typealias MOutput = OperationOutput<DissociateEntityFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DissociateEntityFromThingOutputError>
}

public struct DissociateEntityFromThingInputQueryItemMiddleware: Middleware {
    public let id: String = "DissociateEntityFromThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DissociateEntityFromThingInput>,
                  next: H) -> Swift.Result<OperationOutput<DissociateEntityFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DissociateEntityFromThingInput>
    public typealias MOutput = OperationOutput<DissociateEntityFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DissociateEntityFromThingOutputError>
}

public struct DissociateEntityFromThingInput: Equatable {
    /// <p>The entity type from which to disassociate the thing.</p>
    public let entityType: EntityType?
    /// <p>The name of the thing to disassociate.</p>
    public let thingName: String?

    public init (
        entityType: EntityType? = nil,
        thingName: String? = nil
    )
    {
        self.entityType = entityType
        self.thingName = thingName
    }
}

struct DissociateEntityFromThingInputBody: Equatable {
    public let thingName: String?
    public let entityType: EntityType?
}

extension DissociateEntityFromThingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityType
        case thingName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(EntityType.self, forKey: .entityType)
        entityType = entityTypeDecoded
    }
}

extension DissociateEntityFromThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DissociateEntityFromThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DissociateEntityFromThingOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DissociateEntityFromThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DissociateEntityFromThingOutputResponse()"}
}

extension DissociateEntityFromThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DissociateEntityFromThingOutputResponse: Equatable {

    public init() {}
}

struct DissociateEntityFromThingOutputResponseBody: Equatable {
}

extension DissociateEntityFromThingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EntityDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case definition
        case id
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EntityType.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension EntityDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityDescription(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), definition: \(String(describing: definition)), id: \(String(describing: id)), type: \(String(describing: type)))"}
}

/// <p>Describes the properties of an entity.</p>
public struct EntityDescription: Equatable {
    /// <p>The entity ARN.</p>
    public let arn: String?
    /// <p>The time at which the entity was created.</p>
    public let createdAt: Date?
    /// <p>The definition document of the entity.</p>
    public let definition: DefinitionDocument?
    /// <p>The entity ID.</p>
    public let id: String?
    /// <p>The entity type.</p>
    public let type: EntityType?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        definition: DefinitionDocument? = nil,
        id: String? = nil,
        type: EntityType? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.definition = definition
        self.id = id
        self.type = type
    }
}

extension EntityFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for entityfiltervalues0 in value {
                try valueContainer.encode(entityfiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(EntityFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([String?].self, forKey: .value)
        var valueDecoded0:[String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension EntityFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityFilter(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>An object that filters an entity search. Multiple filters function as OR criteria in the search. For example a search that includes
///       a <code>NAMESPACE</code> and a <code>REFERENCED_ENTITY_ID</code> filter searches for entities in the specified namespace that use the entity specified by
///       the value of <code>REFERENCED_ENTITY_ID</code>.</p>
public struct EntityFilter: Equatable {
    /// <p>The name of the entity search filter field. <code>REFERENCED_ENTITY_ID</code> filters on entities that are used by the entity in the result set. For example,
    ///          you can filter on the ID of a property that is used in a state.</p>
    public let name: EntityFilterName?
    /// <p>An array of string values for the search filter field. Multiple values function as AND criteria in the search.</p>
    public let value: [String]?

    public init (
        name: EntityFilterName? = nil,
        value: [String]? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum EntityFilterName {
    case name
    case namespace
    case referencedEntityId
    case semanticTypePath
    case sdkUnknown(String)
}

extension EntityFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntityFilterName] {
        return [
            .name,
            .namespace,
            .referencedEntityId,
            .semanticTypePath,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .name: return "NAME"
        case .namespace: return "NAMESPACE"
        case .referencedEntityId: return "REFERENCED_ENTITY_ID"
        case .semanticTypePath: return "SEMANTIC_TYPE_PATH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntityFilterName(rawValue: rawValue) ?? EntityFilterName.sdkUnknown(rawValue)
    }
}

public enum EntityType {
    case action
    case capability
    case device
    case deviceModel
    case `enum`
    case event
    case mapping
    case property
    case service
    case state
    case sdkUnknown(String)
}

extension EntityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntityType] {
        return [
            .action,
            .capability,
            .device,
            .deviceModel,
            .enum,
            .event,
            .mapping,
            .property,
            .service,
            .state,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .action: return "ACTION"
        case .capability: return "CAPABILITY"
        case .device: return "DEVICE"
        case .deviceModel: return "DEVICE_MODEL"
        case .enum: return "ENUM"
        case .event: return "EVENT"
        case .mapping: return "MAPPING"
        case .property: return "PROPERTY"
        case .service: return "SERVICE"
        case .state: return "STATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
    }
}

public enum FlowExecutionEventType {
    case acknowledgeTaskMessage
    case activityFailed
    case activityScheduled
    case activityStarted
    case activitySucceeded
    case executionAborted
    case executionFailed
    case executionStarted
    case executionSucceeded
    case scheduleNextReadyStepsTask
    case startFlowExecutionTask
    case stepFailed
    case stepStarted
    case stepSucceeded
    case thingActionTask
    case thingActionTaskFailed
    case thingActionTaskSucceeded
    case sdkUnknown(String)
}

extension FlowExecutionEventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FlowExecutionEventType] {
        return [
            .acknowledgeTaskMessage,
            .activityFailed,
            .activityScheduled,
            .activityStarted,
            .activitySucceeded,
            .executionAborted,
            .executionFailed,
            .executionStarted,
            .executionSucceeded,
            .scheduleNextReadyStepsTask,
            .startFlowExecutionTask,
            .stepFailed,
            .stepStarted,
            .stepSucceeded,
            .thingActionTask,
            .thingActionTaskFailed,
            .thingActionTaskSucceeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .acknowledgeTaskMessage: return "ACKNOWLEDGE_TASK_MESSAGE"
        case .activityFailed: return "ACTIVITY_FAILED"
        case .activityScheduled: return "ACTIVITY_SCHEDULED"
        case .activityStarted: return "ACTIVITY_STARTED"
        case .activitySucceeded: return "ACTIVITY_SUCCEEDED"
        case .executionAborted: return "EXECUTION_ABORTED"
        case .executionFailed: return "EXECUTION_FAILED"
        case .executionStarted: return "EXECUTION_STARTED"
        case .executionSucceeded: return "EXECUTION_SUCCEEDED"
        case .scheduleNextReadyStepsTask: return "SCHEDULE_NEXT_READY_STEPS_TASK"
        case .startFlowExecutionTask: return "START_FLOW_EXECUTION_TASK"
        case .stepFailed: return "STEP_FAILED"
        case .stepStarted: return "STEP_STARTED"
        case .stepSucceeded: return "STEP_SUCCEEDED"
        case .thingActionTask: return "THING_ACTION_TASK"
        case .thingActionTaskFailed: return "THING_ACTION_TASK_FAILED"
        case .thingActionTaskSucceeded: return "THING_ACTION_TASK_SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FlowExecutionEventType(rawValue: rawValue) ?? FlowExecutionEventType.sdkUnknown(rawValue)
    }
}

extension FlowExecutionMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventType
        case messageId
        case payload
        case timestamp
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(FlowExecutionEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(String.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension FlowExecutionMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlowExecutionMessage(eventType: \(String(describing: eventType)), messageId: \(String(describing: messageId)), payload: \(String(describing: payload)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>An object that contains information about a flow event.</p>
public struct FlowExecutionMessage: Equatable {
    /// <p>The type of flow event .</p>
    public let eventType: FlowExecutionEventType?
    /// <p>The unique identifier of the message.</p>
    public let messageId: String?
    /// <p>A string containing information about the flow event.</p>
    public let payload: String?
    /// <p>The date and time when the message was last updated.</p>
    public let timestamp: Date?

    public init (
        eventType: FlowExecutionEventType? = nil,
        messageId: String? = nil,
        payload: String? = nil,
        timestamp: Date? = nil
    )
    {
        self.eventType = eventType
        self.messageId = messageId
        self.payload = payload
        self.timestamp = timestamp
    }
}

public enum FlowExecutionStatus {
    case aborted
    case failed
    case running
    case succeeded
    case sdkUnknown(String)
}

extension FlowExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FlowExecutionStatus] {
        return [
            .aborted,
            .failed,
            .running,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aborted: return "ABORTED"
        case .failed: return "FAILED"
        case .running: return "RUNNING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FlowExecutionStatus(rawValue: rawValue) ?? FlowExecutionStatus.sdkUnknown(rawValue)
    }
}

extension FlowExecutionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case flowExecutionId
        case flowTemplateId
        case status
        case systemInstanceId
        case updatedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let flowExecutionId = flowExecutionId {
            try encodeContainer.encode(flowExecutionId, forKey: .flowExecutionId)
        }
        if let flowTemplateId = flowTemplateId {
            try encodeContainer.encode(flowTemplateId, forKey: .flowTemplateId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let systemInstanceId = systemInstanceId {
            try encodeContainer.encode(systemInstanceId, forKey: .systemInstanceId)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowExecutionId)
        flowExecutionId = flowExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FlowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let systemInstanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .systemInstanceId)
        systemInstanceId = systemInstanceIdDecoded
        let flowTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowTemplateId)
        flowTemplateId = flowTemplateIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension FlowExecutionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlowExecutionSummary(createdAt: \(String(describing: createdAt)), flowExecutionId: \(String(describing: flowExecutionId)), flowTemplateId: \(String(describing: flowTemplateId)), status: \(String(describing: status)), systemInstanceId: \(String(describing: systemInstanceId)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>An object that contains summary information about a flow execution.</p>
public struct FlowExecutionSummary: Equatable {
    /// <p>The date and time when the flow execution summary was created.</p>
    public let createdAt: Date?
    /// <p>The ID of the flow execution.</p>
    public let flowExecutionId: String?
    /// <p>The ID of the flow.</p>
    public let flowTemplateId: String?
    /// <p>The current status of the flow execution.</p>
    public let status: FlowExecutionStatus?
    /// <p>The ID of the system instance that contains the flow.</p>
    public let systemInstanceId: String?
    /// <p>The date and time when the flow execution summary was last updated.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        flowExecutionId: String? = nil,
        flowTemplateId: String? = nil,
        status: FlowExecutionStatus? = nil,
        systemInstanceId: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.flowExecutionId = flowExecutionId
        self.flowTemplateId = flowTemplateId
        self.status = status
        self.systemInstanceId = systemInstanceId
        self.updatedAt = updatedAt
    }
}

extension FlowTemplateDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definition
        case summary
        case validatedNamespaceVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let validatedNamespaceVersion = validatedNamespaceVersion {
            try encodeContainer.encode(validatedNamespaceVersion, forKey: .validatedNamespaceVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(FlowTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let validatedNamespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .validatedNamespaceVersion)
        validatedNamespaceVersion = validatedNamespaceVersionDecoded
    }
}

extension FlowTemplateDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlowTemplateDescription(definition: \(String(describing: definition)), summary: \(String(describing: summary)), validatedNamespaceVersion: \(String(describing: validatedNamespaceVersion)))"}
}

/// <p>An object that contains a workflow's definition and summary information.</p>
public struct FlowTemplateDescription: Equatable {
    /// <p>A workflow's definition document.</p>
    public let definition: DefinitionDocument?
    /// <p>An object that contains summary information about a workflow.</p>
    public let summary: FlowTemplateSummary?
    /// <p>The version of the user's namespace against which the workflow was validated. Use this value in your system instance.</p>
    public let validatedNamespaceVersion: Int?

    public init (
        definition: DefinitionDocument? = nil,
        summary: FlowTemplateSummary? = nil,
        validatedNamespaceVersion: Int? = nil
    )
    {
        self.definition = definition
        self.summary = summary
        self.validatedNamespaceVersion = validatedNamespaceVersion
    }
}

extension FlowTemplateFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for flowtemplatefiltervalues0 in value {
                try valueContainer.encode(flowtemplatefiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(FlowTemplateFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([String?].self, forKey: .value)
        var valueDecoded0:[String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension FlowTemplateFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlowTemplateFilter(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>An object that filters a workflow search.</p>
public struct FlowTemplateFilter: Equatable {
    /// <p>The name of the search filter field.</p>
    public let name: FlowTemplateFilterName?
    /// <p>An array of string values for the search filter field. Multiple values function as AND criteria in the search.</p>
    public let value: [String]?

    public init (
        name: FlowTemplateFilterName? = nil,
        value: [String]? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum FlowTemplateFilterName {
    case deviceModelId
    case sdkUnknown(String)
}

extension FlowTemplateFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FlowTemplateFilterName] {
        return [
            .deviceModelId,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deviceModelId: return "DEVICE_MODEL_ID"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FlowTemplateFilterName(rawValue: rawValue) ?? FlowTemplateFilterName.sdkUnknown(rawValue)
    }
}

extension FlowTemplateSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case id
        case revisionNumber
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension FlowTemplateSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlowTemplateSummary(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), id: \(String(describing: id)), revisionNumber: \(String(describing: revisionNumber)))"}
}

/// <p>An object that contains summary information about a workflow.</p>
public struct FlowTemplateSummary: Equatable {
    /// <p>The ARN of the workflow.</p>
    public let arn: String?
    /// <p>The date when the workflow was created.</p>
    public let createdAt: Date?
    /// <p>The ID of the workflow.</p>
    public let id: String?
    /// <p>The revision number of the workflow.</p>
    public let revisionNumber: Int?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        id: String? = nil,
        revisionNumber: Int? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.revisionNumber = revisionNumber
    }
}

public struct GetEntitiesInputBodyMiddleware: Middleware {
    public let id: String = "GetEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEntitiesInput>
    public typealias MOutput = OperationOutput<GetEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEntitiesOutputError>
}

extension GetEntitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEntitiesInput(ids: \(String(describing: ids)), namespaceVersion: \(String(describing: namespaceVersion)))"}
}

extension GetEntitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ids
        case namespaceVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for urns0 in ids {
                try idsContainer.encode(urns0)
            }
        }
        if let namespaceVersion = namespaceVersion {
            try encodeContainer.encode(namespaceVersion, forKey: .namespaceVersion)
        }
    }
}

public struct GetEntitiesInputHeadersMiddleware: Middleware {
    public let id: String = "GetEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEntitiesInput>
    public typealias MOutput = OperationOutput<GetEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEntitiesOutputError>
}

public struct GetEntitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEntitiesInput>
    public typealias MOutput = OperationOutput<GetEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEntitiesOutputError>
}

public struct GetEntitiesInput: Equatable {
    /// <p>An array of entity IDs.</p>
    ///          <p>The IDs should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME</code>
    ///          </p>
    public let ids: [String]?
    /// <p>The version of the user's namespace. Defaults to the latest version of the user's namespace.</p>
    public let namespaceVersion: Int?

    public init (
        ids: [String]? = nil,
        namespaceVersion: Int? = nil
    )
    {
        self.ids = ids
        self.namespaceVersion = namespaceVersion
    }
}

struct GetEntitiesInputBody: Equatable {
    public let ids: [String]?
    public let namespaceVersion: Int?
}

extension GetEntitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ids
        case namespaceVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension GetEntitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEntitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEntitiesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEntitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEntitiesOutputResponse(descriptions: \(String(describing: descriptions)))"}
}

extension GetEntitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.descriptions = output.descriptions
        } else {
            self.descriptions = nil
        }
    }
}

public struct GetEntitiesOutputResponse: Equatable {
    /// <p>An array of descriptions for the specified entities.</p>
    public let descriptions: [EntityDescription]?

    public init (
        descriptions: [EntityDescription]? = nil
    )
    {
        self.descriptions = descriptions
    }
}

struct GetEntitiesOutputResponseBody: Equatable {
    public let descriptions: [EntityDescription]?
}

extension GetEntitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case descriptions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionsContainer = try containerValues.decodeIfPresent([EntityDescription?].self, forKey: .descriptions)
        var descriptionsDecoded0:[EntityDescription]? = nil
        if let descriptionsContainer = descriptionsContainer {
            descriptionsDecoded0 = [EntityDescription]()
            for structure0 in descriptionsContainer {
                if let structure0 = structure0 {
                    descriptionsDecoded0?.append(structure0)
                }
            }
        }
        descriptions = descriptionsDecoded0
    }
}

public struct GetFlowTemplateInputBodyMiddleware: Middleware {
    public let id: String = "GetFlowTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFlowTemplateInput>
    public typealias MOutput = OperationOutput<GetFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFlowTemplateOutputError>
}

extension GetFlowTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFlowTemplateInput(id: \(String(describing: id)), revisionNumber: \(String(describing: revisionNumber)))"}
}

extension GetFlowTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case revisionNumber
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }
}

public struct GetFlowTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetFlowTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFlowTemplateInput>
    public typealias MOutput = OperationOutput<GetFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFlowTemplateOutputError>
}

public struct GetFlowTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFlowTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFlowTemplateInput>
    public typealias MOutput = OperationOutput<GetFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFlowTemplateOutputError>
}

public struct GetFlowTemplateInput: Equatable {
    /// <p>The ID of the workflow.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME</code>
    ///          </p>
    public let id: String?
    /// <p>The number of the workflow revision to retrieve.</p>
    public let revisionNumber: Int?

    public init (
        id: String? = nil,
        revisionNumber: Int? = nil
    )
    {
        self.id = id
        self.revisionNumber = revisionNumber
    }
}

struct GetFlowTemplateInputBody: Equatable {
    public let id: String?
    public let revisionNumber: Int?
}

extension GetFlowTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case revisionNumber
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
    }
}

extension GetFlowTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFlowTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFlowTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFlowTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFlowTemplateOutputResponse(description: \(String(describing: description)))"}
}

extension GetFlowTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFlowTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
        } else {
            self.description = nil
        }
    }
}

public struct GetFlowTemplateOutputResponse: Equatable {
    /// <p>The object that describes the specified workflow.</p>
    public let description: FlowTemplateDescription?

    public init (
        description: FlowTemplateDescription? = nil
    )
    {
        self.description = description
    }
}

struct GetFlowTemplateOutputResponseBody: Equatable {
    public let description: FlowTemplateDescription?
}

extension GetFlowTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(FlowTemplateDescription.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct GetFlowTemplateRevisionsInputBodyMiddleware: Middleware {
    public let id: String = "GetFlowTemplateRevisionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFlowTemplateRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFlowTemplateRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFlowTemplateRevisionsInput>
    public typealias MOutput = OperationOutput<GetFlowTemplateRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFlowTemplateRevisionsOutputError>
}

extension GetFlowTemplateRevisionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFlowTemplateRevisionsInput(id: \(String(describing: id)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetFlowTemplateRevisionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetFlowTemplateRevisionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetFlowTemplateRevisionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFlowTemplateRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFlowTemplateRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFlowTemplateRevisionsInput>
    public typealias MOutput = OperationOutput<GetFlowTemplateRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFlowTemplateRevisionsOutputError>
}

public struct GetFlowTemplateRevisionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFlowTemplateRevisionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFlowTemplateRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFlowTemplateRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFlowTemplateRevisionsInput>
    public typealias MOutput = OperationOutput<GetFlowTemplateRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFlowTemplateRevisionsOutputError>
}

public struct GetFlowTemplateRevisionsInput: Equatable {
    /// <p>The ID of the workflow.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME</code>
    ///          </p>
    public let id: String?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>The string that specifies the next page of results. Use this when you're paginating results.</p>
    public let nextToken: String?

    public init (
        id: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetFlowTemplateRevisionsInputBody: Equatable {
    public let id: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetFlowTemplateRevisionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetFlowTemplateRevisionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFlowTemplateRevisionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFlowTemplateRevisionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFlowTemplateRevisionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFlowTemplateRevisionsOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension GetFlowTemplateRevisionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFlowTemplateRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct GetFlowTemplateRevisionsOutputResponse: Equatable {
    /// <p>The string to specify as <code>nextToken</code> when you request the next page of results.</p>
    public let nextToken: String?
    /// <p>An array of objects that provide summary data about each revision.</p>
    public let summaries: [FlowTemplateSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [FlowTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct GetFlowTemplateRevisionsOutputResponseBody: Equatable {
    public let summaries: [FlowTemplateSummary]?
    public let nextToken: String?
}

extension GetFlowTemplateRevisionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([FlowTemplateSummary?].self, forKey: .summaries)
        var summariesDecoded0:[FlowTemplateSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [FlowTemplateSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetNamespaceDeletionStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNamespaceDeletionStatusInput()"}
}

extension GetNamespaceDeletionStatusInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetNamespaceDeletionStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetNamespaceDeletionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNamespaceDeletionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNamespaceDeletionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNamespaceDeletionStatusInput>
    public typealias MOutput = OperationOutput<GetNamespaceDeletionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNamespaceDeletionStatusOutputError>
}

public struct GetNamespaceDeletionStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetNamespaceDeletionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNamespaceDeletionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNamespaceDeletionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNamespaceDeletionStatusInput>
    public typealias MOutput = OperationOutput<GetNamespaceDeletionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNamespaceDeletionStatusOutputError>
}

public struct GetNamespaceDeletionStatusInput: Equatable {

    public init() {}
}

struct GetNamespaceDeletionStatusInputBody: Equatable {
}

extension GetNamespaceDeletionStatusInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetNamespaceDeletionStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNamespaceDeletionStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNamespaceDeletionStatusOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNamespaceDeletionStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNamespaceDeletionStatusOutputResponse(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), namespaceArn: \(String(describing: namespaceArn)), namespaceName: \(String(describing: namespaceName)), status: \(String(describing: status)))"}
}

extension GetNamespaceDeletionStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetNamespaceDeletionStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.errorMessage = output.errorMessage
            self.namespaceArn = output.namespaceArn
            self.namespaceName = output.namespaceName
            self.status = output.status
        } else {
            self.errorCode = nil
            self.errorMessage = nil
            self.namespaceArn = nil
            self.namespaceName = nil
            self.status = nil
        }
    }
}

public struct GetNamespaceDeletionStatusOutputResponse: Equatable {
    /// <p>An error code returned by the namespace deletion task.</p>
    public let errorCode: NamespaceDeletionStatusErrorCodes?
    /// <p>An error code returned by the namespace deletion task.</p>
    public let errorMessage: String?
    /// <p>The ARN of the namespace that is being deleted.</p>
    public let namespaceArn: String?
    /// <p>The name of the namespace that is being deleted.</p>
    public let namespaceName: String?
    /// <p>The status of the deletion request.</p>
    public let status: NamespaceDeletionStatus?

    public init (
        errorCode: NamespaceDeletionStatusErrorCodes? = nil,
        errorMessage: String? = nil,
        namespaceArn: String? = nil,
        namespaceName: String? = nil,
        status: NamespaceDeletionStatus? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.status = status
    }
}

struct GetNamespaceDeletionStatusOutputResponseBody: Equatable {
    public let namespaceArn: String?
    public let namespaceName: String?
    public let status: NamespaceDeletionStatus?
    public let errorCode: NamespaceDeletionStatusErrorCodes?
    public let errorMessage: String?
}

extension GetNamespaceDeletionStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case namespaceArn
        case namespaceName
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NamespaceDeletionStatus.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(NamespaceDeletionStatusErrorCodes.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

public struct GetSystemInstanceInputBodyMiddleware: Middleware {
    public let id: String = "GetSystemInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSystemInstanceInput>
    public typealias MOutput = OperationOutput<GetSystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSystemInstanceOutputError>
}

extension GetSystemInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSystemInstanceInput(id: \(String(describing: id)))"}
}

extension GetSystemInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct GetSystemInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "GetSystemInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSystemInstanceInput>
    public typealias MOutput = OperationOutput<GetSystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSystemInstanceOutputError>
}

public struct GetSystemInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSystemInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSystemInstanceInput>
    public typealias MOutput = OperationOutput<GetSystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSystemInstanceOutputError>
}

public struct GetSystemInstanceInput: Equatable {
    /// <p>The ID of the system deployment instance. This value is returned by <code>CreateSystemInstance</code>.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:deployment:DEPLOYMENTNAME</code>
    ///          </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetSystemInstanceInputBody: Equatable {
    public let id: String?
}

extension GetSystemInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetSystemInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSystemInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSystemInstanceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSystemInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSystemInstanceOutputResponse(description: \(String(describing: description)))"}
}

extension GetSystemInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSystemInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
        } else {
            self.description = nil
        }
    }
}

public struct GetSystemInstanceOutputResponse: Equatable {
    /// <p>An object that describes the system instance.</p>
    public let description: SystemInstanceDescription?

    public init (
        description: SystemInstanceDescription? = nil
    )
    {
        self.description = description
    }
}

struct GetSystemInstanceOutputResponseBody: Equatable {
    public let description: SystemInstanceDescription?
}

extension GetSystemInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(SystemInstanceDescription.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct GetSystemTemplateInputBodyMiddleware: Middleware {
    public let id: String = "GetSystemTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSystemTemplateInput>
    public typealias MOutput = OperationOutput<GetSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSystemTemplateOutputError>
}

extension GetSystemTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSystemTemplateInput(id: \(String(describing: id)), revisionNumber: \(String(describing: revisionNumber)))"}
}

extension GetSystemTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case revisionNumber
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }
}

public struct GetSystemTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetSystemTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSystemTemplateInput>
    public typealias MOutput = OperationOutput<GetSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSystemTemplateOutputError>
}

public struct GetSystemTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSystemTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSystemTemplateInput>
    public typealias MOutput = OperationOutput<GetSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSystemTemplateOutputError>
}

public struct GetSystemTemplateInput: Equatable {
    /// <p>The ID of the system to get. This ID must be in the user's namespace.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME</code>
    ///          </p>
    public let id: String?
    /// <p>The number that specifies the revision of the system to get.</p>
    public let revisionNumber: Int?

    public init (
        id: String? = nil,
        revisionNumber: Int? = nil
    )
    {
        self.id = id
        self.revisionNumber = revisionNumber
    }
}

struct GetSystemTemplateInputBody: Equatable {
    public let id: String?
    public let revisionNumber: Int?
}

extension GetSystemTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case revisionNumber
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
    }
}

extension GetSystemTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSystemTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSystemTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSystemTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSystemTemplateOutputResponse(description: \(String(describing: description)))"}
}

extension GetSystemTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSystemTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
        } else {
            self.description = nil
        }
    }
}

public struct GetSystemTemplateOutputResponse: Equatable {
    /// <p>An object that contains summary data about the system.</p>
    public let description: SystemTemplateDescription?

    public init (
        description: SystemTemplateDescription? = nil
    )
    {
        self.description = description
    }
}

struct GetSystemTemplateOutputResponseBody: Equatable {
    public let description: SystemTemplateDescription?
}

extension GetSystemTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(SystemTemplateDescription.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct GetSystemTemplateRevisionsInputBodyMiddleware: Middleware {
    public let id: String = "GetSystemTemplateRevisionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSystemTemplateRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSystemTemplateRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSystemTemplateRevisionsInput>
    public typealias MOutput = OperationOutput<GetSystemTemplateRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSystemTemplateRevisionsOutputError>
}

extension GetSystemTemplateRevisionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSystemTemplateRevisionsInput(id: \(String(describing: id)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetSystemTemplateRevisionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetSystemTemplateRevisionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSystemTemplateRevisionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSystemTemplateRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSystemTemplateRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSystemTemplateRevisionsInput>
    public typealias MOutput = OperationOutput<GetSystemTemplateRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSystemTemplateRevisionsOutputError>
}

public struct GetSystemTemplateRevisionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSystemTemplateRevisionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSystemTemplateRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSystemTemplateRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSystemTemplateRevisionsInput>
    public typealias MOutput = OperationOutput<GetSystemTemplateRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSystemTemplateRevisionsOutputError>
}

public struct GetSystemTemplateRevisionsInput: Equatable {
    /// <p>The ID of the system template.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME</code>
    ///          </p>
    public let id: String?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>The string that specifies the next page of results. Use this when you're paginating results.</p>
    public let nextToken: String?

    public init (
        id: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetSystemTemplateRevisionsInputBody: Equatable {
    public let id: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetSystemTemplateRevisionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetSystemTemplateRevisionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSystemTemplateRevisionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSystemTemplateRevisionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSystemTemplateRevisionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSystemTemplateRevisionsOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension GetSystemTemplateRevisionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSystemTemplateRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct GetSystemTemplateRevisionsOutputResponse: Equatable {
    /// <p>The string to specify as <code>nextToken</code> when you request the next page of results. </p>
    public let nextToken: String?
    /// <p>An array of objects that contain summary data about the system template revisions.</p>
    public let summaries: [SystemTemplateSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [SystemTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct GetSystemTemplateRevisionsOutputResponseBody: Equatable {
    public let summaries: [SystemTemplateSummary]?
    public let nextToken: String?
}

extension GetSystemTemplateRevisionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([SystemTemplateSummary?].self, forKey: .summaries)
        var summariesDecoded0:[SystemTemplateSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [SystemTemplateSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetUploadStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetUploadStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUploadStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUploadStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUploadStatusInput>
    public typealias MOutput = OperationOutput<GetUploadStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUploadStatusOutputError>
}

extension GetUploadStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUploadStatusInput(uploadId: \(String(describing: uploadId)))"}
}

extension GetUploadStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case uploadId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uploadId = uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

public struct GetUploadStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetUploadStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUploadStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUploadStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUploadStatusInput>
    public typealias MOutput = OperationOutput<GetUploadStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUploadStatusOutputError>
}

public struct GetUploadStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUploadStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUploadStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUploadStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUploadStatusInput>
    public typealias MOutput = OperationOutput<GetUploadStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUploadStatusOutputError>
}

public struct GetUploadStatusInput: Equatable {
    /// <p>The ID of the upload. This value is returned by the <code>UploadEntityDefinitions</code> action.</p>
    public let uploadId: String?

    public init (
        uploadId: String? = nil
    )
    {
        self.uploadId = uploadId
    }
}

struct GetUploadStatusInputBody: Equatable {
    public let uploadId: String?
}

extension GetUploadStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

extension GetUploadStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUploadStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUploadStatusOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUploadStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUploadStatusOutputResponse(createdDate: \(String(describing: createdDate)), failureReason: \(String(describing: failureReason)), namespaceArn: \(String(describing: namespaceArn)), namespaceName: \(String(describing: namespaceName)), namespaceVersion: \(String(describing: namespaceVersion)), uploadId: \(String(describing: uploadId)), uploadStatus: \(String(describing: uploadStatus)))"}
}

extension GetUploadStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUploadStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdDate = output.createdDate
            self.failureReason = output.failureReason
            self.namespaceArn = output.namespaceArn
            self.namespaceName = output.namespaceName
            self.namespaceVersion = output.namespaceVersion
            self.uploadId = output.uploadId
            self.uploadStatus = output.uploadStatus
        } else {
            self.createdDate = nil
            self.failureReason = nil
            self.namespaceArn = nil
            self.namespaceName = nil
            self.namespaceVersion = nil
            self.uploadId = nil
            self.uploadStatus = nil
        }
    }
}

public struct GetUploadStatusOutputResponse: Equatable {
    /// <p>The date at which the upload was created.</p>
    public let createdDate: Date?
    /// <p>The reason for an upload failure.</p>
    public let failureReason: [String]?
    /// <p>The ARN of the upload.</p>
    public let namespaceArn: String?
    /// <p>The name of the upload's namespace.</p>
    public let namespaceName: String?
    /// <p>The version of the user's namespace. Defaults to the latest version of the user's namespace.</p>
    public let namespaceVersion: Int?
    /// <p>The ID of the upload.</p>
    public let uploadId: String?
    /// <p>The status of the upload. The initial status is <code>IN_PROGRESS</code>. The response show all validation failures if the upload fails.</p>
    public let uploadStatus: UploadStatus?

    public init (
        createdDate: Date? = nil,
        failureReason: [String]? = nil,
        namespaceArn: String? = nil,
        namespaceName: String? = nil,
        namespaceVersion: Int? = nil,
        uploadId: String? = nil,
        uploadStatus: UploadStatus? = nil
    )
    {
        self.createdDate = createdDate
        self.failureReason = failureReason
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.namespaceVersion = namespaceVersion
        self.uploadId = uploadId
        self.uploadStatus = uploadStatus
    }
}

struct GetUploadStatusOutputResponseBody: Equatable {
    public let uploadId: String?
    public let uploadStatus: UploadStatus?
    public let namespaceArn: String?
    public let namespaceName: String?
    public let namespaceVersion: Int?
    public let failureReason: [String]?
    public let createdDate: Date?
}

extension GetUploadStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdDate
        case failureReason
        case namespaceArn
        case namespaceName
        case namespaceVersion
        case uploadId
        case uploadStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let uploadStatusDecoded = try containerValues.decodeIfPresent(UploadStatus.self, forKey: .uploadStatus)
        uploadStatus = uploadStatusDecoded
        let namespaceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
        let failureReasonContainer = try containerValues.decodeIfPresent([String?].self, forKey: .failureReason)
        var failureReasonDecoded0:[String]? = nil
        if let failureReasonContainer = failureReasonContainer {
            failureReasonDecoded0 = [String]()
            for string0 in failureReasonContainer {
                if let string0 = string0 {
                    failureReasonDecoded0?.append(string0)
                }
            }
        }
        failureReason = failureReasonDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListFlowExecutionMessagesInputBodyMiddleware: Middleware {
    public let id: String = "ListFlowExecutionMessagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFlowExecutionMessagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFlowExecutionMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFlowExecutionMessagesInput>
    public typealias MOutput = OperationOutput<ListFlowExecutionMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFlowExecutionMessagesOutputError>
}

extension ListFlowExecutionMessagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFlowExecutionMessagesInput(flowExecutionId: \(String(describing: flowExecutionId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFlowExecutionMessagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case flowExecutionId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowExecutionId = flowExecutionId {
            try encodeContainer.encode(flowExecutionId, forKey: .flowExecutionId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFlowExecutionMessagesInputHeadersMiddleware: Middleware {
    public let id: String = "ListFlowExecutionMessagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFlowExecutionMessagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFlowExecutionMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFlowExecutionMessagesInput>
    public typealias MOutput = OperationOutput<ListFlowExecutionMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFlowExecutionMessagesOutputError>
}

public struct ListFlowExecutionMessagesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFlowExecutionMessagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFlowExecutionMessagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFlowExecutionMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFlowExecutionMessagesInput>
    public typealias MOutput = OperationOutput<ListFlowExecutionMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFlowExecutionMessagesOutputError>
}

public struct ListFlowExecutionMessagesInput: Equatable {
    /// <p>The ID of the flow execution.</p>
    public let flowExecutionId: String?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>The string that specifies the next page of results. Use this when you're paginating results.</p>
    public let nextToken: String?

    public init (
        flowExecutionId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.flowExecutionId = flowExecutionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFlowExecutionMessagesInputBody: Equatable {
    public let flowExecutionId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListFlowExecutionMessagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowExecutionId
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowExecutionId)
        flowExecutionId = flowExecutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFlowExecutionMessagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFlowExecutionMessagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFlowExecutionMessagesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFlowExecutionMessagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFlowExecutionMessagesOutputResponse(messages: \(String(describing: messages)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFlowExecutionMessagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFlowExecutionMessagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messages = output.messages
            self.nextToken = output.nextToken
        } else {
            self.messages = nil
            self.nextToken = nil
        }
    }
}

public struct ListFlowExecutionMessagesOutputResponse: Equatable {
    /// <p>A list of objects that contain information about events in the specified flow execution.</p>
    public let messages: [FlowExecutionMessage]?
    /// <p>The string to specify as <code>nextToken</code> when you request the next page of results. </p>
    public let nextToken: String?

    public init (
        messages: [FlowExecutionMessage]? = nil,
        nextToken: String? = nil
    )
    {
        self.messages = messages
        self.nextToken = nextToken
    }
}

struct ListFlowExecutionMessagesOutputResponseBody: Equatable {
    public let messages: [FlowExecutionMessage]?
    public let nextToken: String?
}

extension ListFlowExecutionMessagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messages
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([FlowExecutionMessage?].self, forKey: .messages)
        var messagesDecoded0:[FlowExecutionMessage]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [FlowExecutionMessage]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The maximum number of tags to return.</p>
    public let maxResults: Int?
    /// <p>The token that specifies the next page of results to return.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the resource whose tags are to be returned.</p>
    public let resourceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let maxResults: Int?
    public let resourceArn: String?
    public let nextToken: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The token that specifies the next page of results to return.</p>
    public let nextToken: String?
    /// <p>List of tags returned by the <code>ListTagsForResource</code> operation.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MetricsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudMetricEnabled
        case metricRuleRoleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cloudMetricEnabled != false {
            try encodeContainer.encode(cloudMetricEnabled, forKey: .cloudMetricEnabled)
        }
        if let metricRuleRoleArn = metricRuleRoleArn {
            try encodeContainer.encode(metricRuleRoleArn, forKey: .metricRuleRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudMetricEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cloudMetricEnabled)
        cloudMetricEnabled = cloudMetricEnabledDecoded
        let metricRuleRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricRuleRoleArn)
        metricRuleRoleArn = metricRuleRoleArnDecoded
    }
}

extension MetricsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricsConfiguration(cloudMetricEnabled: \(String(describing: cloudMetricEnabled)), metricRuleRoleArn: \(String(describing: metricRuleRoleArn)))"}
}

/// <p>An object that specifies whether cloud metrics are collected in a deployment and, if so, what role is used to collect metrics.</p>
public struct MetricsConfiguration: Equatable {
    /// <p>A Boolean that specifies whether cloud metrics are collected.</p>
    public let cloudMetricEnabled: Bool
    /// <p>The ARN of the role that is used to collect cloud metrics.</p>
    public let metricRuleRoleArn: String?

    public init (
        cloudMetricEnabled: Bool = false,
        metricRuleRoleArn: String? = nil
    )
    {
        self.cloudMetricEnabled = cloudMetricEnabled
        self.metricRuleRoleArn = metricRuleRoleArn
    }
}

public enum NamespaceDeletionStatus {
    case failed
    case inProgress
    case succeeded
    case sdkUnknown(String)
}

extension NamespaceDeletionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NamespaceDeletionStatus] {
        return [
            .failed,
            .inProgress,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NamespaceDeletionStatus(rawValue: rawValue) ?? NamespaceDeletionStatus.sdkUnknown(rawValue)
    }
}

public enum NamespaceDeletionStatusErrorCodes {
    case validationFailed
    case sdkUnknown(String)
}

extension NamespaceDeletionStatusErrorCodes : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NamespaceDeletionStatusErrorCodes] {
        return [
            .validationFailed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .validationFailed: return "VALIDATION_FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NamespaceDeletionStatusErrorCodes(rawValue: rawValue) ?? NamespaceDeletionStatusErrorCodes.sdkUnknown(rawValue)
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SearchEntitiesInputBodyMiddleware: Middleware {
    public let id: String = "SearchEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchEntitiesInput>
    public typealias MOutput = OperationOutput<SearchEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchEntitiesOutputError>
}

extension SearchEntitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchEntitiesInput(entityTypes: \(String(describing: entityTypes)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), namespaceVersion: \(String(describing: namespaceVersion)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchEntitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityTypes
        case filters
        case maxResults
        case namespaceVersion
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for entitytypes0 in entityTypes {
                try entityTypesContainer.encode(entitytypes0.rawValue)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for entityfilters0 in filters {
                try filtersContainer.encode(entityfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let namespaceVersion = namespaceVersion {
            try encodeContainer.encode(namespaceVersion, forKey: .namespaceVersion)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SearchEntitiesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchEntitiesInput>
    public typealias MOutput = OperationOutput<SearchEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchEntitiesOutputError>
}

public struct SearchEntitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchEntitiesInput>
    public typealias MOutput = OperationOutput<SearchEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchEntitiesOutputError>
}

public struct SearchEntitiesInput: Equatable {
    /// <p>The entity types for which to search.</p>
    public let entityTypes: [EntityType]?
    /// <p>Optional filter to apply to the search. Valid filters are <code>NAME</code>
    ///             <code>NAMESPACE</code>, <code>SEMANTIC_TYPE_PATH</code> and <code>REFERENCED_ENTITY_ID</code>.
    ///          <code>REFERENCED_ENTITY_ID</code> filters on entities that are used by the entity in the result set. For example,
    ///       you can filter on the ID of a property that is used in a state.</p>
    ///          <p>Multiple filters function as OR criteria in the query. Multiple values passed inside the filter function as AND criteria.</p>
    public let filters: [EntityFilter]?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>The version of the user's namespace. Defaults to the latest version of the user's namespace.</p>
    public let namespaceVersion: Int?
    /// <p>The string that specifies the next page of results. Use this when you're paginating results.</p>
    public let nextToken: String?

    public init (
        entityTypes: [EntityType]? = nil,
        filters: [EntityFilter]? = nil,
        maxResults: Int? = nil,
        namespaceVersion: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.entityTypes = entityTypes
        self.filters = filters
        self.maxResults = maxResults
        self.namespaceVersion = namespaceVersion
        self.nextToken = nextToken
    }
}

struct SearchEntitiesInputBody: Equatable {
    public let entityTypes: [EntityType]?
    public let filters: [EntityFilter]?
    public let nextToken: String?
    public let maxResults: Int?
    public let namespaceVersion: Int?
}

extension SearchEntitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityTypes
        case filters
        case maxResults
        case namespaceVersion
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypesContainer = try containerValues.decodeIfPresent([EntityType?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[EntityType]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [EntityType]()
            for string0 in entityTypesContainer {
                if let string0 = string0 {
                    entityTypesDecoded0?.append(string0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([EntityFilter?].self, forKey: .filters)
        var filtersDecoded0:[EntityFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [EntityFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension SearchEntitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchEntitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchEntitiesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchEntitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchEntitiesOutputResponse(descriptions: \(String(describing: descriptions)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchEntitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.descriptions = output.descriptions
            self.nextToken = output.nextToken
        } else {
            self.descriptions = nil
            self.nextToken = nil
        }
    }
}

public struct SearchEntitiesOutputResponse: Equatable {
    /// <p>An array of descriptions for each entity returned in the search result.</p>
    public let descriptions: [EntityDescription]?
    /// <p>The string to specify as <code>nextToken</code> when you request the next page of results.</p>
    public let nextToken: String?

    public init (
        descriptions: [EntityDescription]? = nil,
        nextToken: String? = nil
    )
    {
        self.descriptions = descriptions
        self.nextToken = nextToken
    }
}

struct SearchEntitiesOutputResponseBody: Equatable {
    public let descriptions: [EntityDescription]?
    public let nextToken: String?
}

extension SearchEntitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case descriptions
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionsContainer = try containerValues.decodeIfPresent([EntityDescription?].self, forKey: .descriptions)
        var descriptionsDecoded0:[EntityDescription]? = nil
        if let descriptionsContainer = descriptionsContainer {
            descriptionsDecoded0 = [EntityDescription]()
            for structure0 in descriptionsContainer {
                if let structure0 = structure0 {
                    descriptionsDecoded0?.append(structure0)
                }
            }
        }
        descriptions = descriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct SearchFlowExecutionsInputBodyMiddleware: Middleware {
    public let id: String = "SearchFlowExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchFlowExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchFlowExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchFlowExecutionsInput>
    public typealias MOutput = OperationOutput<SearchFlowExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchFlowExecutionsOutputError>
}

extension SearchFlowExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchFlowExecutionsInput(endTime: \(String(describing: endTime)), flowExecutionId: \(String(describing: flowExecutionId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)), systemInstanceId: \(String(describing: systemInstanceId)))"}
}

extension SearchFlowExecutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime
        case flowExecutionId
        case maxResults
        case nextToken
        case startTime
        case systemInstanceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let flowExecutionId = flowExecutionId {
            try encodeContainer.encode(flowExecutionId, forKey: .flowExecutionId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let systemInstanceId = systemInstanceId {
            try encodeContainer.encode(systemInstanceId, forKey: .systemInstanceId)
        }
    }
}

public struct SearchFlowExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "SearchFlowExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchFlowExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchFlowExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchFlowExecutionsInput>
    public typealias MOutput = OperationOutput<SearchFlowExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchFlowExecutionsOutputError>
}

public struct SearchFlowExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchFlowExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchFlowExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchFlowExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchFlowExecutionsInput>
    public typealias MOutput = OperationOutput<SearchFlowExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchFlowExecutionsOutputError>
}

public struct SearchFlowExecutionsInput: Equatable {
    /// <p>The date and time of the latest flow execution to return.</p>
    public let endTime: Date?
    /// <p>The ID of a flow execution.</p>
    public let flowExecutionId: String?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>The string that specifies the next page of results. Use this when you're paginating results.</p>
    public let nextToken: String?
    /// <p>The date and time of the earliest flow execution to return.</p>
    public let startTime: Date?
    /// <p>The ID of the system instance that contains the flow.</p>
    public let systemInstanceId: String?

    public init (
        endTime: Date? = nil,
        flowExecutionId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil,
        systemInstanceId: String? = nil
    )
    {
        self.endTime = endTime
        self.flowExecutionId = flowExecutionId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.systemInstanceId = systemInstanceId
    }
}

struct SearchFlowExecutionsInputBody: Equatable {
    public let systemInstanceId: String?
    public let flowExecutionId: String?
    public let startTime: Date?
    public let endTime: Date?
    public let nextToken: String?
    public let maxResults: Int?
}

extension SearchFlowExecutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime
        case flowExecutionId
        case maxResults
        case nextToken
        case startTime
        case systemInstanceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let systemInstanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .systemInstanceId)
        systemInstanceId = systemInstanceIdDecoded
        let flowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowExecutionId)
        flowExecutionId = flowExecutionIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchFlowExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchFlowExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchFlowExecutionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchFlowExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchFlowExecutionsOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension SearchFlowExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchFlowExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct SearchFlowExecutionsOutputResponse: Equatable {
    /// <p>The string to specify as <code>nextToken</code> when you request the next page of results.</p>
    public let nextToken: String?
    /// <p>An array of objects that contain summary information about each workflow execution in the result set.</p>
    public let summaries: [FlowExecutionSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [FlowExecutionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct SearchFlowExecutionsOutputResponseBody: Equatable {
    public let summaries: [FlowExecutionSummary]?
    public let nextToken: String?
}

extension SearchFlowExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([FlowExecutionSummary?].self, forKey: .summaries)
        var summariesDecoded0:[FlowExecutionSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [FlowExecutionSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct SearchFlowTemplatesInputBodyMiddleware: Middleware {
    public let id: String = "SearchFlowTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchFlowTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchFlowTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchFlowTemplatesInput>
    public typealias MOutput = OperationOutput<SearchFlowTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchFlowTemplatesOutputError>
}

extension SearchFlowTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchFlowTemplatesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchFlowTemplatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for flowtemplatefilters0 in filters {
                try filtersContainer.encode(flowtemplatefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SearchFlowTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchFlowTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchFlowTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchFlowTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchFlowTemplatesInput>
    public typealias MOutput = OperationOutput<SearchFlowTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchFlowTemplatesOutputError>
}

public struct SearchFlowTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchFlowTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchFlowTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchFlowTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchFlowTemplatesInput>
    public typealias MOutput = OperationOutput<SearchFlowTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchFlowTemplatesOutputError>
}

public struct SearchFlowTemplatesInput: Equatable {
    /// <p>An array of objects that limit the result set. The only valid filter is <code>DEVICE_MODEL_ID</code>.</p>
    public let filters: [FlowTemplateFilter]?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>The string that specifies the next page of results. Use this when you're paginating results.</p>
    public let nextToken: String?

    public init (
        filters: [FlowTemplateFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchFlowTemplatesInputBody: Equatable {
    public let filters: [FlowTemplateFilter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension SearchFlowTemplatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([FlowTemplateFilter?].self, forKey: .filters)
        var filtersDecoded0:[FlowTemplateFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FlowTemplateFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchFlowTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchFlowTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchFlowTemplatesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchFlowTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchFlowTemplatesOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension SearchFlowTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchFlowTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct SearchFlowTemplatesOutputResponse: Equatable {
    /// <p>The string to specify as <code>nextToken</code> when you request the next page of results.</p>
    public let nextToken: String?
    /// <p>An array of objects that contain summary information about each workflow in the result set.</p>
    public let summaries: [FlowTemplateSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [FlowTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct SearchFlowTemplatesOutputResponseBody: Equatable {
    public let summaries: [FlowTemplateSummary]?
    public let nextToken: String?
}

extension SearchFlowTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([FlowTemplateSummary?].self, forKey: .summaries)
        var summariesDecoded0:[FlowTemplateSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [FlowTemplateSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct SearchSystemInstancesInputBodyMiddleware: Middleware {
    public let id: String = "SearchSystemInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchSystemInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchSystemInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchSystemInstancesInput>
    public typealias MOutput = OperationOutput<SearchSystemInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchSystemInstancesOutputError>
}

extension SearchSystemInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchSystemInstancesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchSystemInstancesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for systeminstancefilters0 in filters {
                try filtersContainer.encode(systeminstancefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SearchSystemInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchSystemInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchSystemInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchSystemInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchSystemInstancesInput>
    public typealias MOutput = OperationOutput<SearchSystemInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchSystemInstancesOutputError>
}

public struct SearchSystemInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchSystemInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchSystemInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchSystemInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchSystemInstancesInput>
    public typealias MOutput = OperationOutput<SearchSystemInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchSystemInstancesOutputError>
}

public struct SearchSystemInstancesInput: Equatable {
    /// <p>Optional filter to apply to the search. Valid filters are <code>SYSTEM_TEMPLATE_ID</code>, <code>STATUS</code>, and
    ///          <code>GREENGRASS_GROUP_NAME</code>.</p>
    ///          <p>Multiple filters function as OR criteria in the query. Multiple values passed inside the filter function as AND criteria.</p>
    public let filters: [SystemInstanceFilter]?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>The string that specifies the next page of results. Use this when you're paginating results.</p>
    public let nextToken: String?

    public init (
        filters: [SystemInstanceFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchSystemInstancesInputBody: Equatable {
    public let filters: [SystemInstanceFilter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension SearchSystemInstancesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SystemInstanceFilter?].self, forKey: .filters)
        var filtersDecoded0:[SystemInstanceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SystemInstanceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchSystemInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchSystemInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchSystemInstancesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchSystemInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchSystemInstancesOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension SearchSystemInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchSystemInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct SearchSystemInstancesOutputResponse: Equatable {
    /// <p>The string to specify as <code>nextToken</code> when you request the next page of results. </p>
    public let nextToken: String?
    /// <p>An array of objects that contain summary data abour the system instances in the result set.</p>
    public let summaries: [SystemInstanceSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [SystemInstanceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct SearchSystemInstancesOutputResponseBody: Equatable {
    public let summaries: [SystemInstanceSummary]?
    public let nextToken: String?
}

extension SearchSystemInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([SystemInstanceSummary?].self, forKey: .summaries)
        var summariesDecoded0:[SystemInstanceSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [SystemInstanceSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct SearchSystemTemplatesInputBodyMiddleware: Middleware {
    public let id: String = "SearchSystemTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchSystemTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchSystemTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchSystemTemplatesInput>
    public typealias MOutput = OperationOutput<SearchSystemTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchSystemTemplatesOutputError>
}

extension SearchSystemTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchSystemTemplatesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchSystemTemplatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for systemtemplatefilters0 in filters {
                try filtersContainer.encode(systemtemplatefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SearchSystemTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchSystemTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchSystemTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchSystemTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchSystemTemplatesInput>
    public typealias MOutput = OperationOutput<SearchSystemTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchSystemTemplatesOutputError>
}

public struct SearchSystemTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchSystemTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchSystemTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchSystemTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchSystemTemplatesInput>
    public typealias MOutput = OperationOutput<SearchSystemTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchSystemTemplatesOutputError>
}

public struct SearchSystemTemplatesInput: Equatable {
    /// <p>An array of filters that limit the result set. The only valid filter is <code>FLOW_TEMPLATE_ID</code>.</p>
    public let filters: [SystemTemplateFilter]?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>The string that specifies the next page of results. Use this when you're paginating results.</p>
    public let nextToken: String?

    public init (
        filters: [SystemTemplateFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchSystemTemplatesInputBody: Equatable {
    public let filters: [SystemTemplateFilter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension SearchSystemTemplatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SystemTemplateFilter?].self, forKey: .filters)
        var filtersDecoded0:[SystemTemplateFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SystemTemplateFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchSystemTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchSystemTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchSystemTemplatesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchSystemTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchSystemTemplatesOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension SearchSystemTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchSystemTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct SearchSystemTemplatesOutputResponse: Equatable {
    /// <p>The string to specify as <code>nextToken</code> when you request the next page of results.</p>
    public let nextToken: String?
    /// <p>An array of objects that contain summary information about each system deployment in the result set.</p>
    public let summaries: [SystemTemplateSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [SystemTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct SearchSystemTemplatesOutputResponseBody: Equatable {
    public let summaries: [SystemTemplateSummary]?
    public let nextToken: String?
}

extension SearchSystemTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([SystemTemplateSummary?].self, forKey: .summaries)
        var summariesDecoded0:[SystemTemplateSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [SystemTemplateSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct SearchThingsInputBodyMiddleware: Middleware {
    public let id: String = "SearchThingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchThingsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchThingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchThingsInput>
    public typealias MOutput = OperationOutput<SearchThingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchThingsOutputError>
}

extension SearchThingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchThingsInput(entityId: \(String(describing: entityId)), maxResults: \(String(describing: maxResults)), namespaceVersion: \(String(describing: namespaceVersion)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchThingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityId
        case maxResults
        case namespaceVersion
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let namespaceVersion = namespaceVersion {
            try encodeContainer.encode(namespaceVersion, forKey: .namespaceVersion)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SearchThingsInputHeadersMiddleware: Middleware {
    public let id: String = "SearchThingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchThingsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchThingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchThingsInput>
    public typealias MOutput = OperationOutput<SearchThingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchThingsOutputError>
}

public struct SearchThingsInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchThingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchThingsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchThingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchThingsInput>
    public typealias MOutput = OperationOutput<SearchThingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchThingsOutputError>
}

public struct SearchThingsInput: Equatable {
    /// <p>The ID of the entity to which the things are associated.</p>
    ///          <p>The IDs should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME</code>
    ///          </p>
    public let entityId: String?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>The version of the user's namespace. Defaults to the latest version of the user's namespace.</p>
    public let namespaceVersion: Int?
    /// <p>The string that specifies the next page of results. Use this when you're paginating results.</p>
    public let nextToken: String?

    public init (
        entityId: String? = nil,
        maxResults: Int? = nil,
        namespaceVersion: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.namespaceVersion = namespaceVersion
        self.nextToken = nextToken
    }
}

struct SearchThingsInputBody: Equatable {
    public let entityId: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let namespaceVersion: Int?
}

extension SearchThingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityId
        case maxResults
        case namespaceVersion
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension SearchThingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchThingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchThingsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchThingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchThingsOutputResponse(nextToken: \(String(describing: nextToken)), things: \(String(describing: things)))"}
}

extension SearchThingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchThingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.things = output.things
        } else {
            self.nextToken = nil
            self.things = nil
        }
    }
}

public struct SearchThingsOutputResponse: Equatable {
    /// <p>The string to specify as <code>nextToken</code> when you request the next page of results.</p>
    public let nextToken: String?
    /// <p>An array of things in the result set.</p>
    public let things: [Thing]?

    public init (
        nextToken: String? = nil,
        things: [Thing]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

struct SearchThingsOutputResponseBody: Equatable {
    public let things: [Thing]?
    public let nextToken: String?
}

extension SearchThingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case things
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingsContainer = try containerValues.decodeIfPresent([Thing?].self, forKey: .things)
        var thingsDecoded0:[Thing]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [Thing]()
            for structure0 in thingsContainer {
                if let structure0 = structure0 {
                    thingsDecoded0?.append(structure0)
                }
            }
        }
        things = thingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum SystemInstanceDeploymentStatus {
    case bootstrap
    case deletedInTarget
    case deployedInTarget
    case deployInProgress
    case failed
    case notDeployed
    case pendingDelete
    case undeployInProgress
    case sdkUnknown(String)
}

extension SystemInstanceDeploymentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SystemInstanceDeploymentStatus] {
        return [
            .bootstrap,
            .deletedInTarget,
            .deployedInTarget,
            .deployInProgress,
            .failed,
            .notDeployed,
            .pendingDelete,
            .undeployInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bootstrap: return "BOOTSTRAP"
        case .deletedInTarget: return "DELETED_IN_TARGET"
        case .deployedInTarget: return "DEPLOYED_IN_TARGET"
        case .deployInProgress: return "DEPLOY_IN_PROGRESS"
        case .failed: return "FAILED"
        case .notDeployed: return "NOT_DEPLOYED"
        case .pendingDelete: return "PENDING_DELETE"
        case .undeployInProgress: return "UNDEPLOY_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SystemInstanceDeploymentStatus(rawValue: rawValue) ?? SystemInstanceDeploymentStatus.sdkUnknown(rawValue)
    }
}

extension SystemInstanceDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definition
        case flowActionsRoleArn
        case metricsConfiguration
        case s3BucketName
        case summary
        case validatedDependencyRevisions
        case validatedNamespaceVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let flowActionsRoleArn = flowActionsRoleArn {
            try encodeContainer.encode(flowActionsRoleArn, forKey: .flowActionsRoleArn)
        }
        if let metricsConfiguration = metricsConfiguration {
            try encodeContainer.encode(metricsConfiguration, forKey: .metricsConfiguration)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let validatedDependencyRevisions = validatedDependencyRevisions {
            var validatedDependencyRevisionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validatedDependencyRevisions)
            for dependencyrevisions0 in validatedDependencyRevisions {
                try validatedDependencyRevisionsContainer.encode(dependencyrevisions0)
            }
        }
        if let validatedNamespaceVersion = validatedNamespaceVersion {
            try encodeContainer.encode(validatedNamespaceVersion, forKey: .validatedNamespaceVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(SystemInstanceSummary.self, forKey: .summary)
        summary = summaryDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let metricsConfigurationDecoded = try containerValues.decodeIfPresent(MetricsConfiguration.self, forKey: .metricsConfiguration)
        metricsConfiguration = metricsConfigurationDecoded
        let validatedNamespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .validatedNamespaceVersion)
        validatedNamespaceVersion = validatedNamespaceVersionDecoded
        let validatedDependencyRevisionsContainer = try containerValues.decodeIfPresent([DependencyRevision?].self, forKey: .validatedDependencyRevisions)
        var validatedDependencyRevisionsDecoded0:[DependencyRevision]? = nil
        if let validatedDependencyRevisionsContainer = validatedDependencyRevisionsContainer {
            validatedDependencyRevisionsDecoded0 = [DependencyRevision]()
            for structure0 in validatedDependencyRevisionsContainer {
                if let structure0 = structure0 {
                    validatedDependencyRevisionsDecoded0?.append(structure0)
                }
            }
        }
        validatedDependencyRevisions = validatedDependencyRevisionsDecoded0
        let flowActionsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowActionsRoleArn)
        flowActionsRoleArn = flowActionsRoleArnDecoded
    }
}

extension SystemInstanceDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SystemInstanceDescription(definition: \(String(describing: definition)), flowActionsRoleArn: \(String(describing: flowActionsRoleArn)), metricsConfiguration: \(String(describing: metricsConfiguration)), s3BucketName: \(String(describing: s3BucketName)), summary: \(String(describing: summary)), validatedDependencyRevisions: \(String(describing: validatedDependencyRevisions)), validatedNamespaceVersion: \(String(describing: validatedNamespaceVersion)))"}
}

/// <p>An object that contains a system instance definition and summary information.</p>
public struct SystemInstanceDescription: Equatable {
    /// <p>A document that defines an entity. </p>
    public let definition: DefinitionDocument?
    /// <p>The AWS Identity and Access Management (IAM) role that AWS IoT Things Graph assumes during flow execution in a
    ///       cloud deployment. This role must have read and write permissionss to AWS Lambda and AWS IoT and to any other
    ///       AWS services that the flow uses.</p>
    public let flowActionsRoleArn: String?
    /// <p>An object that specifies whether cloud metrics are collected in a deployment and, if so, what role is used to collect metrics.</p>
    public let metricsConfiguration: MetricsConfiguration?
    /// <p>The Amazon Simple Storage Service bucket where information about a system instance is stored.</p>
    public let s3BucketName: String?
    /// <p>An object that contains summary information about a system instance.</p>
    public let summary: SystemInstanceSummary?
    /// <p>A list of objects that contain all of the IDs and revision numbers of workflows and systems that are used in a system instance.</p>
    public let validatedDependencyRevisions: [DependencyRevision]?
    /// <p>The version of the user's namespace against which the system instance was validated.</p>
    public let validatedNamespaceVersion: Int?

    public init (
        definition: DefinitionDocument? = nil,
        flowActionsRoleArn: String? = nil,
        metricsConfiguration: MetricsConfiguration? = nil,
        s3BucketName: String? = nil,
        summary: SystemInstanceSummary? = nil,
        validatedDependencyRevisions: [DependencyRevision]? = nil,
        validatedNamespaceVersion: Int? = nil
    )
    {
        self.definition = definition
        self.flowActionsRoleArn = flowActionsRoleArn
        self.metricsConfiguration = metricsConfiguration
        self.s3BucketName = s3BucketName
        self.summary = summary
        self.validatedDependencyRevisions = validatedDependencyRevisions
        self.validatedNamespaceVersion = validatedNamespaceVersion
    }
}

extension SystemInstanceFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for systeminstancefiltervalues0 in value {
                try valueContainer.encode(systeminstancefiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SystemInstanceFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([String?].self, forKey: .value)
        var valueDecoded0:[String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension SystemInstanceFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SystemInstanceFilter(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>An object that filters a system instance search.
///          Multiple filters function as OR criteria in the search. For example a search that includes a GREENGRASS_GROUP_NAME and a
///          STATUS filter searches for system instances in the specified Greengrass group that have the specified status.</p>
public struct SystemInstanceFilter: Equatable {
    /// <p>The name of the search filter field.</p>
    public let name: SystemInstanceFilterName?
    /// <p>An array of string values for the search filter field. Multiple values function as AND criteria in the search. </p>
    public let value: [String]?

    public init (
        name: SystemInstanceFilterName? = nil,
        value: [String]? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum SystemInstanceFilterName {
    case greengrassGroupName
    case status
    case systemTemplateId
    case sdkUnknown(String)
}

extension SystemInstanceFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SystemInstanceFilterName] {
        return [
            .greengrassGroupName,
            .status,
            .systemTemplateId,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .greengrassGroupName: return "GREENGRASS_GROUP_NAME"
        case .status: return "STATUS"
        case .systemTemplateId: return "SYSTEM_TEMPLATE_ID"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SystemInstanceFilterName(rawValue: rawValue) ?? SystemInstanceFilterName.sdkUnknown(rawValue)
    }
}

extension SystemInstanceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case greengrassGroupId
        case greengrassGroupName
        case greengrassGroupVersionId
        case id
        case status
        case target
        case updatedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let greengrassGroupId = greengrassGroupId {
            try encodeContainer.encode(greengrassGroupId, forKey: .greengrassGroupId)
        }
        if let greengrassGroupName = greengrassGroupName {
            try encodeContainer.encode(greengrassGroupName, forKey: .greengrassGroupName)
        }
        if let greengrassGroupVersionId = greengrassGroupVersionId {
            try encodeContainer.encode(greengrassGroupVersionId, forKey: .greengrassGroupVersionId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let target = target {
            try encodeContainer.encode(target.rawValue, forKey: .target)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SystemInstanceDeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let targetDecoded = try containerValues.decodeIfPresent(DeploymentTarget.self, forKey: .target)
        target = targetDecoded
        let greengrassGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .greengrassGroupName)
        greengrassGroupName = greengrassGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let greengrassGroupVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .greengrassGroupVersionId)
        greengrassGroupVersionId = greengrassGroupVersionIdDecoded
    }
}

extension SystemInstanceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SystemInstanceSummary(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), greengrassGroupId: \(String(describing: greengrassGroupId)), greengrassGroupName: \(String(describing: greengrassGroupName)), greengrassGroupVersionId: \(String(describing: greengrassGroupVersionId)), id: \(String(describing: id)), status: \(String(describing: status)), target: \(String(describing: target)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>An object that contains summary information about a system instance.</p>
public struct SystemInstanceSummary: Equatable {
    /// <p>The ARN of the system instance.</p>
    public let arn: String?
    /// <p>The date when the system instance was created.</p>
    public let createdAt: Date?
    /// <p>The ID of the Greengrass group where the system instance is deployed.</p>
    public let greengrassGroupId: String?
    /// <p>The ID of the Greengrass group where the system instance is deployed.</p>
    public let greengrassGroupName: String?
    /// <p>The version of the Greengrass group where the system instance is deployed.</p>
    public let greengrassGroupVersionId: String?
    /// <p>The ID of the system instance.</p>
    public let id: String?
    /// <p>The status of the system instance.</p>
    public let status: SystemInstanceDeploymentStatus?
    /// <p>The target of the system instance.</p>
    public let target: DeploymentTarget?
    /// <p>
    ///
    ///          The date and time when the system instance was last updated.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        greengrassGroupId: String? = nil,
        greengrassGroupName: String? = nil,
        greengrassGroupVersionId: String? = nil,
        id: String? = nil,
        status: SystemInstanceDeploymentStatus? = nil,
        target: DeploymentTarget? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.greengrassGroupId = greengrassGroupId
        self.greengrassGroupName = greengrassGroupName
        self.greengrassGroupVersionId = greengrassGroupVersionId
        self.id = id
        self.status = status
        self.target = target
        self.updatedAt = updatedAt
    }
}

extension SystemTemplateDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definition
        case summary
        case validatedNamespaceVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let validatedNamespaceVersion = validatedNamespaceVersion {
            try encodeContainer.encode(validatedNamespaceVersion, forKey: .validatedNamespaceVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(SystemTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let validatedNamespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .validatedNamespaceVersion)
        validatedNamespaceVersion = validatedNamespaceVersionDecoded
    }
}

extension SystemTemplateDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SystemTemplateDescription(definition: \(String(describing: definition)), summary: \(String(describing: summary)), validatedNamespaceVersion: \(String(describing: validatedNamespaceVersion)))"}
}

/// <p>An object that contains a system's definition document and summary information.</p>
public struct SystemTemplateDescription: Equatable {
    /// <p>The definition document of a system.</p>
    public let definition: DefinitionDocument?
    /// <p>An object that contains summary information about a system.</p>
    public let summary: SystemTemplateSummary?
    /// <p>The namespace version against which the system was validated. Use this value in your system instance.</p>
    public let validatedNamespaceVersion: Int?

    public init (
        definition: DefinitionDocument? = nil,
        summary: SystemTemplateSummary? = nil,
        validatedNamespaceVersion: Int? = nil
    )
    {
        self.definition = definition
        self.summary = summary
        self.validatedNamespaceVersion = validatedNamespaceVersion
    }
}

extension SystemTemplateFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for systemtemplatefiltervalues0 in value {
                try valueContainer.encode(systemtemplatefiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SystemTemplateFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([String?].self, forKey: .value)
        var valueDecoded0:[String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension SystemTemplateFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SystemTemplateFilter(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>An object that filters a system search.</p>
public struct SystemTemplateFilter: Equatable {
    /// <p>The name of the system search filter field.</p>
    public let name: SystemTemplateFilterName?
    /// <p>An array of string values for the search filter field. Multiple values function as AND criteria in the search.</p>
    public let value: [String]?

    public init (
        name: SystemTemplateFilterName? = nil,
        value: [String]? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum SystemTemplateFilterName {
    case flowTemplateId
    case sdkUnknown(String)
}

extension SystemTemplateFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SystemTemplateFilterName] {
        return [
            .flowTemplateId,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .flowTemplateId: return "FLOW_TEMPLATE_ID"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SystemTemplateFilterName(rawValue: rawValue) ?? SystemTemplateFilterName.sdkUnknown(rawValue)
    }
}

extension SystemTemplateSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case id
        case revisionNumber
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension SystemTemplateSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SystemTemplateSummary(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), id: \(String(describing: id)), revisionNumber: \(String(describing: revisionNumber)))"}
}

/// <p>An object that contains information about a system.</p>
public struct SystemTemplateSummary: Equatable {
    /// <p>The ARN of the system.</p>
    public let arn: String?
    /// <p>The date when the system was created.</p>
    public let createdAt: Date?
    /// <p>The ID of the system.</p>
    public let id: String?
    /// <p>The revision number of the system.</p>
    public let revisionNumber: Int?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        id: String? = nil,
        revisionNumber: Int? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.revisionNumber = revisionNumber
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Metadata assigned to an AWS IoT Things Graph resource consisting of a key-value pair.</p>
public struct Tag: Equatable {
    /// <p>The required name of the tag. The string value can be from 1 to 128 Unicode characters in length.</p>
    public let key: String?
    /// <p>The optional value of the tag. The string value can be from 1 to 256 Unicode characters in length.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource whose tags are returned.</p>
    public let resourceArn: String?
    /// <p>A list of tags to add to the resource.></p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Thing: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case thingArn
        case thingName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
    }
}

extension Thing: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Thing(thingArn: \(String(describing: thingArn)), thingName: \(String(describing: thingName)))"}
}

/// <p>An AWS IoT thing.</p>
public struct Thing: Equatable {
    /// <p>The ARN of the thing.</p>
    public let thingArn: String?
    /// <p>The name of the thing.</p>
    public let thingName: String?

    public init (
        thingArn: String? = nil,
        thingName: String? = nil
    )
    {
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UndeploySystemInstanceInputBodyMiddleware: Middleware {
    public let id: String = "UndeploySystemInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UndeploySystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UndeploySystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UndeploySystemInstanceInput>
    public typealias MOutput = OperationOutput<UndeploySystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UndeploySystemInstanceOutputError>
}

extension UndeploySystemInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UndeploySystemInstanceInput(id: \(String(describing: id)))"}
}

extension UndeploySystemInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct UndeploySystemInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "UndeploySystemInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UndeploySystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UndeploySystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UndeploySystemInstanceInput>
    public typealias MOutput = OperationOutput<UndeploySystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UndeploySystemInstanceOutputError>
}

public struct UndeploySystemInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "UndeploySystemInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UndeploySystemInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UndeploySystemInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UndeploySystemInstanceInput>
    public typealias MOutput = OperationOutput<UndeploySystemInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UndeploySystemInstanceOutputError>
}

public struct UndeploySystemInstanceInput: Equatable {
    /// <p>The ID of the system instance to remove from its target.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct UndeploySystemInstanceInputBody: Equatable {
    public let id: String?
}

extension UndeploySystemInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension UndeploySystemInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UndeploySystemInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UndeploySystemInstanceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UndeploySystemInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UndeploySystemInstanceOutputResponse(summary: \(String(describing: summary)))"}
}

extension UndeploySystemInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UndeploySystemInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct UndeploySystemInstanceOutputResponse: Equatable {
    /// <p>An object that contains summary information about the system instance that was removed from its target.</p>
    public let summary: SystemInstanceSummary?

    public init (
        summary: SystemInstanceSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct UndeploySystemInstanceOutputResponseBody: Equatable {
    public let summary: SystemInstanceSummary?
}

extension UndeploySystemInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case summary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(SystemInstanceSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource whose tags are to be removed.</p>
    public let resourceArn: String?
    /// <p>A list of tag key names to remove from the resource. You don't specify the value. Both the key and its associated value are removed. </p>
    ///          <p>This parameter to the API requires a JSON text string argument. For information on how to format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>AWS CLI User Guide</i>. </p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateFlowTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFlowTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowTemplateInput>
    public typealias MOutput = OperationOutput<UpdateFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowTemplateOutputError>
}

extension UpdateFlowTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowTemplateInput(compatibleNamespaceVersion: \(String(describing: compatibleNamespaceVersion)), definition: \(String(describing: definition)), id: \(String(describing: id)))"}
}

extension UpdateFlowTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compatibleNamespaceVersion
        case definition
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleNamespaceVersion = compatibleNamespaceVersion {
            try encodeContainer.encode(compatibleNamespaceVersion, forKey: .compatibleNamespaceVersion)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct UpdateFlowTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFlowTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowTemplateInput>
    public typealias MOutput = OperationOutput<UpdateFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowTemplateOutputError>
}

public struct UpdateFlowTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFlowTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowTemplateInput>
    public typealias MOutput = OperationOutput<UpdateFlowTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowTemplateOutputError>
}

public struct UpdateFlowTemplateInput: Equatable {
    /// <p>The version of the user's namespace.</p>
    ///          <p>If no value is specified, the latest version is used by default. Use the <code>GetFlowTemplateRevisions</code> if you want to find earlier revisions of the flow
    ///       to update.</p>
    public let compatibleNamespaceVersion: Int?
    /// <p>The <code>DefinitionDocument</code> that contains the updated workflow definition.</p>
    public let definition: DefinitionDocument?
    /// <p>The ID of the workflow to be updated.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME</code>
    ///          </p>
    public let id: String?

    public init (
        compatibleNamespaceVersion: Int? = nil,
        definition: DefinitionDocument? = nil,
        id: String? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
        self.id = id
    }
}

struct UpdateFlowTemplateInputBody: Equatable {
    public let id: String?
    public let definition: DefinitionDocument?
    public let compatibleNamespaceVersion: Int?
}

extension UpdateFlowTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibleNamespaceVersion
        case definition
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let compatibleNamespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .compatibleNamespaceVersion)
        compatibleNamespaceVersion = compatibleNamespaceVersionDecoded
    }
}

extension UpdateFlowTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowTemplateOutputResponse(summary: \(String(describing: summary)))"}
}

extension UpdateFlowTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFlowTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct UpdateFlowTemplateOutputResponse: Equatable {
    /// <p>An object containing summary information about the updated workflow.</p>
    public let summary: FlowTemplateSummary?

    public init (
        summary: FlowTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct UpdateFlowTemplateOutputResponseBody: Equatable {
    public let summary: FlowTemplateSummary?
}

extension UpdateFlowTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case summary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(FlowTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

public struct UpdateSystemTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSystemTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSystemTemplateInput>
    public typealias MOutput = OperationOutput<UpdateSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSystemTemplateOutputError>
}

extension UpdateSystemTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSystemTemplateInput(compatibleNamespaceVersion: \(String(describing: compatibleNamespaceVersion)), definition: \(String(describing: definition)), id: \(String(describing: id)))"}
}

extension UpdateSystemTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compatibleNamespaceVersion
        case definition
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleNamespaceVersion = compatibleNamespaceVersion {
            try encodeContainer.encode(compatibleNamespaceVersion, forKey: .compatibleNamespaceVersion)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct UpdateSystemTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSystemTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSystemTemplateInput>
    public typealias MOutput = OperationOutput<UpdateSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSystemTemplateOutputError>
}

public struct UpdateSystemTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSystemTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSystemTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSystemTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSystemTemplateInput>
    public typealias MOutput = OperationOutput<UpdateSystemTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSystemTemplateOutputError>
}

public struct UpdateSystemTemplateInput: Equatable {
    /// <p>The version of the user's namespace. Defaults to the latest version of the user's namespace.</p>
    ///          <p>If no value is specified, the latest version is used by default.</p>
    public let compatibleNamespaceVersion: Int?
    /// <p>The <code>DefinitionDocument</code> that contains the updated system definition.</p>
    public let definition: DefinitionDocument?
    /// <p>The ID of the system to be updated.</p>
    ///          <p>The ID should be in the following format.</p>
    ///          <p>
    ///             <code>urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME</code>
    ///          </p>
    public let id: String?

    public init (
        compatibleNamespaceVersion: Int? = nil,
        definition: DefinitionDocument? = nil,
        id: String? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
        self.id = id
    }
}

struct UpdateSystemTemplateInputBody: Equatable {
    public let id: String?
    public let definition: DefinitionDocument?
    public let compatibleNamespaceVersion: Int?
}

extension UpdateSystemTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibleNamespaceVersion
        case definition
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let compatibleNamespaceVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .compatibleNamespaceVersion)
        compatibleNamespaceVersion = compatibleNamespaceVersionDecoded
    }
}

extension UpdateSystemTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSystemTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSystemTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSystemTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSystemTemplateOutputResponse(summary: \(String(describing: summary)))"}
}

extension UpdateSystemTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSystemTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct UpdateSystemTemplateOutputResponse: Equatable {
    /// <p>An object containing summary information about the updated system.</p>
    public let summary: SystemTemplateSummary?

    public init (
        summary: SystemTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct UpdateSystemTemplateOutputResponseBody: Equatable {
    public let summary: SystemTemplateSummary?
}

extension UpdateSystemTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case summary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(SystemTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

public struct UploadEntityDefinitionsInputBodyMiddleware: Middleware {
    public let id: String = "UploadEntityDefinitionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadEntityDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadEntityDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadEntityDefinitionsInput>
    public typealias MOutput = OperationOutput<UploadEntityDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadEntityDefinitionsOutputError>
}

extension UploadEntityDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadEntityDefinitionsInput(deprecateExistingEntities: \(String(describing: deprecateExistingEntities)), document: \(String(describing: document)), syncWithPublicNamespace: \(String(describing: syncWithPublicNamespace)))"}
}

extension UploadEntityDefinitionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deprecateExistingEntities
        case document
        case syncWithPublicNamespace
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deprecateExistingEntities != false {
            try encodeContainer.encode(deprecateExistingEntities, forKey: .deprecateExistingEntities)
        }
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if syncWithPublicNamespace != false {
            try encodeContainer.encode(syncWithPublicNamespace, forKey: .syncWithPublicNamespace)
        }
    }
}

public struct UploadEntityDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "UploadEntityDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadEntityDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadEntityDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadEntityDefinitionsInput>
    public typealias MOutput = OperationOutput<UploadEntityDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadEntityDefinitionsOutputError>
}

public struct UploadEntityDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "UploadEntityDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadEntityDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadEntityDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadEntityDefinitionsInput>
    public typealias MOutput = OperationOutput<UploadEntityDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadEntityDefinitionsOutputError>
}

public struct UploadEntityDefinitionsInput: Equatable {
    /// <p>A Boolean that specifies whether to deprecate all entities in the latest version before uploading the new <code>DefinitionDocument</code>.
    ///          If set to <code>true</code>, the upload will create a new namespace version.</p>
    public let deprecateExistingEntities: Bool
    /// <p>The <code>DefinitionDocument</code> that defines the updated entities.</p>
    public let document: DefinitionDocument?
    /// <p>A Boolean that specifies whether to synchronize with the latest version of the public namespace. If set to <code>true</code>, the upload will create a new namespace version.</p>
    public let syncWithPublicNamespace: Bool

    public init (
        deprecateExistingEntities: Bool = false,
        document: DefinitionDocument? = nil,
        syncWithPublicNamespace: Bool = false
    )
    {
        self.deprecateExistingEntities = deprecateExistingEntities
        self.document = document
        self.syncWithPublicNamespace = syncWithPublicNamespace
    }
}

struct UploadEntityDefinitionsInputBody: Equatable {
    public let document: DefinitionDocument?
    public let syncWithPublicNamespace: Bool
    public let deprecateExistingEntities: Bool
}

extension UploadEntityDefinitionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deprecateExistingEntities
        case document
        case syncWithPublicNamespace
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(DefinitionDocument.self, forKey: .document)
        document = documentDecoded
        let syncWithPublicNamespaceDecoded = try containerValues.decode(Bool.self, forKey: .syncWithPublicNamespace)
        syncWithPublicNamespace = syncWithPublicNamespaceDecoded
        let deprecateExistingEntitiesDecoded = try containerValues.decode(Bool.self, forKey: .deprecateExistingEntities)
        deprecateExistingEntities = deprecateExistingEntitiesDecoded
    }
}

extension UploadEntityDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadEntityDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadEntityDefinitionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadEntityDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadEntityDefinitionsOutputResponse(uploadId: \(String(describing: uploadId)))"}
}

extension UploadEntityDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UploadEntityDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.uploadId = output.uploadId
        } else {
            self.uploadId = nil
        }
    }
}

public struct UploadEntityDefinitionsOutputResponse: Equatable {
    /// <p>The ID that specifies the upload action. You can use this to track the status of the upload.</p>
    public let uploadId: String?

    public init (
        uploadId: String? = nil
    )
    {
        self.uploadId = uploadId
    }
}

struct UploadEntityDefinitionsOutputResponseBody: Equatable {
    public let uploadId: String?
}

extension UploadEntityDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

public enum UploadStatus {
    case failed
    case inProgress
    case succeeded
    case sdkUnknown(String)
}

extension UploadStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UploadStatus] {
        return [
            .failed,
            .inProgress,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UploadStatus(rawValue: rawValue) ?? UploadStatus.sdkUnknown(rawValue)
    }
}
