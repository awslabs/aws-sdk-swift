// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AutoScalingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case autoScalingConfigurationRevision = "AutoScalingConfigurationRevision"
        case createdAt = "CreatedAt"
        case deletedAt = "DeletedAt"
        case latest = "Latest"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if autoScalingConfigurationRevision != 0 {
            try encodeContainer.encode(autoScalingConfigurationRevision, forKey: .autoScalingConfigurationRevision)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deletedAt = deletedAt {
            try encodeContainer.encode(deletedAt.timeIntervalSince1970, forKey: .deletedAt)
        }
        if latest != false {
            try encodeContainer.encode(latest, forKey: .latest)
        }
        if maxConcurrency != 0 {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if maxSize != 0 {
            try encodeContainer.encode(maxSize, forKey: .maxSize)
        }
        if minSize != 0 {
            try encodeContainer.encode(minSize, forKey: .minSize)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let autoScalingConfigurationRevisionDecoded = try containerValues.decode(Int.self, forKey: .autoScalingConfigurationRevision)
        autoScalingConfigurationRevision = autoScalingConfigurationRevisionDecoded
        let latestDecoded = try containerValues.decode(Bool.self, forKey: .latest)
        latest = latestDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AutoScalingConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let maxConcurrencyDecoded = try containerValues.decode(Int.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let minSizeDecoded = try containerValues.decode(Int.self, forKey: .minSize)
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decode(Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deletedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
    }
}
