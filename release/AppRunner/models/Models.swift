// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssociateCustomDomainInputBodyMiddleware: Middleware {
    public let id: String = "AssociateCustomDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateCustomDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateCustomDomainInput>
    public typealias MOutput = OperationOutput<AssociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateCustomDomainOutputError>
}

extension AssociateCustomDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateCustomDomainInput(domainName: \(String(describing: domainName)), enableWWWSubdomain: \(String(describing: enableWWWSubdomain)), serviceArn: \(String(describing: serviceArn)))"}
}

extension AssociateCustomDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case enableWWWSubdomain = "EnableWWWSubdomain"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let enableWWWSubdomain = enableWWWSubdomain {
            try encodeContainer.encode(enableWWWSubdomain, forKey: .enableWWWSubdomain)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct AssociateCustomDomainInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateCustomDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateCustomDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateCustomDomainInput>
    public typealias MOutput = OperationOutput<AssociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateCustomDomainOutputError>
}

public struct AssociateCustomDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateCustomDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateCustomDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateCustomDomainInput>
    public typealias MOutput = OperationOutput<AssociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateCustomDomainOutputError>
}

public struct AssociateCustomDomainInput: Equatable {
    /// <p>A custom domain endpoint to associate. Specify a root domain (for example, <code>example.com</code>), a subdomain (for example,
    ///         <code>login.example.com</code> or <code>admin.login.example.com</code>), or a wildcard (for example, <code>*.example.com</code>).</p>
    public let domainName: String?
    /// <p>Set to <code>true</code> to associate the subdomain <code>www.<i>DomainName</i>
    ///             </code> with the App Runner service in addition to the base
    ///       domain.</p>
    ///          <p>Default: <code>true</code>
    ///          </p>
    public let enableWWWSubdomain: Bool?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to associate a custom domain name with.</p>
    public let serviceArn: String?

    public init (
        domainName: String? = nil,
        enableWWWSubdomain: Bool? = nil,
        serviceArn: String? = nil
    )
    {
        self.domainName = domainName
        self.enableWWWSubdomain = enableWWWSubdomain
        self.serviceArn = serviceArn
    }
}

struct AssociateCustomDomainInputBody: Equatable {
    public let serviceArn: String?
    public let domainName: String?
    public let enableWWWSubdomain: Bool?
}

extension AssociateCustomDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case enableWWWSubdomain = "EnableWWWSubdomain"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let enableWWWSubdomainDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableWWWSubdomain)
        enableWWWSubdomain = enableWWWSubdomainDecoded
    }
}

extension AssociateCustomDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateCustomDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateCustomDomainOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateCustomDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateCustomDomainOutputResponse(customDomain: \(String(describing: customDomain)), dNSTarget: \(String(describing: dNSTarget)), serviceArn: \(String(describing: serviceArn)))"}
}

extension AssociateCustomDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateCustomDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customDomain = output.customDomain
            self.dNSTarget = output.dNSTarget
            self.serviceArn = output.serviceArn
        } else {
            self.customDomain = nil
            self.dNSTarget = nil
            self.serviceArn = nil
        }
    }
}

public struct AssociateCustomDomainOutputResponse: Equatable {
    /// <p>A description of the domain name that's being associated.</p>
    public let customDomain: CustomDomain?
    /// <p>The App Runner subdomain of the App Runner service. The custom domain name is mapped to this target name.</p>
    public let dNSTarget: String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service with which a custom domain name is associated.</p>
    public let serviceArn: String?

    public init (
        customDomain: CustomDomain? = nil,
        dNSTarget: String? = nil,
        serviceArn: String? = nil
    )
    {
        self.customDomain = customDomain
        self.dNSTarget = dNSTarget
        self.serviceArn = serviceArn
    }
}

struct AssociateCustomDomainOutputResponseBody: Equatable {
    public let dNSTarget: String?
    public let serviceArn: String?
    public let customDomain: CustomDomain?
}

extension AssociateCustomDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customDomain = "CustomDomain"
        case dNSTarget = "DNSTarget"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dNSTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dNSTarget)
        dNSTarget = dNSTargetDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(CustomDomain.self, forKey: .customDomain)
        customDomain = customDomainDecoded
    }
}

extension AuthenticationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessRoleArn = "AccessRoleArn"
        case connectionArn = "ConnectionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRoleArn = accessRoleArn {
            try encodeContainer.encode(accessRoleArn, forKey: .accessRoleArn)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let accessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessRoleArn)
        accessRoleArn = accessRoleArnDecoded
    }
}

extension AuthenticationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthenticationConfiguration(accessRoleArn: \(String(describing: accessRoleArn)), connectionArn: \(String(describing: connectionArn)))"}
}

/// <p>Describes resources needed to authenticate access to some source repositories. The specific resource depends on the repository provider.</p>
public struct AuthenticationConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants the App Runner service access to a source repository. It's required for ECR image repositories
    ///       (but not for ECR Public repositories).</p>
    public let accessRoleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner connection that enables the App Runner service to connect to a source repository. It's required for GitHub code
    ///       repositories.</p>
    public let connectionArn: String?

    public init (
        accessRoleArn: String? = nil,
        connectionArn: String? = nil
    )
    {
        self.accessRoleArn = accessRoleArn
        self.connectionArn = connectionArn
    }
}

extension AutoScalingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case autoScalingConfigurationRevision = "AutoScalingConfigurationRevision"
        case createdAt = "CreatedAt"
        case deletedAt = "DeletedAt"
        case latest = "Latest"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if autoScalingConfigurationRevision != 0 {
            try encodeContainer.encode(autoScalingConfigurationRevision, forKey: .autoScalingConfigurationRevision)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deletedAt = deletedAt {
            try encodeContainer.encode(deletedAt.timeIntervalSince1970, forKey: .deletedAt)
        }
        if latest != false {
            try encodeContainer.encode(latest, forKey: .latest)
        }
        if maxConcurrency != 0 {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if maxSize != 0 {
            try encodeContainer.encode(maxSize, forKey: .maxSize)
        }
        if minSize != 0 {
            try encodeContainer.encode(minSize, forKey: .minSize)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let autoScalingConfigurationRevisionDecoded = try containerValues.decode(Int.self, forKey: .autoScalingConfigurationRevision)
        autoScalingConfigurationRevision = autoScalingConfigurationRevisionDecoded
        let latestDecoded = try containerValues.decode(Bool.self, forKey: .latest)
        latest = latestDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AutoScalingConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let maxConcurrencyDecoded = try containerValues.decode(Int.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let minSizeDecoded = try containerValues.decode(Int.self, forKey: .minSize)
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decode(Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deletedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
    }
}

extension AutoScalingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutoScalingConfiguration(autoScalingConfigurationArn: \(String(describing: autoScalingConfigurationArn)), autoScalingConfigurationName: \(String(describing: autoScalingConfigurationName)), autoScalingConfigurationRevision: \(String(describing: autoScalingConfigurationRevision)), createdAt: \(String(describing: createdAt)), deletedAt: \(String(describing: deletedAt)), latest: \(String(describing: latest)), maxConcurrency: \(String(describing: maxConcurrency)), maxSize: \(String(describing: maxSize)), minSize: \(String(describing: minSize)), status: \(String(describing: status)))"}
}

/// <p>Describes an AWS App Runner automatic scaling configuration resource. Multiple revisions of a configuration have the same
///         <code>AutoScalingConfigurationName</code> and different <code>AutoScalingConfigurationRevision</code> values.</p>
///          <p>A higher <code>MinSize</code> increases the spread of your App Runner service over more Availability Zones in the AWS Region. The tradeoff is a higher
///       minimal cost.</p>
///          <p>A lower <code>MaxSize</code> controls your cost. The tradeoff is lower responsiveness during peak demand.</p>
public struct AutoScalingConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) of this auto scaling configuration.</p>
    public let autoScalingConfigurationArn: String?
    /// <p>The customer-provided auto scaling configuration name. It can be used in multiple revisions of a configuration.</p>
    public let autoScalingConfigurationName: String?
    /// <p>The revision of this auto scaling configuration. It's unique among all the active configurations (<code>"Status": "ACTIVE"</code>) that share the same
    ///         <code>AutoScalingConfigurationName</code>.</p>
    public let autoScalingConfigurationRevision: Int
    /// <p>The time when the auto scaling configuration was created. It's in Unix time stamp format.</p>
    public let createdAt: Date?
    /// <p>The time when the auto scaling configuration was deleted. It's in Unix time stamp format.</p>
    public let deletedAt: Date?
    /// <p>It's set to <code>true</code> for the configuration with the highest <code>Revision</code> among all configurations that share the same
    ///         <code>Name</code>. It's set to <code>false</code> otherwise.</p>
    public let latest: Bool
    /// <p>The maximum number of concurrent requests that an instance processes. If the number of concurrent requests exceeds this limit, App Runner scales the service
    ///       up.</p>
    public let maxConcurrency: Int
    /// <p>The maximum number of instances that a service scales up to. At most <code>MaxSize</code> instances actively serve traffic for your service.</p>
    public let maxSize: Int
    /// <p>The minimum number of instances that App Runner provisions for a service. The service always has at least <code>MinSize</code> provisioned instances. Some
    ///       of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to be
    ///       quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset.</p>
    ///          <p>App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code.</p>
    public let minSize: Int
    /// <p>The current state of the auto scaling configuration. If the status of a configuration revision is <code>INACTIVE</code>, it was deleted and can't be
    ///       used. Inactive configuration revisions are permanently removed some time after they are deleted.</p>
    public let status: AutoScalingConfigurationStatus?

    public init (
        autoScalingConfigurationArn: String? = nil,
        autoScalingConfigurationName: String? = nil,
        autoScalingConfigurationRevision: Int = 0,
        createdAt: Date? = nil,
        deletedAt: Date? = nil,
        latest: Bool = false,
        maxConcurrency: Int = 0,
        maxSize: Int = 0,
        minSize: Int = 0,
        status: AutoScalingConfigurationStatus? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.autoScalingConfigurationName = autoScalingConfigurationName
        self.autoScalingConfigurationRevision = autoScalingConfigurationRevision
        self.createdAt = createdAt
        self.deletedAt = deletedAt
        self.latest = latest
        self.maxConcurrency = maxConcurrency
        self.maxSize = maxSize
        self.minSize = minSize
        self.status = status
    }
}

public enum AutoScalingConfigurationStatus {
    case active
    case inactive
    case sdkUnknown(String)
}

extension AutoScalingConfigurationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AutoScalingConfigurationStatus] {
        return [
            .active,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AutoScalingConfigurationStatus(rawValue: rawValue) ?? AutoScalingConfigurationStatus.sdkUnknown(rawValue)
    }
}

extension AutoScalingConfigurationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case autoScalingConfigurationRevision = "AutoScalingConfigurationRevision"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if autoScalingConfigurationRevision != 0 {
            try encodeContainer.encode(autoScalingConfigurationRevision, forKey: .autoScalingConfigurationRevision)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let autoScalingConfigurationRevisionDecoded = try containerValues.decode(Int.self, forKey: .autoScalingConfigurationRevision)
        autoScalingConfigurationRevision = autoScalingConfigurationRevisionDecoded
    }
}

extension AutoScalingConfigurationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutoScalingConfigurationSummary(autoScalingConfigurationArn: \(String(describing: autoScalingConfigurationArn)), autoScalingConfigurationName: \(String(describing: autoScalingConfigurationName)), autoScalingConfigurationRevision: \(String(describing: autoScalingConfigurationRevision)))"}
}

/// <p>Provides summary information about an AWS App Runner automatic scaling configuration resource.</p>
///          <p>This type contains limited information about an auto scaling configuration. It includes only identification information, without configuration
///       details. It's returned by the <a>ListAutoScalingConfigurations</a> action. Complete configuration information is returned by the <a>CreateAutoScalingConfiguration</a>, <a>DescribeAutoScalingConfiguration</a>, and <a>DeleteAutoScalingConfiguration</a>
///       actions using the <a>AutoScalingConfiguration</a> type.</p>
public struct AutoScalingConfigurationSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of this auto scaling configuration.</p>
    public let autoScalingConfigurationArn: String?
    /// <p>The customer-provided auto scaling configuration name. It can be used in multiple revisions of a configuration.</p>
    public let autoScalingConfigurationName: String?
    /// <p>The revision of this auto scaling configuration. It's unique among all the active configurations (<code>"Status": "ACTIVE"</code>) with the same
    ///         <code>AutoScalingConfigurationName</code>.</p>
    public let autoScalingConfigurationRevision: Int

    public init (
        autoScalingConfigurationArn: String? = nil,
        autoScalingConfigurationName: String? = nil,
        autoScalingConfigurationRevision: Int = 0
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.autoScalingConfigurationName = autoScalingConfigurationName
        self.autoScalingConfigurationRevision = autoScalingConfigurationRevision
    }
}

extension CertificateValidationRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case status = "Status"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CertificateValidationRecordStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CertificateValidationRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateValidationRecord(name: \(String(describing: name)), status: \(String(describing: status)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Describes a certificate CNAME record to add to your DNS. For more information, see <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_AssociateCustomDomain.html">AssociateCustomDomain</a>.</p>
public struct CertificateValidationRecord: Equatable {
    /// <p>The certificate CNAME record name.</p>
    public let name: String?
    /// <p>The current state of the certificate CNAME record validation. It should change to <code>SUCCESS</code> after App Runner completes validation with your
    ///       DNS.</p>
    public let status: CertificateValidationRecordStatus?
    /// <p>The record type, always <code>CNAME</code>.</p>
    public let type: String?
    /// <p>The certificate CNAME record value.</p>
    public let value: String?

    public init (
        name: String? = nil,
        status: CertificateValidationRecordStatus? = nil,
        type: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.status = status
        self.type = type
        self.value = value
    }
}

public enum CertificateValidationRecordStatus {
    case failed
    case pendingValidation
    case success
    case sdkUnknown(String)
}

extension CertificateValidationRecordStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CertificateValidationRecordStatus] {
        return [
            .failed,
            .pendingValidation,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .pendingValidation: return "PENDING_VALIDATION"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CertificateValidationRecordStatus(rawValue: rawValue) ?? CertificateValidationRecordStatus.sdkUnknown(rawValue)
    }
}

extension CodeConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeConfigurationValues = "CodeConfigurationValues"
        case configurationSource = "ConfigurationSource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeConfigurationValues = codeConfigurationValues {
            try encodeContainer.encode(codeConfigurationValues, forKey: .codeConfigurationValues)
        }
        if let configurationSource = configurationSource {
            try encodeContainer.encode(configurationSource.rawValue, forKey: .configurationSource)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSourceDecoded = try containerValues.decodeIfPresent(ConfigurationSource.self, forKey: .configurationSource)
        configurationSource = configurationSourceDecoded
        let codeConfigurationValuesDecoded = try containerValues.decodeIfPresent(CodeConfigurationValues.self, forKey: .codeConfigurationValues)
        codeConfigurationValues = codeConfigurationValuesDecoded
    }
}

extension CodeConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeConfiguration(codeConfigurationValues: \(String(describing: codeConfigurationValues)), configurationSource: \(String(describing: configurationSource)))"}
}

/// <p>Describes the configuration that AWS App Runner uses to build and run an App Runner service from a source code repository.</p>
public struct CodeConfiguration: Equatable {
    /// <p>The basic configuration for building and running the App Runner service. Use it to quickly launch an App Runner service without providing a
    ///         <code>apprunner.yaml</code> file in the source code repository (or ignoring the file if it exists).</p>
    public let codeConfigurationValues: CodeConfigurationValues?
    /// <p>The source of the App Runner configuration. Values are interpreted as follows:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>REPOSITORY</code> – App Runner reads configuration values from the <code>apprunner.yaml</code> file in the source code repository and
    ///           ignores <code>CodeConfigurationValues</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>API</code> – App Runner uses configuration values provided in <code>CodeConfigurationValues</code> and ignores the
    ///             <code>apprunner.yaml</code> file in the source code repository.</p>
    ///             </li>
    ///          </ul>
    public let configurationSource: ConfigurationSource?

    public init (
        codeConfigurationValues: CodeConfigurationValues? = nil,
        configurationSource: ConfigurationSource? = nil
    )
    {
        self.codeConfigurationValues = codeConfigurationValues
        self.configurationSource = configurationSource
    }
}

extension CodeConfigurationValues: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case buildCommand = "BuildCommand"
        case port = "Port"
        case runtime = "Runtime"
        case runtimeEnvironmentVariables = "RuntimeEnvironmentVariables"
        case startCommand = "StartCommand"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let buildCommand = buildCommand {
            try encodeContainer.encode(buildCommand, forKey: .buildCommand)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let runtimeEnvironmentVariables = runtimeEnvironmentVariables {
            var runtimeEnvironmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .runtimeEnvironmentVariables)
            for (dictKey0, runtimeenvironmentvariables0) in runtimeEnvironmentVariables {
                try runtimeEnvironmentVariablesContainer.encode(runtimeenvironmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let startCommand = startCommand {
            try encodeContainer.encode(startCommand, forKey: .startCommand)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeDecoded = try containerValues.decodeIfPresent(Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let buildCommandDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildCommand)
        buildCommand = buildCommandDecoded
        let startCommandDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startCommand)
        startCommand = startCommandDecoded
        let portDecoded = try containerValues.decodeIfPresent(String.self, forKey: .port)
        port = portDecoded
        let runtimeEnvironmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .runtimeEnvironmentVariables)
        var runtimeEnvironmentVariablesDecoded0: [String:String]? = nil
        if let runtimeEnvironmentVariablesContainer = runtimeEnvironmentVariablesContainer {
            runtimeEnvironmentVariablesDecoded0 = [String:String]()
            for (key0, runtimeenvironmentvariablesvalue0) in runtimeEnvironmentVariablesContainer {
                if let runtimeenvironmentvariablesvalue0 = runtimeenvironmentvariablesvalue0 {
                    runtimeEnvironmentVariablesDecoded0?[key0] = runtimeenvironmentvariablesvalue0
                }
            }
        }
        runtimeEnvironmentVariables = runtimeEnvironmentVariablesDecoded0
    }
}

extension CodeConfigurationValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeConfigurationValues(buildCommand: \(String(describing: buildCommand)), port: \(String(describing: port)), runtime: \(String(describing: runtime)), runtimeEnvironmentVariables: \(String(describing: runtimeEnvironmentVariables)), startCommand: \(String(describing: startCommand)))"}
}

/// <p>Describes the basic configuration needed for building and running an AWS App Runner service. This type doesn't support the full set of possible
///       configuration options. Fur full configuration capabilities, use a <code>apprunner.yaml</code> file in the source code repository.</p>
public struct CodeConfigurationValues: Equatable {
    /// <p>The command App Runner runs to build your application.</p>
    public let buildCommand: String?
    /// <p>The port that your application listens to in the container.</p>
    ///          <p>Default: <code>8080</code>
    ///          </p>
    public let port: String?
    /// <p>A runtime environment type for building and running an App Runner service.
    ///        It represents a
    ///       programming language runtime.</p>
    public let runtime: Runtime?
    /// <p>The environment variables that are available to your running App Runner service. An array of key-value pairs. Keys with a prefix of
    ///         <code>AWSAPPRUNNER</code> are reserved for system use and aren't valid.</p>
    public let runtimeEnvironmentVariables: [String:String]?
    /// <p>The command App Runner runs to start your application.</p>
    public let startCommand: String?

    public init (
        buildCommand: String? = nil,
        port: String? = nil,
        runtime: Runtime? = nil,
        runtimeEnvironmentVariables: [String:String]? = nil,
        startCommand: String? = nil
    )
    {
        self.buildCommand = buildCommand
        self.port = port
        self.runtime = runtime
        self.runtimeEnvironmentVariables = runtimeEnvironmentVariables
        self.startCommand = startCommand
    }
}

extension CodeRepository: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeConfiguration = "CodeConfiguration"
        case repositoryUrl = "RepositoryUrl"
        case sourceCodeVersion = "SourceCodeVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeConfiguration = codeConfiguration {
            try encodeContainer.encode(codeConfiguration, forKey: .codeConfiguration)
        }
        if let repositoryUrl = repositoryUrl {
            try encodeContainer.encode(repositoryUrl, forKey: .repositoryUrl)
        }
        if let sourceCodeVersion = sourceCodeVersion {
            try encodeContainer.encode(sourceCodeVersion, forKey: .sourceCodeVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryUrl)
        repositoryUrl = repositoryUrlDecoded
        let sourceCodeVersionDecoded = try containerValues.decodeIfPresent(SourceCodeVersion.self, forKey: .sourceCodeVersion)
        sourceCodeVersion = sourceCodeVersionDecoded
        let codeConfigurationDecoded = try containerValues.decodeIfPresent(CodeConfiguration.self, forKey: .codeConfiguration)
        codeConfiguration = codeConfigurationDecoded
    }
}

extension CodeRepository: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeRepository(codeConfiguration: \(String(describing: codeConfiguration)), repositoryUrl: \(String(describing: repositoryUrl)), sourceCodeVersion: \(String(describing: sourceCodeVersion)))"}
}

/// <p>Describes a source code repository.</p>
public struct CodeRepository: Equatable {
    /// <p>Configuration for building and running the service from a source code repository.</p>
    public let codeConfiguration: CodeConfiguration?
    /// <p>The location of the repository that contains the source code.</p>
    public let repositoryUrl: String?
    /// <p>The version that should be used within the source code repository.</p>
    public let sourceCodeVersion: SourceCodeVersion?

    public init (
        codeConfiguration: CodeConfiguration? = nil,
        repositoryUrl: String? = nil,
        sourceCodeVersion: SourceCodeVersion? = nil
    )
    {
        self.codeConfiguration = codeConfiguration
        self.repositoryUrl = repositoryUrl
        self.sourceCodeVersion = sourceCodeVersion
    }
}

public enum ConfigurationSource {
    case api
    case repository
    case sdkUnknown(String)
}

extension ConfigurationSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationSource] {
        return [
            .api,
            .repository,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .api: return "API"
        case .repository: return "REPOSITORY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationSource(rawValue: rawValue) ?? ConfigurationSource.sdkUnknown(rawValue)
    }
}

extension Connection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionName = "ConnectionName"
        case createdAt = "CreatedAt"
        case providerType = "ProviderType"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension Connection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Connection(connectionArn: \(String(describing: connectionArn)), connectionName: \(String(describing: connectionName)), createdAt: \(String(describing: createdAt)), providerType: \(String(describing: providerType)), status: \(String(describing: status)))"}
}

/// <p>Describes an AWS App Runner connection resource.</p>
public struct Connection: Equatable {
    /// <p>The Amazon Resource Name (ARN) of this connection.</p>
    public let connectionArn: String?
    /// <p>The customer-provided connection name.</p>
    public let connectionName: String?
    /// <p>The App Runner connection creation time, expressed as a Unix time stamp.</p>
    public let createdAt: Date?
    /// <p>The source repository provider.</p>
    public let providerType: ProviderType?
    /// <p>The current state of the App Runner connection. When the state is <code>AVAILABLE</code>, you can use the connection to create an App Runner service.</p>
    public let status: ConnectionStatus?

    public init (
        connectionArn: String? = nil,
        connectionName: String? = nil,
        createdAt: Date? = nil,
        providerType: ProviderType? = nil,
        status: ConnectionStatus? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionName = connectionName
        self.createdAt = createdAt
        self.providerType = providerType
        self.status = status
    }
}

public enum ConnectionStatus {
    case available
    case deleted
    case error
    case pendingHandshake
    case sdkUnknown(String)
}

extension ConnectionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionStatus] {
        return [
            .available,
            .deleted,
            .error,
            .pendingHandshake,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleted: return "DELETED"
        case .error: return "ERROR"
        case .pendingHandshake: return "PENDING_HANDSHAKE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
    }
}

extension ConnectionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionName = "ConnectionName"
        case createdAt = "CreatedAt"
        case providerType = "ProviderType"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension ConnectionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionSummary(connectionArn: \(String(describing: connectionArn)), connectionName: \(String(describing: connectionName)), createdAt: \(String(describing: createdAt)), providerType: \(String(describing: providerType)), status: \(String(describing: status)))"}
}

/// <p>Provides summary information about an AWS App Runner connection resource.</p>
public struct ConnectionSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of this connection.</p>
    public let connectionArn: String?
    /// <p>The customer-provided connection name.</p>
    public let connectionName: String?
    /// <p>The App Runner connection creation time, expressed as a Unix time stamp.</p>
    public let createdAt: Date?
    /// <p>The source repository provider.</p>
    public let providerType: ProviderType?
    /// <p>The current state of the App Runner connection. When the state is <code>AVAILABLE</code>, you can use the connection to create an App Runner service.</p>
    public let status: ConnectionStatus?

    public init (
        connectionArn: String? = nil,
        connectionName: String? = nil,
        createdAt: Date? = nil,
        providerType: ProviderType? = nil,
        status: ConnectionStatus? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionName = connectionName
        self.createdAt = createdAt
        self.providerType = providerType
        self.status = status
    }
}

public struct CreateAutoScalingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateAutoScalingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAutoScalingConfigurationInput>
    public typealias MOutput = OperationOutput<CreateAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAutoScalingConfigurationOutputError>
}

extension CreateAutoScalingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAutoScalingConfigurationInput(autoScalingConfigurationName: \(String(describing: autoScalingConfigurationName)), maxConcurrency: \(String(describing: maxConcurrency)), maxSize: \(String(describing: maxSize)), minSize: \(String(describing: minSize)), tags: \(String(describing: tags)))"}
}

extension CreateAutoScalingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxSize = maxSize {
            try encodeContainer.encode(maxSize, forKey: .maxSize)
        }
        if let minSize = minSize {
            try encodeContainer.encode(minSize, forKey: .minSize)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateAutoScalingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAutoScalingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAutoScalingConfigurationInput>
    public typealias MOutput = OperationOutput<CreateAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAutoScalingConfigurationOutputError>
}

public struct CreateAutoScalingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAutoScalingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAutoScalingConfigurationInput>
    public typealias MOutput = OperationOutput<CreateAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAutoScalingConfigurationOutputError>
}

public struct CreateAutoScalingConfigurationInput: Equatable {
    /// <p>A name for the auto scaling configuration. When you use it for the first time in an AWS Region, App Runner creates revision number <code>1</code> of this
    ///       name. When you use the same name in subsequent calls, App Runner creates incremental revisions of the configuration.</p>
    public let autoScalingConfigurationName: String?
    /// <p>The maximum number of concurrent requests that you want an instance to process. If the number of concurrent requests exceeds this limit, App Runner scales
    ///       up your service.</p>
    ///          <p>Default: <code>100</code>
    ///          </p>
    public let maxConcurrency: Int?
    /// <p>The maximum number of instances that your service scales up to. At most <code>MaxSize</code> instances actively serve traffic for your service.</p>
    ///          <p>Default: <code>25</code>
    ///          </p>
    public let maxSize: Int?
    /// <p>The minimum number of instances that App Runner provisions for your service. The service always has at least <code>MinSize</code> provisioned instances.
    ///       Some of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to
    ///       be quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset.</p>
    ///          <p>App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code.</p>
    ///          <p>Default: <code>1</code>
    ///          </p>
    public let minSize: Int?
    /// <p>A list of metadata items that you can associate with your auto scaling configuration resource. A tag is a key-value pair.</p>
    public let tags: [Tag]?

    public init (
        autoScalingConfigurationName: String? = nil,
        maxConcurrency: Int? = nil,
        maxSize: Int? = nil,
        minSize: Int? = nil,
        tags: [Tag]? = nil
    )
    {
        self.autoScalingConfigurationName = autoScalingConfigurationName
        self.maxConcurrency = maxConcurrency
        self.maxSize = maxSize
        self.minSize = minSize
        self.tags = tags
    }
}

struct CreateAutoScalingConfigurationInputBody: Equatable {
    public let autoScalingConfigurationName: String?
    public let maxConcurrency: Int?
    public let minSize: Int?
    public let maxSize: Int?
    public let tags: [Tag]?
}

extension CreateAutoScalingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let minSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minSize)
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAutoScalingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAutoScalingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAutoScalingConfigurationOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAutoScalingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAutoScalingConfigurationOutputResponse(autoScalingConfiguration: \(String(describing: autoScalingConfiguration)))"}
}

extension CreateAutoScalingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAutoScalingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.autoScalingConfiguration = output.autoScalingConfiguration
        } else {
            self.autoScalingConfiguration = nil
        }
    }
}

public struct CreateAutoScalingConfigurationOutputResponse: Equatable {
    /// <p>A description of the App Runner auto scaling configuration that's created by this request.</p>
    public let autoScalingConfiguration: AutoScalingConfiguration?

    public init (
        autoScalingConfiguration: AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

struct CreateAutoScalingConfigurationOutputResponseBody: Equatable {
    public let autoScalingConfiguration: AutoScalingConfiguration?
}

extension CreateAutoScalingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfiguration = "AutoScalingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
    }
}

public struct CreateConnectionInputBodyMiddleware: Middleware {
    public let id: String = "CreateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

extension CreateConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionInput(connectionName: \(String(describing: connectionName)), providerType: \(String(describing: providerType)), tags: \(String(describing: tags)))"}
}

extension CreateConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionName = "ConnectionName"
        case providerType = "ProviderType"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInput: Equatable {
    /// <p>A name for the new connection. It must be unique across all App Runner connections for the AWS account in the AWS Region.</p>
    public let connectionName: String?
    /// <p>The source repository provider.</p>
    public let providerType: ProviderType?
    /// <p>A list of metadata items that you can associate with your connection resource. A tag is a key-value pair.</p>
    public let tags: [Tag]?

    public init (
        connectionName: String? = nil,
        providerType: ProviderType? = nil,
        tags: [Tag]? = nil
    )
    {
        self.connectionName = connectionName
        self.providerType = providerType
        self.tags = tags
    }
}

struct CreateConnectionInputBody: Equatable {
    public let connectionName: String?
    public let providerType: ProviderType?
    public let tags: [Tag]?
}

extension CreateConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionName = "ConnectionName"
        case providerType = "ProviderType"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionOutputResponse(connection: \(String(describing: connection)))"}
}

extension CreateConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct CreateConnectionOutputResponse: Equatable {
    /// <p>A description of the App Runner connection that's created by this request.</p>
    public let connection: Connection?

    public init (
        connection: Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct CreateConnectionOutputResponseBody: Equatable {
    public let connection: Connection?
}

extension CreateConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct CreateServiceInputBodyMiddleware: Middleware {
    public let id: String = "CreateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceInput>
    public typealias MOutput = OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceOutputError>
}

extension CreateServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceInput(autoScalingConfigurationArn: \(String(describing: autoScalingConfigurationArn)), encryptionConfiguration: \(String(describing: encryptionConfiguration)), healthCheckConfiguration: \(String(describing: healthCheckConfiguration)), instanceConfiguration: \(String(describing: instanceConfiguration)), serviceName: \(String(describing: serviceName)), sourceConfiguration: \(String(describing: sourceConfiguration)), tags: \(String(describing: tags)))"}
}

extension CreateServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case encryptionConfiguration = "EncryptionConfiguration"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceName = "ServiceName"
        case sourceConfiguration = "SourceConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let healthCheckConfiguration = healthCheckConfiguration {
            try encodeContainer.encode(healthCheckConfiguration, forKey: .healthCheckConfiguration)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let sourceConfiguration = sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateServiceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceInput>
    public typealias MOutput = OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceInput>
    public typealias MOutput = OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceOutputError>
}

public struct CreateServiceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service. If not provided, App Runner
    ///       associates the latest revision of a default auto scaling configuration.</p>
    public let autoScalingConfigurationArn: String?
    /// <p>An optional custom encryption key that App Runner uses to encrypt the copy of your source repository that it maintains and your service logs. By default,
    ///       App Runner uses an AWS managed CMK.</p>
    public let encryptionConfiguration: EncryptionConfiguration?
    /// <p>The settings for the health check that AWS App Runner performs to monitor the health of your service.</p>
    public let healthCheckConfiguration: HealthCheckConfiguration?
    /// <p>The runtime configuration of instances (scaling units) of the App Runner service.</p>
    public let instanceConfiguration: InstanceConfiguration?
    /// <p>A name for the new service. It must be unique across all the running App Runner services in your AWS account in the AWS Region.</p>
    public let serviceName: String?
    /// <p>The source to deploy to the App Runner service. It can be a code or an image repository.</p>
    public let sourceConfiguration: SourceConfiguration?
    /// <p>An optional list of metadata items that you can associate with your service resource. A tag is a key-value pair.</p>
    public let tags: [Tag]?

    public init (
        autoScalingConfigurationArn: String? = nil,
        encryptionConfiguration: EncryptionConfiguration? = nil,
        healthCheckConfiguration: HealthCheckConfiguration? = nil,
        instanceConfiguration: InstanceConfiguration? = nil,
        serviceName: String? = nil,
        sourceConfiguration: SourceConfiguration? = nil,
        tags: [Tag]? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.encryptionConfiguration = encryptionConfiguration
        self.healthCheckConfiguration = healthCheckConfiguration
        self.instanceConfiguration = instanceConfiguration
        self.serviceName = serviceName
        self.sourceConfiguration = sourceConfiguration
        self.tags = tags
    }
}

struct CreateServiceInputBody: Equatable {
    public let serviceName: String?
    public let sourceConfiguration: SourceConfiguration?
    public let instanceConfiguration: InstanceConfiguration?
    public let tags: [Tag]?
    public let encryptionConfiguration: EncryptionConfiguration?
    public let healthCheckConfiguration: HealthCheckConfiguration?
    public let autoScalingConfigurationArn: String?
}

extension CreateServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case encryptionConfiguration = "EncryptionConfiguration"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceName = "ServiceName"
        case sourceConfiguration = "SourceConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let healthCheckConfigurationDecoded = try containerValues.decodeIfPresent(HealthCheckConfiguration.self, forKey: .healthCheckConfiguration)
        healthCheckConfiguration = healthCheckConfigurationDecoded
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
    }
}

extension CreateServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceOutputResponse(operationId: \(String(describing: operationId)), service: \(String(describing: service)))"}
}

extension CreateServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateServiceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct CreateServiceOutputResponse: Equatable {
    /// <p>The unique ID of the asynchronous operation that this request started. You can use it combined with the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_ListOperations.html">ListOperations</a> call to track the operation's progress.</p>
    public let operationId: String?
    /// <p>A description of the App Runner service that's created by this request.</p>
    public let service: Service?

    public init (
        operationId: String? = nil,
        service: Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct CreateServiceOutputResponseBody: Equatable {
    public let service: Service?
    public let operationId: String?
}

extension CreateServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension CustomDomain: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateValidationRecords = "CertificateValidationRecords"
        case domainName = "DomainName"
        case enableWWWSubdomain = "EnableWWWSubdomain"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateValidationRecords = certificateValidationRecords {
            var certificateValidationRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateValidationRecords)
            for certificatevalidationrecordlist0 in certificateValidationRecords {
                try certificateValidationRecordsContainer.encode(certificatevalidationrecordlist0)
            }
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let enableWWWSubdomain = enableWWWSubdomain {
            try encodeContainer.encode(enableWWWSubdomain, forKey: .enableWWWSubdomain)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let enableWWWSubdomainDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableWWWSubdomain)
        enableWWWSubdomain = enableWWWSubdomainDecoded
        let certificateValidationRecordsContainer = try containerValues.decodeIfPresent([CertificateValidationRecord?].self, forKey: .certificateValidationRecords)
        var certificateValidationRecordsDecoded0:[CertificateValidationRecord]? = nil
        if let certificateValidationRecordsContainer = certificateValidationRecordsContainer {
            certificateValidationRecordsDecoded0 = [CertificateValidationRecord]()
            for structure0 in certificateValidationRecordsContainer {
                if let structure0 = structure0 {
                    certificateValidationRecordsDecoded0?.append(structure0)
                }
            }
        }
        certificateValidationRecords = certificateValidationRecordsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(CustomDomainAssociationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CustomDomain: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomDomain(certificateValidationRecords: \(String(describing: certificateValidationRecords)), domainName: \(String(describing: domainName)), enableWWWSubdomain: \(String(describing: enableWWWSubdomain)), status: \(String(describing: status)))"}
}

/// <p>Describes a custom domain that's associated with an AWS App Runner service.</p>
public struct CustomDomain: Equatable {
    /// <p>A list of certificate CNAME records that's used for this domain name.</p>
    public let certificateValidationRecords: [CertificateValidationRecord]?
    /// <p>An associated custom domain endpoint. It can be a root domain (for example, <code>example.com</code>), a subdomain (for example,
    ///         <code>login.example.com</code> or <code>admin.login.example.com</code>), or a wildcard (for example, <code>*.example.com</code>).</p>
    public let domainName: String?
    /// <p>When <code>true</code>, the subdomain <code>www.<i>DomainName</i>
    ///             </code> is associated with the App Runner service in addition to the base
    ///       domain.</p>
    public let enableWWWSubdomain: Bool?
    /// <p>The current state of the domain name association.</p>
    public let status: CustomDomainAssociationStatus?

    public init (
        certificateValidationRecords: [CertificateValidationRecord]? = nil,
        domainName: String? = nil,
        enableWWWSubdomain: Bool? = nil,
        status: CustomDomainAssociationStatus? = nil
    )
    {
        self.certificateValidationRecords = certificateValidationRecords
        self.domainName = domainName
        self.enableWWWSubdomain = enableWWWSubdomain
        self.status = status
    }
}

public enum CustomDomainAssociationStatus {
    case active
    case bindingCertificate
    case createFailed
    case creating
    case deleteFailed
    case deleting
    case pendingCertificateDnsValidation
    case sdkUnknown(String)
}

extension CustomDomainAssociationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomDomainAssociationStatus] {
        return [
            .active,
            .bindingCertificate,
            .createFailed,
            .creating,
            .deleteFailed,
            .deleting,
            .pendingCertificateDnsValidation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .bindingCertificate: return "BINDING_CERTIFICATE"
        case .createFailed: return "CREATE_FAILED"
        case .creating: return "CREATING"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleting: return "DELETING"
        case .pendingCertificateDnsValidation: return "PENDING_CERTIFICATE_DNS_VALIDATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomDomainAssociationStatus(rawValue: rawValue) ?? CustomDomainAssociationStatus.sdkUnknown(rawValue)
    }
}

public struct DeleteAutoScalingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAutoScalingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAutoScalingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAutoScalingConfigurationOutputError>
}

extension DeleteAutoScalingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAutoScalingConfigurationInput(autoScalingConfigurationArn: \(String(describing: autoScalingConfigurationArn)))"}
}

extension DeleteAutoScalingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
    }
}

public struct DeleteAutoScalingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAutoScalingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAutoScalingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAutoScalingConfigurationOutputError>
}

public struct DeleteAutoScalingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAutoScalingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAutoScalingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAutoScalingConfigurationOutputError>
}

public struct DeleteAutoScalingConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want to delete.</p>
    ///          <p>The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either <code>.../<i>name</i>
    ///             </code> or
    ///           <code>.../<i>name</i>/<i>revision</i>
    ///             </code>. If a revision isn't specified, the latest active revision is deleted.</p>
    public let autoScalingConfigurationArn: String?

    public init (
        autoScalingConfigurationArn: String? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
    }
}

struct DeleteAutoScalingConfigurationInputBody: Equatable {
    public let autoScalingConfigurationArn: String?
}

extension DeleteAutoScalingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
    }
}

extension DeleteAutoScalingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAutoScalingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAutoScalingConfigurationOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAutoScalingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAutoScalingConfigurationOutputResponse(autoScalingConfiguration: \(String(describing: autoScalingConfiguration)))"}
}

extension DeleteAutoScalingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteAutoScalingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.autoScalingConfiguration = output.autoScalingConfiguration
        } else {
            self.autoScalingConfiguration = nil
        }
    }
}

public struct DeleteAutoScalingConfigurationOutputResponse: Equatable {
    /// <p>A description of the App Runner auto scaling configuration that this request just deleted.</p>
    public let autoScalingConfiguration: AutoScalingConfiguration?

    public init (
        autoScalingConfiguration: AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

struct DeleteAutoScalingConfigurationOutputResponseBody: Equatable {
    public let autoScalingConfiguration: AutoScalingConfiguration?
}

extension DeleteAutoScalingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfiguration = "AutoScalingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
    }
}

public struct DeleteConnectionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

extension DeleteConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionInput(connectionArn: \(String(describing: connectionArn)))"}
}

extension DeleteConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
    }
}

public struct DeleteConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner connection that you want to delete.</p>
    public let connectionArn: String?

    public init (
        connectionArn: String? = nil
    )
    {
        self.connectionArn = connectionArn
    }
}

struct DeleteConnectionInputBody: Equatable {
    public let connectionArn: String?
}

extension DeleteConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
    }
}

extension DeleteConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionOutputResponse(connection: \(String(describing: connection)))"}
}

extension DeleteConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct DeleteConnectionOutputResponse: Equatable {
    /// <p>A description of the App Runner connection that this request just deleted.</p>
    public let connection: Connection?

    public init (
        connection: Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteConnectionOutputResponseBody: Equatable {
    public let connection: Connection?
}

extension DeleteConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct DeleteServiceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceOutputError>
}

extension DeleteServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceInput(serviceArn: \(String(describing: serviceArn)))"}
}

extension DeleteServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct DeleteServiceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to delete.</p>
    public let serviceArn: String?

    public init (
        serviceArn: String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct DeleteServiceInputBody: Equatable {
    public let serviceArn: String?
}

extension DeleteServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension DeleteServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceOutputResponse(operationId: \(String(describing: operationId)), service: \(String(describing: service)))"}
}

extension DeleteServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteServiceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct DeleteServiceOutputResponse: Equatable {
    /// <p>The unique ID of the asynchronous operation that this request started. You can use it combined with the <a>ListOperations</a> call to track
    ///       the operation's progress.</p>
    public let operationId: String?
    /// <p>A description of the App Runner service that this request just deleted.</p>
    public let service: Service?

    public init (
        operationId: String? = nil,
        service: Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct DeleteServiceOutputResponseBody: Equatable {
    public let service: Service?
    public let operationId: String?
}

extension DeleteServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct DescribeAutoScalingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAutoScalingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAutoScalingConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAutoScalingConfigurationOutputError>
}

extension DescribeAutoScalingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAutoScalingConfigurationInput(autoScalingConfigurationArn: \(String(describing: autoScalingConfigurationArn)))"}
}

extension DescribeAutoScalingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
    }
}

public struct DescribeAutoScalingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAutoScalingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAutoScalingConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAutoScalingConfigurationOutputError>
}

public struct DescribeAutoScalingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAutoScalingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAutoScalingConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAutoScalingConfigurationOutputError>
}

public struct DescribeAutoScalingConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want a description for.</p>
    ///          <p>The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either <code>.../<i>name</i>
    ///             </code> or
    ///           <code>.../<i>name</i>/<i>revision</i>
    ///             </code>. If a revision isn't specified, the latest active revision is
    ///       described.</p>
    public let autoScalingConfigurationArn: String?

    public init (
        autoScalingConfigurationArn: String? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
    }
}

struct DescribeAutoScalingConfigurationInputBody: Equatable {
    public let autoScalingConfigurationArn: String?
}

extension DescribeAutoScalingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
    }
}

extension DescribeAutoScalingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAutoScalingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAutoScalingConfigurationOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAutoScalingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAutoScalingConfigurationOutputResponse(autoScalingConfiguration: \(String(describing: autoScalingConfiguration)))"}
}

extension DescribeAutoScalingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAutoScalingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.autoScalingConfiguration = output.autoScalingConfiguration
        } else {
            self.autoScalingConfiguration = nil
        }
    }
}

public struct DescribeAutoScalingConfigurationOutputResponse: Equatable {
    /// <p>A full description of the App Runner auto scaling configuration that you specified in this request.</p>
    public let autoScalingConfiguration: AutoScalingConfiguration?

    public init (
        autoScalingConfiguration: AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

struct DescribeAutoScalingConfigurationOutputResponseBody: Equatable {
    public let autoScalingConfiguration: AutoScalingConfiguration?
}

extension DescribeAutoScalingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfiguration = "AutoScalingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
    }
}

public struct DescribeCustomDomainsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCustomDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomDomainsInput>
    public typealias MOutput = OperationOutput<DescribeCustomDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomDomainsOutputError>
}

extension DescribeCustomDomainsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomDomainsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serviceArn: \(String(describing: serviceArn)))"}
}

extension DescribeCustomDomainsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct DescribeCustomDomainsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCustomDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomDomainsInput>
    public typealias MOutput = OperationOutput<DescribeCustomDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomDomainsOutputError>
}

public struct DescribeCustomDomainsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCustomDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomDomainsInput>
    public typealias MOutput = OperationOutput<DescribeCustomDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomDomainsOutputError>
}

public struct DescribeCustomDomainsInput: Equatable {
    /// <p>The maximum number of results that each response (result page) can include. It's used for a paginated request.</p>
    ///          <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
    public let maxResults: Int?
    /// <p>A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be
    ///       identical to the ones that are specified in the initial request.</p>
    ///          <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want associated custom domain names to be described for.</p>
    public let serviceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serviceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

struct DescribeCustomDomainsInputBody: Equatable {
    public let serviceArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeCustomDomainsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeCustomDomainsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomDomainsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomDomainsOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomDomainsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomDomainsOutputResponse(customDomains: \(String(describing: customDomains)), dNSTarget: \(String(describing: dNSTarget)), nextToken: \(String(describing: nextToken)), serviceArn: \(String(describing: serviceArn)))"}
}

extension DescribeCustomDomainsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCustomDomainsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customDomains = output.customDomains
            self.dNSTarget = output.dNSTarget
            self.nextToken = output.nextToken
            self.serviceArn = output.serviceArn
        } else {
            self.customDomains = nil
            self.dNSTarget = nil
            self.nextToken = nil
            self.serviceArn = nil
        }
    }
}

public struct DescribeCustomDomainsOutputResponse: Equatable {
    /// <p>A list of descriptions of custom domain names that are associated with the service. In a paginated request, the request returns up to
    ///         <code>MaxResults</code> records per call.</p>
    public let customDomains: [CustomDomain]?
    /// <p>The App Runner subdomain of the App Runner service. The associated custom domain names are mapped to this target name.</p>
    public let dNSTarget: String?
    /// <p>The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service whose associated custom domain names you want to describe.</p>
    public let serviceArn: String?

    public init (
        customDomains: [CustomDomain]? = nil,
        dNSTarget: String? = nil,
        nextToken: String? = nil,
        serviceArn: String? = nil
    )
    {
        self.customDomains = customDomains
        self.dNSTarget = dNSTarget
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

struct DescribeCustomDomainsOutputResponseBody: Equatable {
    public let dNSTarget: String?
    public let serviceArn: String?
    public let customDomains: [CustomDomain]?
    public let nextToken: String?
}

extension DescribeCustomDomainsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customDomains = "CustomDomains"
        case dNSTarget = "DNSTarget"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dNSTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dNSTarget)
        dNSTarget = dNSTargetDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let customDomainsContainer = try containerValues.decodeIfPresent([CustomDomain?].self, forKey: .customDomains)
        var customDomainsDecoded0:[CustomDomain]? = nil
        if let customDomainsContainer = customDomainsContainer {
            customDomainsDecoded0 = [CustomDomain]()
            for structure0 in customDomainsContainer {
                if let structure0 = structure0 {
                    customDomainsDecoded0?.append(structure0)
                }
            }
        }
        customDomains = customDomainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeServiceInputBodyMiddleware: Middleware {
    public let id: String = "DescribeServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceInput>
    public typealias MOutput = OperationOutput<DescribeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceOutputError>
}

extension DescribeServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServiceInput(serviceArn: \(String(describing: serviceArn)))"}
}

extension DescribeServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct DescribeServiceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceInput>
    public typealias MOutput = OperationOutput<DescribeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceOutputError>
}

public struct DescribeServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceInput>
    public typealias MOutput = OperationOutput<DescribeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceOutputError>
}

public struct DescribeServiceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want a description for.</p>
    public let serviceArn: String?

    public init (
        serviceArn: String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct DescribeServiceInputBody: Equatable {
    public let serviceArn: String?
}

extension DescribeServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension DescribeServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServiceOutputResponse(service: \(String(describing: service)))"}
}

extension DescribeServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeServiceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct DescribeServiceOutputResponse: Equatable {
    /// <p>A full description of the App Runner service that you specified in this request.</p>
    public let service: Service?

    public init (
        service: Service? = nil
    )
    {
        self.service = service
    }
}

struct DescribeServiceOutputResponseBody: Equatable {
    public let service: Service?
}

extension DescribeServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case service = "Service"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Service.self, forKey: .service)
        service = serviceDecoded
    }
}

public struct DisassociateCustomDomainInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateCustomDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateCustomDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateCustomDomainInput>
    public typealias MOutput = OperationOutput<DisassociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateCustomDomainOutputError>
}

extension DisassociateCustomDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateCustomDomainInput(domainName: \(String(describing: domainName)), serviceArn: \(String(describing: serviceArn)))"}
}

extension DisassociateCustomDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct DisassociateCustomDomainInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateCustomDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateCustomDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateCustomDomainInput>
    public typealias MOutput = OperationOutput<DisassociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateCustomDomainOutputError>
}

public struct DisassociateCustomDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateCustomDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateCustomDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateCustomDomainInput>
    public typealias MOutput = OperationOutput<DisassociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateCustomDomainOutputError>
}

public struct DisassociateCustomDomainInput: Equatable {
    /// <p>The domain name that you want to disassociate from the App Runner service.</p>
    public let domainName: String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to disassociate a custom domain name from.</p>
    public let serviceArn: String?

    public init (
        domainName: String? = nil,
        serviceArn: String? = nil
    )
    {
        self.domainName = domainName
        self.serviceArn = serviceArn
    }
}

struct DisassociateCustomDomainInputBody: Equatable {
    public let serviceArn: String?
    public let domainName: String?
}

extension DisassociateCustomDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DisassociateCustomDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateCustomDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateCustomDomainOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateCustomDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateCustomDomainOutputResponse(customDomain: \(String(describing: customDomain)), dNSTarget: \(String(describing: dNSTarget)), serviceArn: \(String(describing: serviceArn)))"}
}

extension DisassociateCustomDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateCustomDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customDomain = output.customDomain
            self.dNSTarget = output.dNSTarget
            self.serviceArn = output.serviceArn
        } else {
            self.customDomain = nil
            self.dNSTarget = nil
            self.serviceArn = nil
        }
    }
}

public struct DisassociateCustomDomainOutputResponse: Equatable {
    /// <p>A description of the domain name that's being disassociated.</p>
    public let customDomain: CustomDomain?
    /// <p>The App Runner subdomain of the App Runner service. The disassociated custom domain name was mapped to this target name.</p>
    public let dNSTarget: String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that a custom domain name is disassociated from.</p>
    public let serviceArn: String?

    public init (
        customDomain: CustomDomain? = nil,
        dNSTarget: String? = nil,
        serviceArn: String? = nil
    )
    {
        self.customDomain = customDomain
        self.dNSTarget = dNSTarget
        self.serviceArn = serviceArn
    }
}

struct DisassociateCustomDomainOutputResponseBody: Equatable {
    public let dNSTarget: String?
    public let serviceArn: String?
    public let customDomain: CustomDomain?
}

extension DisassociateCustomDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customDomain = "CustomDomain"
        case dNSTarget = "DNSTarget"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dNSTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dNSTarget)
        dNSTarget = dNSTargetDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(CustomDomain.self, forKey: .customDomain)
        customDomain = customDomainDecoded
    }
}

extension EncryptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKey = "KmsKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKey = kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension EncryptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionConfiguration(kmsKey: \(String(describing: kmsKey)))"}
}

/// <p>Describes a custom encryption key that AWS App Runner uses to encrypt copies of the source repository and service logs.</p>
public struct EncryptionConfiguration: Equatable {
    /// <p>The ARN of the KMS key that's used for encryption.</p>
    public let kmsKey: String?

    public init (
        kmsKey: String? = nil
    )
    {
        self.kmsKey = kmsKey
    }
}

extension HealthCheckConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case healthyThreshold = "HealthyThreshold"
        case interval = "Interval"
        case path = "Path"
        case `protocol` = "Protocol"
        case timeout = "Timeout"
        case unhealthyThreshold = "UnhealthyThreshold"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthyThreshold = healthyThreshold {
            try encodeContainer.encode(healthyThreshold, forKey: .healthyThreshold)
        }
        if let interval = interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let unhealthyThreshold = unhealthyThreshold {
            try encodeContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(HealthCheckProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .interval)
        interval = intervalDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let healthyThresholdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthyThreshold)
        healthyThreshold = healthyThresholdDecoded
        let unhealthyThresholdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .unhealthyThreshold)
        unhealthyThreshold = unhealthyThresholdDecoded
    }
}

extension HealthCheckConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HealthCheckConfiguration(healthyThreshold: \(String(describing: healthyThreshold)), interval: \(String(describing: interval)), path: \(String(describing: path)), protocol: \(String(describing: `protocol`)), timeout: \(String(describing: timeout)), unhealthyThreshold: \(String(describing: unhealthyThreshold)))"}
}

/// <p>Describes the settings for the health check that AWS App Runner performs to monitor the health of a service.</p>
public struct HealthCheckConfiguration: Equatable {
    /// <p>The IP protocol that App Runner uses to perform health checks for your service.</p>
    ///          <p>If you set <code>Protocol</code> to <code>HTTP</code>, App Runner sends health check requests to the HTTP path specified by <code>Path</code>.</p>
    ///          <p>Default: <code>TCP</code>
    ///          </p>
    public let `protocol`: HealthCheckProtocol?
    /// <p>The number of consecutive checks that must succeed before App Runner decides that the service is healthy.</p>
    ///          <p>Default: <code>3</code>
    ///          </p>
    public let healthyThreshold: Int?
    /// <p>The time interval, in seconds, between health checks.</p>
    ///          <p>Default: <code>5</code>
    ///          </p>
    public let interval: Int?
    /// <p>The URL that health check requests are sent to.</p>
    ///          <p>
    ///             <code>Path</code> is only applicable when you set <code>Protocol</code> to <code>HTTP</code>.</p>
    ///          <p>Default: <code>"/"</code>
    ///          </p>
    public let path: String?
    /// <p>The time, in seconds, to wait for a health check response before deciding it failed.</p>
    ///          <p>Default: <code>2</code>
    ///          </p>
    public let timeout: Int?
    /// <p>The number of consecutive checks that must fail before App Runner decides that the service is unhealthy.</p>
    ///          <p>Default: <code>3</code>
    ///          </p>
    public let unhealthyThreshold: Int?

    public init (
        `protocol`: HealthCheckProtocol? = nil,
        healthyThreshold: Int? = nil,
        interval: Int? = nil,
        path: String? = nil,
        timeout: Int? = nil,
        unhealthyThreshold: Int? = nil
    )
    {
        self.`protocol` = `protocol`
        self.healthyThreshold = healthyThreshold
        self.interval = interval
        self.path = path
        self.timeout = timeout
        self.unhealthyThreshold = unhealthyThreshold
    }
}

public enum HealthCheckProtocol {
    case http
    case tcp
    case sdkUnknown(String)
}

extension HealthCheckProtocol : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HealthCheckProtocol] {
        return [
            .http,
            .tcp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .http: return "HTTP"
        case .tcp: return "TCP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HealthCheckProtocol(rawValue: rawValue) ?? HealthCheckProtocol.sdkUnknown(rawValue)
    }
}

extension ImageConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case port = "Port"
        case runtimeEnvironmentVariables = "RuntimeEnvironmentVariables"
        case startCommand = "StartCommand"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let runtimeEnvironmentVariables = runtimeEnvironmentVariables {
            var runtimeEnvironmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .runtimeEnvironmentVariables)
            for (dictKey0, runtimeenvironmentvariables0) in runtimeEnvironmentVariables {
                try runtimeEnvironmentVariablesContainer.encode(runtimeenvironmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let startCommand = startCommand {
            try encodeContainer.encode(startCommand, forKey: .startCommand)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeEnvironmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .runtimeEnvironmentVariables)
        var runtimeEnvironmentVariablesDecoded0: [String:String]? = nil
        if let runtimeEnvironmentVariablesContainer = runtimeEnvironmentVariablesContainer {
            runtimeEnvironmentVariablesDecoded0 = [String:String]()
            for (key0, runtimeenvironmentvariablesvalue0) in runtimeEnvironmentVariablesContainer {
                if let runtimeenvironmentvariablesvalue0 = runtimeenvironmentvariablesvalue0 {
                    runtimeEnvironmentVariablesDecoded0?[key0] = runtimeenvironmentvariablesvalue0
                }
            }
        }
        runtimeEnvironmentVariables = runtimeEnvironmentVariablesDecoded0
        let startCommandDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startCommand)
        startCommand = startCommandDecoded
        let portDecoded = try containerValues.decodeIfPresent(String.self, forKey: .port)
        port = portDecoded
    }
}

extension ImageConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageConfiguration(port: \(String(describing: port)), runtimeEnvironmentVariables: \(String(describing: runtimeEnvironmentVariables)), startCommand: \(String(describing: startCommand)))"}
}

/// <p>Describes the configuration that AWS App Runner uses to run an App Runner service using an image pulled from a source image repository.</p>
public struct ImageConfiguration: Equatable {
    /// <p>The port that your application listens to in the container.</p>
    ///          <p>Default: <code>8080</code>
    ///          </p>
    public let port: String?
    /// <p>Environment variables that are available to your running App Runner service. An array of key-value pairs. Keys with a prefix of <code>AWSAPPRUNNER</code>
    ///       are reserved for system use and aren't valid.</p>
    public let runtimeEnvironmentVariables: [String:String]?
    /// <p>An optional command that App Runner runs to start the application in the source image. If specified, this command overrides the Docker image’s default start
    ///       command.</p>
    public let startCommand: String?

    public init (
        port: String? = nil,
        runtimeEnvironmentVariables: [String:String]? = nil,
        startCommand: String? = nil
    )
    {
        self.port = port
        self.runtimeEnvironmentVariables = runtimeEnvironmentVariables
        self.startCommand = startCommand
    }
}

extension ImageRepository: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageConfiguration = "ImageConfiguration"
        case imageIdentifier = "ImageIdentifier"
        case imageRepositoryType = "ImageRepositoryType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageConfiguration = imageConfiguration {
            try encodeContainer.encode(imageConfiguration, forKey: .imageConfiguration)
        }
        if let imageIdentifier = imageIdentifier {
            try encodeContainer.encode(imageIdentifier, forKey: .imageIdentifier)
        }
        if let imageRepositoryType = imageRepositoryType {
            try encodeContainer.encode(imageRepositoryType.rawValue, forKey: .imageRepositoryType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageIdentifier)
        imageIdentifier = imageIdentifierDecoded
        let imageConfigurationDecoded = try containerValues.decodeIfPresent(ImageConfiguration.self, forKey: .imageConfiguration)
        imageConfiguration = imageConfigurationDecoded
        let imageRepositoryTypeDecoded = try containerValues.decodeIfPresent(ImageRepositoryType.self, forKey: .imageRepositoryType)
        imageRepositoryType = imageRepositoryTypeDecoded
    }
}

extension ImageRepository: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageRepository(imageConfiguration: \(String(describing: imageConfiguration)), imageIdentifier: \(String(describing: imageIdentifier)), imageRepositoryType: \(String(describing: imageRepositoryType)))"}
}

/// <p>Describes a source image repository.</p>
public struct ImageRepository: Equatable {
    /// <p>Configuration for running the identified image.</p>
    public let imageConfiguration: ImageConfiguration?
    /// <p>The identifier of an image.</p>
    ///          <p>For an image in Amazon Elastic Container Registry (Amazon ECR), this is an image name. For the image name format, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-pull-ecr-image.html">Pulling an image</a> in the <i>Amazon ECR User Guide</i>.</p>
    public let imageIdentifier: String?
    /// <p>The type of the image repository. This reflects the repository provider and whether the repository is private or public.</p>
    public let imageRepositoryType: ImageRepositoryType?

    public init (
        imageConfiguration: ImageConfiguration? = nil,
        imageIdentifier: String? = nil,
        imageRepositoryType: ImageRepositoryType? = nil
    )
    {
        self.imageConfiguration = imageConfiguration
        self.imageIdentifier = imageIdentifier
        self.imageRepositoryType = imageRepositoryType
    }
}

public enum ImageRepositoryType {
    case ecr
    case ecrPublic
    case sdkUnknown(String)
}

extension ImageRepositoryType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageRepositoryType] {
        return [
            .ecr,
            .ecrPublic,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ecr: return "ECR"
        case .ecrPublic: return "ECR_PUBLIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageRepositoryType(rawValue: rawValue) ?? ImageRepositoryType.sdkUnknown(rawValue)
    }
}

extension InstanceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cpu = "Cpu"
        case instanceRoleArn = "InstanceRoleArn"
        case memory = "Memory"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpu = cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let instanceRoleArn = instanceRoleArn {
            try encodeContainer.encode(instanceRoleArn, forKey: .instanceRoleArn)
        }
        if let memory = memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cpu)
        cpu = cpuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memory)
        memory = memoryDecoded
        let instanceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceRoleArn)
        instanceRoleArn = instanceRoleArnDecoded
    }
}

extension InstanceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceConfiguration(cpu: \(String(describing: cpu)), instanceRoleArn: \(String(describing: instanceRoleArn)), memory: \(String(describing: memory)))"}
}

/// <p>Describes the runtime configuration of an AWS App Runner service instance (scaling unit).</p>
public struct InstanceConfiguration: Equatable {
    /// <p>The number of CPU units reserved for each instance of your App Runner service.</p>
    ///          <p>Default: <code>1 vCPU</code>
    ///          </p>
    public let cpu: String?
    /// <p>The Amazon Resource Name (ARN) of an IAM role that provides permissions to your App Runner service. These are permissions that your code needs when it calls
    ///       any AWS APIs.</p>
    public let instanceRoleArn: String?
    /// <p>The amount of memory, in MB or GB, reserved for each instance of your App Runner service.</p>
    ///          <p>Default: <code>2 GB</code>
    ///          </p>
    public let memory: String?

    public init (
        cpu: String? = nil,
        instanceRoleArn: String? = nil,
        memory: String? = nil
    )
    {
        self.cpu = cpu
        self.instanceRoleArn = instanceRoleArn
        self.memory = memory
    }
}

extension InternalServiceErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceErrorException(message: \(String(describing: message)))"}
}

extension InternalServiceErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An unexpected service exception occurred.</p>
public struct InternalServiceErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more input parameters aren't valid. Refer to the API action's document page, correct the input parameters, and try the action again.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidStateException(message: \(String(describing: message)))"}
}

extension InvalidStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't perform this action when the resource is in its current state.</p>
public struct InvalidStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAutoScalingConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "ListAutoScalingConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAutoScalingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAutoScalingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAutoScalingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListAutoScalingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAutoScalingConfigurationsOutputError>
}

extension ListAutoScalingConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAutoScalingConfigurationsInput(autoScalingConfigurationName: \(String(describing: autoScalingConfigurationName)), latestOnly: \(String(describing: latestOnly)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAutoScalingConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case latestOnly = "LatestOnly"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if latestOnly != false {
            try encodeContainer.encode(latestOnly, forKey: .latestOnly)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAutoScalingConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAutoScalingConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAutoScalingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAutoScalingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAutoScalingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListAutoScalingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAutoScalingConfigurationsOutputError>
}

public struct ListAutoScalingConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAutoScalingConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAutoScalingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAutoScalingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAutoScalingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListAutoScalingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAutoScalingConfigurationsOutputError>
}

public struct ListAutoScalingConfigurationsInput: Equatable {
    /// <p>The name of the App Runner auto scaling configuration that you want to list. If specified, App Runner lists revisions that share this name. If not specified, App Runner
    ///       returns revisions of all configurations.</p>
    public let autoScalingConfigurationName: String?
    /// <p>Set to <code>true</code> to list only the latest revision for each requested configuration name.</p>
    ///          <p>Keep as <code>false</code> to list all revisions for each requested configuration name.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let latestOnly: Bool
    /// <p>The maximum number of results to include in each response (result page). It's used for a paginated request.</p>
    ///          <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
    public let maxResults: Int?
    /// <p>A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be
    ///       identical to the ones that are specified in the initial request.</p>
    ///          <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
    public let nextToken: String?

    public init (
        autoScalingConfigurationName: String? = nil,
        latestOnly: Bool = false,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.autoScalingConfigurationName = autoScalingConfigurationName
        self.latestOnly = latestOnly
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAutoScalingConfigurationsInputBody: Equatable {
    public let autoScalingConfigurationName: String?
    public let latestOnly: Bool
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListAutoScalingConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case latestOnly = "LatestOnly"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let latestOnlyDecoded = try containerValues.decode(Bool.self, forKey: .latestOnly)
        latestOnly = latestOnlyDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAutoScalingConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAutoScalingConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAutoScalingConfigurationsOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAutoScalingConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAutoScalingConfigurationsOutputResponse(autoScalingConfigurationSummaryList: \(String(describing: autoScalingConfigurationSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAutoScalingConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAutoScalingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.autoScalingConfigurationSummaryList = output.autoScalingConfigurationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.autoScalingConfigurationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAutoScalingConfigurationsOutputResponse: Equatable {
    /// <p>A list of summary information records for auto scaling configurations. In a paginated request, the request returns up to <code>MaxResults</code>
    ///       records for each call.</p>
    public let autoScalingConfigurationSummaryList: [AutoScalingConfigurationSummary]?
    /// <p>The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.</p>
    public let nextToken: String?

    public init (
        autoScalingConfigurationSummaryList: [AutoScalingConfigurationSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.autoScalingConfigurationSummaryList = autoScalingConfigurationSummaryList
        self.nextToken = nextToken
    }
}

struct ListAutoScalingConfigurationsOutputResponseBody: Equatable {
    public let autoScalingConfigurationSummaryList: [AutoScalingConfigurationSummary]?
    public let nextToken: String?
}

extension ListAutoScalingConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationSummaryList = "AutoScalingConfigurationSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationSummaryListContainer = try containerValues.decodeIfPresent([AutoScalingConfigurationSummary?].self, forKey: .autoScalingConfigurationSummaryList)
        var autoScalingConfigurationSummaryListDecoded0:[AutoScalingConfigurationSummary]? = nil
        if let autoScalingConfigurationSummaryListContainer = autoScalingConfigurationSummaryListContainer {
            autoScalingConfigurationSummaryListDecoded0 = [AutoScalingConfigurationSummary]()
            for structure0 in autoScalingConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    autoScalingConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        autoScalingConfigurationSummaryList = autoScalingConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListConnectionsInputBodyMiddleware: Middleware {
    public let id: String = "ListConnectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectionsOutputError>
}

extension ListConnectionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConnectionsInput(connectionName: \(String(describing: connectionName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConnectionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionName = "ConnectionName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListConnectionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInput: Equatable {
    /// <p>If specified, only this connection is returned. If not specified, the result isn't filtered by name.</p>
    public let connectionName: String?
    /// <p>The maximum number of results to include in each response (result page). Used for a paginated request.</p>
    ///          <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
    public let maxResults: Int?
    /// <p>A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be
    ///       identical to the ones specified in the initial request.</p>
    ///          <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
    public let nextToken: String?

    public init (
        connectionName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.connectionName = connectionName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectionsInputBody: Equatable {
    public let connectionName: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListConnectionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionName = "ConnectionName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectionsOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConnectionsOutputResponse(connectionSummaryList: \(String(describing: connectionSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConnectionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectionSummaryList = output.connectionSummaryList
            self.nextToken = output.nextToken
        } else {
            self.connectionSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectionsOutputResponse: Equatable {
    /// <p>A list of summary information records for connections. In a paginated request, the request returns up to <code>MaxResults</code> records for each
    ///       call.</p>
    public let connectionSummaryList: [ConnectionSummary]?
    /// <p>The token that you can pass in a subsequent request to get the next result page. Returned in a paginated request.</p>
    public let nextToken: String?

    public init (
        connectionSummaryList: [ConnectionSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.connectionSummaryList = connectionSummaryList
        self.nextToken = nextToken
    }
}

struct ListConnectionsOutputResponseBody: Equatable {
    public let connectionSummaryList: [ConnectionSummary]?
    public let nextToken: String?
}

extension ListConnectionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionSummaryList = "ConnectionSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionSummaryListContainer = try containerValues.decodeIfPresent([ConnectionSummary?].self, forKey: .connectionSummaryList)
        var connectionSummaryListDecoded0:[ConnectionSummary]? = nil
        if let connectionSummaryListContainer = connectionSummaryListContainer {
            connectionSummaryListDecoded0 = [ConnectionSummary]()
            for structure0 in connectionSummaryListContainer {
                if let structure0 = structure0 {
                    connectionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        connectionSummaryList = connectionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOperationsInputBodyMiddleware: Middleware {
    public let id: String = "ListOperationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOperationsInput>
    public typealias MOutput = OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOperationsOutputError>
}

extension ListOperationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOperationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serviceArn: \(String(describing: serviceArn)))"}
}

extension ListOperationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct ListOperationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOperationsInput>
    public typealias MOutput = OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOperationsOutputError>
}

public struct ListOperationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOperationsInput>
    public typealias MOutput = OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOperationsOutputError>
}

public struct ListOperationsInput: Equatable {
    /// <p>The maximum number of results to include in each response (result page). It's used for a paginated request.</p>
    ///          <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
    public let maxResults: Int?
    /// <p>A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be
    ///       identical to the ones specified in the initial request.</p>
    ///          <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want a list of operations for.</p>
    public let serviceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serviceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

struct ListOperationsInputBody: Equatable {
    public let serviceArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListOperationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListOperationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOperationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOperationsOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOperationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOperationsOutputResponse(nextToken: \(String(describing: nextToken)), operationSummaryList: \(String(describing: operationSummaryList)))"}
}

extension ListOperationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOperationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.operationSummaryList = output.operationSummaryList
        } else {
            self.nextToken = nil
            self.operationSummaryList = nil
        }
    }
}

public struct ListOperationsOutputResponse: Equatable {
    /// <p>The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.</p>
    public let nextToken: String?
    /// <p>A list of operation summary information records. In a paginated request, the request returns up to <code>MaxResults</code> records for each
    ///       call.</p>
    public let operationSummaryList: [OperationSummary]?

    public init (
        nextToken: String? = nil,
        operationSummaryList: [OperationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.operationSummaryList = operationSummaryList
    }
}

struct ListOperationsOutputResponseBody: Equatable {
    public let operationSummaryList: [OperationSummary]?
    public let nextToken: String?
}

extension ListOperationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case operationSummaryList = "OperationSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationSummaryListContainer = try containerValues.decodeIfPresent([OperationSummary?].self, forKey: .operationSummaryList)
        var operationSummaryListDecoded0:[OperationSummary]? = nil
        if let operationSummaryListContainer = operationSummaryListContainer {
            operationSummaryListDecoded0 = [OperationSummary]()
            for structure0 in operationSummaryListContainer {
                if let structure0 = structure0 {
                    operationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        operationSummaryList = operationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListServicesInputBodyMiddleware: Middleware {
    public let id: String = "ListServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServicesInput>
    public typealias MOutput = OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServicesOutputError>
}

extension ListServicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServicesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListServicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListServicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServicesInput>
    public typealias MOutput = OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServicesOutputError>
}

public struct ListServicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServicesInput>
    public typealias MOutput = OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServicesOutputError>
}

public struct ListServicesInput: Equatable {
    /// <p>The maximum number of results to include in each response (result page). It's used for a paginated request.</p>
    ///          <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
    public let maxResults: Int?
    /// <p>A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be
    ///       identical to the ones specified in the initial request.</p>
    ///          <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListServicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicesOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServicesOutputResponse(nextToken: \(String(describing: nextToken)), serviceSummaryList: \(String(describing: serviceSummaryList)))"}
}

extension ListServicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.serviceSummaryList = output.serviceSummaryList
        } else {
            self.nextToken = nil
            self.serviceSummaryList = nil
        }
    }
}

public struct ListServicesOutputResponse: Equatable {
    /// <p>The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.</p>
    public let nextToken: String?
    /// <p>A list of service summary information records. In a paginated request, the request returns up to <code>MaxResults</code> records for each call.</p>
    public let serviceSummaryList: [ServiceSummary]?

    public init (
        nextToken: String? = nil,
        serviceSummaryList: [ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceSummaryList = serviceSummaryList
    }
}

struct ListServicesOutputResponseBody: Equatable {
    public let serviceSummaryList: [ServiceSummary]?
    public let nextToken: String?
}

extension ListServicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case serviceSummaryList = "ServiceSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSummaryListContainer = try containerValues.decodeIfPresent([ServiceSummary?].self, forKey: .serviceSummaryList)
        var serviceSummaryListDecoded0:[ServiceSummary]? = nil
        if let serviceSummaryListContainer = serviceSummaryListContainer {
            serviceSummaryListDecoded0 = [ServiceSummary]()
            for structure0 in serviceSummaryListContainer {
                if let structure0 = structure0 {
                    serviceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        serviceSummaryList = serviceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that a tag list is requested for.</p>
    ///          <p>It must be the ARN of an App Runner resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of the tag key-value pairs that are associated with the resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum OperationStatus {
    case failed
    case inProgress
    case pending
    case rollbackFailed
    case rollbackInProgress
    case rollbackSucceeded
    case succeeded
    case sdkUnknown(String)
}

extension OperationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperationStatus] {
        return [
            .failed,
            .inProgress,
            .pending,
            .rollbackFailed,
            .rollbackInProgress,
            .rollbackSucceeded,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .pending: return "PENDING"
        case .rollbackFailed: return "ROLLBACK_FAILED"
        case .rollbackInProgress: return "ROLLBACK_IN_PROGRESS"
        case .rollbackSucceeded: return "ROLLBACK_SUCCEEDED"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
    }
}

extension OperationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endedAt = "EndedAt"
        case id = "Id"
        case startedAt = "StartedAt"
        case status = "Status"
        case targetArn = "TargetArn"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.timeIntervalSince1970, forKey: .endedAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OperationType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OperationStatus.self, forKey: .status)
        status = statusDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endedAt)
        endedAt = endedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension OperationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationSummary(endedAt: \(String(describing: endedAt)), id: \(String(describing: id)), startedAt: \(String(describing: startedAt)), status: \(String(describing: status)), targetArn: \(String(describing: targetArn)), type: \(String(describing: type)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Provides summary information for an operation that occurred on an AWS App Runner service.</p>
public struct OperationSummary: Equatable {
    /// <p>The time when the operation ended. It's in the Unix time stamp format.</p>
    public let endedAt: Date?
    /// <p>A unique ID of this operation. It's unique in the scope of the App Runner service.</p>
    public let id: String?
    /// <p>The time when the operation started. It's in the Unix time stamp format.</p>
    public let startedAt: Date?
    /// <p>The current state of the operation.</p>
    public let status: OperationStatus?
    /// <p>The Amazon Resource Name (ARN) of the resource that the operation acted on (for example, an App Runner service).</p>
    public let targetArn: String?
    /// <p>The type of operation. It indicates a specific action that occured.</p>
    public let type: OperationType?
    /// <p>The time when the operation was last updated. It's in the Unix time stamp format.</p>
    public let updatedAt: Date?

    public init (
        endedAt: Date? = nil,
        id: String? = nil,
        startedAt: Date? = nil,
        status: OperationStatus? = nil,
        targetArn: String? = nil,
        type: OperationType? = nil,
        updatedAt: Date? = nil
    )
    {
        self.endedAt = endedAt
        self.id = id
        self.startedAt = startedAt
        self.status = status
        self.targetArn = targetArn
        self.type = type
        self.updatedAt = updatedAt
    }
}

public enum OperationType {
    case createService
    case deleteService
    case pauseService
    case resumeService
    case startDeployment
    case sdkUnknown(String)
}

extension OperationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperationType] {
        return [
            .createService,
            .deleteService,
            .pauseService,
            .resumeService,
            .startDeployment,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createService: return "CREATE_SERVICE"
        case .deleteService: return "DELETE_SERVICE"
        case .pauseService: return "PAUSE_SERVICE"
        case .resumeService: return "RESUME_SERVICE"
        case .startDeployment: return "START_DEPLOYMENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
    }
}

public struct PauseServiceInputBodyMiddleware: Middleware {
    public let id: String = "PauseServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PauseServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<PauseServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PauseServiceInput>
    public typealias MOutput = OperationOutput<PauseServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PauseServiceOutputError>
}

extension PauseServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PauseServiceInput(serviceArn: \(String(describing: serviceArn)))"}
}

extension PauseServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct PauseServiceInputHeadersMiddleware: Middleware {
    public let id: String = "PauseServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PauseServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<PauseServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PauseServiceInput>
    public typealias MOutput = OperationOutput<PauseServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PauseServiceOutputError>
}

public struct PauseServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "PauseServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PauseServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<PauseServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PauseServiceInput>
    public typealias MOutput = OperationOutput<PauseServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PauseServiceOutputError>
}

public struct PauseServiceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to pause.</p>
    public let serviceArn: String?

    public init (
        serviceArn: String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct PauseServiceInputBody: Equatable {
    public let serviceArn: String?
}

extension PauseServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension PauseServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PauseServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PauseServiceOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PauseServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PauseServiceOutputResponse(operationId: \(String(describing: operationId)), service: \(String(describing: service)))"}
}

extension PauseServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PauseServiceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct PauseServiceOutputResponse: Equatable {
    /// <p>The unique ID of the asynchronous operation that this request started. You can use it combined with the <a>ListOperations</a> call to track
    ///       the operation's progress.</p>
    public let operationId: String?
    /// <p>A description of the App Runner service that this request just paused.</p>
    public let service: Service?

    public init (
        operationId: String? = nil,
        service: Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct PauseServiceOutputResponseBody: Equatable {
    public let service: Service?
    public let operationId: String?
}

extension PauseServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public enum ProviderType {
    case github
    case sdkUnknown(String)
}

extension ProviderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProviderType] {
        return [
            .github,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .github: return "GITHUB"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProviderType(rawValue: rawValue) ?? ProviderType.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource doesn't exist for the specified Amazon Resource Name (ARN) in your AWS account.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ResumeServiceInputBodyMiddleware: Middleware {
    public let id: String = "ResumeServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeServiceInput>
    public typealias MOutput = OperationOutput<ResumeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeServiceOutputError>
}

extension ResumeServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResumeServiceInput(serviceArn: \(String(describing: serviceArn)))"}
}

extension ResumeServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct ResumeServiceInputHeadersMiddleware: Middleware {
    public let id: String = "ResumeServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeServiceInput>
    public typealias MOutput = OperationOutput<ResumeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeServiceOutputError>
}

public struct ResumeServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "ResumeServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeServiceInput>
    public typealias MOutput = OperationOutput<ResumeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeServiceOutputError>
}

public struct ResumeServiceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to resume.</p>
    public let serviceArn: String?

    public init (
        serviceArn: String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct ResumeServiceInputBody: Equatable {
    public let serviceArn: String?
}

extension ResumeServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension ResumeServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResumeServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResumeServiceOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResumeServiceOutputResponse(operationId: \(String(describing: operationId)), service: \(String(describing: service)))"}
}

extension ResumeServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResumeServiceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct ResumeServiceOutputResponse: Equatable {
    /// <p>The unique ID of the asynchronous operation that this request started. You can use it combined with the <a>ListOperations</a> call to track
    ///       the operation's progress.</p>
    public let operationId: String?
    /// <p>A description of the App Runner service that this request just resumed.</p>
    public let service: Service?

    public init (
        operationId: String? = nil,
        service: Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct ResumeServiceOutputResponseBody: Equatable {
    public let service: Service?
    public let operationId: String?
}

extension ResumeServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public enum Runtime {
    case nodejs12
    case python3
    case sdkUnknown(String)
}

extension Runtime : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Runtime] {
        return [
            .nodejs12,
            .python3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .nodejs12: return "NODEJS_12"
        case .python3: return "PYTHON_3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Runtime(rawValue: rawValue) ?? Runtime.sdkUnknown(rawValue)
    }
}

extension Service: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationSummary = "AutoScalingConfigurationSummary"
        case createdAt = "CreatedAt"
        case deletedAt = "DeletedAt"
        case encryptionConfiguration = "EncryptionConfiguration"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceArn = "ServiceArn"
        case serviceId = "ServiceId"
        case serviceName = "ServiceName"
        case serviceUrl = "ServiceUrl"
        case sourceConfiguration = "SourceConfiguration"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationSummary = autoScalingConfigurationSummary {
            try encodeContainer.encode(autoScalingConfigurationSummary, forKey: .autoScalingConfigurationSummary)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deletedAt = deletedAt {
            try encodeContainer.encode(deletedAt.timeIntervalSince1970, forKey: .deletedAt)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let healthCheckConfiguration = healthCheckConfiguration {
            try encodeContainer.encode(healthCheckConfiguration, forKey: .healthCheckConfiguration)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceUrl = serviceUrl {
            try encodeContainer.encode(serviceUrl, forKey: .serviceUrl)
        }
        if let sourceConfiguration = sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceUrl)
        serviceUrl = serviceUrlDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let deletedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceStatus.self, forKey: .status)
        status = statusDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let healthCheckConfigurationDecoded = try containerValues.decodeIfPresent(HealthCheckConfiguration.self, forKey: .healthCheckConfiguration)
        healthCheckConfiguration = healthCheckConfigurationDecoded
        let autoScalingConfigurationSummaryDecoded = try containerValues.decodeIfPresent(AutoScalingConfigurationSummary.self, forKey: .autoScalingConfigurationSummary)
        autoScalingConfigurationSummary = autoScalingConfigurationSummaryDecoded
    }
}

extension Service: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Service(autoScalingConfigurationSummary: \(String(describing: autoScalingConfigurationSummary)), createdAt: \(String(describing: createdAt)), deletedAt: \(String(describing: deletedAt)), encryptionConfiguration: \(String(describing: encryptionConfiguration)), healthCheckConfiguration: \(String(describing: healthCheckConfiguration)), instanceConfiguration: \(String(describing: instanceConfiguration)), serviceArn: \(String(describing: serviceArn)), serviceId: \(String(describing: serviceId)), serviceName: \(String(describing: serviceName)), serviceUrl: \(String(describing: serviceUrl)), sourceConfiguration: \(String(describing: sourceConfiguration)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Describes an AWS App Runner service. It can describe a service in any state, including deleted services.</p>
///          <p>This type contains the full information about a service, including configuration details. It's returned by the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_CreateService.html">CreateService</a>, <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_DescribeService.html">DescribeService</a>, and <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_DeleteService.html">DeleteService</a> actions. A subset of this
///       information is returned by the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_ListServices.html">ListServices</a> action using the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_ServiceSummary.html">ServiceSummary</a> type.</p>
public struct Service: Equatable {
    /// <p>Summary information for the App Runner automatic scaling configuration resource that's associated with this service.</p>
    public let autoScalingConfigurationSummary: AutoScalingConfigurationSummary?
    /// <p>The time when the App Runner service was created. It's in the Unix time stamp format.</p>
    public let createdAt: Date?
    /// <p>The time when the App Runner service was deleted. It's in the Unix time stamp format.</p>
    public let deletedAt: Date?
    /// <p>The encryption key that App Runner uses to encrypt the service logs and the copy of the source repository that App Runner maintains for the service. It can be
    ///       either a customer-provided encryption key or an AWS managed CMK.</p>
    public let encryptionConfiguration: EncryptionConfiguration?
    /// <p>The settings for the health check that App Runner performs to monitor the health of this service.</p>
    public let healthCheckConfiguration: HealthCheckConfiguration?
    /// <p>The runtime configuration of instances (scaling units) of this service.</p>
    public let instanceConfiguration: InstanceConfiguration?
    /// <p>The Amazon Resource Name (ARN) of this service.</p>
    public let serviceArn: String?
    /// <p>An ID that App Runner generated for this service. It's unique within the AWS Region.</p>
    public let serviceId: String?
    /// <p>The customer-provided service name.</p>
    public let serviceName: String?
    /// <p>A subdomain URL that App Runner generated for this service. You can use this URL to access your service web application.</p>
    public let serviceUrl: String?
    /// <p>The source deployed to the App Runner service. It can be a code or an image repository.</p>
    public let sourceConfiguration: SourceConfiguration?
    /// <p>The current state of the App Runner service. These particular values mean the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_FAILED</code> – The service failed to create. To troubleshoot this failure, read the failure events and logs, change any
    ///           parameters that need to be fixed, and retry the call to create the service.</p>
    ///                <p>The failed service isn't usable, and still counts towards your service quota. When you're done analyzing the failure, delete the service.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_FAILED</code> – The service failed to delete and can't be successfully recovered. Retry the service deletion call to ensure
    ///           that all related resources are removed.</p>
    ///             </li>
    ///          </ul>
    public let status: ServiceStatus?
    /// <p>The time when the App Runner service was last updated at. It's in the Unix time stamp format.</p>
    public let updatedAt: Date?

    public init (
        autoScalingConfigurationSummary: AutoScalingConfigurationSummary? = nil,
        createdAt: Date? = nil,
        deletedAt: Date? = nil,
        encryptionConfiguration: EncryptionConfiguration? = nil,
        healthCheckConfiguration: HealthCheckConfiguration? = nil,
        instanceConfiguration: InstanceConfiguration? = nil,
        serviceArn: String? = nil,
        serviceId: String? = nil,
        serviceName: String? = nil,
        serviceUrl: String? = nil,
        sourceConfiguration: SourceConfiguration? = nil,
        status: ServiceStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.autoScalingConfigurationSummary = autoScalingConfigurationSummary
        self.createdAt = createdAt
        self.deletedAt = deletedAt
        self.encryptionConfiguration = encryptionConfiguration
        self.healthCheckConfiguration = healthCheckConfiguration
        self.instanceConfiguration = instanceConfiguration
        self.serviceArn = serviceArn
        self.serviceId = serviceId
        self.serviceName = serviceName
        self.serviceUrl = serviceUrl
        self.sourceConfiguration = sourceConfiguration
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>App Runner can't create this resource. You've reached your account quota for this resource type.</p>
///          <p>For App Runner per-resource quotas, see <a href="https://docs.aws.amazon.com/general/latest/gr/apprunner.html">AWS App Runner endpoints and quotas</a> in the
///         <i>AWS General Reference</i>.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ServiceStatus {
    case createFailed
    case deleted
    case deleteFailed
    case operationInProgress
    case paused
    case running
    case sdkUnknown(String)
}

extension ServiceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceStatus] {
        return [
            .createFailed,
            .deleted,
            .deleteFailed,
            .operationInProgress,
            .paused,
            .running,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .deleted: return "DELETED"
        case .deleteFailed: return "DELETE_FAILED"
        case .operationInProgress: return "OPERATION_IN_PROGRESS"
        case .paused: return "PAUSED"
        case .running: return "RUNNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceStatus(rawValue: rawValue) ?? ServiceStatus.sdkUnknown(rawValue)
    }
}

extension ServiceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case serviceArn = "ServiceArn"
        case serviceId = "ServiceId"
        case serviceName = "ServiceName"
        case serviceUrl = "ServiceUrl"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceUrl = serviceUrl {
            try encodeContainer.encode(serviceUrl, forKey: .serviceUrl)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceUrl)
        serviceUrl = serviceUrlDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ServiceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceSummary(createdAt: \(String(describing: createdAt)), serviceArn: \(String(describing: serviceArn)), serviceId: \(String(describing: serviceId)), serviceName: \(String(describing: serviceName)), serviceUrl: \(String(describing: serviceUrl)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Provides summary information for an AWS App Runner service.</p>
///          <p>This type contains limited information about a service. It doesn't include configuration details. It's returned by the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_ListServices.html">ListServices</a> action. Complete service information is returned by the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_CreateService.html">CreateService</a>, <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_DescribeService.html">DescribeService</a>, and <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_DeleteService.html">DeleteService</a> actions using the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_Service.html">Service</a> type.</p>
public struct ServiceSummary: Equatable {
    /// <p>The time when the App Runner service was created. It's in the Unix time stamp format.</p>
    public let createdAt: Date?
    /// <p>The Amazon Resource Name (ARN) of this service.</p>
    public let serviceArn: String?
    /// <p>An ID that App Runner generated for this service. It's unique within the AWS Region.</p>
    public let serviceId: String?
    /// <p>The customer-provided service name.</p>
    public let serviceName: String?
    /// <p>A subdomain URL that App Runner generated for this service. You can use this URL to access your service web application.</p>
    public let serviceUrl: String?
    /// <p>The current state of the App Runner service. These particular values mean the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_FAILED</code> – The service failed to create. Read the failure events and logs, change any parameters that need to be fixed,
    ///           and retry the call to create the service.</p>
    ///                <p>The failed service isn't usable, and still counts towards your service quota. When you're done analyzing the failure, delete the service.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_FAILED</code> – The service failed to delete and can't be successfully recovered. Retry the service deletion call to ensure
    ///           that all related resources are removed.</p>
    ///             </li>
    ///          </ul>
    public let status: ServiceStatus?
    /// <p>The time when the App Runner service was last updated. It's in theUnix time stamp format.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        serviceArn: String? = nil,
        serviceId: String? = nil,
        serviceName: String? = nil,
        serviceUrl: String? = nil,
        status: ServiceStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.serviceArn = serviceArn
        self.serviceId = serviceId
        self.serviceName = serviceName
        self.serviceUrl = serviceUrl
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension SourceCodeVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SourceCodeVersionType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SourceCodeVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceCodeVersion(type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Identifies a version of code that AWS App Runner refers to within a source code repository.</p>
public struct SourceCodeVersion: Equatable {
    /// <p>The type of version identifier.</p>
    ///          <p>For a git-based repository, branches represent versions.</p>
    public let type: SourceCodeVersionType?
    /// <p>A source code version.</p>
    ///          <p>For a git-based repository, a branch name maps to a specific version. App Runner uses the most recent commit to the branch.</p>
    public let value: String?

    public init (
        type: SourceCodeVersionType? = nil,
        value: String? = nil
    )
    {
        self.type = type
        self.value = value
    }
}

public enum SourceCodeVersionType {
    case branch
    case sdkUnknown(String)
}

extension SourceCodeVersionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceCodeVersionType] {
        return [
            .branch,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .branch: return "BRANCH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceCodeVersionType(rawValue: rawValue) ?? SourceCodeVersionType.sdkUnknown(rawValue)
    }
}

extension SourceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationConfiguration = "AuthenticationConfiguration"
        case autoDeploymentsEnabled = "AutoDeploymentsEnabled"
        case codeRepository = "CodeRepository"
        case imageRepository = "ImageRepository"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationConfiguration = authenticationConfiguration {
            try encodeContainer.encode(authenticationConfiguration, forKey: .authenticationConfiguration)
        }
        if let autoDeploymentsEnabled = autoDeploymentsEnabled {
            try encodeContainer.encode(autoDeploymentsEnabled, forKey: .autoDeploymentsEnabled)
        }
        if let codeRepository = codeRepository {
            try encodeContainer.encode(codeRepository, forKey: .codeRepository)
        }
        if let imageRepository = imageRepository {
            try encodeContainer.encode(imageRepository, forKey: .imageRepository)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeRepositoryDecoded = try containerValues.decodeIfPresent(CodeRepository.self, forKey: .codeRepository)
        codeRepository = codeRepositoryDecoded
        let imageRepositoryDecoded = try containerValues.decodeIfPresent(ImageRepository.self, forKey: .imageRepository)
        imageRepository = imageRepositoryDecoded
        let autoDeploymentsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoDeploymentsEnabled)
        autoDeploymentsEnabled = autoDeploymentsEnabledDecoded
        let authenticationConfigurationDecoded = try containerValues.decodeIfPresent(AuthenticationConfiguration.self, forKey: .authenticationConfiguration)
        authenticationConfiguration = authenticationConfigurationDecoded
    }
}

extension SourceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceConfiguration(authenticationConfiguration: \(String(describing: authenticationConfiguration)), autoDeploymentsEnabled: \(String(describing: autoDeploymentsEnabled)), codeRepository: \(String(describing: codeRepository)), imageRepository: \(String(describing: imageRepository)))"}
}

/// <p>Describes the source deployed to an AWS App Runner service. It can be a code or an image repository.</p>
public struct SourceConfiguration: Equatable {
    /// <p>Describes the resources that are needed to authenticate access to some source repositories.</p>
    public let authenticationConfiguration: AuthenticationConfiguration?
    /// <p>If <code>true</code>, continuous integration from the source repository is enabled for the App Runner service. Each repository change (source code commit or
    ///       new image version) starts a deployment.</p>
    ///          <p>Default: <code>true</code>
    ///          </p>
    public let autoDeploymentsEnabled: Bool?
    /// <p>The description of a source code repository.</p>
    ///          <p>You must provide either this member or <code>ImageRepository</code> (but not both).</p>
    public let codeRepository: CodeRepository?
    /// <p>The description of a source image
    ///       repository.</p>
    ///          <p>You must provide either this member or <code>CodeRepository</code> (but not both).</p>
    public let imageRepository: ImageRepository?

    public init (
        authenticationConfiguration: AuthenticationConfiguration? = nil,
        autoDeploymentsEnabled: Bool? = nil,
        codeRepository: CodeRepository? = nil,
        imageRepository: ImageRepository? = nil
    )
    {
        self.authenticationConfiguration = authenticationConfiguration
        self.autoDeploymentsEnabled = autoDeploymentsEnabled
        self.codeRepository = codeRepository
        self.imageRepository = imageRepository
    }
}

public struct StartDeploymentInputBodyMiddleware: Middleware {
    public let id: String = "StartDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeploymentOutputError>
}

extension StartDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDeploymentInput(serviceArn: \(String(describing: serviceArn)))"}
}

extension StartDeploymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct StartDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "StartDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to manually deploy to.</p>
    public let serviceArn: String?

    public init (
        serviceArn: String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct StartDeploymentInputBody: Equatable {
    public let serviceArn: String?
}

extension StartDeploymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension StartDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDeploymentOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDeploymentOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension StartDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct StartDeploymentOutputResponse: Equatable {
    /// <p>The unique ID of the asynchronous operation that this request started. You can use it combined with the <a>ListOperations</a> call to track
    ///       the operation's progress.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct StartDeploymentOutputResponseBody: Equatable {
    public let operationId: String?
}

extension StartDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Describes a tag that is applied to an AWS App Runner resource. A tag is a metadata item consisting of a key-value pair.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to update tags for.</p>
    ///          <p>It must be the ARN of an App Runner resource.</p>
    public let resourceArn: String?
    /// <p>A list of tag key-value pairs to add or update. If a key is new to the resource, the tag is added with the provided value. If a key is already
    ///       associated with the resource, the value of the tag is updated.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove tags from.</p>
    ///          <p>It must be the ARN of an App Runner resource.</p>
    public let resourceArn: String?
    /// <p>A list of tag keys that you want to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateServiceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceOutputError>
}

extension UpdateServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceInput(autoScalingConfigurationArn: \(String(describing: autoScalingConfigurationArn)), healthCheckConfiguration: \(String(describing: healthCheckConfiguration)), instanceConfiguration: \(String(describing: instanceConfiguration)), serviceArn: \(String(describing: serviceArn)), sourceConfiguration: \(String(describing: sourceConfiguration)))"}
}

extension UpdateServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceArn = "ServiceArn"
        case sourceConfiguration = "SourceConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let healthCheckConfiguration = healthCheckConfiguration {
            try encodeContainer.encode(healthCheckConfiguration, forKey: .healthCheckConfiguration)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let sourceConfiguration = sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
    }
}

public struct UpdateServiceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service.</p>
    public let autoScalingConfigurationArn: String?
    /// <p>The settings for the health check that AWS App Runner performs to monitor the health of your service.</p>
    public let healthCheckConfiguration: HealthCheckConfiguration?
    /// <p>The runtime configuration to apply to instances (scaling units) of the App Runner service.</p>
    public let instanceConfiguration: InstanceConfiguration?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to update.</p>
    public let serviceArn: String?
    /// <p>The source configuration to apply to the App Runner service.</p>
    ///          <p>You can change the configuration of the code or image repository that the service uses. However, you can't switch from code to image or the other way
    ///       around. This means that you must provide the same structure member of <code>SourceConfiguration</code> that you originally included when you created the
    ///       service. Specifically, you can include either <code>CodeRepository</code> or <code>ImageRepository</code>. To update the source configuration, set the
    ///       values to members of the structure that you include.</p>
    public let sourceConfiguration: SourceConfiguration?

    public init (
        autoScalingConfigurationArn: String? = nil,
        healthCheckConfiguration: HealthCheckConfiguration? = nil,
        instanceConfiguration: InstanceConfiguration? = nil,
        serviceArn: String? = nil,
        sourceConfiguration: SourceConfiguration? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.healthCheckConfiguration = healthCheckConfiguration
        self.instanceConfiguration = instanceConfiguration
        self.serviceArn = serviceArn
        self.sourceConfiguration = sourceConfiguration
    }
}

struct UpdateServiceInputBody: Equatable {
    public let serviceArn: String?
    public let sourceConfiguration: SourceConfiguration?
    public let instanceConfiguration: InstanceConfiguration?
    public let autoScalingConfigurationArn: String?
    public let healthCheckConfiguration: HealthCheckConfiguration?
}

extension UpdateServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceArn = "ServiceArn"
        case sourceConfiguration = "SourceConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let healthCheckConfigurationDecoded = try containerValues.decodeIfPresent(HealthCheckConfiguration.self, forKey: .healthCheckConfiguration)
        healthCheckConfiguration = healthCheckConfigurationDecoded
    }
}

extension UpdateServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceOutputResponse(operationId: \(String(describing: operationId)), service: \(String(describing: service)))"}
}

extension UpdateServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateServiceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct UpdateServiceOutputResponse: Equatable {
    /// <p>The unique ID of the asynchronous operation that this request started. You can use it combined with the <a>ListOperations</a> call to track
    ///       the operation's progress.</p>
    public let operationId: String?
    /// <p>A description of the App Runner service updated by this request. All configuration values in the returned <code>Service</code> structure reflect
    ///       configuration changes that are being applied by this request.</p>
    public let service: Service?

    public init (
        operationId: String? = nil,
        service: Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct UpdateServiceOutputResponseBody: Equatable {
    public let service: Service?
    public let operationId: String?
}

extension UpdateServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}
