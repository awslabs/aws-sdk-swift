// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension NodeGroupConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nodeGroupId = "NodeGroupId"
        case primaryAvailabilityZone = "PrimaryAvailabilityZone"
        case primaryOutpostArn = "PrimaryOutpostArn"
        case replicaAvailabilityZones = "ReplicaAvailabilityZones"
        case replicaCount = "ReplicaCount"
        case replicaOutpostArns = "ReplicaOutpostArns"
        case slots = "Slots"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nodeGroupId = nodeGroupId {
            try container.encode(nodeGroupId, forKey: Key("NodeGroupId"))
        }
        if let primaryAvailabilityZone = primaryAvailabilityZone {
            try container.encode(primaryAvailabilityZone, forKey: Key("PrimaryAvailabilityZone"))
        }
        if let primaryOutpostArn = primaryOutpostArn {
            try container.encode(primaryOutpostArn, forKey: Key("PrimaryOutpostArn"))
        }
        if let replicaAvailabilityZones = replicaAvailabilityZones {
            var replicaAvailabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReplicaAvailabilityZones"))
            for (index0, string0) in replicaAvailabilityZones.enumerated() {
                try replicaAvailabilityZonesContainer.encode(string0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let replicaCount = replicaCount {
            try container.encode(replicaCount, forKey: Key("ReplicaCount"))
        }
        if let replicaOutpostArns = replicaOutpostArns {
            var replicaOutpostArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReplicaOutpostArns"))
            for (index0, string0) in replicaOutpostArns.enumerated() {
                try replicaOutpostArnsContainer.encode(string0, forKey: Key("OutpostArn.\(index0.advanced(by: 1))"))
            }
        }
        if let slots = slots {
            try container.encode(slots, forKey: Key("Slots"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeGroupId)
        nodeGroupId = nodeGroupIdDecoded
        let slotsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slots)
        slots = slotsDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let primaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .primaryAvailabilityZone)
        primaryAvailabilityZone = primaryAvailabilityZoneDecoded
        if containerValues.contains(.replicaAvailabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let replicaAvailabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .replicaAvailabilityZones)
            if let replicaAvailabilityZonesWrappedContainer = replicaAvailabilityZonesWrappedContainer {
                let replicaAvailabilityZonesContainer = try replicaAvailabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var replicaAvailabilityZonesBuffer:[String]? = nil
                if let replicaAvailabilityZonesContainer = replicaAvailabilityZonesContainer {
                    replicaAvailabilityZonesBuffer = [String]()
                    for stringContainer0 in replicaAvailabilityZonesContainer {
                        replicaAvailabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                replicaAvailabilityZones = replicaAvailabilityZonesBuffer
            } else {
                replicaAvailabilityZones = []
            }
        } else {
            replicaAvailabilityZones = nil
        }
        let primaryOutpostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .primaryOutpostArn)
        primaryOutpostArn = primaryOutpostArnDecoded
        if containerValues.contains(.replicaOutpostArns) {
            struct KeyVal0{struct OutpostArn{}}
            let replicaOutpostArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OutpostArn>.CodingKeys.self, forKey: .replicaOutpostArns)
            if let replicaOutpostArnsWrappedContainer = replicaOutpostArnsWrappedContainer {
                let replicaOutpostArnsContainer = try replicaOutpostArnsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var replicaOutpostArnsBuffer:[String]? = nil
                if let replicaOutpostArnsContainer = replicaOutpostArnsContainer {
                    replicaOutpostArnsBuffer = [String]()
                    for stringContainer0 in replicaOutpostArnsContainer {
                        replicaOutpostArnsBuffer?.append(stringContainer0)
                    }
                }
                replicaOutpostArns = replicaOutpostArnsBuffer
            } else {
                replicaOutpostArns = []
            }
        } else {
            replicaOutpostArns = nil
        }
    }
}
