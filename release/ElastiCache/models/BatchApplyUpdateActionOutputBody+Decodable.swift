// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct BatchApplyUpdateActionOutputBody: Equatable {
    public let processedUpdateActions: [ProcessedUpdateAction]?
    public let unprocessedUpdateActions: [UnprocessedUpdateAction]?
}

extension BatchApplyUpdateActionOutputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case processedUpdateActions = "ProcessedUpdateActions"
        case unprocessedUpdateActions = "UnprocessedUpdateActions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("BatchApplyUpdateActionResult"))
        if containerValues.contains(.processedUpdateActions) {
            struct KeyVal0{struct ProcessedUpdateAction{}}
            let processedUpdateActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessedUpdateAction>.CodingKeys.self, forKey: .processedUpdateActions)
            if let processedUpdateActionsWrappedContainer = processedUpdateActionsWrappedContainer {
                let processedUpdateActionsContainer = try processedUpdateActionsWrappedContainer.decodeIfPresent([ProcessedUpdateAction].self, forKey: .member)
                var processedUpdateActionsBuffer:[ProcessedUpdateAction]? = nil
                if let processedUpdateActionsContainer = processedUpdateActionsContainer {
                    processedUpdateActionsBuffer = [ProcessedUpdateAction]()
                    for structureContainer0 in processedUpdateActionsContainer {
                        processedUpdateActionsBuffer?.append(structureContainer0)
                    }
                }
                processedUpdateActions = processedUpdateActionsBuffer
            } else {
                processedUpdateActions = []
            }
        } else {
            processedUpdateActions = nil
        }
        if containerValues.contains(.unprocessedUpdateActions) {
            struct KeyVal0{struct UnprocessedUpdateAction{}}
            let unprocessedUpdateActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UnprocessedUpdateAction>.CodingKeys.self, forKey: .unprocessedUpdateActions)
            if let unprocessedUpdateActionsWrappedContainer = unprocessedUpdateActionsWrappedContainer {
                let unprocessedUpdateActionsContainer = try unprocessedUpdateActionsWrappedContainer.decodeIfPresent([UnprocessedUpdateAction].self, forKey: .member)
                var unprocessedUpdateActionsBuffer:[UnprocessedUpdateAction]? = nil
                if let unprocessedUpdateActionsContainer = unprocessedUpdateActionsContainer {
                    unprocessedUpdateActionsBuffer = [UnprocessedUpdateAction]()
                    for structureContainer0 in unprocessedUpdateActionsContainer {
                        unprocessedUpdateActionsBuffer?.append(structureContainer0)
                    }
                }
                unprocessedUpdateActions = unprocessedUpdateActionsBuffer
            } else {
                unprocessedUpdateActions = []
            }
        } else {
            unprocessedUpdateActions = nil
        }
    }
}
