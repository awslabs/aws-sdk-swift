// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension CacheCluster: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case atRestEncryptionEnabled = "AtRestEncryptionEnabled"
        case authTokenEnabled = "AuthTokenEnabled"
        case authTokenLastModifiedDate = "AuthTokenLastModifiedDate"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case cacheClusterCreateTime = "CacheClusterCreateTime"
        case cacheClusterId = "CacheClusterId"
        case cacheClusterStatus = "CacheClusterStatus"
        case cacheNodeType = "CacheNodeType"
        case cacheNodes = "CacheNodes"
        case cacheParameterGroup = "CacheParameterGroup"
        case cacheSecurityGroups = "CacheSecurityGroups"
        case cacheSubnetGroupName = "CacheSubnetGroupName"
        case clientDownloadLandingPage = "ClientDownloadLandingPage"
        case configurationEndpoint = "ConfigurationEndpoint"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case logDeliveryConfigurations = "LogDeliveryConfigurations"
        case notificationConfiguration = "NotificationConfiguration"
        case numCacheNodes = "NumCacheNodes"
        case pendingModifiedValues = "PendingModifiedValues"
        case preferredAvailabilityZone = "PreferredAvailabilityZone"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case preferredOutpostArn = "PreferredOutpostArn"
        case replicationGroupId = "ReplicationGroupId"
        case replicationGroupLogDeliveryEnabled = "ReplicationGroupLogDeliveryEnabled"
        case securityGroups = "SecurityGroups"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotWindow = "SnapshotWindow"
        case transitEncryptionEnabled = "TransitEncryptionEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let aRN = aRN {
            try container.encode(aRN, forKey: Key("ARN"))
        }
        if let atRestEncryptionEnabled = atRestEncryptionEnabled {
            try container.encode(atRestEncryptionEnabled, forKey: Key("AtRestEncryptionEnabled"))
        }
        if let authTokenEnabled = authTokenEnabled {
            try container.encode(authTokenEnabled, forKey: Key("AuthTokenEnabled"))
        }
        if let authTokenLastModifiedDate = authTokenLastModifiedDate {
            try container.encode(TimestampWrapper(authTokenLastModifiedDate, format: .dateTime), forKey: Key("authTokenLastModifiedDate"))
        }
        if autoMinorVersionUpgrade != false {
            try container.encode(autoMinorVersionUpgrade, forKey: Key("AutoMinorVersionUpgrade"))
        }
        if let cacheClusterCreateTime = cacheClusterCreateTime {
            try container.encode(TimestampWrapper(cacheClusterCreateTime, format: .dateTime), forKey: Key("cacheClusterCreateTime"))
        }
        if let cacheClusterId = cacheClusterId {
            try container.encode(cacheClusterId, forKey: Key("CacheClusterId"))
        }
        if let cacheClusterStatus = cacheClusterStatus {
            try container.encode(cacheClusterStatus, forKey: Key("CacheClusterStatus"))
        }
        if let cacheNodeType = cacheNodeType {
            try container.encode(cacheNodeType, forKey: Key("CacheNodeType"))
        }
        if let cacheNodes = cacheNodes {
            var cacheNodesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("CacheNodes"))
            for (index0, cachenode0) in cacheNodes.enumerated() {
                try cacheNodesContainer.encode(cachenode0, forKey: Key("CacheNode.\(index0.advanced(by: 1))"))
            }
        }
        if let cacheParameterGroup = cacheParameterGroup {
            try container.encode(cacheParameterGroup, forKey: Key("CacheParameterGroup"))
        }
        if let cacheSecurityGroups = cacheSecurityGroups {
            var cacheSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("CacheSecurityGroups"))
            for (index0, cachesecuritygroupmembership0) in cacheSecurityGroups.enumerated() {
                try cacheSecurityGroupsContainer.encode(cachesecuritygroupmembership0, forKey: Key("CacheSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let cacheSubnetGroupName = cacheSubnetGroupName {
            try container.encode(cacheSubnetGroupName, forKey: Key("CacheSubnetGroupName"))
        }
        if let clientDownloadLandingPage = clientDownloadLandingPage {
            try container.encode(clientDownloadLandingPage, forKey: Key("ClientDownloadLandingPage"))
        }
        if let configurationEndpoint = configurationEndpoint {
            try container.encode(configurationEndpoint, forKey: Key("ConfigurationEndpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let logDeliveryConfigurations = logDeliveryConfigurations {
            var logDeliveryConfigurationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LogDeliveryConfigurations"))
            for (index0, logdeliveryconfiguration0) in logDeliveryConfigurations.enumerated() {
                try logDeliveryConfigurationsContainer.encode(logdeliveryconfiguration0, forKey: Key("LogDeliveryConfiguration.\(index0.advanced(by: 1))"))
            }
        }
        if let notificationConfiguration = notificationConfiguration {
            try container.encode(notificationConfiguration, forKey: Key("NotificationConfiguration"))
        }
        if let numCacheNodes = numCacheNodes {
            try container.encode(numCacheNodes, forKey: Key("NumCacheNodes"))
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: Key("PendingModifiedValues"))
        }
        if let preferredAvailabilityZone = preferredAvailabilityZone {
            try container.encode(preferredAvailabilityZone, forKey: Key("PreferredAvailabilityZone"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let preferredOutpostArn = preferredOutpostArn {
            try container.encode(preferredOutpostArn, forKey: Key("PreferredOutpostArn"))
        }
        if let replicationGroupId = replicationGroupId {
            try container.encode(replicationGroupId, forKey: Key("ReplicationGroupId"))
        }
        if replicationGroupLogDeliveryEnabled != false {
            try container.encode(replicationGroupLogDeliveryEnabled, forKey: Key("ReplicationGroupLogDeliveryEnabled"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SecurityGroups"))
            for (index0, securitygroupmembership0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(securitygroupmembership0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let snapshotRetentionLimit = snapshotRetentionLimit {
            try container.encode(snapshotRetentionLimit, forKey: Key("SnapshotRetentionLimit"))
        }
        if let snapshotWindow = snapshotWindow {
            try container.encode(snapshotWindow, forKey: Key("SnapshotWindow"))
        }
        if let transitEncryptionEnabled = transitEncryptionEnabled {
            try container.encode(transitEncryptionEnabled, forKey: Key("TransitEncryptionEnabled"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cacheClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheClusterId)
        cacheClusterId = cacheClusterIdDecoded
        let configurationEndpointDecoded = try containerValues.decodeIfPresent(Endpoint.self, forKey: .configurationEndpoint)
        configurationEndpoint = configurationEndpointDecoded
        let clientDownloadLandingPageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientDownloadLandingPage)
        clientDownloadLandingPage = clientDownloadLandingPageDecoded
        let cacheNodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheNodeType)
        cacheNodeType = cacheNodeTypeDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let numCacheNodesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numCacheNodes)
        numCacheNodes = numCacheNodesDecoded
        let preferredAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredAvailabilityZone)
        preferredAvailabilityZone = preferredAvailabilityZoneDecoded
        let preferredOutpostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredOutpostArn)
        preferredOutpostArn = preferredOutpostArnDecoded
        let cacheClusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheClusterCreateTime)
        var cacheClusterCreateTimeBuffer:Date? = nil
        if let cacheClusterCreateTimeDecoded = cacheClusterCreateTimeDecoded {
            cacheClusterCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(cacheClusterCreateTimeDecoded, format: .dateTime)
        }
        cacheClusterCreateTime = cacheClusterCreateTimeBuffer
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(PendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
        if containerValues.contains(.cacheSecurityGroups) {
            struct KeyVal0{struct CacheSecurityGroup{}}
            let cacheSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CacheSecurityGroup>.CodingKeys.self, forKey: .cacheSecurityGroups)
            if let cacheSecurityGroupsWrappedContainer = cacheSecurityGroupsWrappedContainer {
                let cacheSecurityGroupsContainer = try cacheSecurityGroupsWrappedContainer.decodeIfPresent([CacheSecurityGroupMembership].self, forKey: .member)
                var cacheSecurityGroupsBuffer:[CacheSecurityGroupMembership]? = nil
                if let cacheSecurityGroupsContainer = cacheSecurityGroupsContainer {
                    cacheSecurityGroupsBuffer = [CacheSecurityGroupMembership]()
                    for structureContainer0 in cacheSecurityGroupsContainer {
                        cacheSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                cacheSecurityGroups = cacheSecurityGroupsBuffer
            } else {
                cacheSecurityGroups = []
            }
        } else {
            cacheSecurityGroups = nil
        }
        let cacheParameterGroupDecoded = try containerValues.decodeIfPresent(CacheParameterGroupStatus.self, forKey: .cacheParameterGroup)
        cacheParameterGroup = cacheParameterGroupDecoded
        let cacheSubnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheSubnetGroupName)
        cacheSubnetGroupName = cacheSubnetGroupNameDecoded
        if containerValues.contains(.cacheNodes) {
            struct KeyVal0{struct CacheNode{}}
            let cacheNodesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CacheNode>.CodingKeys.self, forKey: .cacheNodes)
            if let cacheNodesWrappedContainer = cacheNodesWrappedContainer {
                let cacheNodesContainer = try cacheNodesWrappedContainer.decodeIfPresent([CacheNode].self, forKey: .member)
                var cacheNodesBuffer:[CacheNode]? = nil
                if let cacheNodesContainer = cacheNodesContainer {
                    cacheNodesBuffer = [CacheNode]()
                    for structureContainer0 in cacheNodesContainer {
                        cacheNodesBuffer?.append(structureContainer0)
                    }
                }
                cacheNodes = cacheNodesBuffer
            } else {
                cacheNodes = []
            }
        } else {
            cacheNodes = nil
        }
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct member{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([SecurityGroupMembership].self, forKey: .member)
                var securityGroupsBuffer:[SecurityGroupMembership]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [SecurityGroupMembership]()
                    for structureContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(structureContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let replicationGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationGroupId)
        replicationGroupId = replicationGroupIdDecoded
        let snapshotRetentionLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .snapshotRetentionLimit)
        snapshotRetentionLimit = snapshotRetentionLimitDecoded
        let snapshotWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotWindow)
        snapshotWindow = snapshotWindowDecoded
        let authTokenEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .authTokenEnabled)
        authTokenEnabled = authTokenEnabledDecoded
        let authTokenLastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authTokenLastModifiedDate)
        var authTokenLastModifiedDateBuffer:Date? = nil
        if let authTokenLastModifiedDateDecoded = authTokenLastModifiedDateDecoded {
            authTokenLastModifiedDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(authTokenLastModifiedDateDecoded, format: .dateTime)
        }
        authTokenLastModifiedDate = authTokenLastModifiedDateBuffer
        let transitEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .transitEncryptionEnabled)
        transitEncryptionEnabled = transitEncryptionEnabledDecoded
        let atRestEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .atRestEncryptionEnabled)
        atRestEncryptionEnabled = atRestEncryptionEnabledDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let replicationGroupLogDeliveryEnabledDecoded = try containerValues.decode(Bool.self, forKey: .replicationGroupLogDeliveryEnabled)
        replicationGroupLogDeliveryEnabled = replicationGroupLogDeliveryEnabledDecoded
        if containerValues.contains(.logDeliveryConfigurations) {
            struct KeyVal0{struct LogDeliveryConfiguration{}}
            let logDeliveryConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.LogDeliveryConfiguration>.CodingKeys.self, forKey: .logDeliveryConfigurations)
            if let logDeliveryConfigurationsWrappedContainer = logDeliveryConfigurationsWrappedContainer {
                let logDeliveryConfigurationsContainer = try logDeliveryConfigurationsWrappedContainer.decodeIfPresent([LogDeliveryConfiguration].self, forKey: .member)
                var logDeliveryConfigurationsBuffer:[LogDeliveryConfiguration]? = nil
                if let logDeliveryConfigurationsContainer = logDeliveryConfigurationsContainer {
                    logDeliveryConfigurationsBuffer = [LogDeliveryConfiguration]()
                    for structureContainer0 in logDeliveryConfigurationsContainer {
                        logDeliveryConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                logDeliveryConfigurations = logDeliveryConfigurationsBuffer
            } else {
                logDeliveryConfigurations = []
            }
        } else {
            logDeliveryConfigurations = nil
        }
    }
}
