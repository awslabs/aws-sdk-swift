// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Snapshot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case automaticFailover = "AutomaticFailover"
        case cacheClusterCreateTime = "CacheClusterCreateTime"
        case cacheClusterId = "CacheClusterId"
        case cacheNodeType = "CacheNodeType"
        case cacheParameterGroupName = "CacheParameterGroupName"
        case cacheSubnetGroupName = "CacheSubnetGroupName"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case nodeSnapshots = "NodeSnapshots"
        case numCacheNodes = "NumCacheNodes"
        case numNodeGroups = "NumNodeGroups"
        case port = "Port"
        case preferredAvailabilityZone = "PreferredAvailabilityZone"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case preferredOutpostArn = "PreferredOutpostArn"
        case replicationGroupDescription = "ReplicationGroupDescription"
        case replicationGroupId = "ReplicationGroupId"
        case snapshotName = "SnapshotName"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotSource = "SnapshotSource"
        case snapshotStatus = "SnapshotStatus"
        case snapshotWindow = "SnapshotWindow"
        case topicArn = "TopicArn"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let aRN = aRN {
            try container.encode(aRN, forKey: Key("ARN"))
        }
        if autoMinorVersionUpgrade != false {
            try container.encode(autoMinorVersionUpgrade, forKey: Key("AutoMinorVersionUpgrade"))
        }
        if let automaticFailover = automaticFailover {
            try container.encode(automaticFailover, forKey: Key("AutomaticFailover"))
        }
        if let cacheClusterCreateTime = cacheClusterCreateTime {
            try container.encode(TimestampWrapper(cacheClusterCreateTime, format: .dateTime), forKey: Key("cacheClusterCreateTime"))
        }
        if let cacheClusterId = cacheClusterId {
            try container.encode(cacheClusterId, forKey: Key("CacheClusterId"))
        }
        if let cacheNodeType = cacheNodeType {
            try container.encode(cacheNodeType, forKey: Key("CacheNodeType"))
        }
        if let cacheParameterGroupName = cacheParameterGroupName {
            try container.encode(cacheParameterGroupName, forKey: Key("CacheParameterGroupName"))
        }
        if let cacheSubnetGroupName = cacheSubnetGroupName {
            try container.encode(cacheSubnetGroupName, forKey: Key("CacheSubnetGroupName"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let nodeSnapshots = nodeSnapshots {
            var nodeSnapshotsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("NodeSnapshots"))
            for (index0, nodesnapshot0) in nodeSnapshots.enumerated() {
                try nodeSnapshotsContainer.encode(nodesnapshot0, forKey: Key("NodeSnapshot.\(index0.advanced(by: 1))"))
            }
        }
        if let numCacheNodes = numCacheNodes {
            try container.encode(numCacheNodes, forKey: Key("NumCacheNodes"))
        }
        if let numNodeGroups = numNodeGroups {
            try container.encode(numNodeGroups, forKey: Key("NumNodeGroups"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredAvailabilityZone = preferredAvailabilityZone {
            try container.encode(preferredAvailabilityZone, forKey: Key("PreferredAvailabilityZone"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let preferredOutpostArn = preferredOutpostArn {
            try container.encode(preferredOutpostArn, forKey: Key("PreferredOutpostArn"))
        }
        if let replicationGroupDescription = replicationGroupDescription {
            try container.encode(replicationGroupDescription, forKey: Key("ReplicationGroupDescription"))
        }
        if let replicationGroupId = replicationGroupId {
            try container.encode(replicationGroupId, forKey: Key("ReplicationGroupId"))
        }
        if let snapshotName = snapshotName {
            try container.encode(snapshotName, forKey: Key("SnapshotName"))
        }
        if let snapshotRetentionLimit = snapshotRetentionLimit {
            try container.encode(snapshotRetentionLimit, forKey: Key("SnapshotRetentionLimit"))
        }
        if let snapshotSource = snapshotSource {
            try container.encode(snapshotSource, forKey: Key("SnapshotSource"))
        }
        if let snapshotStatus = snapshotStatus {
            try container.encode(snapshotStatus, forKey: Key("SnapshotStatus"))
        }
        if let snapshotWindow = snapshotWindow {
            try container.encode(snapshotWindow, forKey: Key("SnapshotWindow"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let replicationGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationGroupId)
        replicationGroupId = replicationGroupIdDecoded
        let replicationGroupDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationGroupDescription)
        replicationGroupDescription = replicationGroupDescriptionDecoded
        let cacheClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheClusterId)
        cacheClusterId = cacheClusterIdDecoded
        let snapshotStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotStatus)
        snapshotStatus = snapshotStatusDecoded
        let snapshotSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotSource)
        snapshotSource = snapshotSourceDecoded
        let cacheNodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheNodeType)
        cacheNodeType = cacheNodeTypeDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let numCacheNodesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numCacheNodes)
        numCacheNodes = numCacheNodesDecoded
        let preferredAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredAvailabilityZone)
        preferredAvailabilityZone = preferredAvailabilityZoneDecoded
        let preferredOutpostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredOutpostArn)
        preferredOutpostArn = preferredOutpostArnDecoded
        let cacheClusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheClusterCreateTime)
        var cacheClusterCreateTimeBuffer:Date? = nil
        if let cacheClusterCreateTimeDecoded = cacheClusterCreateTimeDecoded {
            cacheClusterCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(cacheClusterCreateTimeDecoded, format: .dateTime)
        }
        cacheClusterCreateTime = cacheClusterCreateTimeBuffer
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let cacheParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheParameterGroupName)
        cacheParameterGroupName = cacheParameterGroupNameDecoded
        let cacheSubnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheSubnetGroupName)
        cacheSubnetGroupName = cacheSubnetGroupNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let snapshotRetentionLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .snapshotRetentionLimit)
        snapshotRetentionLimit = snapshotRetentionLimitDecoded
        let snapshotWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotWindow)
        snapshotWindow = snapshotWindowDecoded
        let numNodeGroupsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numNodeGroups)
        numNodeGroups = numNodeGroupsDecoded
        let automaticFailoverDecoded = try containerValues.decodeIfPresent(AutomaticFailoverStatus.self, forKey: .automaticFailover)
        automaticFailover = automaticFailoverDecoded
        if containerValues.contains(.nodeSnapshots) {
            struct KeyVal0{struct NodeSnapshot{}}
            let nodeSnapshotsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NodeSnapshot>.CodingKeys.self, forKey: .nodeSnapshots)
            if let nodeSnapshotsWrappedContainer = nodeSnapshotsWrappedContainer {
                let nodeSnapshotsContainer = try nodeSnapshotsWrappedContainer.decodeIfPresent([NodeSnapshot].self, forKey: .member)
                var nodeSnapshotsBuffer:[NodeSnapshot]? = nil
                if let nodeSnapshotsContainer = nodeSnapshotsContainer {
                    nodeSnapshotsBuffer = [NodeSnapshot]()
                    for structureContainer0 in nodeSnapshotsContainer {
                        nodeSnapshotsBuffer?.append(structureContainer0)
                    }
                }
                nodeSnapshots = nodeSnapshotsBuffer
            } else {
                nodeSnapshots = []
            }
        } else {
            nodeSnapshots = nil
        }
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}
