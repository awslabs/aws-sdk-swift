// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension UpdateAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheClusterId = "CacheClusterId"
        case cacheNodeUpdateStatus = "CacheNodeUpdateStatus"
        case engine = "Engine"
        case estimatedUpdateTime = "EstimatedUpdateTime"
        case nodeGroupUpdateStatus = "NodeGroupUpdateStatus"
        case nodesUpdated = "NodesUpdated"
        case replicationGroupId = "ReplicationGroupId"
        case serviceUpdateName = "ServiceUpdateName"
        case serviceUpdateRecommendedApplyByDate = "ServiceUpdateRecommendedApplyByDate"
        case serviceUpdateReleaseDate = "ServiceUpdateReleaseDate"
        case serviceUpdateSeverity = "ServiceUpdateSeverity"
        case serviceUpdateStatus = "ServiceUpdateStatus"
        case serviceUpdateType = "ServiceUpdateType"
        case slaMet = "SlaMet"
        case updateActionAvailableDate = "UpdateActionAvailableDate"
        case updateActionStatus = "UpdateActionStatus"
        case updateActionStatusModifiedDate = "UpdateActionStatusModifiedDate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cacheClusterId = cacheClusterId {
            try container.encode(cacheClusterId, forKey: Key("CacheClusterId"))
        }
        if let cacheNodeUpdateStatus = cacheNodeUpdateStatus {
            var cacheNodeUpdateStatusContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("CacheNodeUpdateStatus"))
            for (index0, cachenodeupdatestatus0) in cacheNodeUpdateStatus.enumerated() {
                try cacheNodeUpdateStatusContainer.encode(cachenodeupdatestatus0, forKey: Key("CacheNodeUpdateStatus.\(index0.advanced(by: 1))"))
            }
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let estimatedUpdateTime = estimatedUpdateTime {
            try container.encode(estimatedUpdateTime, forKey: Key("EstimatedUpdateTime"))
        }
        if let nodeGroupUpdateStatus = nodeGroupUpdateStatus {
            var nodeGroupUpdateStatusContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("NodeGroupUpdateStatus"))
            for (index0, nodegroupupdatestatus0) in nodeGroupUpdateStatus.enumerated() {
                try nodeGroupUpdateStatusContainer.encode(nodegroupupdatestatus0, forKey: Key("NodeGroupUpdateStatus.\(index0.advanced(by: 1))"))
            }
        }
        if let nodesUpdated = nodesUpdated {
            try container.encode(nodesUpdated, forKey: Key("NodesUpdated"))
        }
        if let replicationGroupId = replicationGroupId {
            try container.encode(replicationGroupId, forKey: Key("ReplicationGroupId"))
        }
        if let serviceUpdateName = serviceUpdateName {
            try container.encode(serviceUpdateName, forKey: Key("ServiceUpdateName"))
        }
        if let serviceUpdateRecommendedApplyByDate = serviceUpdateRecommendedApplyByDate {
            try container.encode(TimestampWrapper(serviceUpdateRecommendedApplyByDate, format: .dateTime), forKey: Key("serviceUpdateRecommendedApplyByDate"))
        }
        if let serviceUpdateReleaseDate = serviceUpdateReleaseDate {
            try container.encode(TimestampWrapper(serviceUpdateReleaseDate, format: .dateTime), forKey: Key("serviceUpdateReleaseDate"))
        }
        if let serviceUpdateSeverity = serviceUpdateSeverity {
            try container.encode(serviceUpdateSeverity, forKey: Key("ServiceUpdateSeverity"))
        }
        if let serviceUpdateStatus = serviceUpdateStatus {
            try container.encode(serviceUpdateStatus, forKey: Key("ServiceUpdateStatus"))
        }
        if let serviceUpdateType = serviceUpdateType {
            try container.encode(serviceUpdateType, forKey: Key("ServiceUpdateType"))
        }
        if let slaMet = slaMet {
            try container.encode(slaMet, forKey: Key("SlaMet"))
        }
        if let updateActionAvailableDate = updateActionAvailableDate {
            try container.encode(TimestampWrapper(updateActionAvailableDate, format: .dateTime), forKey: Key("updateActionAvailableDate"))
        }
        if let updateActionStatus = updateActionStatus {
            try container.encode(updateActionStatus, forKey: Key("UpdateActionStatus"))
        }
        if let updateActionStatusModifiedDate = updateActionStatusModifiedDate {
            try container.encode(TimestampWrapper(updateActionStatusModifiedDate, format: .dateTime), forKey: Key("updateActionStatusModifiedDate"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationGroupId)
        replicationGroupId = replicationGroupIdDecoded
        let cacheClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheClusterId)
        cacheClusterId = cacheClusterIdDecoded
        let serviceUpdateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceUpdateName)
        serviceUpdateName = serviceUpdateNameDecoded
        let serviceUpdateReleaseDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceUpdateReleaseDate)
        var serviceUpdateReleaseDateBuffer:Date? = nil
        if let serviceUpdateReleaseDateDecoded = serviceUpdateReleaseDateDecoded {
            serviceUpdateReleaseDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(serviceUpdateReleaseDateDecoded, format: .dateTime)
        }
        serviceUpdateReleaseDate = serviceUpdateReleaseDateBuffer
        let serviceUpdateSeverityDecoded = try containerValues.decodeIfPresent(ServiceUpdateSeverity.self, forKey: .serviceUpdateSeverity)
        serviceUpdateSeverity = serviceUpdateSeverityDecoded
        let serviceUpdateStatusDecoded = try containerValues.decodeIfPresent(ServiceUpdateStatus.self, forKey: .serviceUpdateStatus)
        serviceUpdateStatus = serviceUpdateStatusDecoded
        let serviceUpdateRecommendedApplyByDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceUpdateRecommendedApplyByDate)
        var serviceUpdateRecommendedApplyByDateBuffer:Date? = nil
        if let serviceUpdateRecommendedApplyByDateDecoded = serviceUpdateRecommendedApplyByDateDecoded {
            serviceUpdateRecommendedApplyByDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(serviceUpdateRecommendedApplyByDateDecoded, format: .dateTime)
        }
        serviceUpdateRecommendedApplyByDate = serviceUpdateRecommendedApplyByDateBuffer
        let serviceUpdateTypeDecoded = try containerValues.decodeIfPresent(ServiceUpdateType.self, forKey: .serviceUpdateType)
        serviceUpdateType = serviceUpdateTypeDecoded
        let updateActionAvailableDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateActionAvailableDate)
        var updateActionAvailableDateBuffer:Date? = nil
        if let updateActionAvailableDateDecoded = updateActionAvailableDateDecoded {
            updateActionAvailableDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(updateActionAvailableDateDecoded, format: .dateTime)
        }
        updateActionAvailableDate = updateActionAvailableDateBuffer
        let updateActionStatusDecoded = try containerValues.decodeIfPresent(UpdateActionStatus.self, forKey: .updateActionStatus)
        updateActionStatus = updateActionStatusDecoded
        let nodesUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodesUpdated)
        nodesUpdated = nodesUpdatedDecoded
        let updateActionStatusModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateActionStatusModifiedDate)
        var updateActionStatusModifiedDateBuffer:Date? = nil
        if let updateActionStatusModifiedDateDecoded = updateActionStatusModifiedDateDecoded {
            updateActionStatusModifiedDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(updateActionStatusModifiedDateDecoded, format: .dateTime)
        }
        updateActionStatusModifiedDate = updateActionStatusModifiedDateBuffer
        let slaMetDecoded = try containerValues.decodeIfPresent(SlaMet.self, forKey: .slaMet)
        slaMet = slaMetDecoded
        if containerValues.contains(.nodeGroupUpdateStatus) {
            struct KeyVal0{struct NodeGroupUpdateStatus{}}
            let nodeGroupUpdateStatusWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NodeGroupUpdateStatus>.CodingKeys.self, forKey: .nodeGroupUpdateStatus)
            if let nodeGroupUpdateStatusWrappedContainer = nodeGroupUpdateStatusWrappedContainer {
                let nodeGroupUpdateStatusContainer = try nodeGroupUpdateStatusWrappedContainer.decodeIfPresent([NodeGroupUpdateStatus].self, forKey: .member)
                var nodeGroupUpdateStatusBuffer:[NodeGroupUpdateStatus]? = nil
                if let nodeGroupUpdateStatusContainer = nodeGroupUpdateStatusContainer {
                    nodeGroupUpdateStatusBuffer = [NodeGroupUpdateStatus]()
                    for structureContainer0 in nodeGroupUpdateStatusContainer {
                        nodeGroupUpdateStatusBuffer?.append(structureContainer0)
                    }
                }
                nodeGroupUpdateStatus = nodeGroupUpdateStatusBuffer
            } else {
                nodeGroupUpdateStatus = []
            }
        } else {
            nodeGroupUpdateStatus = nil
        }
        if containerValues.contains(.cacheNodeUpdateStatus) {
            struct KeyVal0{struct CacheNodeUpdateStatus{}}
            let cacheNodeUpdateStatusWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CacheNodeUpdateStatus>.CodingKeys.self, forKey: .cacheNodeUpdateStatus)
            if let cacheNodeUpdateStatusWrappedContainer = cacheNodeUpdateStatusWrappedContainer {
                let cacheNodeUpdateStatusContainer = try cacheNodeUpdateStatusWrappedContainer.decodeIfPresent([CacheNodeUpdateStatus].self, forKey: .member)
                var cacheNodeUpdateStatusBuffer:[CacheNodeUpdateStatus]? = nil
                if let cacheNodeUpdateStatusContainer = cacheNodeUpdateStatusContainer {
                    cacheNodeUpdateStatusBuffer = [CacheNodeUpdateStatus]()
                    for structureContainer0 in cacheNodeUpdateStatusContainer {
                        cacheNodeUpdateStatusBuffer?.append(structureContainer0)
                    }
                }
                cacheNodeUpdateStatus = cacheNodeUpdateStatusBuffer
            } else {
                cacheNodeUpdateStatus = []
            }
        } else {
            cacheNodeUpdateStatus = nil
        }
        let estimatedUpdateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedUpdateTime)
        estimatedUpdateTime = estimatedUpdateTimeDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
    }
}
