// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient permissions to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaConfiguration = "LambdaConfiguration"
        case sNSConfiguration = "SNSConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaConfiguration = lambdaConfiguration {
            try encodeContainer.encode(lambdaConfiguration, forKey: .lambdaConfiguration)
        }
        if let sNSConfiguration = sNSConfiguration {
            try encodeContainer.encode(sNSConfiguration, forKey: .sNSConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sNSConfigurationDecoded = try containerValues.decodeIfPresent(SNSConfiguration.self, forKey: .sNSConfiguration)
        sNSConfiguration = sNSConfigurationDecoded
        let lambdaConfigurationDecoded = try containerValues.decodeIfPresent(LambdaConfiguration.self, forKey: .lambdaConfiguration)
        lambdaConfiguration = lambdaConfigurationDecoded
    }
}

extension Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Action(lambdaConfiguration: \(String(describing: lambdaConfiguration)), sNSConfiguration: \(String(describing: sNSConfiguration)))"}
}

/// <p>A configuration that specifies the action to perform when anomalies are detected.</p>
public struct Action: Equatable {
    /// <p>A configuration for an AWS Lambda channel.</p>
    public let lambdaConfiguration: LambdaConfiguration?
    /// <p>A configuration for an Amazon SNS channel.</p>
    public let sNSConfiguration: SNSConfiguration?

    public init (
        lambdaConfiguration: LambdaConfiguration? = nil,
        sNSConfiguration: SNSConfiguration? = nil
    )
    {
        self.lambdaConfiguration = lambdaConfiguration
        self.sNSConfiguration = sNSConfiguration
    }
}

public struct ActivateAnomalyDetectorInputBodyMiddleware: Middleware {
    public let id: String = "ActivateAnomalyDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<ActivateAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateAnomalyDetectorOutputError>
}

extension ActivateAnomalyDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivateAnomalyDetectorInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)))"}
}

extension ActivateAnomalyDetectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

public struct ActivateAnomalyDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "ActivateAnomalyDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<ActivateAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateAnomalyDetectorOutputError>
}

public struct ActivateAnomalyDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "ActivateAnomalyDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<ActivateAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateAnomalyDetectorOutputError>
}

public struct ActivateAnomalyDetectorInput: Equatable {
    /// <p>The ARN of the anomaly detector.</p>
    public let anomalyDetectorArn: String?

    public init (
        anomalyDetectorArn: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct ActivateAnomalyDetectorInputBody: Equatable {
    public let anomalyDetectorArn: String?
}

extension ActivateAnomalyDetectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension ActivateAnomalyDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateAnomalyDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ActivateAnomalyDetectorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateAnomalyDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivateAnomalyDetectorOutputResponse()"}
}

extension ActivateAnomalyDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ActivateAnomalyDetectorOutputResponse: Equatable {

    public init() {}
}

struct ActivateAnomalyDetectorOutputResponseBody: Equatable {
}

extension ActivateAnomalyDetectorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum AggregationFunction {
    case avg
    case sum
    case sdkUnknown(String)
}

extension AggregationFunction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AggregationFunction] {
        return [
            .avg,
            .sum,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .avg: return "AVG"
        case .sum: return "SUM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AggregationFunction(rawValue: rawValue) ?? AggregationFunction.sdkUnknown(rawValue)
    }
}

extension Alert: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case alertArn = "AlertArn"
        case alertDescription = "AlertDescription"
        case alertName = "AlertName"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
        case alertStatus = "AlertStatus"
        case alertType = "AlertType"
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let alertArn = alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
        if let alertDescription = alertDescription {
            try encodeContainer.encode(alertDescription, forKey: .alertDescription)
        }
        if let alertName = alertName {
            try encodeContainer.encode(alertName, forKey: .alertName)
        }
        if alertSensitivityThreshold != 0 {
            try encodeContainer.encode(alertSensitivityThreshold, forKey: .alertSensitivityThreshold)
        }
        if let alertStatus = alertStatus {
            try encodeContainer.encode(alertStatus.rawValue, forKey: .alertStatus)
        }
        if let alertType = alertType {
            try encodeContainer.encode(alertType.rawValue, forKey: .alertType)
        }
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let alertDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alertDescription)
        alertDescription = alertDescriptionDecoded
        let alertArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let alertNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alertName)
        alertName = alertNameDecoded
        let alertSensitivityThresholdDecoded = try containerValues.decode(Int.self, forKey: .alertSensitivityThreshold)
        alertSensitivityThreshold = alertSensitivityThresholdDecoded
        let alertTypeDecoded = try containerValues.decodeIfPresent(AlertType.self, forKey: .alertType)
        alertType = alertTypeDecoded
        let alertStatusDecoded = try containerValues.decodeIfPresent(AlertStatus.self, forKey: .alertStatus)
        alertStatus = alertStatusDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension Alert: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Alert(action: \(String(describing: action)), alertArn: \(String(describing: alertArn)), alertDescription: \(String(describing: alertDescription)), alertName: \(String(describing: alertName)), alertSensitivityThreshold: \(String(describing: alertSensitivityThreshold)), alertStatus: \(String(describing: alertStatus)), alertType: \(String(describing: alertType)), anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), creationTime: \(String(describing: creationTime)), lastModificationTime: \(String(describing: lastModificationTime)))"}
}

/// <p>A configuration for Amazon SNS-integrated notifications.</p>
public struct Alert: Equatable {
    /// <p>Action that will be triggered when there is an alert.</p>
    public let action: Action?
    /// <p>The ARN of the alert.</p>
    public let alertArn: String?
    /// <p>A description of the alert.</p>
    public let alertDescription: String?
    /// <p>The name of the alert.</p>
    public let alertName: String?
    /// <p>The minimum severity for an anomaly to trigger the alert.</p>
    public let alertSensitivityThreshold: Int
    /// <p>The status of the alert.</p>
    public let alertStatus: AlertStatus?
    /// <p>The type of the alert.</p>
    public let alertType: AlertType?
    /// <p>The ARN of the detector to which the alert is attached.</p>
    public let anomalyDetectorArn: String?
    /// <p>The time at which the alert was created.</p>
    public let creationTime: Date?
    /// <p>The time at which the alert was last modified.</p>
    public let lastModificationTime: Date?

    public init (
        action: Action? = nil,
        alertArn: String? = nil,
        alertDescription: String? = nil,
        alertName: String? = nil,
        alertSensitivityThreshold: Int = 0,
        alertStatus: AlertStatus? = nil,
        alertType: AlertType? = nil,
        anomalyDetectorArn: String? = nil,
        creationTime: Date? = nil,
        lastModificationTime: Date? = nil
    )
    {
        self.action = action
        self.alertArn = alertArn
        self.alertDescription = alertDescription
        self.alertName = alertName
        self.alertSensitivityThreshold = alertSensitivityThreshold
        self.alertStatus = alertStatus
        self.alertType = alertType
        self.anomalyDetectorArn = anomalyDetectorArn
        self.creationTime = creationTime
        self.lastModificationTime = lastModificationTime
    }
}

public enum AlertStatus {
    case active
    case inactive
    case sdkUnknown(String)
}

extension AlertStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AlertStatus] {
        return [
            .active,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AlertStatus(rawValue: rawValue) ?? AlertStatus.sdkUnknown(rawValue)
    }
}

extension AlertSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alertArn = "AlertArn"
        case alertName = "AlertName"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
        case alertStatus = "AlertStatus"
        case alertType = "AlertType"
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertArn = alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
        if let alertName = alertName {
            try encodeContainer.encode(alertName, forKey: .alertName)
        }
        if alertSensitivityThreshold != 0 {
            try encodeContainer.encode(alertSensitivityThreshold, forKey: .alertSensitivityThreshold)
        }
        if let alertStatus = alertStatus {
            try encodeContainer.encode(alertStatus.rawValue, forKey: .alertStatus)
        }
        if let alertType = alertType {
            try encodeContainer.encode(alertType.rawValue, forKey: .alertType)
        }
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let alertNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alertName)
        alertName = alertNameDecoded
        let alertSensitivityThresholdDecoded = try containerValues.decode(Int.self, forKey: .alertSensitivityThreshold)
        alertSensitivityThreshold = alertSensitivityThresholdDecoded
        let alertTypeDecoded = try containerValues.decodeIfPresent(AlertType.self, forKey: .alertType)
        alertType = alertTypeDecoded
        let alertStatusDecoded = try containerValues.decodeIfPresent(AlertStatus.self, forKey: .alertStatus)
        alertStatus = alertStatusDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AlertSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlertSummary(alertArn: \(String(describing: alertArn)), alertName: \(String(describing: alertName)), alertSensitivityThreshold: \(String(describing: alertSensitivityThreshold)), alertStatus: \(String(describing: alertStatus)), alertType: \(String(describing: alertType)), anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), creationTime: \(String(describing: creationTime)), lastModificationTime: \(String(describing: lastModificationTime)), tags: \(String(describing: tags)))"}
}

/// <p>Provides a summary of an alert's configuration.</p>
public struct AlertSummary: Equatable {
    /// <p>The ARN of the alert.</p>
    public let alertArn: String?
    /// <p>The name of the alert.</p>
    public let alertName: String?
    /// <p>The minimum severity for an anomaly to trigger the alert.</p>
    public let alertSensitivityThreshold: Int
    /// <p>The status of the alert.</p>
    public let alertStatus: AlertStatus?
    /// <p>The type of the alert.</p>
    public let alertType: AlertType?
    /// <p>The ARN of the detector to which the alert is attached.</p>
    public let anomalyDetectorArn: String?
    /// <p>The time at which the alert was created.</p>
    public let creationTime: Date?
    /// <p>The time at which the alert was last modified.</p>
    public let lastModificationTime: Date?
    /// <p>The alert's <a href="https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html">tags</a>.</p>
    public let tags: [String:String]?

    public init (
        alertArn: String? = nil,
        alertName: String? = nil,
        alertSensitivityThreshold: Int = 0,
        alertStatus: AlertStatus? = nil,
        alertType: AlertType? = nil,
        anomalyDetectorArn: String? = nil,
        creationTime: Date? = nil,
        lastModificationTime: Date? = nil,
        tags: [String:String]? = nil
    )
    {
        self.alertArn = alertArn
        self.alertName = alertName
        self.alertSensitivityThreshold = alertSensitivityThreshold
        self.alertStatus = alertStatus
        self.alertType = alertType
        self.anomalyDetectorArn = anomalyDetectorArn
        self.creationTime = creationTime
        self.lastModificationTime = lastModificationTime
        self.tags = tags
    }
}

public enum AlertType {
    case lambda
    case sns
    case sdkUnknown(String)
}

extension AlertType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AlertType] {
        return [
            .lambda,
            .sns,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lambda: return "LAMBDA"
        case .sns: return "SNS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AlertType(rawValue: rawValue) ?? AlertType.sdkUnknown(rawValue)
    }
}

public enum AnomalyDetectionTaskStatus {
    case completed
    case failed
    case failedToSchedule
    case inProgress
    case pending
    case sdkUnknown(String)
}

extension AnomalyDetectionTaskStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnomalyDetectionTaskStatus] {
        return [
            .completed,
            .failed,
            .failedToSchedule,
            .inProgress,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .failedToSchedule: return "FAILED_TO_SCHEDULE"
        case .inProgress: return "IN_PROGRESS"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnomalyDetectionTaskStatus(rawValue: rawValue) ?? AnomalyDetectionTaskStatus.sdkUnknown(rawValue)
    }
}

extension AnomalyDetectorConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorFrequency = "AnomalyDetectorFrequency"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorFrequency = anomalyDetectorFrequency {
            try encodeContainer.encode(anomalyDetectorFrequency.rawValue, forKey: .anomalyDetectorFrequency)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorFrequencyDecoded = try containerValues.decodeIfPresent(Frequency.self, forKey: .anomalyDetectorFrequency)
        anomalyDetectorFrequency = anomalyDetectorFrequencyDecoded
    }
}

extension AnomalyDetectorConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyDetectorConfig(anomalyDetectorFrequency: \(String(describing: anomalyDetectorFrequency)))"}
}

/// <p>Contains information about a detector's configuration.</p>
public struct AnomalyDetectorConfig: Equatable {
    /// <p>The frequency at which the detector analyzes its source data.</p>
    public let anomalyDetectorFrequency: Frequency?

    public init (
        anomalyDetectorFrequency: Frequency? = nil
    )
    {
        self.anomalyDetectorFrequency = anomalyDetectorFrequency
    }
}

extension AnomalyDetectorConfigSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorFrequency = "AnomalyDetectorFrequency"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorFrequency = anomalyDetectorFrequency {
            try encodeContainer.encode(anomalyDetectorFrequency.rawValue, forKey: .anomalyDetectorFrequency)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorFrequencyDecoded = try containerValues.decodeIfPresent(Frequency.self, forKey: .anomalyDetectorFrequency)
        anomalyDetectorFrequency = anomalyDetectorFrequencyDecoded
    }
}

extension AnomalyDetectorConfigSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyDetectorConfigSummary(anomalyDetectorFrequency: \(String(describing: anomalyDetectorFrequency)))"}
}

/// <p>Contains information about a detector's configuration.</p>
public struct AnomalyDetectorConfigSummary: Equatable {
    /// <p>The interval at which the detector analyzes its source data.</p>
    public let anomalyDetectorFrequency: Frequency?

    public init (
        anomalyDetectorFrequency: Frequency? = nil
    )
    {
        self.anomalyDetectorFrequency = anomalyDetectorFrequency
    }
}

public enum AnomalyDetectorStatus {
    case activating
    case active
    case backTestActivating
    case backTestActive
    case backTestComplete
    case deleting
    case failed
    case inactive
    case sdkUnknown(String)
}

extension AnomalyDetectorStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnomalyDetectorStatus] {
        return [
            .activating,
            .active,
            .backTestActivating,
            .backTestActive,
            .backTestComplete,
            .deleting,
            .failed,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activating: return "ACTIVATING"
        case .active: return "ACTIVE"
        case .backTestActivating: return "BACK_TEST_ACTIVATING"
        case .backTestActive: return "BACK_TEST_ACTIVE"
        case .backTestComplete: return "BACK_TEST_COMPLETE"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnomalyDetectorStatus(rawValue: rawValue) ?? AnomalyDetectorStatus.sdkUnknown(rawValue)
    }
}

extension AnomalyDetectorSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case anomalyDetectorName = "AnomalyDetectorName"
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyDetectorDescription = anomalyDetectorDescription {
            try encodeContainer.encode(anomalyDetectorDescription, forKey: .anomalyDetectorDescription)
        }
        if let anomalyDetectorName = anomalyDetectorName {
            try encodeContainer.encode(anomalyDetectorName, forKey: .anomalyDetectorName)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyDetectorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorName)
        anomalyDetectorName = anomalyDetectorNameDecoded
        let anomalyDetectorDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorDescription)
        anomalyDetectorDescription = anomalyDetectorDescriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AnomalyDetectorStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AnomalyDetectorSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyDetectorSummary(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), anomalyDetectorDescription: \(String(describing: anomalyDetectorDescription)), anomalyDetectorName: \(String(describing: anomalyDetectorName)), creationTime: \(String(describing: creationTime)), lastModificationTime: \(String(describing: lastModificationTime)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

/// <p>Contains information about an an anomaly detector.</p>
public struct AnomalyDetectorSummary: Equatable {
    /// <p>The ARN of the detector.</p>
    public let anomalyDetectorArn: String?
    /// <p>A description of the detector.</p>
    public let anomalyDetectorDescription: String?
    /// <p>The name of the detector.</p>
    public let anomalyDetectorName: String?
    /// <p>The time at which the detector was created.</p>
    public let creationTime: Date?
    /// <p>The time at which the detector was last modified.</p>
    public let lastModificationTime: Date?
    /// <p>The status of detector.</p>
    public let status: AnomalyDetectorStatus?
    /// <p>The detector's <a href="https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html">tags</a>.</p>
    public let tags: [String:String]?

    public init (
        anomalyDetectorArn: String? = nil,
        anomalyDetectorDescription: String? = nil,
        anomalyDetectorName: String? = nil,
        creationTime: Date? = nil,
        lastModificationTime: Date? = nil,
        status: AnomalyDetectorStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.anomalyDetectorName = anomalyDetectorName
        self.creationTime = creationTime
        self.lastModificationTime = lastModificationTime
        self.status = status
        self.tags = tags
    }
}

extension AnomalyGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case anomalyGroupScore = "AnomalyGroupScore"
        case endTime = "EndTime"
        case metricLevelImpactList = "MetricLevelImpactList"
        case primaryMetricName = "PrimaryMetricName"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let anomalyGroupScore = anomalyGroupScore {
            try encodeContainer.encode(anomalyGroupScore, forKey: .anomalyGroupScore)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let metricLevelImpactList = metricLevelImpactList {
            var metricLevelImpactListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricLevelImpactList)
            for metriclevelimpactlist0 in metricLevelImpactList {
                try metricLevelImpactListContainer.encode(metriclevelimpactlist0)
            }
        }
        if let primaryMetricName = primaryMetricName {
            try encodeContainer.encode(primaryMetricName, forKey: .primaryMetricName)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let anomalyGroupScoreDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .anomalyGroupScore)
        anomalyGroupScore = anomalyGroupScoreDecoded
        let primaryMetricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .primaryMetricName)
        primaryMetricName = primaryMetricNameDecoded
        let metricLevelImpactListContainer = try containerValues.decodeIfPresent([MetricLevelImpact?].self, forKey: .metricLevelImpactList)
        var metricLevelImpactListDecoded0:[MetricLevelImpact]? = nil
        if let metricLevelImpactListContainer = metricLevelImpactListContainer {
            metricLevelImpactListDecoded0 = [MetricLevelImpact]()
            for structure0 in metricLevelImpactListContainer {
                if let structure0 = structure0 {
                    metricLevelImpactListDecoded0?.append(structure0)
                }
            }
        }
        metricLevelImpactList = metricLevelImpactListDecoded0
    }
}

extension AnomalyGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyGroup(anomalyGroupId: \(String(describing: anomalyGroupId)), anomalyGroupScore: \(String(describing: anomalyGroupScore)), endTime: \(String(describing: endTime)), metricLevelImpactList: \(String(describing: metricLevelImpactList)), primaryMetricName: \(String(describing: primaryMetricName)), startTime: \(String(describing: startTime)))"}
}

/// <p>A group of anomalous metrics</p>
public struct AnomalyGroup: Equatable {
    /// <p>The ID of the anomaly group.</p>
    public let anomalyGroupId: String?
    /// <p>The severity score of the group.</p>
    public let anomalyGroupScore: Double?
    /// <p>The end time for the group.</p>
    public let endTime: String?
    /// <p>A list of measures affected by the anomaly.</p>
    public let metricLevelImpactList: [MetricLevelImpact]?
    /// <p>The name of the primary affected measure for the group.</p>
    public let primaryMetricName: String?
    /// <p>The start time for the group.</p>
    public let startTime: String?

    public init (
        anomalyGroupId: String? = nil,
        anomalyGroupScore: Double? = nil,
        endTime: String? = nil,
        metricLevelImpactList: [MetricLevelImpact]? = nil,
        primaryMetricName: String? = nil,
        startTime: String? = nil
    )
    {
        self.anomalyGroupId = anomalyGroupId
        self.anomalyGroupScore = anomalyGroupScore
        self.endTime = endTime
        self.metricLevelImpactList = metricLevelImpactList
        self.primaryMetricName = primaryMetricName
        self.startTime = startTime
    }
}

extension AnomalyGroupStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evaluationStartDate = "EvaluationStartDate"
        case itemizedMetricStatsList = "ItemizedMetricStatsList"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationStartDate = evaluationStartDate {
            try encodeContainer.encode(evaluationStartDate, forKey: .evaluationStartDate)
        }
        if let itemizedMetricStatsList = itemizedMetricStatsList {
            var itemizedMetricStatsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .itemizedMetricStatsList)
            for itemizedmetricstatslist0 in itemizedMetricStatsList {
                try itemizedMetricStatsListContainer.encode(itemizedmetricstatslist0)
            }
        }
        if totalCount != 0 {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationStartDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evaluationStartDate)
        evaluationStartDate = evaluationStartDateDecoded
        let totalCountDecoded = try containerValues.decode(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let itemizedMetricStatsListContainer = try containerValues.decodeIfPresent([ItemizedMetricStats?].self, forKey: .itemizedMetricStatsList)
        var itemizedMetricStatsListDecoded0:[ItemizedMetricStats]? = nil
        if let itemizedMetricStatsListContainer = itemizedMetricStatsListContainer {
            itemizedMetricStatsListDecoded0 = [ItemizedMetricStats]()
            for structure0 in itemizedMetricStatsListContainer {
                if let structure0 = structure0 {
                    itemizedMetricStatsListDecoded0?.append(structure0)
                }
            }
        }
        itemizedMetricStatsList = itemizedMetricStatsListDecoded0
    }
}

extension AnomalyGroupStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyGroupStatistics(evaluationStartDate: \(String(describing: evaluationStartDate)), itemizedMetricStatsList: \(String(describing: itemizedMetricStatsList)), totalCount: \(String(describing: totalCount)))"}
}

/// <p>Aggregated statistics for a group of anomalous metrics.</p>
public struct AnomalyGroupStatistics: Equatable {
    /// <p>The start of the time range that was searched.</p>
    public let evaluationStartDate: String?
    /// <p>Statistics for individual metrics within the group.</p>
    public let itemizedMetricStatsList: [ItemizedMetricStats]?
    /// <p>The number of groups found.</p>
    public let totalCount: Int

    public init (
        evaluationStartDate: String? = nil,
        itemizedMetricStatsList: [ItemizedMetricStats]? = nil,
        totalCount: Int = 0
    )
    {
        self.evaluationStartDate = evaluationStartDate
        self.itemizedMetricStatsList = itemizedMetricStatsList
        self.totalCount = totalCount
    }
}

extension AnomalyGroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case anomalyGroupScore = "AnomalyGroupScore"
        case endTime = "EndTime"
        case primaryMetricName = "PrimaryMetricName"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let anomalyGroupScore = anomalyGroupScore {
            try encodeContainer.encode(anomalyGroupScore, forKey: .anomalyGroupScore)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let primaryMetricName = primaryMetricName {
            try encodeContainer.encode(primaryMetricName, forKey: .primaryMetricName)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let anomalyGroupScoreDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .anomalyGroupScore)
        anomalyGroupScore = anomalyGroupScoreDecoded
        let primaryMetricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .primaryMetricName)
        primaryMetricName = primaryMetricNameDecoded
    }
}

extension AnomalyGroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyGroupSummary(anomalyGroupId: \(String(describing: anomalyGroupId)), anomalyGroupScore: \(String(describing: anomalyGroupScore)), endTime: \(String(describing: endTime)), primaryMetricName: \(String(describing: primaryMetricName)), startTime: \(String(describing: startTime)))"}
}

/// <p>Details about a group of anomalous metrics.</p>
public struct AnomalyGroupSummary: Equatable {
    /// <p>The ID of the anomaly group.</p>
    public let anomalyGroupId: String?
    /// <p>The severity score of the group.</p>
    public let anomalyGroupScore: Double?
    /// <p>The end time for the group.</p>
    public let endTime: String?
    /// <p>The name of the primary affected measure for the group.</p>
    public let primaryMetricName: String?
    /// <p>The start time for the group.</p>
    public let startTime: String?

    public init (
        anomalyGroupId: String? = nil,
        anomalyGroupScore: Double? = nil,
        endTime: String? = nil,
        primaryMetricName: String? = nil,
        startTime: String? = nil
    )
    {
        self.anomalyGroupId = anomalyGroupId
        self.anomalyGroupScore = anomalyGroupScore
        self.endTime = endTime
        self.primaryMetricName = primaryMetricName
        self.startTime = startTime
    }
}

extension AnomalyGroupTimeSeries: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case timeSeriesId = "TimeSeriesId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let timeSeriesId = timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
    }
}

extension AnomalyGroupTimeSeries: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyGroupTimeSeries(anomalyGroupId: \(String(describing: anomalyGroupId)), timeSeriesId: \(String(describing: timeSeriesId)))"}
}

/// <p>An anomalous metric in an anomaly group.</p>
public struct AnomalyGroupTimeSeries: Equatable {
    /// <p>The ID of the anomaly group.</p>
    public let anomalyGroupId: String?
    /// <p>The ID of the metric.</p>
    public let timeSeriesId: String?

    public init (
        anomalyGroupId: String? = nil,
        timeSeriesId: String? = nil
    )
    {
        self.anomalyGroupId = anomalyGroupId
        self.timeSeriesId = timeSeriesId
    }
}

extension AnomalyGroupTimeSeriesFeedback: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case isAnomaly = "IsAnomaly"
        case timeSeriesId = "TimeSeriesId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let isAnomaly = isAnomaly {
            try encodeContainer.encode(isAnomaly, forKey: .isAnomaly)
        }
        if let timeSeriesId = timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let isAnomalyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isAnomaly)
        isAnomaly = isAnomalyDecoded
    }
}

extension AnomalyGroupTimeSeriesFeedback: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyGroupTimeSeriesFeedback(anomalyGroupId: \(String(describing: anomalyGroupId)), isAnomaly: \(String(describing: isAnomaly)), timeSeriesId: \(String(describing: timeSeriesId)))"}
}

/// <p>Feedback for an anomalous metric.</p>
public struct AnomalyGroupTimeSeriesFeedback: Equatable {
    /// <p>The ID of the anomaly group.</p>
    public let anomalyGroupId: String?
    /// <p>Feedback on whether the metric is a legitimate anomaly.</p>
    public let isAnomaly: Bool?
    /// <p>The ID of the metric.</p>
    public let timeSeriesId: String?

    public init (
        anomalyGroupId: String? = nil,
        isAnomaly: Bool? = nil,
        timeSeriesId: String? = nil
    )
    {
        self.anomalyGroupId = anomalyGroupId
        self.isAnomaly = isAnomaly
        self.timeSeriesId = timeSeriesId
    }
}

extension AppFlowConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case flowName = "FlowName"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension AppFlowConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AppFlowConfig(flowName: \(String(describing: flowName)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Details about an Amazon AppFlow flow datasource.</p>
public struct AppFlowConfig: Equatable {
    /// <p> name of the flow.</p>
    public let flowName: String?
    /// <p>An IAM role that gives Amazon Lookout for Metrics permission to access the flow.</p>
    public let roleArn: String?

    public init (
        flowName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.flowName = flowName
        self.roleArn = roleArn
    }
}

public struct BackTestAnomalyDetectorInputBodyMiddleware: Middleware {
    public let id: String = "BackTestAnomalyDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BackTestAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<BackTestAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BackTestAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<BackTestAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BackTestAnomalyDetectorOutputError>
}

extension BackTestAnomalyDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackTestAnomalyDetectorInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)))"}
}

extension BackTestAnomalyDetectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

public struct BackTestAnomalyDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "BackTestAnomalyDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BackTestAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<BackTestAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BackTestAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<BackTestAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BackTestAnomalyDetectorOutputError>
}

public struct BackTestAnomalyDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "BackTestAnomalyDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BackTestAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<BackTestAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BackTestAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<BackTestAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BackTestAnomalyDetectorOutputError>
}

public struct BackTestAnomalyDetectorInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the anomaly detector.</p>
    public let anomalyDetectorArn: String?

    public init (
        anomalyDetectorArn: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct BackTestAnomalyDetectorInputBody: Equatable {
    public let anomalyDetectorArn: String?
}

extension BackTestAnomalyDetectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension BackTestAnomalyDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BackTestAnomalyDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BackTestAnomalyDetectorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BackTestAnomalyDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackTestAnomalyDetectorOutputResponse()"}
}

extension BackTestAnomalyDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct BackTestAnomalyDetectorOutputResponse: Equatable {

    public init() {}
}

struct BackTestAnomalyDetectorOutputResponseBody: Equatable {
}

extension BackTestAnomalyDetectorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum CSVFileCompression {
    case gzip
    case `none`
    case sdkUnknown(String)
}

extension CSVFileCompression : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CSVFileCompression] {
        return [
            .gzip,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .gzip: return "GZIP"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CSVFileCompression(rawValue: rawValue) ?? CSVFileCompression.sdkUnknown(rawValue)
    }
}

extension CloudWatchConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CloudWatchConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchConfig(roleArn: \(String(describing: roleArn)))"}
}

/// <p>Details about an Amazon CloudWatch datasource.</p>
public struct CloudWatchConfig: Equatable {
    /// <p>An IAM role that gives Amazon Lookout for Metrics permission to access data in Amazon CloudWatch.</p>
    public let roleArn: String?

    public init (
        roleArn: String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was a conflict processing the request. Try your request again.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?
    /// <p>The type of the resource.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ContributionMatrix: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensionContributionList = "DimensionContributionList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionContributionList = dimensionContributionList {
            var dimensionContributionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionContributionList)
            for dimensioncontributionlist0 in dimensionContributionList {
                try dimensionContributionListContainer.encode(dimensioncontributionlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionContributionListContainer = try containerValues.decodeIfPresent([DimensionContribution?].self, forKey: .dimensionContributionList)
        var dimensionContributionListDecoded0:[DimensionContribution]? = nil
        if let dimensionContributionListContainer = dimensionContributionListContainer {
            dimensionContributionListDecoded0 = [DimensionContribution]()
            for structure0 in dimensionContributionListContainer {
                if let structure0 = structure0 {
                    dimensionContributionListDecoded0?.append(structure0)
                }
            }
        }
        dimensionContributionList = dimensionContributionListDecoded0
    }
}

extension ContributionMatrix: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContributionMatrix(dimensionContributionList: \(String(describing: dimensionContributionList)))"}
}

/// <p>Details about dimensions that contributed to an anomaly.</p>
public struct ContributionMatrix: Equatable {
    /// <p>A list of contributing dimensions.</p>
    public let dimensionContributionList: [DimensionContribution]?

    public init (
        dimensionContributionList: [DimensionContribution]? = nil
    )
    {
        self.dimensionContributionList = dimensionContributionList
    }
}

public struct CreateAlertInputBodyMiddleware: Middleware {
    public let id: String = "CreateAlertInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAlertInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAlertOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAlertInput>
    public typealias MOutput = OperationOutput<CreateAlertOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAlertOutputError>
}

extension CreateAlertInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAlertInput(action: \(String(describing: action)), alertDescription: \(String(describing: alertDescription)), alertName: \(String(describing: alertName)), alertSensitivityThreshold: \(String(describing: alertSensitivityThreshold)), anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), tags: \(String(describing: tags)))"}
}

extension CreateAlertInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case alertDescription = "AlertDescription"
        case alertName = "AlertName"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let alertDescription = alertDescription {
            try encodeContainer.encode(alertDescription, forKey: .alertDescription)
        }
        if let alertName = alertName {
            try encodeContainer.encode(alertName, forKey: .alertName)
        }
        if alertSensitivityThreshold != 0 {
            try encodeContainer.encode(alertSensitivityThreshold, forKey: .alertSensitivityThreshold)
        }
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAlertInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAlertInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAlertInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAlertOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAlertInput>
    public typealias MOutput = OperationOutput<CreateAlertOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAlertOutputError>
}

public struct CreateAlertInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAlertInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAlertInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAlertOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAlertInput>
    public typealias MOutput = OperationOutput<CreateAlertOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAlertOutputError>
}

public struct CreateAlertInput: Equatable {
    /// <p>Action that will be triggered when there is an alert.</p>
    public let action: Action?
    /// <p>A description of the alert.</p>
    public let alertDescription: String?
    /// <p>The name of the alert.</p>
    public let alertName: String?
    /// <p>An integer from 0 to 100 specifying the alert sensitivity threshold.</p>
    public let alertSensitivityThreshold: Int
    /// <p>The ARN of the detector to which the alert is attached.</p>
    public let anomalyDetectorArn: String?
    /// <p>A list of <a href="https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html">tags</a> to apply to the alert.</p>
    public let tags: [String:String]?

    public init (
        action: Action? = nil,
        alertDescription: String? = nil,
        alertName: String? = nil,
        alertSensitivityThreshold: Int = 0,
        anomalyDetectorArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.action = action
        self.alertDescription = alertDescription
        self.alertName = alertName
        self.alertSensitivityThreshold = alertSensitivityThreshold
        self.anomalyDetectorArn = anomalyDetectorArn
        self.tags = tags
    }
}

struct CreateAlertInputBody: Equatable {
    public let alertName: String?
    public let alertSensitivityThreshold: Int
    public let alertDescription: String?
    public let anomalyDetectorArn: String?
    public let action: Action?
    public let tags: [String:String]?
}

extension CreateAlertInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case alertDescription = "AlertDescription"
        case alertName = "AlertName"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alertName)
        alertName = alertNameDecoded
        let alertSensitivityThresholdDecoded = try containerValues.decode(Int.self, forKey: .alertSensitivityThreshold)
        alertSensitivityThreshold = alertSensitivityThresholdDecoded
        let alertDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alertDescription)
        alertDescription = alertDescriptionDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAlertOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAlertOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAlertOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAlertOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAlertOutputResponse(alertArn: \(String(describing: alertArn)))"}
}

extension CreateAlertOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAlertOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alertArn = output.alertArn
        } else {
            self.alertArn = nil
        }
    }
}

public struct CreateAlertOutputResponse: Equatable {
    /// <p>The ARN of the alert.</p>
    public let alertArn: String?

    public init (
        alertArn: String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

struct CreateAlertOutputResponseBody: Equatable {
    public let alertArn: String?
}

extension CreateAlertOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alertArn = "AlertArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
    }
}

public struct CreateAnomalyDetectorInputBodyMiddleware: Middleware {
    public let id: String = "CreateAnomalyDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<CreateAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnomalyDetectorOutputError>
}

extension CreateAnomalyDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAnomalyDetectorInput(anomalyDetectorConfig: \(String(describing: anomalyDetectorConfig)), anomalyDetectorDescription: \(String(describing: anomalyDetectorDescription)), anomalyDetectorName: \(String(describing: anomalyDetectorName)), kmsKeyArn: \(String(describing: kmsKeyArn)), tags: \(String(describing: tags)))"}
}

extension CreateAnomalyDetectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case anomalyDetectorName = "AnomalyDetectorName"
        case kmsKeyArn = "KmsKeyArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorConfig = anomalyDetectorConfig {
            try encodeContainer.encode(anomalyDetectorConfig, forKey: .anomalyDetectorConfig)
        }
        if let anomalyDetectorDescription = anomalyDetectorDescription {
            try encodeContainer.encode(anomalyDetectorDescription, forKey: .anomalyDetectorDescription)
        }
        if let anomalyDetectorName = anomalyDetectorName {
            try encodeContainer.encode(anomalyDetectorName, forKey: .anomalyDetectorName)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAnomalyDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAnomalyDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<CreateAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnomalyDetectorOutputError>
}

public struct CreateAnomalyDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAnomalyDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<CreateAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnomalyDetectorOutputError>
}

public struct CreateAnomalyDetectorInput: Equatable {
    /// <p>Contains information about the configuration of the anomaly detector.</p>
    public let anomalyDetectorConfig: AnomalyDetectorConfig?
    /// <p>A description of the detector.</p>
    public let anomalyDetectorDescription: String?
    /// <p>The name of the detector.</p>
    public let anomalyDetectorName: String?
    /// <p>The ARN of the KMS key to use to encrypt your data.</p>
    public let kmsKeyArn: String?
    /// <p>A list of <a href="https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html">tags</a> to apply to the anomaly detector.</p>
    public let tags: [String:String]?

    public init (
        anomalyDetectorConfig: AnomalyDetectorConfig? = nil,
        anomalyDetectorDescription: String? = nil,
        anomalyDetectorName: String? = nil,
        kmsKeyArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.anomalyDetectorConfig = anomalyDetectorConfig
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.anomalyDetectorName = anomalyDetectorName
        self.kmsKeyArn = kmsKeyArn
        self.tags = tags
    }
}

struct CreateAnomalyDetectorInputBody: Equatable {
    public let anomalyDetectorName: String?
    public let anomalyDetectorDescription: String?
    public let anomalyDetectorConfig: AnomalyDetectorConfig?
    public let kmsKeyArn: String?
    public let tags: [String:String]?
}

extension CreateAnomalyDetectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case anomalyDetectorName = "AnomalyDetectorName"
        case kmsKeyArn = "KmsKeyArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorName)
        anomalyDetectorName = anomalyDetectorNameDecoded
        let anomalyDetectorDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorDescription)
        anomalyDetectorDescription = anomalyDetectorDescriptionDecoded
        let anomalyDetectorConfigDecoded = try containerValues.decodeIfPresent(AnomalyDetectorConfig.self, forKey: .anomalyDetectorConfig)
        anomalyDetectorConfig = anomalyDetectorConfigDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAnomalyDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnomalyDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAnomalyDetectorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnomalyDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAnomalyDetectorOutputResponse(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)))"}
}

extension CreateAnomalyDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAnomalyDetectorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalyDetectorArn = output.anomalyDetectorArn
        } else {
            self.anomalyDetectorArn = nil
        }
    }
}

public struct CreateAnomalyDetectorOutputResponse: Equatable {
    /// <p>The ARN of the detector.</p>
    public let anomalyDetectorArn: String?

    public init (
        anomalyDetectorArn: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct CreateAnomalyDetectorOutputResponseBody: Equatable {
    public let anomalyDetectorArn: String?
}

extension CreateAnomalyDetectorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

public struct CreateMetricSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateMetricSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMetricSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMetricSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMetricSetInput>
    public typealias MOutput = OperationOutput<CreateMetricSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMetricSetOutputError>
}

extension CreateMetricSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMetricSetInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), dimensionList: \(String(describing: dimensionList)), metricList: \(String(describing: metricList)), metricSetDescription: \(String(describing: metricSetDescription)), metricSetFrequency: \(String(describing: metricSetFrequency)), metricSetName: \(String(describing: metricSetName)), metricSource: \(String(describing: metricSource)), offset: \(String(describing: offset)), tags: \(String(describing: tags)), timestampColumn: \(String(describing: timestampColumn)), timezone: \(String(describing: timezone)))"}
}

extension CreateMetricSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case dimensionList = "DimensionList"
        case metricList = "MetricList"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSetName = "MetricSetName"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case tags = "Tags"
        case timestampColumn = "TimestampColumn"
        case timezone = "Timezone"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let dimensionList = dimensionList {
            var dimensionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionList)
            for dimensionlist0 in dimensionList {
                try dimensionListContainer.encode(dimensionlist0)
            }
        }
        if let metricList = metricList {
            var metricListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricList)
            for metriclist0 in metricList {
                try metricListContainer.encode(metriclist0)
            }
        }
        if let metricSetDescription = metricSetDescription {
            try encodeContainer.encode(metricSetDescription, forKey: .metricSetDescription)
        }
        if let metricSetFrequency = metricSetFrequency {
            try encodeContainer.encode(metricSetFrequency.rawValue, forKey: .metricSetFrequency)
        }
        if let metricSetName = metricSetName {
            try encodeContainer.encode(metricSetName, forKey: .metricSetName)
        }
        if let metricSource = metricSource {
            try encodeContainer.encode(metricSource, forKey: .metricSource)
        }
        if offset != 0 {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let timestampColumn = timestampColumn {
            try encodeContainer.encode(timestampColumn, forKey: .timestampColumn)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }
}

public struct CreateMetricSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMetricSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMetricSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMetricSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMetricSetInput>
    public typealias MOutput = OperationOutput<CreateMetricSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMetricSetOutputError>
}

public struct CreateMetricSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMetricSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMetricSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMetricSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMetricSetInput>
    public typealias MOutput = OperationOutput<CreateMetricSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMetricSetOutputError>
}

public struct CreateMetricSetInput: Equatable {
    /// <p>The ARN of the anomaly detector that will use the dataset.</p>
    public let anomalyDetectorArn: String?
    /// <p>A list of the fields you want to treat as dimensions.</p>
    public let dimensionList: [String]?
    /// <p>A list of metrics that the dataset will contain.</p>
    public let metricList: [Metric]?
    /// <p>A description of the dataset you are creating.</p>
    public let metricSetDescription: String?
    /// <p>The frequency with which the source data will be analyzed for anomalies.</p>
    public let metricSetFrequency: Frequency?
    /// <p>The name of the dataset.</p>
    public let metricSetName: String?
    /// <p>Contains information about how the source data should be interpreted.</p>
    public let metricSource: MetricSource?
    /// <p>After an interval ends, the amount of time that the detector waits before importing data.</p>
    public let offset: Int
    /// <p>A list of <a href="https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html">tags</a> to apply to the dataset.</p>
    public let tags: [String:String]?
    /// <p>Contains information about the column used for tracking time in your source data.</p>
    public let timestampColumn: TimestampColumn?
    /// <p>The time zone in which your source data was recorded.</p>
    public let timezone: String?

    public init (
        anomalyDetectorArn: String? = nil,
        dimensionList: [String]? = nil,
        metricList: [Metric]? = nil,
        metricSetDescription: String? = nil,
        metricSetFrequency: Frequency? = nil,
        metricSetName: String? = nil,
        metricSource: MetricSource? = nil,
        offset: Int = 0,
        tags: [String:String]? = nil,
        timestampColumn: TimestampColumn? = nil,
        timezone: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.dimensionList = dimensionList
        self.metricList = metricList
        self.metricSetDescription = metricSetDescription
        self.metricSetFrequency = metricSetFrequency
        self.metricSetName = metricSetName
        self.metricSource = metricSource
        self.offset = offset
        self.tags = tags
        self.timestampColumn = timestampColumn
        self.timezone = timezone
    }
}

struct CreateMetricSetInputBody: Equatable {
    public let anomalyDetectorArn: String?
    public let metricSetName: String?
    public let metricSetDescription: String?
    public let metricList: [Metric]?
    public let offset: Int
    public let timestampColumn: TimestampColumn?
    public let dimensionList: [String]?
    public let metricSetFrequency: Frequency?
    public let metricSource: MetricSource?
    public let timezone: String?
    public let tags: [String:String]?
}

extension CreateMetricSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case dimensionList = "DimensionList"
        case metricList = "MetricList"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSetName = "MetricSetName"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case tags = "Tags"
        case timestampColumn = "TimestampColumn"
        case timezone = "Timezone"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let metricSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetName)
        metricSetName = metricSetNameDecoded
        let metricSetDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetDescription)
        metricSetDescription = metricSetDescriptionDecoded
        let metricListContainer = try containerValues.decodeIfPresent([Metric?].self, forKey: .metricList)
        var metricListDecoded0:[Metric]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [Metric]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let offsetDecoded = try containerValues.decode(Int.self, forKey: .offset)
        offset = offsetDecoded
        let timestampColumnDecoded = try containerValues.decodeIfPresent(TimestampColumn.self, forKey: .timestampColumn)
        timestampColumn = timestampColumnDecoded
        let dimensionListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dimensionList)
        var dimensionListDecoded0:[String]? = nil
        if let dimensionListContainer = dimensionListContainer {
            dimensionListDecoded0 = [String]()
            for string0 in dimensionListContainer {
                if let string0 = string0 {
                    dimensionListDecoded0?.append(string0)
                }
            }
        }
        dimensionList = dimensionListDecoded0
        let metricSetFrequencyDecoded = try containerValues.decodeIfPresent(Frequency.self, forKey: .metricSetFrequency)
        metricSetFrequency = metricSetFrequencyDecoded
        let metricSourceDecoded = try containerValues.decodeIfPresent(MetricSource.self, forKey: .metricSource)
        metricSource = metricSourceDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMetricSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMetricSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMetricSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMetricSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMetricSetOutputResponse(metricSetArn: \(String(describing: metricSetArn)))"}
}

extension CreateMetricSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMetricSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metricSetArn = output.metricSetArn
        } else {
            self.metricSetArn = nil
        }
    }
}

public struct CreateMetricSetOutputResponse: Equatable {
    /// <p>The ARN of the dataset.</p>
    public let metricSetArn: String?

    public init (
        metricSetArn: String? = nil
    )
    {
        self.metricSetArn = metricSetArn
    }
}

struct CreateMetricSetOutputResponseBody: Equatable {
    public let metricSetArn: String?
}

extension CreateMetricSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metricSetArn = "MetricSetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
    }
}

extension CsvFormatDescriptor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case charset = "Charset"
        case containsHeader = "ContainsHeader"
        case delimiter = "Delimiter"
        case fileCompression = "FileCompression"
        case headerList = "HeaderList"
        case quoteSymbol = "QuoteSymbol"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let charset = charset {
            try encodeContainer.encode(charset, forKey: .charset)
        }
        if let containsHeader = containsHeader {
            try encodeContainer.encode(containsHeader, forKey: .containsHeader)
        }
        if let delimiter = delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let fileCompression = fileCompression {
            try encodeContainer.encode(fileCompression.rawValue, forKey: .fileCompression)
        }
        if let headerList = headerList {
            var headerListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headerList)
            for headerlist0 in headerList {
                try headerListContainer.encode(headerlist0)
            }
        }
        if let quoteSymbol = quoteSymbol {
            try encodeContainer.encode(quoteSymbol, forKey: .quoteSymbol)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileCompressionDecoded = try containerValues.decodeIfPresent(CSVFileCompression.self, forKey: .fileCompression)
        fileCompression = fileCompressionDecoded
        let charsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .charset)
        charset = charsetDecoded
        let containsHeaderDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .containsHeader)
        containsHeader = containsHeaderDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let headerListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .headerList)
        var headerListDecoded0:[String]? = nil
        if let headerListContainer = headerListContainer {
            headerListDecoded0 = [String]()
            for string0 in headerListContainer {
                if let string0 = string0 {
                    headerListDecoded0?.append(string0)
                }
            }
        }
        headerList = headerListDecoded0
        let quoteSymbolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteSymbol)
        quoteSymbol = quoteSymbolDecoded
    }
}

extension CsvFormatDescriptor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CsvFormatDescriptor(charset: \(String(describing: charset)), containsHeader: \(String(describing: containsHeader)), delimiter: \(String(describing: delimiter)), fileCompression: \(String(describing: fileCompression)), headerList: \(String(describing: headerList)), quoteSymbol: \(String(describing: quoteSymbol)))"}
}

/// <p>Contains information about how a source CSV data file should be analyzed.</p>
public struct CsvFormatDescriptor: Equatable {
    /// <p>The character set in which the source CSV file is written.</p>
    public let charset: String?
    /// <p>Whether or not the source CSV file contains a header.</p>
    public let containsHeader: Bool?
    /// <p>The character used to delimit the source CSV file.</p>
    public let delimiter: String?
    /// <p>The level of compression of the source CSV file.</p>
    public let fileCompression: CSVFileCompression?
    /// <p>A list of the source CSV file's headers, if any.</p>
    public let headerList: [String]?
    /// <p>The character used as a quote character.</p>
    public let quoteSymbol: String?

    public init (
        charset: String? = nil,
        containsHeader: Bool? = nil,
        delimiter: String? = nil,
        fileCompression: CSVFileCompression? = nil,
        headerList: [String]? = nil,
        quoteSymbol: String? = nil
    )
    {
        self.charset = charset
        self.containsHeader = containsHeader
        self.delimiter = delimiter
        self.fileCompression = fileCompression
        self.headerList = headerList
        self.quoteSymbol = quoteSymbol
    }
}

public struct DeleteAlertInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAlertInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAlertInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAlertOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAlertInput>
    public typealias MOutput = OperationOutput<DeleteAlertOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAlertOutputError>
}

extension DeleteAlertInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAlertInput(alertArn: \(String(describing: alertArn)))"}
}

extension DeleteAlertInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alertArn = "AlertArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertArn = alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
    }
}

public struct DeleteAlertInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAlertInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAlertInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAlertOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAlertInput>
    public typealias MOutput = OperationOutput<DeleteAlertOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAlertOutputError>
}

public struct DeleteAlertInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAlertInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAlertInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAlertOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAlertInput>
    public typealias MOutput = OperationOutput<DeleteAlertOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAlertOutputError>
}

public struct DeleteAlertInput: Equatable {
    /// <p>The ARN of the alert to delete.</p>
    public let alertArn: String?

    public init (
        alertArn: String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

struct DeleteAlertInputBody: Equatable {
    public let alertArn: String?
}

extension DeleteAlertInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alertArn = "AlertArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
    }
}

extension DeleteAlertOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAlertOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAlertOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAlertOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAlertOutputResponse()"}
}

extension DeleteAlertOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAlertOutputResponse: Equatable {

    public init() {}
}

struct DeleteAlertOutputResponseBody: Equatable {
}

extension DeleteAlertOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteAnomalyDetectorInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAnomalyDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<DeleteAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnomalyDetectorOutputError>
}

extension DeleteAnomalyDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAnomalyDetectorInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)))"}
}

extension DeleteAnomalyDetectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

public struct DeleteAnomalyDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAnomalyDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<DeleteAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnomalyDetectorOutputError>
}

public struct DeleteAnomalyDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAnomalyDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<DeleteAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnomalyDetectorOutputError>
}

public struct DeleteAnomalyDetectorInput: Equatable {
    /// <p>The ARN of the detector to delete.</p>
    public let anomalyDetectorArn: String?

    public init (
        anomalyDetectorArn: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct DeleteAnomalyDetectorInputBody: Equatable {
    public let anomalyDetectorArn: String?
}

extension DeleteAnomalyDetectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension DeleteAnomalyDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnomalyDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAnomalyDetectorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnomalyDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAnomalyDetectorOutputResponse()"}
}

extension DeleteAnomalyDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAnomalyDetectorOutputResponse: Equatable {

    public init() {}
}

struct DeleteAnomalyDetectorOutputResponseBody: Equatable {
}

extension DeleteAnomalyDetectorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAlertInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAlertInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAlertInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAlertOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAlertInput>
    public typealias MOutput = OperationOutput<DescribeAlertOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAlertOutputError>
}

extension DescribeAlertInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAlertInput(alertArn: \(String(describing: alertArn)))"}
}

extension DescribeAlertInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alertArn = "AlertArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertArn = alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
    }
}

public struct DescribeAlertInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAlertInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAlertInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAlertOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAlertInput>
    public typealias MOutput = OperationOutput<DescribeAlertOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAlertOutputError>
}

public struct DescribeAlertInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAlertInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAlertInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAlertOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAlertInput>
    public typealias MOutput = OperationOutput<DescribeAlertOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAlertOutputError>
}

public struct DescribeAlertInput: Equatable {
    /// <p>The ARN of the alert to describe.</p>
    public let alertArn: String?

    public init (
        alertArn: String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

struct DescribeAlertInputBody: Equatable {
    public let alertArn: String?
}

extension DescribeAlertInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alertArn = "AlertArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
    }
}

extension DescribeAlertOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAlertOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAlertOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAlertOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAlertOutputResponse(alert: \(String(describing: alert)))"}
}

extension DescribeAlertOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAlertOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alert = output.alert
        } else {
            self.alert = nil
        }
    }
}

public struct DescribeAlertOutputResponse: Equatable {
    /// <p>Contains information about an alert.</p>
    public let alert: Alert?

    public init (
        alert: Alert? = nil
    )
    {
        self.alert = alert
    }
}

struct DescribeAlertOutputResponseBody: Equatable {
    public let alert: Alert?
}

extension DescribeAlertOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alert = "Alert"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertDecoded = try containerValues.decodeIfPresent(Alert.self, forKey: .alert)
        alert = alertDecoded
    }
}

public struct DescribeAnomalyDetectionExecutionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAnomalyDetectionExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnomalyDetectionExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnomalyDetectionExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnomalyDetectionExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeAnomalyDetectionExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnomalyDetectionExecutionsOutputError>
}

extension DescribeAnomalyDetectionExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAnomalyDetectionExecutionsInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), timestamp: \(String(describing: timestamp)))"}
}

extension DescribeAnomalyDetectionExecutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }
}

public struct DescribeAnomalyDetectionExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAnomalyDetectionExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnomalyDetectionExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnomalyDetectionExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnomalyDetectionExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeAnomalyDetectionExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnomalyDetectionExecutionsOutputError>
}

public struct DescribeAnomalyDetectionExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAnomalyDetectionExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnomalyDetectionExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnomalyDetectionExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnomalyDetectionExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeAnomalyDetectionExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnomalyDetectionExecutionsOutputError>
}

public struct DescribeAnomalyDetectionExecutionsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the anomaly detector.</p>
    public let anomalyDetectorArn: String?
    /// <p>The number of items to return in the response.</p>
    public let maxResults: Int
    /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
    public let nextToken: String?
    /// <p>The timestamp of the anomaly detection job.</p>
    public let timestamp: String?

    public init (
        anomalyDetectorArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        timestamp: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timestamp = timestamp
    }
}

struct DescribeAnomalyDetectionExecutionsInputBody: Equatable {
    public let anomalyDetectorArn: String?
    public let timestamp: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeAnomalyDetectionExecutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timestamp = "Timestamp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAnomalyDetectionExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnomalyDetectionExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAnomalyDetectionExecutionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnomalyDetectionExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAnomalyDetectionExecutionsOutputResponse(executionList: \(String(describing: executionList)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAnomalyDetectionExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAnomalyDetectionExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.executionList = output.executionList
            self.nextToken = output.nextToken
        } else {
            self.executionList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAnomalyDetectionExecutionsOutputResponse: Equatable {
    /// <p>A list of detection jobs.</p>
    public let executionList: [ExecutionStatus]?
    /// <p>The pagination token that's included if more results are available.</p>
    public let nextToken: String?

    public init (
        executionList: [ExecutionStatus]? = nil,
        nextToken: String? = nil
    )
    {
        self.executionList = executionList
        self.nextToken = nextToken
    }
}

struct DescribeAnomalyDetectionExecutionsOutputResponseBody: Equatable {
    public let executionList: [ExecutionStatus]?
    public let nextToken: String?
}

extension DescribeAnomalyDetectionExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionList = "ExecutionList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionListContainer = try containerValues.decodeIfPresent([ExecutionStatus?].self, forKey: .executionList)
        var executionListDecoded0:[ExecutionStatus]? = nil
        if let executionListContainer = executionListContainer {
            executionListDecoded0 = [ExecutionStatus]()
            for structure0 in executionListContainer {
                if let structure0 = structure0 {
                    executionListDecoded0?.append(structure0)
                }
            }
        }
        executionList = executionListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAnomalyDetectorInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAnomalyDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<DescribeAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnomalyDetectorOutputError>
}

extension DescribeAnomalyDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAnomalyDetectorInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)))"}
}

extension DescribeAnomalyDetectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

public struct DescribeAnomalyDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAnomalyDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<DescribeAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnomalyDetectorOutputError>
}

public struct DescribeAnomalyDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAnomalyDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<DescribeAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnomalyDetectorOutputError>
}

public struct DescribeAnomalyDetectorInput: Equatable {
    /// <p>The ARN of the detector to describe.</p>
    public let anomalyDetectorArn: String?

    public init (
        anomalyDetectorArn: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct DescribeAnomalyDetectorInputBody: Equatable {
    public let anomalyDetectorArn: String?
}

extension DescribeAnomalyDetectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension DescribeAnomalyDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnomalyDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAnomalyDetectorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnomalyDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAnomalyDetectorOutputResponse(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), anomalyDetectorConfig: \(String(describing: anomalyDetectorConfig)), anomalyDetectorDescription: \(String(describing: anomalyDetectorDescription)), anomalyDetectorName: \(String(describing: anomalyDetectorName)), creationTime: \(String(describing: creationTime)), failureReason: \(String(describing: failureReason)), kmsKeyArn: \(String(describing: kmsKeyArn)), lastModificationTime: \(String(describing: lastModificationTime)), status: \(String(describing: status)))"}
}

extension DescribeAnomalyDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAnomalyDetectorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalyDetectorArn = output.anomalyDetectorArn
            self.anomalyDetectorConfig = output.anomalyDetectorConfig
            self.anomalyDetectorDescription = output.anomalyDetectorDescription
            self.anomalyDetectorName = output.anomalyDetectorName
            self.creationTime = output.creationTime
            self.failureReason = output.failureReason
            self.kmsKeyArn = output.kmsKeyArn
            self.lastModificationTime = output.lastModificationTime
            self.status = output.status
        } else {
            self.anomalyDetectorArn = nil
            self.anomalyDetectorConfig = nil
            self.anomalyDetectorDescription = nil
            self.anomalyDetectorName = nil
            self.creationTime = nil
            self.failureReason = nil
            self.kmsKeyArn = nil
            self.lastModificationTime = nil
            self.status = nil
        }
    }
}

public struct DescribeAnomalyDetectorOutputResponse: Equatable {
    /// <p>The ARN of the detector.</p>
    public let anomalyDetectorArn: String?
    /// <p>Contains information about the detector's configuration.</p>
    public let anomalyDetectorConfig: AnomalyDetectorConfigSummary?
    /// <p>A description of the detector.</p>
    public let anomalyDetectorDescription: String?
    /// <p>The name of the detector.</p>
    public let anomalyDetectorName: String?
    /// <p>The time at which the detector was created.</p>
    public let creationTime: Date?
    /// <p>The reason that the detector failed, if any.</p>
    public let failureReason: String?
    /// <p>The ARN of the KMS key to use to encrypt your data.</p>
    public let kmsKeyArn: String?
    /// <p>The time at which the detector was last modified.</p>
    public let lastModificationTime: Date?
    /// <p>The status of the detector.</p>
    public let status: AnomalyDetectorStatus?

    public init (
        anomalyDetectorArn: String? = nil,
        anomalyDetectorConfig: AnomalyDetectorConfigSummary? = nil,
        anomalyDetectorDescription: String? = nil,
        anomalyDetectorName: String? = nil,
        creationTime: Date? = nil,
        failureReason: String? = nil,
        kmsKeyArn: String? = nil,
        lastModificationTime: Date? = nil,
        status: AnomalyDetectorStatus? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyDetectorConfig = anomalyDetectorConfig
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.anomalyDetectorName = anomalyDetectorName
        self.creationTime = creationTime
        self.failureReason = failureReason
        self.kmsKeyArn = kmsKeyArn
        self.lastModificationTime = lastModificationTime
        self.status = status
    }
}

struct DescribeAnomalyDetectorOutputResponseBody: Equatable {
    public let anomalyDetectorArn: String?
    public let anomalyDetectorName: String?
    public let anomalyDetectorDescription: String?
    public let anomalyDetectorConfig: AnomalyDetectorConfigSummary?
    public let creationTime: Date?
    public let lastModificationTime: Date?
    public let status: AnomalyDetectorStatus?
    public let failureReason: String?
    public let kmsKeyArn: String?
}

extension DescribeAnomalyDetectorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case anomalyDetectorName = "AnomalyDetectorName"
        case creationTime = "CreationTime"
        case failureReason = "FailureReason"
        case kmsKeyArn = "KmsKeyArn"
        case lastModificationTime = "LastModificationTime"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyDetectorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorName)
        anomalyDetectorName = anomalyDetectorNameDecoded
        let anomalyDetectorDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorDescription)
        anomalyDetectorDescription = anomalyDetectorDescriptionDecoded
        let anomalyDetectorConfigDecoded = try containerValues.decodeIfPresent(AnomalyDetectorConfigSummary.self, forKey: .anomalyDetectorConfig)
        anomalyDetectorConfig = anomalyDetectorConfigDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AnomalyDetectorStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

public struct DescribeMetricSetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMetricSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMetricSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMetricSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMetricSetInput>
    public typealias MOutput = OperationOutput<DescribeMetricSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMetricSetOutputError>
}

extension DescribeMetricSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMetricSetInput(metricSetArn: \(String(describing: metricSetArn)))"}
}

extension DescribeMetricSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metricSetArn = "MetricSetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricSetArn = metricSetArn {
            try encodeContainer.encode(metricSetArn, forKey: .metricSetArn)
        }
    }
}

public struct DescribeMetricSetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMetricSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMetricSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMetricSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMetricSetInput>
    public typealias MOutput = OperationOutput<DescribeMetricSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMetricSetOutputError>
}

public struct DescribeMetricSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMetricSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMetricSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMetricSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMetricSetInput>
    public typealias MOutput = OperationOutput<DescribeMetricSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMetricSetOutputError>
}

public struct DescribeMetricSetInput: Equatable {
    /// <p>The ARN of the dataset.</p>
    public let metricSetArn: String?

    public init (
        metricSetArn: String? = nil
    )
    {
        self.metricSetArn = metricSetArn
    }
}

struct DescribeMetricSetInputBody: Equatable {
    public let metricSetArn: String?
}

extension DescribeMetricSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metricSetArn = "MetricSetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
    }
}

extension DescribeMetricSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMetricSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMetricSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMetricSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMetricSetOutputResponse(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), creationTime: \(String(describing: creationTime)), dimensionList: \(String(describing: dimensionList)), lastModificationTime: \(String(describing: lastModificationTime)), metricList: \(String(describing: metricList)), metricSetArn: \(String(describing: metricSetArn)), metricSetDescription: \(String(describing: metricSetDescription)), metricSetFrequency: \(String(describing: metricSetFrequency)), metricSetName: \(String(describing: metricSetName)), metricSource: \(String(describing: metricSource)), offset: \(String(describing: offset)), timestampColumn: \(String(describing: timestampColumn)), timezone: \(String(describing: timezone)))"}
}

extension DescribeMetricSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMetricSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalyDetectorArn = output.anomalyDetectorArn
            self.creationTime = output.creationTime
            self.dimensionList = output.dimensionList
            self.lastModificationTime = output.lastModificationTime
            self.metricList = output.metricList
            self.metricSetArn = output.metricSetArn
            self.metricSetDescription = output.metricSetDescription
            self.metricSetFrequency = output.metricSetFrequency
            self.metricSetName = output.metricSetName
            self.metricSource = output.metricSource
            self.offset = output.offset
            self.timestampColumn = output.timestampColumn
            self.timezone = output.timezone
        } else {
            self.anomalyDetectorArn = nil
            self.creationTime = nil
            self.dimensionList = nil
            self.lastModificationTime = nil
            self.metricList = nil
            self.metricSetArn = nil
            self.metricSetDescription = nil
            self.metricSetFrequency = nil
            self.metricSetName = nil
            self.metricSource = nil
            self.offset = 0
            self.timestampColumn = nil
            self.timezone = nil
        }
    }
}

public struct DescribeMetricSetOutputResponse: Equatable {
    /// <p>The ARN of the detector that contains the dataset.</p>
    public let anomalyDetectorArn: String?
    /// <p>The time at which the dataset was created.</p>
    public let creationTime: Date?
    /// <p>A list of the dimensions chosen for analysis.</p>
    public let dimensionList: [String]?
    /// <p>The time at which the dataset was last modified.</p>
    public let lastModificationTime: Date?
    /// <p>A list of the metrics defined by the dataset.</p>
    public let metricList: [Metric]?
    /// <p>The ARN of the dataset.</p>
    public let metricSetArn: String?
    /// <p>The dataset's description.</p>
    public let metricSetDescription: String?
    /// <p>The interval at which the data will be analyzed for anomalies.</p>
    public let metricSetFrequency: Frequency?
    /// <p>The name of the dataset.</p>
    public let metricSetName: String?
    /// <p>Contains information about the dataset's source data.</p>
    public let metricSource: MetricSource?
    /// <p>The offset for the dataset.</p>
    public let offset: Int
    /// <p>Contains information about the column used for tracking time in your source data.</p>
    public let timestampColumn: TimestampColumn?
    /// <p>The time zone in which the dataset's data was recorded.</p>
    public let timezone: String?

    public init (
        anomalyDetectorArn: String? = nil,
        creationTime: Date? = nil,
        dimensionList: [String]? = nil,
        lastModificationTime: Date? = nil,
        metricList: [Metric]? = nil,
        metricSetArn: String? = nil,
        metricSetDescription: String? = nil,
        metricSetFrequency: Frequency? = nil,
        metricSetName: String? = nil,
        metricSource: MetricSource? = nil,
        offset: Int = 0,
        timestampColumn: TimestampColumn? = nil,
        timezone: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.creationTime = creationTime
        self.dimensionList = dimensionList
        self.lastModificationTime = lastModificationTime
        self.metricList = metricList
        self.metricSetArn = metricSetArn
        self.metricSetDescription = metricSetDescription
        self.metricSetFrequency = metricSetFrequency
        self.metricSetName = metricSetName
        self.metricSource = metricSource
        self.offset = offset
        self.timestampColumn = timestampColumn
        self.timezone = timezone
    }
}

struct DescribeMetricSetOutputResponseBody: Equatable {
    public let metricSetArn: String?
    public let anomalyDetectorArn: String?
    public let metricSetName: String?
    public let metricSetDescription: String?
    public let creationTime: Date?
    public let lastModificationTime: Date?
    public let offset: Int
    public let metricList: [Metric]?
    public let timestampColumn: TimestampColumn?
    public let dimensionList: [String]?
    public let metricSetFrequency: Frequency?
    public let timezone: String?
    public let metricSource: MetricSource?
}

extension DescribeMetricSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case creationTime = "CreationTime"
        case dimensionList = "DimensionList"
        case lastModificationTime = "LastModificationTime"
        case metricList = "MetricList"
        case metricSetArn = "MetricSetArn"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSetName = "MetricSetName"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case timestampColumn = "TimestampColumn"
        case timezone = "Timezone"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let metricSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetName)
        metricSetName = metricSetNameDecoded
        let metricSetDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetDescription)
        metricSetDescription = metricSetDescriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let offsetDecoded = try containerValues.decode(Int.self, forKey: .offset)
        offset = offsetDecoded
        let metricListContainer = try containerValues.decodeIfPresent([Metric?].self, forKey: .metricList)
        var metricListDecoded0:[Metric]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [Metric]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let timestampColumnDecoded = try containerValues.decodeIfPresent(TimestampColumn.self, forKey: .timestampColumn)
        timestampColumn = timestampColumnDecoded
        let dimensionListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dimensionList)
        var dimensionListDecoded0:[String]? = nil
        if let dimensionListContainer = dimensionListContainer {
            dimensionListDecoded0 = [String]()
            for string0 in dimensionListContainer {
                if let string0 = string0 {
                    dimensionListDecoded0?.append(string0)
                }
            }
        }
        dimensionList = dimensionListDecoded0
        let metricSetFrequencyDecoded = try containerValues.decodeIfPresent(Frequency.self, forKey: .metricSetFrequency)
        metricSetFrequency = metricSetFrequencyDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let metricSourceDecoded = try containerValues.decodeIfPresent(MetricSource.self, forKey: .metricSource)
        metricSource = metricSourceDecoded
    }
}

extension DimensionContribution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensionName = "DimensionName"
        case dimensionValueContributionList = "DimensionValueContributionList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionName = dimensionName {
            try encodeContainer.encode(dimensionName, forKey: .dimensionName)
        }
        if let dimensionValueContributionList = dimensionValueContributionList {
            var dimensionValueContributionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionValueContributionList)
            for dimensionvaluecontributionlist0 in dimensionValueContributionList {
                try dimensionValueContributionListContainer.encode(dimensionvaluecontributionlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionValueContributionListContainer = try containerValues.decodeIfPresent([DimensionValueContribution?].self, forKey: .dimensionValueContributionList)
        var dimensionValueContributionListDecoded0:[DimensionValueContribution]? = nil
        if let dimensionValueContributionListContainer = dimensionValueContributionListContainer {
            dimensionValueContributionListDecoded0 = [DimensionValueContribution]()
            for structure0 in dimensionValueContributionListContainer {
                if let structure0 = structure0 {
                    dimensionValueContributionListDecoded0?.append(structure0)
                }
            }
        }
        dimensionValueContributionList = dimensionValueContributionListDecoded0
    }
}

extension DimensionContribution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DimensionContribution(dimensionName: \(String(describing: dimensionName)), dimensionValueContributionList: \(String(describing: dimensionValueContributionList)))"}
}

/// <p>Details about a dimension that contributed to an anomaly.</p>
public struct DimensionContribution: Equatable {
    /// <p>The name of the dimension.</p>
    public let dimensionName: String?
    /// <p>A list of dimension values that contributed to the anomaly.</p>
    public let dimensionValueContributionList: [DimensionValueContribution]?

    public init (
        dimensionName: String? = nil,
        dimensionValueContributionList: [DimensionValueContribution]? = nil
    )
    {
        self.dimensionName = dimensionName
        self.dimensionValueContributionList = dimensionValueContributionList
    }
}

extension DimensionNameValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensionName = "DimensionName"
        case dimensionValue = "DimensionValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionName = dimensionName {
            try encodeContainer.encode(dimensionName, forKey: .dimensionName)
        }
        if let dimensionValue = dimensionValue {
            try encodeContainer.encode(dimensionValue, forKey: .dimensionValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimensionValue)
        dimensionValue = dimensionValueDecoded
    }
}

extension DimensionNameValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DimensionNameValue(dimensionName: \(String(describing: dimensionName)), dimensionValue: \(String(describing: dimensionValue)))"}
}

/// <p>A dimension name and value.</p>
public struct DimensionNameValue: Equatable {
    /// <p>The name of the dimension.</p>
    public let dimensionName: String?
    /// <p>The value of the dimension.</p>
    public let dimensionValue: String?

    public init (
        dimensionName: String? = nil,
        dimensionValue: String? = nil
    )
    {
        self.dimensionName = dimensionName
        self.dimensionValue = dimensionValue
    }
}

extension DimensionValueContribution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contributionScore = "ContributionScore"
        case dimensionValue = "DimensionValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contributionScore = contributionScore {
            try encodeContainer.encode(contributionScore, forKey: .contributionScore)
        }
        if let dimensionValue = dimensionValue {
            try encodeContainer.encode(dimensionValue, forKey: .dimensionValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimensionValue)
        dimensionValue = dimensionValueDecoded
        let contributionScoreDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .contributionScore)
        contributionScore = contributionScoreDecoded
    }
}

extension DimensionValueContribution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DimensionValueContribution(contributionScore: \(String(describing: contributionScore)), dimensionValue: \(String(describing: dimensionValue)))"}
}

/// <p>The severity of a value of a dimension that contributed to an anomaly.</p>
public struct DimensionValueContribution: Equatable {
    /// <p>The severity score of the value.</p>
    public let contributionScore: Double?
    /// <p>The value of the dimension.</p>
    public let dimensionValue: String?

    public init (
        contributionScore: Double? = nil,
        dimensionValue: String? = nil
    )
    {
        self.contributionScore = contributionScore
        self.dimensionValue = dimensionValue
    }
}

extension ExecutionStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureReason = "FailureReason"
        case status = "Status"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AnomalyDetectionTaskStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension ExecutionStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionStatus(failureReason: \(String(describing: failureReason)), status: \(String(describing: status)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>The status of an anomaly detector run.</p>
public struct ExecutionStatus: Equatable {
    /// <p>The reason that the run failed, if applicable.</p>
    public let failureReason: String?
    /// <p>The run's status.</p>
    public let status: AnomalyDetectionTaskStatus?
    /// <p>The run's timestamp.</p>
    public let timestamp: String?

    public init (
        failureReason: String? = nil,
        status: AnomalyDetectionTaskStatus? = nil,
        timestamp: String? = nil
    )
    {
        self.failureReason = failureReason
        self.status = status
        self.timestamp = timestamp
    }
}

extension FileFormatDescriptor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case csvFormatDescriptor = "CsvFormatDescriptor"
        case jsonFormatDescriptor = "JsonFormatDescriptor"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvFormatDescriptor = csvFormatDescriptor {
            try encodeContainer.encode(csvFormatDescriptor, forKey: .csvFormatDescriptor)
        }
        if let jsonFormatDescriptor = jsonFormatDescriptor {
            try encodeContainer.encode(jsonFormatDescriptor, forKey: .jsonFormatDescriptor)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvFormatDescriptorDecoded = try containerValues.decodeIfPresent(CsvFormatDescriptor.self, forKey: .csvFormatDescriptor)
        csvFormatDescriptor = csvFormatDescriptorDecoded
        let jsonFormatDescriptorDecoded = try containerValues.decodeIfPresent(JsonFormatDescriptor.self, forKey: .jsonFormatDescriptor)
        jsonFormatDescriptor = jsonFormatDescriptorDecoded
    }
}

extension FileFormatDescriptor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileFormatDescriptor(csvFormatDescriptor: \(String(describing: csvFormatDescriptor)), jsonFormatDescriptor: \(String(describing: jsonFormatDescriptor)))"}
}

/// <p>Contains information about a source file's formatting.</p>
public struct FileFormatDescriptor: Equatable {
    /// <p>Contains information about how a source CSV data file should be analyzed.</p>
    public let csvFormatDescriptor: CsvFormatDescriptor?
    /// <p>Contains information about how a source JSON data file should be analyzed.</p>
    public let jsonFormatDescriptor: JsonFormatDescriptor?

    public init (
        csvFormatDescriptor: CsvFormatDescriptor? = nil,
        jsonFormatDescriptor: JsonFormatDescriptor? = nil
    )
    {
        self.csvFormatDescriptor = csvFormatDescriptor
        self.jsonFormatDescriptor = jsonFormatDescriptor
    }
}

public enum Frequency {
    case p1d
    case pt10m
    case pt1h
    case pt5m
    case sdkUnknown(String)
}

extension Frequency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Frequency] {
        return [
            .p1d,
            .pt10m,
            .pt1h,
            .pt5m,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .p1d: return "P1D"
        case .pt10m: return "PT10M"
        case .pt1h: return "PT1H"
        case .pt5m: return "PT5M"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Frequency(rawValue: rawValue) ?? Frequency.sdkUnknown(rawValue)
    }
}

public struct GetAnomalyGroupInputBodyMiddleware: Middleware {
    public let id: String = "GetAnomalyGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnomalyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnomalyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnomalyGroupInput>
    public typealias MOutput = OperationOutput<GetAnomalyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnomalyGroupOutputError>
}

extension GetAnomalyGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnomalyGroupInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), anomalyGroupId: \(String(describing: anomalyGroupId)))"}
}

extension GetAnomalyGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupId = anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
    }
}

public struct GetAnomalyGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetAnomalyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnomalyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnomalyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnomalyGroupInput>
    public typealias MOutput = OperationOutput<GetAnomalyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnomalyGroupOutputError>
}

public struct GetAnomalyGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAnomalyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnomalyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnomalyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnomalyGroupInput>
    public typealias MOutput = OperationOutput<GetAnomalyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnomalyGroupOutputError>
}

public struct GetAnomalyGroupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the anomaly detector.</p>
    public let anomalyDetectorArn: String?
    /// <p>The ID of the anomaly group.</p>
    public let anomalyGroupId: String?

    public init (
        anomalyDetectorArn: String? = nil,
        anomalyGroupId: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupId = anomalyGroupId
    }
}

struct GetAnomalyGroupInputBody: Equatable {
    public let anomalyGroupId: String?
    public let anomalyDetectorArn: String?
}

extension GetAnomalyGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension GetAnomalyGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnomalyGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnomalyGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnomalyGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnomalyGroupOutputResponse(anomalyGroup: \(String(describing: anomalyGroup)))"}
}

extension GetAnomalyGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAnomalyGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalyGroup = output.anomalyGroup
        } else {
            self.anomalyGroup = nil
        }
    }
}

public struct GetAnomalyGroupOutputResponse: Equatable {
    /// <p>Details about the anomaly group.</p>
    public let anomalyGroup: AnomalyGroup?

    public init (
        anomalyGroup: AnomalyGroup? = nil
    )
    {
        self.anomalyGroup = anomalyGroup
    }
}

struct GetAnomalyGroupOutputResponseBody: Equatable {
    public let anomalyGroup: AnomalyGroup?
}

extension GetAnomalyGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyGroup = "AnomalyGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupDecoded = try containerValues.decodeIfPresent(AnomalyGroup.self, forKey: .anomalyGroup)
        anomalyGroup = anomalyGroupDecoded
    }
}

public struct GetFeedbackInputBodyMiddleware: Middleware {
    public let id: String = "GetFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFeedbackInput>
    public typealias MOutput = OperationOutput<GetFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFeedbackOutputError>
}

extension GetFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFeedbackInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), anomalyGroupTimeSeriesFeedback: \(String(describing: anomalyGroupTimeSeriesFeedback)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetFeedbackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback {
            try encodeContainer.encode(anomalyGroupTimeSeriesFeedback, forKey: .anomalyGroupTimeSeriesFeedback)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "GetFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFeedbackInput>
    public typealias MOutput = OperationOutput<GetFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFeedbackOutputError>
}

public struct GetFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFeedbackInput>
    public typealias MOutput = OperationOutput<GetFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFeedbackOutputError>
}

public struct GetFeedbackInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the anomaly detector.</p>
    public let anomalyDetectorArn: String?
    /// <p>The anomalous metric and group ID.</p>
    public let anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeries?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int
    /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
    public let nextToken: String?

    public init (
        anomalyDetectorArn: String? = nil,
        anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeries? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetFeedbackInputBody: Equatable {
    public let anomalyDetectorArn: String?
    public let anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeries?
    public let maxResults: Int
    public let nextToken: String?
}

extension GetFeedbackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyGroupTimeSeriesFeedbackDecoded = try containerValues.decodeIfPresent(AnomalyGroupTimeSeries.self, forKey: .anomalyGroupTimeSeriesFeedback)
        anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedbackDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFeedbackOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFeedbackOutputResponse(anomalyGroupTimeSeriesFeedback: \(String(describing: anomalyGroupTimeSeriesFeedback)), nextToken: \(String(describing: nextToken)))"}
}

extension GetFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFeedbackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalyGroupTimeSeriesFeedback = output.anomalyGroupTimeSeriesFeedback
            self.nextToken = output.nextToken
        } else {
            self.anomalyGroupTimeSeriesFeedback = nil
            self.nextToken = nil
        }
    }
}

public struct GetFeedbackOutputResponse: Equatable {
    /// <p>Feedback for an anomalous metric.</p>
    public let anomalyGroupTimeSeriesFeedback: [TimeSeriesFeedback]?
    /// <p>The pagination token that's included if more results are available.</p>
    public let nextToken: String?

    public init (
        anomalyGroupTimeSeriesFeedback: [TimeSeriesFeedback]? = nil,
        nextToken: String? = nil
    )
    {
        self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
        self.nextToken = nextToken
    }
}

struct GetFeedbackOutputResponseBody: Equatable {
    public let anomalyGroupTimeSeriesFeedback: [TimeSeriesFeedback]?
    public let nextToken: String?
}

extension GetFeedbackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupTimeSeriesFeedbackContainer = try containerValues.decodeIfPresent([TimeSeriesFeedback?].self, forKey: .anomalyGroupTimeSeriesFeedback)
        var anomalyGroupTimeSeriesFeedbackDecoded0:[TimeSeriesFeedback]? = nil
        if let anomalyGroupTimeSeriesFeedbackContainer = anomalyGroupTimeSeriesFeedbackContainer {
            anomalyGroupTimeSeriesFeedbackDecoded0 = [TimeSeriesFeedback]()
            for structure0 in anomalyGroupTimeSeriesFeedbackContainer {
                if let structure0 = structure0 {
                    anomalyGroupTimeSeriesFeedbackDecoded0?.append(structure0)
                }
            }
        }
        anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedbackDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetSampleDataInputBodyMiddleware: Middleware {
    public let id: String = "GetSampleDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSampleDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSampleDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSampleDataInput>
    public typealias MOutput = OperationOutput<GetSampleDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSampleDataOutputError>
}

extension GetSampleDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSampleDataInput(s3SourceConfig: \(String(describing: s3SourceConfig)))"}
}

extension GetSampleDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3SourceConfig = "S3SourceConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3SourceConfig = s3SourceConfig {
            try encodeContainer.encode(s3SourceConfig, forKey: .s3SourceConfig)
        }
    }
}

public struct GetSampleDataInputHeadersMiddleware: Middleware {
    public let id: String = "GetSampleDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSampleDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSampleDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSampleDataInput>
    public typealias MOutput = OperationOutput<GetSampleDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSampleDataOutputError>
}

public struct GetSampleDataInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSampleDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSampleDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSampleDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSampleDataInput>
    public typealias MOutput = OperationOutput<GetSampleDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSampleDataOutputError>
}

public struct GetSampleDataInput: Equatable {
    /// <p>A datasource bucket in Amazon S3.</p>
    public let s3SourceConfig: SampleDataS3SourceConfig?

    public init (
        s3SourceConfig: SampleDataS3SourceConfig? = nil
    )
    {
        self.s3SourceConfig = s3SourceConfig
    }
}

struct GetSampleDataInputBody: Equatable {
    public let s3SourceConfig: SampleDataS3SourceConfig?
}

extension GetSampleDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case s3SourceConfig = "S3SourceConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3SourceConfigDecoded = try containerValues.decodeIfPresent(SampleDataS3SourceConfig.self, forKey: .s3SourceConfig)
        s3SourceConfig = s3SourceConfigDecoded
    }
}

extension GetSampleDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSampleDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSampleDataOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSampleDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSampleDataOutputResponse(headerValues: \(String(describing: headerValues)), sampleRows: \(String(describing: sampleRows)))"}
}

extension GetSampleDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSampleDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.headerValues = output.headerValues
            self.sampleRows = output.sampleRows
        } else {
            self.headerValues = nil
            self.sampleRows = nil
        }
    }
}

public struct GetSampleDataOutputResponse: Equatable {
    /// <p>A list of header labels for the records.</p>
    public let headerValues: [String]?
    /// <p>A list of records.</p>
    public let sampleRows: [[String]]?

    public init (
        headerValues: [String]? = nil,
        sampleRows: [[String]]? = nil
    )
    {
        self.headerValues = headerValues
        self.sampleRows = sampleRows
    }
}

struct GetSampleDataOutputResponseBody: Equatable {
    public let headerValues: [String]?
    public let sampleRows: [[String]]?
}

extension GetSampleDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case headerValues = "HeaderValues"
        case sampleRows = "SampleRows"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .headerValues)
        var headerValuesDecoded0:[String]? = nil
        if let headerValuesContainer = headerValuesContainer {
            headerValuesDecoded0 = [String]()
            for string0 in headerValuesContainer {
                if let string0 = string0 {
                    headerValuesDecoded0?.append(string0)
                }
            }
        }
        headerValues = headerValuesDecoded0
        let sampleRowsContainer = try containerValues.decodeIfPresent([[String?]?].self, forKey: .sampleRows)
        var sampleRowsDecoded0:[[String]]? = nil
        if let sampleRowsContainer = sampleRowsContainer {
            sampleRowsDecoded0 = [[String]]()
            for list0 in sampleRowsContainer {
                var list0Decoded0: [String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    sampleRowsDecoded0?.append(list0Decoded0)
                }
            }
        }
        sampleRows = sampleRowsDecoded0
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request processing has failed because of an unknown error, exception, or failure.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ItemizedMetricStats: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metricName = "MetricName"
        case occurrenceCount = "OccurrenceCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if occurrenceCount != 0 {
            try encodeContainer.encode(occurrenceCount, forKey: .occurrenceCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let occurrenceCountDecoded = try containerValues.decode(Int.self, forKey: .occurrenceCount)
        occurrenceCount = occurrenceCountDecoded
    }
}

extension ItemizedMetricStats: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ItemizedMetricStats(metricName: \(String(describing: metricName)), occurrenceCount: \(String(describing: occurrenceCount)))"}
}

/// <p>Aggregated statistics about a measure affected by an anomaly.</p>
public struct ItemizedMetricStats: Equatable {
    /// <p>The name of the measure.</p>
    public let metricName: String?
    /// <p>The number of times that the measure appears.</p>
    public let occurrenceCount: Int

    public init (
        metricName: String? = nil,
        occurrenceCount: Int = 0
    )
    {
        self.metricName = metricName
        self.occurrenceCount = occurrenceCount
    }
}

public enum JsonFileCompression {
    case gzip
    case `none`
    case sdkUnknown(String)
}

extension JsonFileCompression : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JsonFileCompression] {
        return [
            .gzip,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .gzip: return "GZIP"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JsonFileCompression(rawValue: rawValue) ?? JsonFileCompression.sdkUnknown(rawValue)
    }
}

extension JsonFormatDescriptor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case charset = "Charset"
        case fileCompression = "FileCompression"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let charset = charset {
            try encodeContainer.encode(charset, forKey: .charset)
        }
        if let fileCompression = fileCompression {
            try encodeContainer.encode(fileCompression.rawValue, forKey: .fileCompression)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileCompressionDecoded = try containerValues.decodeIfPresent(JsonFileCompression.self, forKey: .fileCompression)
        fileCompression = fileCompressionDecoded
        let charsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .charset)
        charset = charsetDecoded
    }
}

extension JsonFormatDescriptor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JsonFormatDescriptor(charset: \(String(describing: charset)), fileCompression: \(String(describing: fileCompression)))"}
}

/// <p>Contains information about how a source JSON data file should be analyzed.</p>
public struct JsonFormatDescriptor: Equatable {
    /// <p>The character set in which the source JSON file is written.</p>
    public let charset: String?
    /// <p>The level of compression of the source CSV file.</p>
    public let fileCompression: JsonFileCompression?

    public init (
        charset: String? = nil,
        fileCompression: JsonFileCompression? = nil
    )
    {
        self.charset = charset
        self.fileCompression = fileCompression
    }
}

extension LambdaConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaArn = "LambdaArn"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let lambdaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension LambdaConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaConfiguration(lambdaArn: \(String(describing: lambdaArn)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Contains information about a Lambda configuration.</p>
public struct LambdaConfiguration: Equatable {
    /// <p>The ARN of the Lambda function.</p>
    public let lambdaArn: String?
    /// <p>The ARN of an IAM role that has permission to invoke the Lambda function.</p>
    public let roleArn: String?

    public init (
        lambdaArn: String? = nil,
        roleArn: String? = nil
    )
    {
        self.lambdaArn = lambdaArn
        self.roleArn = roleArn
    }
}

public struct ListAlertsInputBodyMiddleware: Middleware {
    public let id: String = "ListAlertsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAlertsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAlertsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAlertsInput>
    public typealias MOutput = OperationOutput<ListAlertsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAlertsOutputError>
}

extension ListAlertsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAlertsInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAlertsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAlertsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAlertsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAlertsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAlertsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAlertsInput>
    public typealias MOutput = OperationOutput<ListAlertsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAlertsOutputError>
}

public struct ListAlertsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAlertsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAlertsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAlertsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAlertsInput>
    public typealias MOutput = OperationOutput<ListAlertsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAlertsOutputError>
}

public struct ListAlertsInput: Equatable {
    /// <p>The ARN of the alert's detector.</p>
    public let anomalyDetectorArn: String?
    /// <p>The maximum number of results that will be displayed by the request.</p>
    public let maxResults: Int
    /// <p>If the result of the previous request is truncated, the response includes a <code>NextToken</code>. To
    ///       retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.</p>
    public let nextToken: String?

    public init (
        anomalyDetectorArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlertsInputBody: Equatable {
    public let anomalyDetectorArn: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListAlertsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAlertsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlertsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAlertsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlertsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAlertsOutputResponse(alertSummaryList: \(String(describing: alertSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAlertsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAlertsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alertSummaryList = output.alertSummaryList
            self.nextToken = output.nextToken
        } else {
            self.alertSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlertsOutputResponse: Equatable {
    /// <p>Contains information about an alert.</p>
    public let alertSummaryList: [AlertSummary]?
    /// <p>If the response is truncated, the service returns this token. To retrieve the next set of results, use this
    ///       token in the next request.</p>
    public let nextToken: String?

    public init (
        alertSummaryList: [AlertSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.alertSummaryList = alertSummaryList
        self.nextToken = nextToken
    }
}

struct ListAlertsOutputResponseBody: Equatable {
    public let alertSummaryList: [AlertSummary]?
    public let nextToken: String?
}

extension ListAlertsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alertSummaryList = "AlertSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertSummaryListContainer = try containerValues.decodeIfPresent([AlertSummary?].self, forKey: .alertSummaryList)
        var alertSummaryListDecoded0:[AlertSummary]? = nil
        if let alertSummaryListContainer = alertSummaryListContainer {
            alertSummaryListDecoded0 = [AlertSummary]()
            for structure0 in alertSummaryListContainer {
                if let structure0 = structure0 {
                    alertSummaryListDecoded0?.append(structure0)
                }
            }
        }
        alertSummaryList = alertSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAnomalyDetectorsInputBodyMiddleware: Middleware {
    public let id: String = "ListAnomalyDetectorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnomalyDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnomalyDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnomalyDetectorsInput>
    public typealias MOutput = OperationOutput<ListAnomalyDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnomalyDetectorsOutputError>
}

extension ListAnomalyDetectorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnomalyDetectorsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAnomalyDetectorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAnomalyDetectorsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAnomalyDetectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnomalyDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnomalyDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnomalyDetectorsInput>
    public typealias MOutput = OperationOutput<ListAnomalyDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnomalyDetectorsOutputError>
}

public struct ListAnomalyDetectorsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAnomalyDetectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnomalyDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnomalyDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnomalyDetectorsInput>
    public typealias MOutput = OperationOutput<ListAnomalyDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnomalyDetectorsOutputError>
}

public struct ListAnomalyDetectorsInput: Equatable {
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int
    /// <p>If the result of the previous request was truncated, the response includes a <code>NextToken</code>. To
    ///       retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAnomalyDetectorsInputBody: Equatable {
    public let maxResults: Int
    public let nextToken: String?
}

extension ListAnomalyDetectorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyDetectorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnomalyDetectorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnomalyDetectorsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnomalyDetectorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnomalyDetectorsOutputResponse(anomalyDetectorSummaryList: \(String(describing: anomalyDetectorSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAnomalyDetectorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAnomalyDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalyDetectorSummaryList = output.anomalyDetectorSummaryList
            self.nextToken = output.nextToken
        } else {
            self.anomalyDetectorSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnomalyDetectorsOutputResponse: Equatable {
    /// <p>A list of anomaly detectors in the account in the current region.</p>
    public let anomalyDetectorSummaryList: [AnomalyDetectorSummary]?
    /// <p>If the response is truncated, the service returns this token. To retrieve the next set of results, use the
    ///       token in the next request.</p>
    public let nextToken: String?

    public init (
        anomalyDetectorSummaryList: [AnomalyDetectorSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.anomalyDetectorSummaryList = anomalyDetectorSummaryList
        self.nextToken = nextToken
    }
}

struct ListAnomalyDetectorsOutputResponseBody: Equatable {
    public let anomalyDetectorSummaryList: [AnomalyDetectorSummary]?
    public let nextToken: String?
}

extension ListAnomalyDetectorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorSummaryList = "AnomalyDetectorSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorSummaryListContainer = try containerValues.decodeIfPresent([AnomalyDetectorSummary?].self, forKey: .anomalyDetectorSummaryList)
        var anomalyDetectorSummaryListDecoded0:[AnomalyDetectorSummary]? = nil
        if let anomalyDetectorSummaryListContainer = anomalyDetectorSummaryListContainer {
            anomalyDetectorSummaryListDecoded0 = [AnomalyDetectorSummary]()
            for structure0 in anomalyDetectorSummaryListContainer {
                if let structure0 = structure0 {
                    anomalyDetectorSummaryListDecoded0?.append(structure0)
                }
            }
        }
        anomalyDetectorSummaryList = anomalyDetectorSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAnomalyGroupSummariesInputBodyMiddleware: Middleware {
    public let id: String = "ListAnomalyGroupSummariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnomalyGroupSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnomalyGroupSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnomalyGroupSummariesInput>
    public typealias MOutput = OperationOutput<ListAnomalyGroupSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnomalyGroupSummariesOutputError>
}

extension ListAnomalyGroupSummariesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnomalyGroupSummariesInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sensitivityThreshold: \(String(describing: sensitivityThreshold)))"}
}

extension ListAnomalyGroupSummariesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sensitivityThreshold = "SensitivityThreshold"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if sensitivityThreshold != 0 {
            try encodeContainer.encode(sensitivityThreshold, forKey: .sensitivityThreshold)
        }
    }
}

public struct ListAnomalyGroupSummariesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAnomalyGroupSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnomalyGroupSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnomalyGroupSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnomalyGroupSummariesInput>
    public typealias MOutput = OperationOutput<ListAnomalyGroupSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnomalyGroupSummariesOutputError>
}

public struct ListAnomalyGroupSummariesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAnomalyGroupSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnomalyGroupSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnomalyGroupSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnomalyGroupSummariesInput>
    public typealias MOutput = OperationOutput<ListAnomalyGroupSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnomalyGroupSummariesOutputError>
}

public struct ListAnomalyGroupSummariesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the anomaly detector.</p>
    public let anomalyDetectorArn: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int
    /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
    public let nextToken: String?
    /// <p>The minimum severity score for inclusion in the output.</p>
    public let sensitivityThreshold: Int

    public init (
        anomalyDetectorArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        sensitivityThreshold: Int = 0
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sensitivityThreshold = sensitivityThreshold
    }
}

struct ListAnomalyGroupSummariesInputBody: Equatable {
    public let anomalyDetectorArn: String?
    public let sensitivityThreshold: Int
    public let maxResults: Int
    public let nextToken: String?
}

extension ListAnomalyGroupSummariesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sensitivityThreshold = "SensitivityThreshold"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let sensitivityThresholdDecoded = try containerValues.decode(Int.self, forKey: .sensitivityThreshold)
        sensitivityThreshold = sensitivityThresholdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyGroupSummariesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnomalyGroupSummariesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnomalyGroupSummariesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnomalyGroupSummariesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnomalyGroupSummariesOutputResponse(anomalyGroupStatistics: \(String(describing: anomalyGroupStatistics)), anomalyGroupSummaryList: \(String(describing: anomalyGroupSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAnomalyGroupSummariesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAnomalyGroupSummariesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalyGroupStatistics = output.anomalyGroupStatistics
            self.anomalyGroupSummaryList = output.anomalyGroupSummaryList
            self.nextToken = output.nextToken
        } else {
            self.anomalyGroupStatistics = nil
            self.anomalyGroupSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnomalyGroupSummariesOutputResponse: Equatable {
    /// <p>Aggregated details about the anomaly groups.</p>
    public let anomalyGroupStatistics: AnomalyGroupStatistics?
    /// <p>A list of anomaly group summaries.</p>
    public let anomalyGroupSummaryList: [AnomalyGroupSummary]?
    /// <p>The pagination token that's included if more results are available.</p>
    public let nextToken: String?

    public init (
        anomalyGroupStatistics: AnomalyGroupStatistics? = nil,
        anomalyGroupSummaryList: [AnomalyGroupSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.anomalyGroupStatistics = anomalyGroupStatistics
        self.anomalyGroupSummaryList = anomalyGroupSummaryList
        self.nextToken = nextToken
    }
}

struct ListAnomalyGroupSummariesOutputResponseBody: Equatable {
    public let anomalyGroupSummaryList: [AnomalyGroupSummary]?
    public let anomalyGroupStatistics: AnomalyGroupStatistics?
    public let nextToken: String?
}

extension ListAnomalyGroupSummariesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyGroupStatistics = "AnomalyGroupStatistics"
        case anomalyGroupSummaryList = "AnomalyGroupSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupSummaryListContainer = try containerValues.decodeIfPresent([AnomalyGroupSummary?].self, forKey: .anomalyGroupSummaryList)
        var anomalyGroupSummaryListDecoded0:[AnomalyGroupSummary]? = nil
        if let anomalyGroupSummaryListContainer = anomalyGroupSummaryListContainer {
            anomalyGroupSummaryListDecoded0 = [AnomalyGroupSummary]()
            for structure0 in anomalyGroupSummaryListContainer {
                if let structure0 = structure0 {
                    anomalyGroupSummaryListDecoded0?.append(structure0)
                }
            }
        }
        anomalyGroupSummaryList = anomalyGroupSummaryListDecoded0
        let anomalyGroupStatisticsDecoded = try containerValues.decodeIfPresent(AnomalyGroupStatistics.self, forKey: .anomalyGroupStatistics)
        anomalyGroupStatistics = anomalyGroupStatisticsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAnomalyGroupTimeSeriesInputBodyMiddleware: Middleware {
    public let id: String = "ListAnomalyGroupTimeSeriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnomalyGroupTimeSeriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnomalyGroupTimeSeriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnomalyGroupTimeSeriesInput>
    public typealias MOutput = OperationOutput<ListAnomalyGroupTimeSeriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnomalyGroupTimeSeriesOutputError>
}

extension ListAnomalyGroupTimeSeriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnomalyGroupTimeSeriesInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), anomalyGroupId: \(String(describing: anomalyGroupId)), maxResults: \(String(describing: maxResults)), metricName: \(String(describing: metricName)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAnomalyGroupTimeSeriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
        case maxResults = "MaxResults"
        case metricName = "MetricName"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupId = anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAnomalyGroupTimeSeriesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAnomalyGroupTimeSeriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnomalyGroupTimeSeriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnomalyGroupTimeSeriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnomalyGroupTimeSeriesInput>
    public typealias MOutput = OperationOutput<ListAnomalyGroupTimeSeriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnomalyGroupTimeSeriesOutputError>
}

public struct ListAnomalyGroupTimeSeriesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAnomalyGroupTimeSeriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnomalyGroupTimeSeriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnomalyGroupTimeSeriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnomalyGroupTimeSeriesInput>
    public typealias MOutput = OperationOutput<ListAnomalyGroupTimeSeriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnomalyGroupTimeSeriesOutputError>
}

public struct ListAnomalyGroupTimeSeriesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the anomaly detector.</p>
    public let anomalyDetectorArn: String?
    /// <p>The ID of the anomaly group.</p>
    public let anomalyGroupId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int
    /// <p>The name of the measure field.</p>
    public let metricName: String?
    /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
    public let nextToken: String?

    public init (
        anomalyDetectorArn: String? = nil,
        anomalyGroupId: String? = nil,
        maxResults: Int = 0,
        metricName: String? = nil,
        nextToken: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupId = anomalyGroupId
        self.maxResults = maxResults
        self.metricName = metricName
        self.nextToken = nextToken
    }
}

struct ListAnomalyGroupTimeSeriesInputBody: Equatable {
    public let anomalyDetectorArn: String?
    public let anomalyGroupId: String?
    public let metricName: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListAnomalyGroupTimeSeriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
        case maxResults = "MaxResults"
        case metricName = "MetricName"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyGroupTimeSeriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnomalyGroupTimeSeriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnomalyGroupTimeSeriesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnomalyGroupTimeSeriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnomalyGroupTimeSeriesOutputResponse(anomalyGroupId: \(String(describing: anomalyGroupId)), metricName: \(String(describing: metricName)), nextToken: \(String(describing: nextToken)), timeSeriesList: \(String(describing: timeSeriesList)), timestampList: \(String(describing: timestampList)))"}
}

extension ListAnomalyGroupTimeSeriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAnomalyGroupTimeSeriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalyGroupId = output.anomalyGroupId
            self.metricName = output.metricName
            self.nextToken = output.nextToken
            self.timeSeriesList = output.timeSeriesList
            self.timestampList = output.timestampList
        } else {
            self.anomalyGroupId = nil
            self.metricName = nil
            self.nextToken = nil
            self.timeSeriesList = nil
            self.timestampList = nil
        }
    }
}

public struct ListAnomalyGroupTimeSeriesOutputResponse: Equatable {
    /// <p>The ID of the anomaly group.</p>
    public let anomalyGroupId: String?
    /// <p>The name of the measure field.</p>
    public let metricName: String?
    /// <p>The pagination token that's included if more results are available.</p>
    public let nextToken: String?
    /// <p>A list of anomalous metrics.</p>
    public let timeSeriesList: [TimeSeries]?
    /// <p>Timestamps for the anomalous metrics.</p>
    public let timestampList: [String]?

    public init (
        anomalyGroupId: String? = nil,
        metricName: String? = nil,
        nextToken: String? = nil,
        timeSeriesList: [TimeSeries]? = nil,
        timestampList: [String]? = nil
    )
    {
        self.anomalyGroupId = anomalyGroupId
        self.metricName = metricName
        self.nextToken = nextToken
        self.timeSeriesList = timeSeriesList
        self.timestampList = timestampList
    }
}

struct ListAnomalyGroupTimeSeriesOutputResponseBody: Equatable {
    public let anomalyGroupId: String?
    public let metricName: String?
    public let timestampList: [String]?
    public let nextToken: String?
    public let timeSeriesList: [TimeSeries]?
}

extension ListAnomalyGroupTimeSeriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case metricName = "MetricName"
        case nextToken = "NextToken"
        case timeSeriesList = "TimeSeriesList"
        case timestampList = "TimestampList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let timestampListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .timestampList)
        var timestampListDecoded0:[String]? = nil
        if let timestampListContainer = timestampListContainer {
            timestampListDecoded0 = [String]()
            for string0 in timestampListContainer {
                if let string0 = string0 {
                    timestampListDecoded0?.append(string0)
                }
            }
        }
        timestampList = timestampListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let timeSeriesListContainer = try containerValues.decodeIfPresent([TimeSeries?].self, forKey: .timeSeriesList)
        var timeSeriesListDecoded0:[TimeSeries]? = nil
        if let timeSeriesListContainer = timeSeriesListContainer {
            timeSeriesListDecoded0 = [TimeSeries]()
            for structure0 in timeSeriesListContainer {
                if let structure0 = structure0 {
                    timeSeriesListDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesList = timeSeriesListDecoded0
    }
}

public struct ListMetricSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListMetricSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMetricSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMetricSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMetricSetsInput>
    public typealias MOutput = OperationOutput<ListMetricSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMetricSetsOutputError>
}

extension ListMetricSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMetricSetsInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMetricSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListMetricSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListMetricSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMetricSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMetricSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMetricSetsInput>
    public typealias MOutput = OperationOutput<ListMetricSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMetricSetsOutputError>
}

public struct ListMetricSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMetricSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMetricSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMetricSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMetricSetsInput>
    public typealias MOutput = OperationOutput<ListMetricSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMetricSetsOutputError>
}

public struct ListMetricSetsInput: Equatable {
    /// <p>The ARN of the anomaly detector containing the metrics sets to list.</p>
    public let anomalyDetectorArn: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int
    /// <p>If the result of the previous request was truncated, the response includes a <code>NextToken</code>. To
    ///       retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.</p>
    public let nextToken: String?

    public init (
        anomalyDetectorArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMetricSetsInputBody: Equatable {
    public let anomalyDetectorArn: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListMetricSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMetricSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMetricSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMetricSetsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMetricSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMetricSetsOutputResponse(metricSetSummaryList: \(String(describing: metricSetSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMetricSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMetricSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metricSetSummaryList = output.metricSetSummaryList
            self.nextToken = output.nextToken
        } else {
            self.metricSetSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMetricSetsOutputResponse: Equatable {
    /// <p>A list of the datasets in the AWS Region, with configuration details for each.</p>
    public let metricSetSummaryList: [MetricSetSummary]?
    /// <p>If the response is truncated, the list call returns this token. To retrieve the next set of results, use the
    ///       token in the next list request. </p>
    public let nextToken: String?

    public init (
        metricSetSummaryList: [MetricSetSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.metricSetSummaryList = metricSetSummaryList
        self.nextToken = nextToken
    }
}

struct ListMetricSetsOutputResponseBody: Equatable {
    public let metricSetSummaryList: [MetricSetSummary]?
    public let nextToken: String?
}

extension ListMetricSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metricSetSummaryList = "MetricSetSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetSummaryListContainer = try containerValues.decodeIfPresent([MetricSetSummary?].self, forKey: .metricSetSummaryList)
        var metricSetSummaryListDecoded0:[MetricSetSummary]? = nil
        if let metricSetSummaryListContainer = metricSetSummaryListContainer {
            metricSetSummaryListDecoded0 = [MetricSetSummary]()
            for structure0 in metricSetSummaryListContainer {
                if let structure0 = structure0 {
                    metricSetSummaryListDecoded0?.append(structure0)
                }
            }
        }
        metricSetSummaryList = metricSetSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The resource's Amazon Resource Name (ARN).</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The resource's tags.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Metric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregationFunction = "AggregationFunction"
        case metricName = "MetricName"
        case namespace = "Namespace"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationFunction = aggregationFunction {
            try encodeContainer.encode(aggregationFunction.rawValue, forKey: .aggregationFunction)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let aggregationFunctionDecoded = try containerValues.decodeIfPresent(AggregationFunction.self, forKey: .aggregationFunction)
        aggregationFunction = aggregationFunctionDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension Metric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Metric(aggregationFunction: \(String(describing: aggregationFunction)), metricName: \(String(describing: metricName)), namespace: \(String(describing: namespace)))"}
}

/// <p>A calculation made by contrasting a measure and a dimension from your source data.</p>
public struct Metric: Equatable {
    /// <p>The function with which the metric is calculated.</p>
    public let aggregationFunction: AggregationFunction?
    /// <p>The name of the metric.</p>
    public let metricName: String?
    /// <p>The namespace for the metric.</p>
    public let namespace: String?

    public init (
        aggregationFunction: AggregationFunction? = nil,
        metricName: String? = nil,
        namespace: String? = nil
    )
    {
        self.aggregationFunction = aggregationFunction
        self.metricName = metricName
        self.namespace = namespace
    }
}

extension MetricLevelImpact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contributionMatrix = "ContributionMatrix"
        case metricName = "MetricName"
        case numTimeSeries = "NumTimeSeries"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contributionMatrix = contributionMatrix {
            try encodeContainer.encode(contributionMatrix, forKey: .contributionMatrix)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if numTimeSeries != 0 {
            try encodeContainer.encode(numTimeSeries, forKey: .numTimeSeries)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let numTimeSeriesDecoded = try containerValues.decode(Int.self, forKey: .numTimeSeries)
        numTimeSeries = numTimeSeriesDecoded
        let contributionMatrixDecoded = try containerValues.decodeIfPresent(ContributionMatrix.self, forKey: .contributionMatrix)
        contributionMatrix = contributionMatrixDecoded
    }
}

extension MetricLevelImpact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricLevelImpact(contributionMatrix: \(String(describing: contributionMatrix)), metricName: \(String(describing: metricName)), numTimeSeries: \(String(describing: numTimeSeries)))"}
}

/// <p>Details about a measure affected by an anomaly.</p>
public struct MetricLevelImpact: Equatable {
    /// <p>Details about the dimensions that contributed to the anomaly.</p>
    public let contributionMatrix: ContributionMatrix?
    /// <p>The name of the measure.</p>
    public let metricName: String?
    /// <p>The number of anomalous metrics for the measure.</p>
    public let numTimeSeries: Int

    public init (
        contributionMatrix: ContributionMatrix? = nil,
        metricName: String? = nil,
        numTimeSeries: Int = 0
    )
    {
        self.contributionMatrix = contributionMatrix
        self.metricName = metricName
        self.numTimeSeries = numTimeSeries
    }
}

extension MetricSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case metricSetArn = "MetricSetArn"
        case metricSetDescription = "MetricSetDescription"
        case metricSetName = "MetricSetName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let metricSetArn = metricSetArn {
            try encodeContainer.encode(metricSetArn, forKey: .metricSetArn)
        }
        if let metricSetDescription = metricSetDescription {
            try encodeContainer.encode(metricSetDescription, forKey: .metricSetDescription)
        }
        if let metricSetName = metricSetName {
            try encodeContainer.encode(metricSetName, forKey: .metricSetName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let metricSetDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetDescription)
        metricSetDescription = metricSetDescriptionDecoded
        let metricSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetName)
        metricSetName = metricSetNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MetricSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricSetSummary(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), creationTime: \(String(describing: creationTime)), lastModificationTime: \(String(describing: lastModificationTime)), metricSetArn: \(String(describing: metricSetArn)), metricSetDescription: \(String(describing: metricSetDescription)), metricSetName: \(String(describing: metricSetName)), tags: \(String(describing: tags)))"}
}

/// <p>Contains information about a dataset.</p>
public struct MetricSetSummary: Equatable {
    /// <p>The ARN of the detector to which the dataset belongs.</p>
    public let anomalyDetectorArn: String?
    /// <p>The time at which the dataset was created.</p>
    public let creationTime: Date?
    /// <p>The time at which the dataset was last modified.</p>
    public let lastModificationTime: Date?
    /// <p>The ARN of the dataset.</p>
    public let metricSetArn: String?
    /// <p>The description of the dataset.</p>
    public let metricSetDescription: String?
    /// <p>The name of the dataset.</p>
    public let metricSetName: String?
    /// <p>The dataset's <a href="https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html">tags</a>.</p>
    public let tags: [String:String]?

    public init (
        anomalyDetectorArn: String? = nil,
        creationTime: Date? = nil,
        lastModificationTime: Date? = nil,
        metricSetArn: String? = nil,
        metricSetDescription: String? = nil,
        metricSetName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.creationTime = creationTime
        self.lastModificationTime = lastModificationTime
        self.metricSetArn = metricSetArn
        self.metricSetDescription = metricSetDescription
        self.metricSetName = metricSetName
        self.tags = tags
    }
}

extension MetricSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appFlowConfig = "AppFlowConfig"
        case cloudWatchConfig = "CloudWatchConfig"
        case rDSSourceConfig = "RDSSourceConfig"
        case redshiftSourceConfig = "RedshiftSourceConfig"
        case s3SourceConfig = "S3SourceConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appFlowConfig = appFlowConfig {
            try encodeContainer.encode(appFlowConfig, forKey: .appFlowConfig)
        }
        if let cloudWatchConfig = cloudWatchConfig {
            try encodeContainer.encode(cloudWatchConfig, forKey: .cloudWatchConfig)
        }
        if let rDSSourceConfig = rDSSourceConfig {
            try encodeContainer.encode(rDSSourceConfig, forKey: .rDSSourceConfig)
        }
        if let redshiftSourceConfig = redshiftSourceConfig {
            try encodeContainer.encode(redshiftSourceConfig, forKey: .redshiftSourceConfig)
        }
        if let s3SourceConfig = s3SourceConfig {
            try encodeContainer.encode(s3SourceConfig, forKey: .s3SourceConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3SourceConfigDecoded = try containerValues.decodeIfPresent(S3SourceConfig.self, forKey: .s3SourceConfig)
        s3SourceConfig = s3SourceConfigDecoded
        let appFlowConfigDecoded = try containerValues.decodeIfPresent(AppFlowConfig.self, forKey: .appFlowConfig)
        appFlowConfig = appFlowConfigDecoded
        let cloudWatchConfigDecoded = try containerValues.decodeIfPresent(CloudWatchConfig.self, forKey: .cloudWatchConfig)
        cloudWatchConfig = cloudWatchConfigDecoded
        let rDSSourceConfigDecoded = try containerValues.decodeIfPresent(RDSSourceConfig.self, forKey: .rDSSourceConfig)
        rDSSourceConfig = rDSSourceConfigDecoded
        let redshiftSourceConfigDecoded = try containerValues.decodeIfPresent(RedshiftSourceConfig.self, forKey: .redshiftSourceConfig)
        redshiftSourceConfig = redshiftSourceConfigDecoded
    }
}

extension MetricSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricSource(appFlowConfig: \(String(describing: appFlowConfig)), cloudWatchConfig: \(String(describing: cloudWatchConfig)), rDSSourceConfig: \(String(describing: rDSSourceConfig)), redshiftSourceConfig: \(String(describing: redshiftSourceConfig)), s3SourceConfig: \(String(describing: s3SourceConfig)))"}
}

/// <p>Contains information about source data used to generate a metric.</p>
public struct MetricSource: Equatable {
    /// <p>An object containing information about the AppFlow configuration.</p>
    public let appFlowConfig: AppFlowConfig?
    /// <p>An object containing information about the Amazon CloudWatch monitoring configuration.</p>
    public let cloudWatchConfig: CloudWatchConfig?
    /// <p>An object containing information about the Amazon Relational Database Service (RDS) configuration.</p>
    public let rDSSourceConfig: RDSSourceConfig?
    /// <p>An object containing information about the Amazon Redshift database configuration.</p>
    public let redshiftSourceConfig: RedshiftSourceConfig?
    /// <p>Contains information about the configuration of the S3 bucket that contains source files.</p>
    public let s3SourceConfig: S3SourceConfig?

    public init (
        appFlowConfig: AppFlowConfig? = nil,
        cloudWatchConfig: CloudWatchConfig? = nil,
        rDSSourceConfig: RDSSourceConfig? = nil,
        redshiftSourceConfig: RedshiftSourceConfig? = nil,
        s3SourceConfig: S3SourceConfig? = nil
    )
    {
        self.appFlowConfig = appFlowConfig
        self.cloudWatchConfig = cloudWatchConfig
        self.rDSSourceConfig = rDSSourceConfig
        self.redshiftSourceConfig = redshiftSourceConfig
        self.s3SourceConfig = s3SourceConfig
    }
}

public struct PutFeedbackInputBodyMiddleware: Middleware {
    public let id: String = "PutFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFeedbackInput>
    public typealias MOutput = OperationOutput<PutFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFeedbackOutputError>
}

extension PutFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFeedbackInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), anomalyGroupTimeSeriesFeedback: \(String(describing: anomalyGroupTimeSeriesFeedback)))"}
}

extension PutFeedbackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback {
            try encodeContainer.encode(anomalyGroupTimeSeriesFeedback, forKey: .anomalyGroupTimeSeriesFeedback)
        }
    }
}

public struct PutFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "PutFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFeedbackInput>
    public typealias MOutput = OperationOutput<PutFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFeedbackOutputError>
}

public struct PutFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "PutFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFeedbackInput>
    public typealias MOutput = OperationOutput<PutFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFeedbackOutputError>
}

public struct PutFeedbackInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the anomaly detector.</p>
    public let anomalyDetectorArn: String?
    /// <p>Feedback for an anomalous metric.</p>
    public let anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeriesFeedback?

    public init (
        anomalyDetectorArn: String? = nil,
        anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeriesFeedback? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
    }
}

struct PutFeedbackInputBody: Equatable {
    public let anomalyDetectorArn: String?
    public let anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeriesFeedback?
}

extension PutFeedbackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyGroupTimeSeriesFeedbackDecoded = try containerValues.decodeIfPresent(AnomalyGroupTimeSeriesFeedback.self, forKey: .anomalyGroupTimeSeriesFeedback)
        anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedbackDecoded
    }
}

extension PutFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFeedbackOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFeedbackOutputResponse()"}
}

extension PutFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutFeedbackOutputResponse: Equatable {

    public init() {}
}

struct PutFeedbackOutputResponseBody: Equatable {
}

extension PutFeedbackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RDSSourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case databaseHost = "DatabaseHost"
        case databaseName = "DatabaseName"
        case databasePort = "DatabasePort"
        case roleArn = "RoleArn"
        case secretManagerArn = "SecretManagerArn"
        case tableName = "TableName"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try encodeContainer.encode(dBInstanceIdentifier, forKey: .dBInstanceIdentifier)
        }
        if let databaseHost = databaseHost {
            try encodeContainer.encode(databaseHost, forKey: .databaseHost)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if databasePort != 0 {
            try encodeContainer.encode(databasePort, forKey: .databasePort)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretManagerArn = secretManagerArn {
            try encodeContainer.encode(secretManagerArn, forKey: .secretManagerArn)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let databaseHostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseHost)
        databaseHost = databaseHostDecoded
        let databasePortDecoded = try containerValues.decode(Int.self, forKey: .databasePort)
        databasePort = databasePortDecoded
        let secretManagerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretManagerArn)
        secretManagerArn = secretManagerArnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
    }
}

extension RDSSourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RDSSourceConfig(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), databaseHost: \(String(describing: databaseHost)), databaseName: \(String(describing: databaseName)), databasePort: \(String(describing: databasePort)), roleArn: \(String(describing: roleArn)), secretManagerArn: \(String(describing: secretManagerArn)), tableName: \(String(describing: tableName)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

/// <p>Contains information about the Amazon Relational Database Service (RDS) configuration.</p>
public struct RDSSourceConfig: Equatable {
    /// <p>A string identifying the database instance.</p>
    public let dBInstanceIdentifier: String?
    /// <p>The host name of the database.</p>
    public let databaseHost: String?
    /// <p>The name of the RDS database.</p>
    public let databaseName: String?
    /// <p>The port number where the database can be accessed.</p>
    public let databasePort: Int
    /// <p>The Amazon Resource Name (ARN) of the role.</p>
    public let roleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Secrets Manager role.</p>
    public let secretManagerArn: String?
    /// <p>The name of the table in the database.</p>
    public let tableName: String?
    /// <p>An object containing information about the Amazon Virtual Private Cloud (VPC) configuration.</p>
    public let vpcConfiguration: VpcConfiguration?

    public init (
        dBInstanceIdentifier: String? = nil,
        databaseHost: String? = nil,
        databaseName: String? = nil,
        databasePort: Int = 0,
        roleArn: String? = nil,
        secretManagerArn: String? = nil,
        tableName: String? = nil,
        vpcConfiguration: VpcConfiguration? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.databaseHost = databaseHost
        self.databaseName = databaseName
        self.databasePort = databasePort
        self.roleArn = roleArn
        self.secretManagerArn = secretManagerArn
        self.tableName = tableName
        self.vpcConfiguration = vpcConfiguration
    }
}

extension RedshiftSourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case databaseHost = "DatabaseHost"
        case databaseName = "DatabaseName"
        case databasePort = "DatabasePort"
        case roleArn = "RoleArn"
        case secretManagerArn = "SecretManagerArn"
        case tableName = "TableName"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterIdentifier = clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let databaseHost = databaseHost {
            try encodeContainer.encode(databaseHost, forKey: .databaseHost)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if databasePort != 0 {
            try encodeContainer.encode(databasePort, forKey: .databasePort)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretManagerArn = secretManagerArn {
            try encodeContainer.encode(secretManagerArn, forKey: .secretManagerArn)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let databaseHostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseHost)
        databaseHost = databaseHostDecoded
        let databasePortDecoded = try containerValues.decode(Int.self, forKey: .databasePort)
        databasePort = databasePortDecoded
        let secretManagerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretManagerArn)
        secretManagerArn = secretManagerArnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
    }
}

extension RedshiftSourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedshiftSourceConfig(clusterIdentifier: \(String(describing: clusterIdentifier)), databaseHost: \(String(describing: databaseHost)), databaseName: \(String(describing: databaseName)), databasePort: \(String(describing: databasePort)), roleArn: \(String(describing: roleArn)), secretManagerArn: \(String(describing: secretManagerArn)), tableName: \(String(describing: tableName)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

/// <p>Provides information about the Amazon Redshift database configuration.</p>
public struct RedshiftSourceConfig: Equatable {
    /// <p>A string identifying the Redshift cluster.</p>
    public let clusterIdentifier: String?
    /// <p>The name of the database host.</p>
    public let databaseHost: String?
    /// <p>The Redshift database name.</p>
    public let databaseName: String?
    /// <p>The port number where the database can be accessed.</p>
    public let databasePort: Int
    /// <p>The Amazon Resource Name (ARN) of the role providing access to the database.</p>
    public let roleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Secrets Manager role.</p>
    public let secretManagerArn: String?
    /// <p>The table name of the Redshift database.</p>
    public let tableName: String?
    /// <p>Contains information about the Amazon Virtual Private Cloud (VPC) configuration.</p>
    public let vpcConfiguration: VpcConfiguration?

    public init (
        clusterIdentifier: String? = nil,
        databaseHost: String? = nil,
        databaseName: String? = nil,
        databasePort: Int = 0,
        roleArn: String? = nil,
        secretManagerArn: String? = nil,
        tableName: String? = nil,
        vpcConfiguration: VpcConfiguration? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.databaseHost = databaseHost
        self.databaseName = databaseName
        self.databasePort = databasePort
        self.roleArn = roleArn
        self.secretManagerArn = secretManagerArn
        self.tableName = tableName
        self.vpcConfiguration = vpcConfiguration
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource cannot be found. Check the ARN of the resource and try again.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?
    /// <p>The type of the resource.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension S3SourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileFormatDescriptor = "FileFormatDescriptor"
        case historicalDataPathList = "HistoricalDataPathList"
        case roleArn = "RoleArn"
        case templatedPathList = "TemplatedPathList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormatDescriptor = fileFormatDescriptor {
            try encodeContainer.encode(fileFormatDescriptor, forKey: .fileFormatDescriptor)
        }
        if let historicalDataPathList = historicalDataPathList {
            var historicalDataPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .historicalDataPathList)
            for historicaldatapathlist0 in historicalDataPathList {
                try historicalDataPathListContainer.encode(historicaldatapathlist0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let templatedPathList = templatedPathList {
            var templatedPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .templatedPathList)
            for templatedpathlist0 in templatedPathList {
                try templatedPathListContainer.encode(templatedpathlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let templatedPathListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .templatedPathList)
        var templatedPathListDecoded0:[String]? = nil
        if let templatedPathListContainer = templatedPathListContainer {
            templatedPathListDecoded0 = [String]()
            for string0 in templatedPathListContainer {
                if let string0 = string0 {
                    templatedPathListDecoded0?.append(string0)
                }
            }
        }
        templatedPathList = templatedPathListDecoded0
        let historicalDataPathListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .historicalDataPathList)
        var historicalDataPathListDecoded0:[String]? = nil
        if let historicalDataPathListContainer = historicalDataPathListContainer {
            historicalDataPathListDecoded0 = [String]()
            for string0 in historicalDataPathListContainer {
                if let string0 = string0 {
                    historicalDataPathListDecoded0?.append(string0)
                }
            }
        }
        historicalDataPathList = historicalDataPathListDecoded0
        let fileFormatDescriptorDecoded = try containerValues.decodeIfPresent(FileFormatDescriptor.self, forKey: .fileFormatDescriptor)
        fileFormatDescriptor = fileFormatDescriptorDecoded
    }
}

extension S3SourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3SourceConfig(fileFormatDescriptor: \(String(describing: fileFormatDescriptor)), historicalDataPathList: \(String(describing: historicalDataPathList)), roleArn: \(String(describing: roleArn)), templatedPathList: \(String(describing: templatedPathList)))"}
}

/// <p>Contains information about the configuration of the S3 bucket that contains source files.</p>
public struct S3SourceConfig: Equatable {
    /// <p>Contains information about a source file's formatting.</p>
    public let fileFormatDescriptor: FileFormatDescriptor?
    /// <p>A list of paths to the historical data files.</p>
    public let historicalDataPathList: [String]?
    /// <p>The ARN of an IAM role that has read and write access permissions to the source S3 bucket.</p>
    public let roleArn: String?
    /// <p>A list of templated paths to the source files.</p>
    public let templatedPathList: [String]?

    public init (
        fileFormatDescriptor: FileFormatDescriptor? = nil,
        historicalDataPathList: [String]? = nil,
        roleArn: String? = nil,
        templatedPathList: [String]? = nil
    )
    {
        self.fileFormatDescriptor = fileFormatDescriptor
        self.historicalDataPathList = historicalDataPathList
        self.roleArn = roleArn
        self.templatedPathList = templatedPathList
    }
}

extension SNSConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
        case snsTopicArn = "SnsTopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
    }
}

extension SNSConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSConfiguration(roleArn: \(String(describing: roleArn)), snsTopicArn: \(String(describing: snsTopicArn)))"}
}

/// <p>Contains information about the SNS topic to which you want to send your alerts and the IAM role that has
///       access to that topic.</p>
public struct SNSConfiguration: Equatable {
    /// <p>The ARN of the IAM role that has access to the target SNS topic.</p>
    public let roleArn: String?
    /// <p>The ARN of the target SNS topic.</p>
    public let snsTopicArn: String?

    public init (
        roleArn: String? = nil,
        snsTopicArn: String? = nil
    )
    {
        self.roleArn = roleArn
        self.snsTopicArn = snsTopicArn
    }
}

extension SampleDataS3SourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileFormatDescriptor = "FileFormatDescriptor"
        case historicalDataPathList = "HistoricalDataPathList"
        case roleArn = "RoleArn"
        case templatedPathList = "TemplatedPathList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormatDescriptor = fileFormatDescriptor {
            try encodeContainer.encode(fileFormatDescriptor, forKey: .fileFormatDescriptor)
        }
        if let historicalDataPathList = historicalDataPathList {
            var historicalDataPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .historicalDataPathList)
            for historicaldatapathlist0 in historicalDataPathList {
                try historicalDataPathListContainer.encode(historicaldatapathlist0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let templatedPathList = templatedPathList {
            var templatedPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .templatedPathList)
            for templatedpathlist0 in templatedPathList {
                try templatedPathListContainer.encode(templatedpathlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let templatedPathListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .templatedPathList)
        var templatedPathListDecoded0:[String]? = nil
        if let templatedPathListContainer = templatedPathListContainer {
            templatedPathListDecoded0 = [String]()
            for string0 in templatedPathListContainer {
                if let string0 = string0 {
                    templatedPathListDecoded0?.append(string0)
                }
            }
        }
        templatedPathList = templatedPathListDecoded0
        let historicalDataPathListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .historicalDataPathList)
        var historicalDataPathListDecoded0:[String]? = nil
        if let historicalDataPathListContainer = historicalDataPathListContainer {
            historicalDataPathListDecoded0 = [String]()
            for string0 in historicalDataPathListContainer {
                if let string0 = string0 {
                    historicalDataPathListDecoded0?.append(string0)
                }
            }
        }
        historicalDataPathList = historicalDataPathListDecoded0
        let fileFormatDescriptorDecoded = try containerValues.decodeIfPresent(FileFormatDescriptor.self, forKey: .fileFormatDescriptor)
        fileFormatDescriptor = fileFormatDescriptorDecoded
    }
}

extension SampleDataS3SourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SampleDataS3SourceConfig(fileFormatDescriptor: \(String(describing: fileFormatDescriptor)), historicalDataPathList: \(String(describing: historicalDataPathList)), roleArn: \(String(describing: roleArn)), templatedPathList: \(String(describing: templatedPathList)))"}
}

/// <p>Contains information about the source configuration in Amazon S3.</p>
public struct SampleDataS3SourceConfig: Equatable {
    /// <p>Contains information about a source file's formatting.</p>
    public let fileFormatDescriptor: FileFormatDescriptor?
    /// <p>An array of strings containing the historical set of data paths.</p>
    public let historicalDataPathList: [String]?
    /// <p>The Amazon Resource Name (ARN) of the role.</p>
    public let roleArn: String?
    /// <p>An array of strings containing the list of templated paths.</p>
    public let templatedPathList: [String]?

    public init (
        fileFormatDescriptor: FileFormatDescriptor? = nil,
        historicalDataPathList: [String]? = nil,
        roleArn: String? = nil,
        templatedPathList: [String]? = nil
    )
    {
        self.fileFormatDescriptor = fileFormatDescriptor
        self.historicalDataPathList = historicalDataPathList
        self.roleArn = roleArn
        self.templatedPathList = templatedPathList
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request exceeded the service's quotas. Check the service quotas and try again.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The quota code.</p>
    public var quotaCode: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?
    /// <p>The type of the resource.</p>
    public var resourceType: String?
    /// <p>The service code.</p>
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
    public let quotaCode: String?
    public let serviceCode: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The resource's Amazon Resource Name (ARN).</p>
    public let resourceArn: String?
    /// <p>Tags to apply to the resource. Tag keys and values can contain letters, numbers, spaces, and the following
    ///       symbols: <code>_.:/=+@-</code>
    ///          </p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TimeSeries: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensionList = "DimensionList"
        case metricValueList = "MetricValueList"
        case timeSeriesId = "TimeSeriesId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionList = dimensionList {
            var dimensionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionList)
            for dimensionnamevaluelist0 in dimensionList {
                try dimensionListContainer.encode(dimensionnamevaluelist0)
            }
        }
        if let metricValueList = metricValueList {
            var metricValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricValueList)
            for metricvaluelist0 in metricValueList {
                try metricValueListContainer.encode(metricvaluelist0)
            }
        }
        if let timeSeriesId = timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let dimensionListContainer = try containerValues.decodeIfPresent([DimensionNameValue?].self, forKey: .dimensionList)
        var dimensionListDecoded0:[DimensionNameValue]? = nil
        if let dimensionListContainer = dimensionListContainer {
            dimensionListDecoded0 = [DimensionNameValue]()
            for structure0 in dimensionListContainer {
                if let structure0 = structure0 {
                    dimensionListDecoded0?.append(structure0)
                }
            }
        }
        dimensionList = dimensionListDecoded0
        let metricValueListContainer = try containerValues.decodeIfPresent([Double?].self, forKey: .metricValueList)
        var metricValueListDecoded0:[Double]? = nil
        if let metricValueListContainer = metricValueListContainer {
            metricValueListDecoded0 = [Double]()
            for double0 in metricValueListContainer {
                if let double0 = double0 {
                    metricValueListDecoded0?.append(double0)
                }
            }
        }
        metricValueList = metricValueListDecoded0
    }
}

extension TimeSeries: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeSeries(dimensionList: \(String(describing: dimensionList)), metricValueList: \(String(describing: metricValueList)), timeSeriesId: \(String(describing: timeSeriesId)))"}
}

/// <p>Details about a metric. A metric is an aggregation of the values of a measure for a dimension value, such as
///         <i>availability</i> in the <i>us-east-1</i> Region.</p>
public struct TimeSeries: Equatable {
    /// <p>The dimensions of the metric.</p>
    public let dimensionList: [DimensionNameValue]?
    /// <p>The values for the metric.</p>
    public let metricValueList: [Double]?
    /// <p>The ID of the metric.</p>
    public let timeSeriesId: String?

    public init (
        dimensionList: [DimensionNameValue]? = nil,
        metricValueList: [Double]? = nil,
        timeSeriesId: String? = nil
    )
    {
        self.dimensionList = dimensionList
        self.metricValueList = metricValueList
        self.timeSeriesId = timeSeriesId
    }
}

extension TimeSeriesFeedback: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isAnomaly = "IsAnomaly"
        case timeSeriesId = "TimeSeriesId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isAnomaly = isAnomaly {
            try encodeContainer.encode(isAnomaly, forKey: .isAnomaly)
        }
        if let timeSeriesId = timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let isAnomalyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isAnomaly)
        isAnomaly = isAnomalyDecoded
    }
}

extension TimeSeriesFeedback: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeSeriesFeedback(isAnomaly: \(String(describing: isAnomaly)), timeSeriesId: \(String(describing: timeSeriesId)))"}
}

/// <p>Details about feedback submitted for an anomalous metric.</p>
public struct TimeSeriesFeedback: Equatable {
    /// <p>Feedback on whether the metric is a legitimate anomaly.</p>
    public let isAnomaly: Bool?
    /// <p>The ID of the metric.</p>
    public let timeSeriesId: String?

    public init (
        isAnomaly: Bool? = nil,
        timeSeriesId: String? = nil
    )
    {
        self.isAnomaly = isAnomaly
        self.timeSeriesId = timeSeriesId
    }
}

extension TimestampColumn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnFormat = "ColumnFormat"
        case columnName = "ColumnName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnFormat = columnFormat {
            try encodeContainer.encode(columnFormat, forKey: .columnFormat)
        }
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let columnFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnFormat)
        columnFormat = columnFormatDecoded
    }
}

extension TimestampColumn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimestampColumn(columnFormat: \(String(describing: columnFormat)), columnName: \(String(describing: columnName)))"}
}

/// <p>Contains information about the column used to track time in a source data file.</p>
public struct TimestampColumn: Equatable {
    /// <p>The format of the timestamp column.</p>
    public let columnFormat: String?
    /// <p>The name of the timestamp column.</p>
    public let columnName: String?

    public init (
        columnFormat: String? = nil,
        columnName: String? = nil
    )
    {
        self.columnFormat = columnFormat
        self.columnName = columnName
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to too many requests being submitted at the same time.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The resource's Amazon Resource Name (ARN).</p>
    public let resourceArn: String?
    /// <p>Keys to remove from the resource's tags.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAnomalyDetectorInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAnomalyDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<UpdateAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnomalyDetectorOutputError>
}

extension UpdateAnomalyDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAnomalyDetectorInput(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)), anomalyDetectorConfig: \(String(describing: anomalyDetectorConfig)), anomalyDetectorDescription: \(String(describing: anomalyDetectorDescription)), kmsKeyArn: \(String(describing: kmsKeyArn)))"}
}

extension UpdateAnomalyDetectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyDetectorConfig = anomalyDetectorConfig {
            try encodeContainer.encode(anomalyDetectorConfig, forKey: .anomalyDetectorConfig)
        }
        if let anomalyDetectorDescription = anomalyDetectorDescription {
            try encodeContainer.encode(anomalyDetectorDescription, forKey: .anomalyDetectorDescription)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }
}

public struct UpdateAnomalyDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAnomalyDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<UpdateAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnomalyDetectorOutputError>
}

public struct UpdateAnomalyDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAnomalyDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnomalyDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnomalyDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnomalyDetectorInput>
    public typealias MOutput = OperationOutput<UpdateAnomalyDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnomalyDetectorOutputError>
}

public struct UpdateAnomalyDetectorInput: Equatable {
    /// <p>The ARN of the detector to update.</p>
    public let anomalyDetectorArn: String?
    /// <p>Contains information about the configuration to which the detector will be updated.</p>
    public let anomalyDetectorConfig: AnomalyDetectorConfig?
    /// <p>The updated detector description.</p>
    public let anomalyDetectorDescription: String?
    /// <p>The Amazon Resource Name (ARN) of an AWS KMS encryption key.</p>
    public let kmsKeyArn: String?

    public init (
        anomalyDetectorArn: String? = nil,
        anomalyDetectorConfig: AnomalyDetectorConfig? = nil,
        anomalyDetectorDescription: String? = nil,
        kmsKeyArn: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyDetectorConfig = anomalyDetectorConfig
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.kmsKeyArn = kmsKeyArn
    }
}

struct UpdateAnomalyDetectorInputBody: Equatable {
    public let anomalyDetectorArn: String?
    public let kmsKeyArn: String?
    public let anomalyDetectorDescription: String?
    public let anomalyDetectorConfig: AnomalyDetectorConfig?
}

extension UpdateAnomalyDetectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case kmsKeyArn = "KmsKeyArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let anomalyDetectorDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorDescription)
        anomalyDetectorDescription = anomalyDetectorDescriptionDecoded
        let anomalyDetectorConfigDecoded = try containerValues.decodeIfPresent(AnomalyDetectorConfig.self, forKey: .anomalyDetectorConfig)
        anomalyDetectorConfig = anomalyDetectorConfigDecoded
    }
}

extension UpdateAnomalyDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnomalyDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnomalyDetectorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnomalyDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAnomalyDetectorOutputResponse(anomalyDetectorArn: \(String(describing: anomalyDetectorArn)))"}
}

extension UpdateAnomalyDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAnomalyDetectorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalyDetectorArn = output.anomalyDetectorArn
        } else {
            self.anomalyDetectorArn = nil
        }
    }
}

public struct UpdateAnomalyDetectorOutputResponse: Equatable {
    /// <p>The ARN of the updated detector.</p>
    public let anomalyDetectorArn: String?

    public init (
        anomalyDetectorArn: String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct UpdateAnomalyDetectorOutputResponseBody: Equatable {
    public let anomalyDetectorArn: String?
}

extension UpdateAnomalyDetectorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

public struct UpdateMetricSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMetricSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMetricSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMetricSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMetricSetInput>
    public typealias MOutput = OperationOutput<UpdateMetricSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMetricSetOutputError>
}

extension UpdateMetricSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMetricSetInput(dimensionList: \(String(describing: dimensionList)), metricList: \(String(describing: metricList)), metricSetArn: \(String(describing: metricSetArn)), metricSetDescription: \(String(describing: metricSetDescription)), metricSetFrequency: \(String(describing: metricSetFrequency)), metricSource: \(String(describing: metricSource)), offset: \(String(describing: offset)), timestampColumn: \(String(describing: timestampColumn)))"}
}

extension UpdateMetricSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensionList = "DimensionList"
        case metricList = "MetricList"
        case metricSetArn = "MetricSetArn"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case timestampColumn = "TimestampColumn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionList = dimensionList {
            var dimensionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionList)
            for dimensionlist0 in dimensionList {
                try dimensionListContainer.encode(dimensionlist0)
            }
        }
        if let metricList = metricList {
            var metricListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricList)
            for metriclist0 in metricList {
                try metricListContainer.encode(metriclist0)
            }
        }
        if let metricSetArn = metricSetArn {
            try encodeContainer.encode(metricSetArn, forKey: .metricSetArn)
        }
        if let metricSetDescription = metricSetDescription {
            try encodeContainer.encode(metricSetDescription, forKey: .metricSetDescription)
        }
        if let metricSetFrequency = metricSetFrequency {
            try encodeContainer.encode(metricSetFrequency.rawValue, forKey: .metricSetFrequency)
        }
        if let metricSource = metricSource {
            try encodeContainer.encode(metricSource, forKey: .metricSource)
        }
        if offset != 0 {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if let timestampColumn = timestampColumn {
            try encodeContainer.encode(timestampColumn, forKey: .timestampColumn)
        }
    }
}

public struct UpdateMetricSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMetricSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMetricSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMetricSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMetricSetInput>
    public typealias MOutput = OperationOutput<UpdateMetricSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMetricSetOutputError>
}

public struct UpdateMetricSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMetricSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMetricSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMetricSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMetricSetInput>
    public typealias MOutput = OperationOutput<UpdateMetricSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMetricSetOutputError>
}

public struct UpdateMetricSetInput: Equatable {
    /// <p>The dimension list.</p>
    public let dimensionList: [String]?
    /// <p>The metric list.</p>
    public let metricList: [Metric]?
    /// <p>The ARN of the dataset to update.</p>
    public let metricSetArn: String?
    /// <p>The dataset's description.</p>
    public let metricSetDescription: String?
    /// <p>The dataset's interval.</p>
    public let metricSetFrequency: Frequency?
    /// <p>Contains information about source data used to generate a metric.</p>
    public let metricSource: MetricSource?
    /// <p>After an interval ends, the amount of time that the detector waits before importing data.</p>
    public let offset: Int
    /// <p>The timestamp column.</p>
    public let timestampColumn: TimestampColumn?

    public init (
        dimensionList: [String]? = nil,
        metricList: [Metric]? = nil,
        metricSetArn: String? = nil,
        metricSetDescription: String? = nil,
        metricSetFrequency: Frequency? = nil,
        metricSource: MetricSource? = nil,
        offset: Int = 0,
        timestampColumn: TimestampColumn? = nil
    )
    {
        self.dimensionList = dimensionList
        self.metricList = metricList
        self.metricSetArn = metricSetArn
        self.metricSetDescription = metricSetDescription
        self.metricSetFrequency = metricSetFrequency
        self.metricSource = metricSource
        self.offset = offset
        self.timestampColumn = timestampColumn
    }
}

struct UpdateMetricSetInputBody: Equatable {
    public let metricSetArn: String?
    public let metricSetDescription: String?
    public let metricList: [Metric]?
    public let offset: Int
    public let timestampColumn: TimestampColumn?
    public let dimensionList: [String]?
    public let metricSetFrequency: Frequency?
    public let metricSource: MetricSource?
}

extension UpdateMetricSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dimensionList = "DimensionList"
        case metricList = "MetricList"
        case metricSetArn = "MetricSetArn"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case timestampColumn = "TimestampColumn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
        let metricSetDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetDescription)
        metricSetDescription = metricSetDescriptionDecoded
        let metricListContainer = try containerValues.decodeIfPresent([Metric?].self, forKey: .metricList)
        var metricListDecoded0:[Metric]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [Metric]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let offsetDecoded = try containerValues.decode(Int.self, forKey: .offset)
        offset = offsetDecoded
        let timestampColumnDecoded = try containerValues.decodeIfPresent(TimestampColumn.self, forKey: .timestampColumn)
        timestampColumn = timestampColumnDecoded
        let dimensionListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dimensionList)
        var dimensionListDecoded0:[String]? = nil
        if let dimensionListContainer = dimensionListContainer {
            dimensionListDecoded0 = [String]()
            for string0 in dimensionListContainer {
                if let string0 = string0 {
                    dimensionListDecoded0?.append(string0)
                }
            }
        }
        dimensionList = dimensionListDecoded0
        let metricSetFrequencyDecoded = try containerValues.decodeIfPresent(Frequency.self, forKey: .metricSetFrequency)
        metricSetFrequency = metricSetFrequencyDecoded
        let metricSourceDecoded = try containerValues.decodeIfPresent(MetricSource.self, forKey: .metricSource)
        metricSource = metricSourceDecoded
    }
}

extension UpdateMetricSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMetricSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMetricSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMetricSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMetricSetOutputResponse(metricSetArn: \(String(describing: metricSetArn)))"}
}

extension UpdateMetricSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateMetricSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metricSetArn = output.metricSetArn
        } else {
            self.metricSetArn = nil
        }
    }
}

public struct UpdateMetricSetOutputResponse: Equatable {
    /// <p>The ARN of the dataset.</p>
    public let metricSetArn: String?

    public init (
        metricSetArn: String? = nil
    )
    {
        self.metricSetArn = metricSetArn
    }
}

struct UpdateMetricSetOutputResponseBody: Equatable {
    public let metricSetArn: String?
}

extension UpdateMetricSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metricSetArn = "MetricSetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(fields: \(String(describing: fields)), message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints specified by the AWS service. Check your input values and try
///       again.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Fields that failed validation.</p>
    public var fields: [ValidationExceptionField]?
    public var message: String?
    /// <p>The reason that validation failed.</p>
    public var reason: ValidationExceptionReason?

    public init (
        fields: [ValidationExceptionField]? = nil,
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let reason: ValidationExceptionReason?
    public let fields: [ValidationExceptionField]?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ValidationExceptionField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationExceptionField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationExceptionField(message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>Contains information about a a field in a validation exception.</p>
public struct ValidationExceptionField: Equatable {
    /// <p>The message with more information about the validation exception.</p>
    public let message: String?
    /// <p>The name of the field.</p>
    public let name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

public enum ValidationExceptionReason {
    case cannotParse
    case fieldValidationFailed
    case other
    case unknownOperation
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .cannotParse,
            .fieldValidationFailed,
            .other,
            .unknownOperation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cannotParse: return "CANNOT_PARSE"
        case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
        case .other: return "OTHER"
        case .unknownOperation: return "UNKNOWN_OPERATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}

extension VpcConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIdList = "SecurityGroupIdList"
        case subnetIdList = "SubnetIdList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIdList = securityGroupIdList {
            var securityGroupIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIdList)
            for securitygroupidlist0 in securityGroupIdList {
                try securityGroupIdListContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIdList = subnetIdList {
            var subnetIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIdList)
            for subnetidlist0 in subnetIdList {
                try subnetIdListContainer.encode(subnetidlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIdList)
        var subnetIdListDecoded0:[String]? = nil
        if let subnetIdListContainer = subnetIdListContainer {
            subnetIdListDecoded0 = [String]()
            for string0 in subnetIdListContainer {
                if let string0 = string0 {
                    subnetIdListDecoded0?.append(string0)
                }
            }
        }
        subnetIdList = subnetIdListDecoded0
        let securityGroupIdListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIdList)
        var securityGroupIdListDecoded0:[String]? = nil
        if let securityGroupIdListContainer = securityGroupIdListContainer {
            securityGroupIdListDecoded0 = [String]()
            for string0 in securityGroupIdListContainer {
                if let string0 = string0 {
                    securityGroupIdListDecoded0?.append(string0)
                }
            }
        }
        securityGroupIdList = securityGroupIdListDecoded0
    }
}

extension VpcConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfiguration(securityGroupIdList: \(String(describing: securityGroupIdList)), subnetIdList: \(String(describing: subnetIdList)))"}
}

/// <p>Contains configuration information about the Amazon Virtual Private Cloud (VPC).</p>
public struct VpcConfiguration: Equatable {
    /// <p>An array of strings containing the list of security groups.</p>
    public let securityGroupIdList: [String]?
    /// <p>An array of strings containing the Amazon VPC subnet IDs (e.g., <code>subnet-0bb1c79de3EXAMPLE</code>.</p>
    public let subnetIdList: [String]?

    public init (
        securityGroupIdList: [String]? = nil,
        subnetIdList: [String]? = nil
    )
    {
        self.securityGroupIdList = securityGroupIdList
        self.subnetIdList = subnetIdList
    }
}
