// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class GreengrassV2Client {
    let client: SdkHttpClient
    let config: GreengrassV2ClientConfiguration
    let serviceName = "GreengrassV2"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: GreengrassV2ClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class GreengrassV2ClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> GreengrassV2ClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try GreengrassV2ClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension GreengrassV2Client: GreengrassV2ClientProtocol {
    /// <p>Cancels a deployment. This operation cancels the deployment for devices that haven't yet
    ///       received it. If a device already received the deployment, this operation doesn't change
    ///       anything for that device.</p>
    public func cancelDeployment(input: CancelDeploymentInput, completion: @escaping (SdkResult<CancelDeploymentOutputResponse, CancelDeploymentOutputError>) -> Void)
    {
        guard let deploymentId = input.deploymentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component deploymentId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/v2/deployments/\(deploymentId)/cancel"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelDeployment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelDeploymentInput, CancelDeploymentOutputResponse, CancelDeploymentOutputError>(id: "cancelDeployment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelDeploymentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelDeploymentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelDeploymentInput, CancelDeploymentOutputResponse, CancelDeploymentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a component. Components are software that run on AWS IoT Greengrass core devices. After you
    ///       develop and test a component on your core device, you can use this operation to upload your
    ///       component to AWS IoT Greengrass. Then, you can deploy the component to other core devices.</p>
    ///          <p>You can use this operation to do the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Create components from recipes</b>
    ///                </p>
    ///                <p>Create a component from a recipe, which is a file that defines the component's
    ///           metadata, parameters, dependencies, lifecycle, artifacts, and platform capability. For
    ///           more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/component-recipe-reference.html">AWS IoT Greengrass component recipe
    ///             reference</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    ///                <p>To create a component from a recipe, specify <code>inlineRecipe</code> when you call
    ///           this operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Create components from Lambda functions</b>
    ///                </p>
    ///                <p>Create a component from an AWS Lambda function that runs on AWS IoT Greengrass. This creates a recipe
    ///           and artifacts from the Lambda function's deployment package. You can use this operation to
    ///           migrate Lambda functions from AWS IoT Greengrass V1 to AWS IoT Greengrass V2.</p>
    ///                <p>This function only accepts Lambda functions that use the following runtimes:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Python 2.7 – <code>python2.7</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Python 3.7 – <code>python3.7</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Python 3.8 – <code>python3.8</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Java 8 – <code>java8</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Node.js 10 – <code>nodejs10.x</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Node.js 12 – <code>nodejs12.x</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                <p>To create a component from a Lambda function, specify <code>lambdaFunction</code>
    ///           when you call this operation.</p>
    ///             </li>
    ///          </ul>
    public func createComponentVersion(input: CreateComponentVersionInput, completion: @escaping (SdkResult<CreateComponentVersionOutputResponse, CreateComponentVersionOutputError>) -> Void)
    {
        let urlPath = "/greengrass/v2/createComponentVersion"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createComponentVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateComponentVersionInput, CreateComponentVersionOutputResponse, CreateComponentVersionOutputError>(id: "createComponentVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateComponentVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateComponentVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateComponentVersionInput, CreateComponentVersionOutputResponse, CreateComponentVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateComponentVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a continuous deployment for a target, which is a AWS IoT Greengrass core device or group of core
    ///       devices. When you add a new core device to a group of core devices that has a deployment, AWS IoT Greengrass
    ///       deploys that group's deployment to the new device.</p>
    ///          <p>You can define one deployment for each target. When you create a new deployment for a
    ///       target that has an existing deployment, you replace the previous deployment. AWS IoT Greengrass applies the
    ///       new deployment to the target devices.</p>
    ///          <p>Every deployment has a revision number that indicates how many deployment revisions you
    ///       define for a target. Use this operation to create a new revision of an existing deployment.
    ///       This operation returns the revision number of the new deployment when you create it.</p>
    ///          <p>For more information, see the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/create-deployments.html">Create deployments</a> in the
    ///         <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    public func createDeployment(input: CreateDeploymentInput, completion: @escaping (SdkResult<CreateDeploymentOutputResponse, CreateDeploymentOutputError>) -> Void)
    {
        let urlPath = "/greengrass/v2/deployments"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDeployment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDeploymentInput, CreateDeploymentOutputResponse, CreateDeploymentOutputError>(id: "createDeployment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDeploymentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDeploymentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDeploymentInput, CreateDeploymentOutputResponse, CreateDeploymentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDeploymentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a version of a component from AWS IoT Greengrass.</p>
    ///          <note>
    ///             <p>This operation deletes the component's recipe and artifacts. As a result, deployments
    ///         that refer to this component version will fail. If you have deployments that use this
    ///         component version, you can remove the component from the deployment or update the deployment
    ///         to use a valid version.</p>
    ///          </note>
    public func deleteComponent(input: DeleteComponentInput, completion: @escaping (SdkResult<DeleteComponentOutputResponse, DeleteComponentOutputError>) -> Void)
    {
        guard let arn = input.arn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component arn unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/v2/components/\(arn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteComponent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteComponentInput, DeleteComponentOutputResponse, DeleteComponentOutputError>(id: "deleteComponent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteComponentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteComponentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteComponentInput, DeleteComponentOutputResponse, DeleteComponentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a AWS IoT Greengrass core device, which is an AWS IoT thing. This operation removes the core
    ///       device from the list of core devices. This operation doesn't delete the AWS IoT thing. For more
    ///       information about how to delete the AWS IoT thing, see <a href="https://docs.aws.amazon.com/iot/latest/apireference/API_DeleteThing.html">DeleteThing</a> in the
    ///         <i>AWS IoT API Reference</i>.</p>
    public func deleteCoreDevice(input: DeleteCoreDeviceInput, completion: @escaping (SdkResult<DeleteCoreDeviceOutputResponse, DeleteCoreDeviceOutputError>) -> Void)
    {
        guard let coreDeviceThingName = input.coreDeviceThingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component coreDeviceThingName unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/v2/coreDevices/\(coreDeviceThingName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCoreDevice")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteCoreDeviceInput, DeleteCoreDeviceOutputResponse, DeleteCoreDeviceOutputError>(id: "deleteCoreDevice")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteCoreDeviceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteCoreDeviceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteCoreDeviceInput, DeleteCoreDeviceOutputResponse, DeleteCoreDeviceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves metadata for a version of a component.</p>
    public func describeComponent(input: DescribeComponentInput, completion: @escaping (SdkResult<DescribeComponentOutputResponse, DescribeComponentOutputError>) -> Void)
    {
        guard let arn = input.arn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component arn unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/v2/components/\(arn)/metadata"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeComponent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeComponentInput, DescribeComponentOutputResponse, DescribeComponentOutputError>(id: "describeComponent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeComponentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeComponentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeComponentInput, DescribeComponentOutputResponse, DescribeComponentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the recipe for a version of a component. Core devices can call this operation to
    ///       identify the artifacts and requirements to install a component.</p>
    public func getComponent(input: GetComponentInput, completion: @escaping (SdkResult<GetComponentOutputResponse, GetComponentOutputError>) -> Void)
    {
        guard let arn = input.arn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component arn unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/v2/components/\(arn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getComponent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetComponentInput, GetComponentOutputResponse, GetComponentOutputError>(id: "getComponent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetComponentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetComponentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetComponentInput, GetComponentOutputResponse, GetComponentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the pre-signed URL to download a public component artifact. Core devices call this
    ///       operation to identify the URL that they can use to download an artifact to install.</p>
    public func getComponentVersionArtifact(input: GetComponentVersionArtifactInput, completion: @escaping (SdkResult<GetComponentVersionArtifactOutputResponse, GetComponentVersionArtifactOutputError>) -> Void)
    {
        guard let arn = input.arn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component arn unexpectedly nil"))))
            return
        }
        guard let artifactName = input.artifactName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component artifactName unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/v2/components/\(arn)/artifacts/\(artifactName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getComponentVersionArtifact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetComponentVersionArtifactInput, GetComponentVersionArtifactOutputResponse, GetComponentVersionArtifactOutputError>(id: "getComponentVersionArtifact")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetComponentVersionArtifactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetComponentVersionArtifactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetComponentVersionArtifactInput, GetComponentVersionArtifactOutputResponse, GetComponentVersionArtifactOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves metadata for a AWS IoT Greengrass core device.</p>
    public func getCoreDevice(input: GetCoreDeviceInput, completion: @escaping (SdkResult<GetCoreDeviceOutputResponse, GetCoreDeviceOutputError>) -> Void)
    {
        guard let coreDeviceThingName = input.coreDeviceThingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component coreDeviceThingName unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/v2/coreDevices/\(coreDeviceThingName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCoreDevice")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCoreDeviceInput, GetCoreDeviceOutputResponse, GetCoreDeviceOutputError>(id: "getCoreDevice")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCoreDeviceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCoreDeviceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCoreDeviceInput, GetCoreDeviceOutputResponse, GetCoreDeviceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a deployment. Deployments define the components that run on AWS IoT Greengrass core devices.</p>
    public func getDeployment(input: GetDeploymentInput, completion: @escaping (SdkResult<GetDeploymentOutputResponse, GetDeploymentOutputError>) -> Void)
    {
        guard let deploymentId = input.deploymentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component deploymentId unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/v2/deployments/\(deploymentId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDeployment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDeploymentInput, GetDeploymentOutputResponse, GetDeploymentOutputError>(id: "getDeployment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDeploymentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDeploymentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDeploymentInput, GetDeploymentOutputResponse, GetDeploymentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a paginated list of all versions for a component.</p>
    public func listComponentVersions(input: ListComponentVersionsInput, completion: @escaping (SdkResult<ListComponentVersionsOutputResponse, ListComponentVersionsOutputError>) -> Void)
    {
        guard let arn = input.arn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component arn unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/v2/components/\(arn)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listComponentVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListComponentVersionsInput, ListComponentVersionsOutputResponse, ListComponentVersionsOutputError>(id: "listComponentVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListComponentVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListComponentVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListComponentVersionsInput, ListComponentVersionsOutputResponse, ListComponentVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a paginated list of component summaries. This list includes components that you
    ///       have permission to view.</p>
    public func listComponents(input: ListComponentsInput, completion: @escaping (SdkResult<ListComponentsOutputResponse, ListComponentsOutputError>) -> Void)
    {
        let urlPath = "/greengrass/v2/components"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listComponents")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListComponentsInput, ListComponentsOutputResponse, ListComponentsOutputError>(id: "listComponents")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListComponentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListComponentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListComponentsInput, ListComponentsOutputResponse, ListComponentsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a paginated list of AWS IoT Greengrass core devices.</p>
    public func listCoreDevices(input: ListCoreDevicesInput, completion: @escaping (SdkResult<ListCoreDevicesOutputResponse, ListCoreDevicesOutputError>) -> Void)
    {
        let urlPath = "/greengrass/v2/coreDevices"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listCoreDevices")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListCoreDevicesInput, ListCoreDevicesOutputResponse, ListCoreDevicesOutputError>(id: "listCoreDevices")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListCoreDevicesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListCoreDevicesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListCoreDevicesInput, ListCoreDevicesOutputResponse, ListCoreDevicesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a paginated list of deployments.</p>
    public func listDeployments(input: ListDeploymentsInput, completion: @escaping (SdkResult<ListDeploymentsOutputResponse, ListDeploymentsOutputError>) -> Void)
    {
        let urlPath = "/greengrass/v2/deployments"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDeployments")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDeploymentsInput, ListDeploymentsOutputResponse, ListDeploymentsOutputError>(id: "listDeployments")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDeploymentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDeploymentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDeploymentsInput, ListDeploymentsOutputResponse, ListDeploymentsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a paginated list of deployment jobs that AWS IoT Greengrass sends to AWS IoT Greengrass core
    ///       devices.</p>
    public func listEffectiveDeployments(input: ListEffectiveDeploymentsInput, completion: @escaping (SdkResult<ListEffectiveDeploymentsOutputResponse, ListEffectiveDeploymentsOutputError>) -> Void)
    {
        guard let coreDeviceThingName = input.coreDeviceThingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component coreDeviceThingName unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/v2/coreDevices/\(coreDeviceThingName)/effectiveDeployments"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listEffectiveDeployments")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListEffectiveDeploymentsInput, ListEffectiveDeploymentsOutputResponse, ListEffectiveDeploymentsOutputError>(id: "listEffectiveDeployments")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListEffectiveDeploymentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListEffectiveDeploymentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListEffectiveDeploymentsInput, ListEffectiveDeploymentsOutputResponse, ListEffectiveDeploymentsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a paginated list of the components that a AWS IoT Greengrass core device runs.</p>
    public func listInstalledComponents(input: ListInstalledComponentsInput, completion: @escaping (SdkResult<ListInstalledComponentsOutputResponse, ListInstalledComponentsOutputError>) -> Void)
    {
        guard let coreDeviceThingName = input.coreDeviceThingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component coreDeviceThingName unexpectedly nil"))))
            return
        }
        let urlPath = "/greengrass/v2/coreDevices/\(coreDeviceThingName)/installedComponents"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listInstalledComponents")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListInstalledComponentsInput, ListInstalledComponentsOutputResponse, ListInstalledComponentsOutputError>(id: "listInstalledComponents")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListInstalledComponentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListInstalledComponentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListInstalledComponentsInput, ListInstalledComponentsOutputResponse, ListInstalledComponentsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the list of tags for an AWS IoT Greengrass resource.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of components that meet the component, version, and platform requirements
    ///       of a deployment. AWS IoT Greengrass core devices call this operation when they receive a deployment to
    ///       identify the components to install.</p>
    ///          <p>This operation identifies components that meet all dependency requirements for a
    ///       deployment. If the requirements conflict, then this operation returns an error and the
    ///       deployment fails. For example, this occurs if component <code>A</code> requires version
    ///         <code>>2.0.0</code> and component <code>B</code> requires version <code><2.0.0</code>
    ///       of a component dependency.</p>
    ///          <p>When you specify the component candidates to resolve, AWS IoT Greengrass compares each component's
    ///       digest from the core device with the component's digest in the AWS Cloud. If the digests don't
    ///       match, then AWS IoT Greengrass specifies to use the version from the AWS Cloud.</p>
    ///          <important>
    ///             <p>To use this operation, you must use the data plane API endpoint and authenticate with an
    ///         AWS IoT device certificate. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/greengrass.html">AWS IoT Greengrass endpoints and quotas</a>.</p>
    ///          </important>
    public func resolveComponentCandidates(input: ResolveComponentCandidatesInput, completion: @escaping (SdkResult<ResolveComponentCandidatesOutputResponse, ResolveComponentCandidatesOutputError>) -> Void)
    {
        let urlPath = "/greengrass/v2/resolveComponentCandidates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "resolveComponentCandidates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ResolveComponentCandidatesInput, ResolveComponentCandidatesOutputResponse, ResolveComponentCandidatesOutputError>(id: "resolveComponentCandidates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ResolveComponentCandidatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ResolveComponentCandidatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ResolveComponentCandidatesInput, ResolveComponentCandidatesOutputResponse, ResolveComponentCandidatesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ResolveComponentCandidatesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds tags to an AWS IoT Greengrass resource. If a tag already exists for the resource, this operation
    ///       updates the tag's value.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes a tag from an AWS IoT Greengrass resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "greengrass.\(config.region).amazonaws.com")
                      .withSigningName(value: "greengrass")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
