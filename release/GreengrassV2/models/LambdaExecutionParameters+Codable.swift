// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension LambdaExecutionParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentVariables
        case eventSources
        case execArgs
        case inputPayloadEncodingType
        case linuxProcessParams
        case maxIdleTimeInSeconds
        case maxInstancesCount
        case maxQueueSize
        case pinned
        case statusTimeoutInSeconds
        case timeoutInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, lambdaenvironmentvariables0) in environmentVariables {
                try environmentVariablesContainer.encode(lambdaenvironmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let eventSources = eventSources {
            var eventSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSources)
            for lambdaeventsourcelist0 in eventSources {
                try eventSourcesContainer.encode(lambdaeventsourcelist0)
            }
        }
        if let execArgs = execArgs {
            var execArgsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .execArgs)
            for lambdaexecargslist0 in execArgs {
                try execArgsContainer.encode(lambdaexecargslist0)
            }
        }
        if let inputPayloadEncodingType = inputPayloadEncodingType {
            try encodeContainer.encode(inputPayloadEncodingType.rawValue, forKey: .inputPayloadEncodingType)
        }
        if let linuxProcessParams = linuxProcessParams {
            try encodeContainer.encode(linuxProcessParams, forKey: .linuxProcessParams)
        }
        if maxIdleTimeInSeconds != 0 {
            try encodeContainer.encode(maxIdleTimeInSeconds, forKey: .maxIdleTimeInSeconds)
        }
        if maxInstancesCount != 0 {
            try encodeContainer.encode(maxInstancesCount, forKey: .maxInstancesCount)
        }
        if maxQueueSize != 0 {
            try encodeContainer.encode(maxQueueSize, forKey: .maxQueueSize)
        }
        if pinned != false {
            try encodeContainer.encode(pinned, forKey: .pinned)
        }
        if statusTimeoutInSeconds != 0 {
            try encodeContainer.encode(statusTimeoutInSeconds, forKey: .statusTimeoutInSeconds)
        }
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourcesContainer = try containerValues.decodeIfPresent([LambdaEventSource].self, forKey: .eventSources)
        var eventSourcesDecoded0:[LambdaEventSource]? = nil
        if let eventSourcesContainer = eventSourcesContainer {
            eventSourcesDecoded0 = [LambdaEventSource]()
            for structure0 in eventSourcesContainer {
                eventSourcesDecoded0?.append(structure0)
            }
        }
        eventSources = eventSourcesDecoded0
        let maxQueueSizeDecoded = try containerValues.decode(Int.self, forKey: .maxQueueSize)
        maxQueueSize = maxQueueSizeDecoded
        let maxInstancesCountDecoded = try containerValues.decode(Int.self, forKey: .maxInstancesCount)
        maxInstancesCount = maxInstancesCountDecoded
        let maxIdleTimeInSecondsDecoded = try containerValues.decode(Int.self, forKey: .maxIdleTimeInSeconds)
        maxIdleTimeInSeconds = maxIdleTimeInSecondsDecoded
        let timeoutInSecondsDecoded = try containerValues.decode(Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let statusTimeoutInSecondsDecoded = try containerValues.decode(Int.self, forKey: .statusTimeoutInSeconds)
        statusTimeoutInSeconds = statusTimeoutInSecondsDecoded
        let pinnedDecoded = try containerValues.decode(Bool.self, forKey: .pinned)
        pinned = pinnedDecoded
        let inputPayloadEncodingTypeDecoded = try containerValues.decodeIfPresent(LambdaInputPayloadEncodingType.self, forKey: .inputPayloadEncodingType)
        inputPayloadEncodingType = inputPayloadEncodingTypeDecoded
        let execArgsContainer = try containerValues.decodeIfPresent([String].self, forKey: .execArgs)
        var execArgsDecoded0:[String]? = nil
        if let execArgsContainer = execArgsContainer {
            execArgsDecoded0 = [String]()
            for string0 in execArgsContainer {
                execArgsDecoded0?.append(string0)
            }
        }
        execArgs = execArgsDecoded0
        let environmentVariablesContainer = try containerValues.decodeIfPresent([String:String].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [String:String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [String:String]()
            for (key0, string0) in environmentVariablesContainer {
                environmentVariablesDecoded0?[key0] = string0
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let linuxProcessParamsDecoded = try containerValues.decodeIfPresent(LambdaLinuxProcessParams.self, forKey: .linuxProcessParams)
        linuxProcessParams = linuxProcessParamsDecoded
    }
}
