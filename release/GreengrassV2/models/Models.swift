// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You don't have permission to perform the action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CancelDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelDeploymentInput(deploymentId: \(String(describing: deploymentId)))"}
}

extension CancelDeploymentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "CancelDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDeploymentInput>
    public typealias MOutput = OperationOutput<CancelDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDeploymentOutputError>
}

public struct CancelDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDeploymentInput>
    public typealias MOutput = OperationOutput<CancelDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDeploymentOutputError>
}

public struct CancelDeploymentInput: Equatable {
    /// <p>The ID of the deployment.</p>
    public let deploymentId: String?

    public init (
        deploymentId: String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct CancelDeploymentInputBody: Equatable {
}

extension CancelDeploymentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelDeploymentOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelDeploymentOutputResponse(message: \(String(describing: message)))"}
}

extension CancelDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct CancelDeploymentOutputResponse: Equatable {
    /// <p>A message that communicates if the cancel was successful.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CancelDeploymentOutputResponseBody: Equatable {
    public let message: String?
}

extension CancelDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum CloudComponentState {
    case deployable
    case deprecated
    case failed
    case initiated
    case requested
    case sdkUnknown(String)
}

extension CloudComponentState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CloudComponentState] {
        return [
            .deployable,
            .deprecated,
            .failed,
            .initiated,
            .requested,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deployable: return "DEPLOYABLE"
        case .deprecated: return "DEPRECATED"
        case .failed: return "FAILED"
        case .initiated: return "INITIATED"
        case .requested: return "REQUESTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CloudComponentState(rawValue: rawValue) ?? CloudComponentState.sdkUnknown(rawValue)
    }
}

extension CloudComponentStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentState
        case errors
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentState = componentState {
            try encodeContainer.encode(componentState.rawValue, forKey: .componentState)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .errors)
            for (dictKey0, stringmap0) in errors {
                try errorsContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentStateDecoded = try containerValues.decodeIfPresent(CloudComponentState.self, forKey: .componentState)
        componentState = componentStateDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .errors)
        var errorsDecoded0: [String:String]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [String:String]()
            for (key0, nonemptystring0) in errorsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    errorsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension CloudComponentStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudComponentStatus(componentState: \(String(describing: componentState)), errors: \(String(describing: errors)), message: \(String(describing: message)))"}
}

/// <p>Contains the status of a component in the AWS IoT Greengrass service.</p>
public struct CloudComponentStatus: Equatable {
    /// <p>The state of the component.</p>
    public let componentState: CloudComponentState?
    /// <p>A dictionary of errors that communicate why the component is in an error state. For
    ///       example, if AWS IoT Greengrass can't access an artifact for the component, then <code>errors</code> contains
    ///       the artifact's URI as a key, and the error message as the value for that key.</p>
    public let errors: [String:String]?
    /// <p>A message that communicates details, such as errors, about the status of the component.</p>
    public let message: String?

    public init (
        componentState: CloudComponentState? = nil,
        errors: [String:String]? = nil,
        message: String? = nil
    )
    {
        self.componentState = componentState
        self.errors = errors
        self.message = message
    }
}

extension Component: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case componentName
        case latestVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let latestVersion = latestVersion {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(ComponentLatestVersion.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
    }
}

extension Component: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Component(arn: \(String(describing: arn)), componentName: \(String(describing: componentName)), latestVersion: \(String(describing: latestVersion)))"}
}

/// <p>Contains information about a component.</p>
public struct Component: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the component version.</p>
    public let arn: String?
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The latest version of the component and its details.</p>
    public let latestVersion: ComponentLatestVersion?

    public init (
        arn: String? = nil,
        componentName: String? = nil,
        latestVersion: ComponentLatestVersion? = nil
    )
    {
        self.arn = arn
        self.componentName = componentName
        self.latestVersion = latestVersion
    }
}

extension ComponentCandidate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentName
        case componentVersion
        case versionRequirements
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let versionRequirements = versionRequirements {
            var versionRequirementsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .versionRequirements)
            for (dictKey0, componentversionrequirementmap0) in versionRequirements {
                try versionRequirementsContainer.encode(componentversionrequirementmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let versionRequirementsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .versionRequirements)
        var versionRequirementsDecoded0: [String:String]? = nil
        if let versionRequirementsContainer = versionRequirementsContainer {
            versionRequirementsDecoded0 = [String:String]()
            for (key0, nonemptystring0) in versionRequirementsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    versionRequirementsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        versionRequirements = versionRequirementsDecoded0
    }
}

extension ComponentCandidate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComponentCandidate(componentName: \(String(describing: componentName)), componentVersion: \(String(describing: componentVersion)), versionRequirements: \(String(describing: versionRequirements)))"}
}

/// <p>Contains information about a component that is a candidate to deploy to a AWS IoT Greengrass core
///       device.</p>
public struct ComponentCandidate: Equatable {
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The version of the component.</p>
    public let componentVersion: String?
    /// <p>The version requirements for the component's dependencies. AWS IoT Greengrass core devices get the
    ///       version requirements from component recipes.</p>
    ///          <p>AWS IoT Greengrass V2 uses semantic version constraints. For more information, see <a href="https://semver.org/">Semantic Versioning</a>.</p>
    public let versionRequirements: [String:String]?

    public init (
        componentName: String? = nil,
        componentVersion: String? = nil,
        versionRequirements: [String:String]? = nil
    )
    {
        self.componentName = componentName
        self.componentVersion = componentVersion
        self.versionRequirements = versionRequirements
    }
}

extension ComponentConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case merge
        case reset
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let merge = merge {
            try encodeContainer.encode(merge, forKey: .merge)
        }
        if let reset = reset {
            var resetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reset)
            for componentconfigurationpathlist0 in reset {
                try resetContainer.encode(componentconfigurationpathlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .merge)
        merge = mergeDecoded
        let resetContainer = try containerValues.decodeIfPresent([String?].self, forKey: .reset)
        var resetDecoded0:[String]? = nil
        if let resetContainer = resetContainer {
            resetDecoded0 = [String]()
            for string0 in resetContainer {
                if let string0 = string0 {
                    resetDecoded0?.append(string0)
                }
            }
        }
        reset = resetDecoded0
    }
}

extension ComponentConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComponentConfigurationUpdate(merge: \(String(describing: merge)), reset: \(String(describing: reset)))"}
}

/// <p>Contains information about a deployment's update to a component's configuration on
///       Greengrass core devices. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html">Update component
///         configurations</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
public struct ComponentConfigurationUpdate: Equatable {
    /// <p>A serialized JSON string that contains the configuration object to merge to target
    ///       devices. The core device merges this configuration with the component's existing
    ///       configuration. If this is the first time a component deploys on a device, the core device
    ///       merges this configuration with the component's default configuration. This means that the core
    ///       device keeps it's existing configuration for keys and values that you don't specify in this
    ///       object. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html#merge-configuration-update">Merge configuration updates</a> in the <i>AWS IoT Greengrass V2 Developer
    ///           Guide</i>.</p>
    public let merge: String?
    /// <p>The list of configuration nodes to reset to default values on target devices. Use JSON
    ///       pointers to specify each node to reset. JSON pointers start with a forward slash
    ///       (<code>/</code>) and use forward slashes to separate the key for each level in the object.
    ///       For more information, see the <a href="https://tools.ietf.org/html/rfc6901">JSON pointer
    ///         specification</a> and <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html#reset-configuration-update">Reset configuration updates</a> in the <i>AWS IoT Greengrass V2 Developer
    ///             Guide</i>.</p>
    public let reset: [String]?

    public init (
        merge: String? = nil,
        reset: [String]? = nil
    )
    {
        self.merge = merge
        self.reset = reset
    }
}

extension ComponentDependencyRequirement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dependencyType
        case versionRequirement
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependencyType = dependencyType {
            try encodeContainer.encode(dependencyType.rawValue, forKey: .dependencyType)
        }
        if let versionRequirement = versionRequirement {
            try encodeContainer.encode(versionRequirement, forKey: .versionRequirement)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionRequirementDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionRequirement)
        versionRequirement = versionRequirementDecoded
        let dependencyTypeDecoded = try containerValues.decodeIfPresent(ComponentDependencyType.self, forKey: .dependencyType)
        dependencyType = dependencyTypeDecoded
    }
}

extension ComponentDependencyRequirement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComponentDependencyRequirement(dependencyType: \(String(describing: dependencyType)), versionRequirement: \(String(describing: versionRequirement)))"}
}

/// <p>Contains information about a component dependency for a Lambda function component.</p>
public struct ComponentDependencyRequirement: Equatable {
    /// <p>The type of this dependency. Choose from the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SOFT</code> – The component doesn't restart if the dependency changes
    ///           state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HARD</code> – The component restarts if the dependency changes
    ///           state.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Default: <code>HARD</code>
    ///          </p>
    public let dependencyType: ComponentDependencyType?
    /// <p>The component version requirement for the component dependency.</p>
    ///          <p>AWS IoT Greengrass V2 uses semantic version constraints. For more information, see <a href="https://semver.org/">Semantic Versioning</a>.</p>
    public let versionRequirement: String?

    public init (
        dependencyType: ComponentDependencyType? = nil,
        versionRequirement: String? = nil
    )
    {
        self.dependencyType = dependencyType
        self.versionRequirement = versionRequirement
    }
}

public enum ComponentDependencyType {
    case hard
    case soft
    case sdkUnknown(String)
}

extension ComponentDependencyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComponentDependencyType] {
        return [
            .hard,
            .soft,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hard: return "HARD"
        case .soft: return "SOFT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComponentDependencyType(rawValue: rawValue) ?? ComponentDependencyType.sdkUnknown(rawValue)
    }
}

extension ComponentDeploymentSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentVersion
        case configurationUpdate
        case runWith
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let configurationUpdate = configurationUpdate {
            try encodeContainer.encode(configurationUpdate, forKey: .configurationUpdate)
        }
        if let runWith = runWith {
            try encodeContainer.encode(runWith, forKey: .runWith)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let configurationUpdateDecoded = try containerValues.decodeIfPresent(ComponentConfigurationUpdate.self, forKey: .configurationUpdate)
        configurationUpdate = configurationUpdateDecoded
        let runWithDecoded = try containerValues.decodeIfPresent(ComponentRunWith.self, forKey: .runWith)
        runWith = runWithDecoded
    }
}

extension ComponentDeploymentSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComponentDeploymentSpecification(componentVersion: \(String(describing: componentVersion)), configurationUpdate: \(String(describing: configurationUpdate)), runWith: \(String(describing: runWith)))"}
}

/// <p>Contains information about a component to deploy.</p>
public struct ComponentDeploymentSpecification: Equatable {
    /// <p>The version of the component.</p>
    public let componentVersion: String?
    /// <p>The configuration updates to deploy for the component. You can define
    ///       <i>reset</i> updates and <i>merge</i> updates. A reset updates
    ///       the keys that you specify to the default configuration for the component. A merge updates the
    ///       core device's component configuration with the keys and values that you specify. The AWS IoT Greengrass Core
    ///       software applies reset updates before it applies merge updates. For more information, see
    ///       <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html">Update component
    ///         configurations</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    public let configurationUpdate: ComponentConfigurationUpdate?
    /// <p>The system user and group that the AWS IoT Greengrass Core software uses to run component processes on the
    ///       core device. If you omit this parameter, the AWS IoT Greengrass Core software uses the system user and group
    ///       that you configure for the core device. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user">Configure the user and group that run components</a> in the <i>AWS IoT Greengrass V2 Developer
    ///         Guide</i>.</p>
    public let runWith: ComponentRunWith?

    public init (
        componentVersion: String? = nil,
        configurationUpdate: ComponentConfigurationUpdate? = nil,
        runWith: ComponentRunWith? = nil
    )
    {
        self.componentVersion = componentVersion
        self.configurationUpdate = configurationUpdate
        self.runWith = runWith
    }
}

extension ComponentLatestVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case componentVersion
        case creationTimestamp
        case description
        case platforms
        case publisher
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let platforms = platforms {
            var platformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platforms)
            for componentplatformlist0 in platforms {
                try platformsContainer.encode(componentplatformlist0)
            }
        }
        if let publisher = publisher {
            try encodeContainer.encode(publisher, forKey: .publisher)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let publisherDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publisher)
        publisher = publisherDecoded
        let platformsContainer = try containerValues.decodeIfPresent([ComponentPlatform?].self, forKey: .platforms)
        var platformsDecoded0:[ComponentPlatform]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [ComponentPlatform]()
            for structure0 in platformsContainer {
                if let structure0 = structure0 {
                    platformsDecoded0?.append(structure0)
                }
            }
        }
        platforms = platformsDecoded0
    }
}

extension ComponentLatestVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComponentLatestVersion(arn: \(String(describing: arn)), componentVersion: \(String(describing: componentVersion)), creationTimestamp: \(String(describing: creationTimestamp)), description: \(String(describing: description)), platforms: \(String(describing: platforms)), publisher: \(String(describing: publisher)))"}
}

/// <p>Contains information about the latest version of a component.</p>
public struct ComponentLatestVersion: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the component version.</p>
    public let arn: String?
    /// <p>The version of the component.</p>
    public let componentVersion: String?
    /// <p>The time at which the component was created, expressed in ISO 8601 format.</p>
    public let creationTimestamp: Date?
    /// <p>The description of the component version.</p>
    public let description: String?
    /// <p>The platforms that the component version supports.</p>
    public let platforms: [ComponentPlatform]?
    /// <p>The publisher of the component version.</p>
    public let publisher: String?

    public init (
        arn: String? = nil,
        componentVersion: String? = nil,
        creationTimestamp: Date? = nil,
        description: String? = nil,
        platforms: [ComponentPlatform]? = nil,
        publisher: String? = nil
    )
    {
        self.arn = arn
        self.componentVersion = componentVersion
        self.creationTimestamp = creationTimestamp
        self.description = description
        self.platforms = platforms
        self.publisher = publisher
    }
}

extension ComponentPlatform: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, platformattributesmap0) in attributes {
                try attributesContainer.encode(platformattributesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, nonemptystring0) in attributesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    attributesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ComponentPlatform: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComponentPlatform(attributes: \(String(describing: attributes)), name: \(String(describing: name)))"}
}

/// <p>Contains information about a platform that a component supports.</p>
public struct ComponentPlatform: Equatable {
    /// <p>A dictionary of attributes for the platform. The AWS IoT Greengrass Core software defines the
    ///         <code>os</code> and <code>platform</code> by default. You can specify additional platform
    ///       attributes for a core device when you deploy the AWS IoT Greengrass nucleus component. For more information,
    ///       see the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/greengrass-nucleus-component.html">AWS IoT Greengrass nucleus
    ///         component</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    public let attributes: [String:String]?
    /// <p>The friendly name of the platform. This name helps you identify the platform.</p>
    ///          <p>If you omit this parameter, AWS IoT Greengrass creates a friendly name from the <code>os</code> and
    ///         <code>architecture</code> of the platform.</p>
    public let name: String?

    public init (
        attributes: [String:String]? = nil,
        name: String? = nil
    )
    {
        self.attributes = attributes
        self.name = name
    }
}

extension ComponentRunWith: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case posixUser
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let posixUser = posixUser {
            try encodeContainer.encode(posixUser, forKey: .posixUser)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let posixUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .posixUser)
        posixUser = posixUserDecoded
    }
}

extension ComponentRunWith: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComponentRunWith(posixUser: \(String(describing: posixUser)))"}
}

/// <p>Contains information system user and group that the AWS IoT Greengrass Core software uses to run component
///       processes on the core device. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user">Configure the user and group that run components</a> in the <i>AWS IoT Greengrass V2 Developer
///         Guide</i>.</p>
public struct ComponentRunWith: Equatable {
    /// <p>The POSIX system user and (optional) group to use to run this component. Specify the user
    ///       and group separated by a colon (<code>:</code>) in the following format:
    ///         <code>user:group</code>. The group is optional. If you don't specify a group, the AWS IoT Greengrass Core
    ///       software uses the primary user for the group.</p>
    public let posixUser: String?

    public init (
        posixUser: String? = nil
    )
    {
        self.posixUser = posixUser
    }
}

extension ComponentVersionListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case componentName
        case componentVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ComponentVersionListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComponentVersionListItem(arn: \(String(describing: arn)), componentName: \(String(describing: componentName)), componentVersion: \(String(describing: componentVersion)))"}
}

/// <p>Contains information about a component version in a list.</p>
public struct ComponentVersionListItem: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the component version.</p>
    public let arn: String?
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The version of the component.</p>
    public let componentVersion: String?

    public init (
        arn: String? = nil,
        componentName: String? = nil,
        componentVersion: String? = nil
    )
    {
        self.arn = arn
        self.componentName = componentName
        self.componentVersion = componentVersion
    }
}

public enum ComponentVisibilityScope {
    case `private`
    case `public`
    case sdkUnknown(String)
}

extension ComponentVisibilityScope : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComponentVisibilityScope] {
        return [
            .private,
            .public,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .private: return "PRIVATE"
        case .public: return "PUBLIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComponentVisibilityScope(rawValue: rawValue) ?? ComponentVisibilityScope.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request has conflicting operations. This can occur if you're trying to perform more
///       than one operation on the same resource at the same time.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ID of the resource that conflicts with the request.</p>
    public var resourceId: String?
    /// <p>The type of the resource that conflicts with the request.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CoreDevice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case coreDeviceThingName
        case lastStatusUpdateTimestamp
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreDeviceThingName = coreDeviceThingName {
            try encodeContainer.encode(coreDeviceThingName, forKey: .coreDeviceThingName)
        }
        if let lastStatusUpdateTimestamp = lastStatusUpdateTimestamp {
            try encodeContainer.encode(lastStatusUpdateTimestamp.timeIntervalSince1970, forKey: .lastStatusUpdateTimestamp)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreDeviceThingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .coreDeviceThingName)
        coreDeviceThingName = coreDeviceThingNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CoreDeviceStatus.self, forKey: .status)
        status = statusDecoded
        let lastStatusUpdateTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStatusUpdateTimestamp)
        lastStatusUpdateTimestamp = lastStatusUpdateTimestampDecoded
    }
}

extension CoreDevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CoreDevice(coreDeviceThingName: \(String(describing: coreDeviceThingName)), lastStatusUpdateTimestamp: \(String(describing: lastStatusUpdateTimestamp)), status: \(String(describing: status)))"}
}

/// <p>Contains information about a AWS IoT Greengrass core device, which is an AWS IoT thing that runs the AWS IoT Greengrass
///       Core software.</p>
public struct CoreDevice: Equatable {
    /// <p>The name of the core device. This is also the name of the AWS IoT thing.</p>
    public let coreDeviceThingName: String?
    /// <p>The time at which the core device's status last updated, expressed in ISO 8601
    ///       format.</p>
    public let lastStatusUpdateTimestamp: Date?
    /// <p>The status of the core device. Core devices can have the following statuses:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HEALTHY</code> – The AWS IoT Greengrass Core software and all components run on the core device without issue.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNHEALTHY</code> – The AWS IoT Greengrass Core software or a component is in a failed state
    ///           on the core device.</p>
    ///             </li>
    ///          </ul>
    public let status: CoreDeviceStatus?

    public init (
        coreDeviceThingName: String? = nil,
        lastStatusUpdateTimestamp: Date? = nil,
        status: CoreDeviceStatus? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.lastStatusUpdateTimestamp = lastStatusUpdateTimestamp
        self.status = status
    }
}

public enum CoreDeviceStatus {
    case healthy
    case unhealthy
    case sdkUnknown(String)
}

extension CoreDeviceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CoreDeviceStatus] {
        return [
            .healthy,
            .unhealthy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .healthy: return "HEALTHY"
        case .unhealthy: return "UNHEALTHY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CoreDeviceStatus(rawValue: rawValue) ?? CoreDeviceStatus.sdkUnknown(rawValue)
    }
}

public struct CreateComponentVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateComponentVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateComponentVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateComponentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateComponentVersionInput>
    public typealias MOutput = OperationOutput<CreateComponentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateComponentVersionOutputError>
}

extension CreateComponentVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateComponentVersionInput(inlineRecipe: \(String(describing: inlineRecipe)), lambdaFunction: \(String(describing: lambdaFunction)), tags: \(String(describing: tags)))"}
}

extension CreateComponentVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inlineRecipe
        case lambdaFunction
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inlineRecipe = inlineRecipe {
            try encodeContainer.encode(inlineRecipe.base64EncodedString(), forKey: .inlineRecipe)
        }
        if let lambdaFunction = lambdaFunction {
            try encodeContainer.encode(lambdaFunction, forKey: .lambdaFunction)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateComponentVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateComponentVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateComponentVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateComponentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateComponentVersionInput>
    public typealias MOutput = OperationOutput<CreateComponentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateComponentVersionOutputError>
}

public struct CreateComponentVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateComponentVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateComponentVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateComponentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateComponentVersionInput>
    public typealias MOutput = OperationOutput<CreateComponentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateComponentVersionOutputError>
}

public struct CreateComponentVersionInput: Equatable {
    /// <p>The recipe to use to create the component. The recipe defines the component's metadata,
    ///       parameters, dependencies, lifecycle, artifacts, and platform compatibility.</p>
    ///          <p>You must specify either <code>inlineRecipe</code> or <code>lambdaFunction</code>.</p>
    public let inlineRecipe: Data?
    /// <p>The parameters to create a component from a Lambda function.</p>
    ///          <p>You must specify either <code>inlineRecipe</code> or <code>lambdaFunction</code>.</p>
    public let lambdaFunction: LambdaFunctionRecipeSource?
    /// <p>A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        inlineRecipe: Data? = nil,
        lambdaFunction: LambdaFunctionRecipeSource? = nil,
        tags: [String:String]? = nil
    )
    {
        self.inlineRecipe = inlineRecipe
        self.lambdaFunction = lambdaFunction
        self.tags = tags
    }
}

struct CreateComponentVersionInputBody: Equatable {
    public let inlineRecipe: Data?
    public let lambdaFunction: LambdaFunctionRecipeSource?
    public let tags: [String:String]?
}

extension CreateComponentVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inlineRecipe
        case lambdaFunction
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlineRecipeDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .inlineRecipe)
        inlineRecipe = inlineRecipeDecoded
        let lambdaFunctionDecoded = try containerValues.decodeIfPresent(LambdaFunctionRecipeSource.self, forKey: .lambdaFunction)
        lambdaFunction = lambdaFunctionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateComponentVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateComponentVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateComponentVersionOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateComponentVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateComponentVersionOutputResponse(arn: \(String(describing: arn)), componentName: \(String(describing: componentName)), componentVersion: \(String(describing: componentVersion)), creationTimestamp: \(String(describing: creationTimestamp)), status: \(String(describing: status)))"}
}

extension CreateComponentVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateComponentVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.componentName = output.componentName
            self.componentVersion = output.componentVersion
            self.creationTimestamp = output.creationTimestamp
            self.status = output.status
        } else {
            self.arn = nil
            self.componentName = nil
            self.componentVersion = nil
            self.creationTimestamp = nil
            self.status = nil
        }
    }
}

public struct CreateComponentVersionOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the component version.</p>
    public let arn: String?
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The version of the component.</p>
    public let componentVersion: String?
    /// <p>The time at which the component was created, expressed in ISO 8601 format.</p>
    public let creationTimestamp: Date?
    /// <p>The status of the component version in AWS IoT Greengrass V2. This status
    ///       is different from the status of the component on a core device.</p>
    public let status: CloudComponentStatus?

    public init (
        arn: String? = nil,
        componentName: String? = nil,
        componentVersion: String? = nil,
        creationTimestamp: Date? = nil,
        status: CloudComponentStatus? = nil
    )
    {
        self.arn = arn
        self.componentName = componentName
        self.componentVersion = componentVersion
        self.creationTimestamp = creationTimestamp
        self.status = status
    }
}

struct CreateComponentVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let componentName: String?
    public let componentVersion: String?
    public let creationTimestamp: Date?
    public let status: CloudComponentStatus?
}

extension CreateComponentVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case componentName
        case componentVersion
        case creationTimestamp
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudComponentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateDeploymentInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

extension CreateDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentInput(components: \(String(describing: components)), deploymentName: \(String(describing: deploymentName)), deploymentPolicies: \(String(describing: deploymentPolicies)), iotJobConfiguration: \(String(describing: iotJobConfiguration)), tags: \(String(describing: tags)), targetArn: \(String(describing: targetArn)))"}
}

extension CreateDeploymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case components
        case deploymentName
        case deploymentPolicies
        case iotJobConfiguration
        case tags
        case targetArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let components = components {
            var componentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .components)
            for (dictKey0, componentdeploymentspecifications0) in components {
                try componentsContainer.encode(componentdeploymentspecifications0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let deploymentName = deploymentName {
            try encodeContainer.encode(deploymentName, forKey: .deploymentName)
        }
        if let deploymentPolicies = deploymentPolicies {
            try encodeContainer.encode(deploymentPolicies, forKey: .deploymentPolicies)
        }
        if let iotJobConfiguration = iotJobConfiguration {
            try encodeContainer.encode(iotJobConfiguration, forKey: .iotJobConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

public struct CreateDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInput: Equatable {
    /// <p>The components to deploy. This is a dictionary, where each key is the name of a component,
    ///         and each key's value is the version and configuration to deploy for that component.</p>
    public let components: [String:ComponentDeploymentSpecification]?
    /// <p>The name of the deployment.</p>
    ///          <p>You can create deployments without names. If you create a deployment without a name, the
    ///       AWS IoT Greengrass V2 console shows the deployment name as <code><targetType>:<targetName></code>,
    ///       where <code>targetType</code> and <code>targetName</code> are the type and name of the
    ///       deployment target.</p>
    public let deploymentName: String?
    /// <p>The deployment policies for the deployment. These policies define how the deployment
    ///       updates components and handles failure.</p>
    public let deploymentPolicies: DeploymentPolicies?
    /// <p>The job configuration for the deployment configuration. The job configuration specifies
    ///       the rollout, timeout, and stop configurations for the deployment configuration.</p>
    public let iotJobConfiguration: DeploymentIoTJobConfiguration?
    /// <p>A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    public let tags: [String:String]?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the target AWS IoT thing or thing group.</p>
    public let targetArn: String?

    public init (
        components: [String:ComponentDeploymentSpecification]? = nil,
        deploymentName: String? = nil,
        deploymentPolicies: DeploymentPolicies? = nil,
        iotJobConfiguration: DeploymentIoTJobConfiguration? = nil,
        tags: [String:String]? = nil,
        targetArn: String? = nil
    )
    {
        self.components = components
        self.deploymentName = deploymentName
        self.deploymentPolicies = deploymentPolicies
        self.iotJobConfiguration = iotJobConfiguration
        self.tags = tags
        self.targetArn = targetArn
    }
}

struct CreateDeploymentInputBody: Equatable {
    public let targetArn: String?
    public let deploymentName: String?
    public let components: [String:ComponentDeploymentSpecification]?
    public let iotJobConfiguration: DeploymentIoTJobConfiguration?
    public let deploymentPolicies: DeploymentPolicies?
    public let tags: [String:String]?
}

extension CreateDeploymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case components
        case deploymentName
        case deploymentPolicies
        case iotJobConfiguration
        case tags
        case targetArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let deploymentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let componentsContainer = try containerValues.decodeIfPresent([String: ComponentDeploymentSpecification?].self, forKey: .components)
        var componentsDecoded0: [String:ComponentDeploymentSpecification]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [String:ComponentDeploymentSpecification]()
            for (key0, componentdeploymentspecification0) in componentsContainer {
                if let componentdeploymentspecification0 = componentdeploymentspecification0 {
                    componentsDecoded0?[key0] = componentdeploymentspecification0
                }
            }
        }
        components = componentsDecoded0
        let iotJobConfigurationDecoded = try containerValues.decodeIfPresent(DeploymentIoTJobConfiguration.self, forKey: .iotJobConfiguration)
        iotJobConfiguration = iotJobConfigurationDecoded
        let deploymentPoliciesDecoded = try containerValues.decodeIfPresent(DeploymentPolicies.self, forKey: .deploymentPolicies)
        deploymentPolicies = deploymentPoliciesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentOutputResponse(deploymentId: \(String(describing: deploymentId)), iotJobArn: \(String(describing: iotJobArn)), iotJobId: \(String(describing: iotJobId)))"}
}

extension CreateDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentId = output.deploymentId
            self.iotJobArn = output.iotJobArn
            self.iotJobId = output.iotJobId
        } else {
            self.deploymentId = nil
            self.iotJobArn = nil
            self.iotJobId = nil
        }
    }
}

public struct CreateDeploymentOutputResponse: Equatable {
    /// <p>The ID of the deployment.</p>
    public let deploymentId: String?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the AWS IoT job that applies the deployment to target devices.</p>
    public let iotJobArn: String?
    /// <p>The ID of the AWS IoT job that applies the deployment to target devices.</p>
    public let iotJobId: String?

    public init (
        deploymentId: String? = nil,
        iotJobArn: String? = nil,
        iotJobId: String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.iotJobArn = iotJobArn
        self.iotJobId = iotJobId
    }
}

struct CreateDeploymentOutputResponseBody: Equatable {
    public let deploymentId: String?
    public let iotJobId: String?
    public let iotJobArn: String?
}

extension CreateDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentId
        case iotJobArn
        case iotJobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let iotJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iotJobId)
        iotJobId = iotJobIdDecoded
        let iotJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iotJobArn)
        iotJobArn = iotJobArnDecoded
    }
}

extension DeleteComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteComponentInput(arn: \(String(describing: arn)))"}
}

extension DeleteComponentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteComponentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteComponentInput>
    public typealias MOutput = OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteComponentInput>
    public typealias MOutput = OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the component version.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteComponentInputBody: Equatable {
}

extension DeleteComponentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteComponentOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteComponentOutputResponse()"}
}

extension DeleteComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteComponentOutputResponse: Equatable {

    public init() {}
}

struct DeleteComponentOutputResponseBody: Equatable {
}

extension DeleteComponentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCoreDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCoreDeviceInput(coreDeviceThingName: \(String(describing: coreDeviceThingName)))"}
}

extension DeleteCoreDeviceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCoreDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCoreDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCoreDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCoreDeviceInput>
    public typealias MOutput = OperationOutput<DeleteCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCoreDeviceOutputError>
}

public struct DeleteCoreDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCoreDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCoreDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCoreDeviceInput>
    public typealias MOutput = OperationOutput<DeleteCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCoreDeviceOutputError>
}

public struct DeleteCoreDeviceInput: Equatable {
    /// <p>The name of the core device. This is also the name of the AWS IoT thing.</p>
    public let coreDeviceThingName: String?

    public init (
        coreDeviceThingName: String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
    }
}

struct DeleteCoreDeviceInputBody: Equatable {
}

extension DeleteCoreDeviceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCoreDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCoreDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCoreDeviceOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCoreDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCoreDeviceOutputResponse()"}
}

extension DeleteCoreDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCoreDeviceOutputResponse: Equatable {

    public init() {}
}

struct DeleteCoreDeviceOutputResponseBody: Equatable {
}

extension DeleteCoreDeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Deployment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTimestamp
        case deploymentId
        case deploymentName
        case deploymentStatus
        case isLatestForTarget
        case revisionId
        case targetArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentName = deploymentName {
            try encodeContainer.encode(deploymentName, forKey: .deploymentName)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if isLatestForTarget != false {
            try encodeContainer.encode(isLatestForTarget, forKey: .isLatestForTarget)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let isLatestForTargetDecoded = try containerValues.decode(Bool.self, forKey: .isLatestForTarget)
        isLatestForTarget = isLatestForTargetDecoded
    }
}

extension Deployment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Deployment(creationTimestamp: \(String(describing: creationTimestamp)), deploymentId: \(String(describing: deploymentId)), deploymentName: \(String(describing: deploymentName)), deploymentStatus: \(String(describing: deploymentStatus)), isLatestForTarget: \(String(describing: isLatestForTarget)), revisionId: \(String(describing: revisionId)), targetArn: \(String(describing: targetArn)))"}
}

/// <p>Contains information about a deployment.</p>
public struct Deployment: Equatable {
    /// <p>The time at which the deployment was created, expressed in ISO 8601 format.</p>
    public let creationTimestamp: Date?
    /// <p>The ID of the deployment.</p>
    public let deploymentId: String?
    /// <p>The name of the deployment.</p>
    ///          <p>You can create deployments without names. If you create a deployment without a name, the
    ///       AWS IoT Greengrass V2 console shows the deployment name as <code><targetType>:<targetName></code>,
    ///       where <code>targetType</code> and <code>targetName</code> are the type and name of the
    ///       deployment target.</p>
    public let deploymentName: String?
    /// <p>The status of the deployment.</p>
    public let deploymentStatus: DeploymentStatus?
    /// <p>Whether or not the deployment is the latest revision for its target.</p>
    public let isLatestForTarget: Bool
    /// <p>The revision number of the deployment.</p>
    public let revisionId: String?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the target AWS IoT thing or thing group.</p>
    public let targetArn: String?

    public init (
        creationTimestamp: Date? = nil,
        deploymentId: String? = nil,
        deploymentName: String? = nil,
        deploymentStatus: DeploymentStatus? = nil,
        isLatestForTarget: Bool = false,
        revisionId: String? = nil,
        targetArn: String? = nil
    )
    {
        self.creationTimestamp = creationTimestamp
        self.deploymentId = deploymentId
        self.deploymentName = deploymentName
        self.deploymentStatus = deploymentStatus
        self.isLatestForTarget = isLatestForTarget
        self.revisionId = revisionId
        self.targetArn = targetArn
    }
}

extension DeploymentComponentUpdatePolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case timeoutInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decode(Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let actionDecoded = try containerValues.decodeIfPresent(DeploymentComponentUpdatePolicyAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension DeploymentComponentUpdatePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentComponentUpdatePolicy(action: \(String(describing: action)), timeoutInSeconds: \(String(describing: timeoutInSeconds)))"}
}

/// <p>Contains information about a deployment's policy that defines when components are safe to
///       update.</p>
///          <p>Each component on a device can report whether or not it's ready to update. After a
///       component and its dependencies are ready, they can apply the update in the deployment. You can
///       configure whether or not the deployment notifies components of an update and waits for a
///       response. You specify the amount of time each component has to respond to the update
///       notification.</p>
public struct DeploymentComponentUpdatePolicy: Equatable {
    /// <p>Whether or not to notify components and wait for components to become safe to update.
    ///       Choose from the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NOTIFY_COMPONENTS</code> – The deployment notifies each component before
    ///           it stops and updates that component. Components can use the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-subscribetocomponentupdates">SubscribeToComponentUpdates</a> IPC operation to receive these notifications. Then,
    ///           components can respond with the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-defercomponentupdate">DeferComponentUpdate</a> IPC operation. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/create-deployments.html">Create deployments</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SKIP_NOTIFY_COMPONENTS</code> – The deployment doesn't notify components
    ///           or wait for them to be safe to update.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Default: <code>NOTIFY_COMPONENTS</code>
    ///          </p>
    public let action: DeploymentComponentUpdatePolicyAction?
    /// <p>The amount of time in seconds that each component on a device has to report that it's safe
    ///       to update. If the component waits for longer than this timeout, then the deployment proceeds
    ///       on the device.</p>
    ///          <p>Default: <code>60</code>
    ///          </p>
    public let timeoutInSeconds: Int

    public init (
        action: DeploymentComponentUpdatePolicyAction? = nil,
        timeoutInSeconds: Int = 0
    )
    {
        self.action = action
        self.timeoutInSeconds = timeoutInSeconds
    }
}

public enum DeploymentComponentUpdatePolicyAction {
    case notifyComponents
    case skipNotifyComponents
    case sdkUnknown(String)
}

extension DeploymentComponentUpdatePolicyAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentComponentUpdatePolicyAction] {
        return [
            .notifyComponents,
            .skipNotifyComponents,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notifyComponents: return "NOTIFY_COMPONENTS"
        case .skipNotifyComponents: return "SKIP_NOTIFY_COMPONENTS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentComponentUpdatePolicyAction(rawValue: rawValue) ?? DeploymentComponentUpdatePolicyAction.sdkUnknown(rawValue)
    }
}

extension DeploymentConfigurationValidationPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timeoutInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decode(Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
    }
}

extension DeploymentConfigurationValidationPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentConfigurationValidationPolicy(timeoutInSeconds: \(String(describing: timeoutInSeconds)))"}
}

/// <p>Contains information about how long a component on a core device can validate its
///       configuration updates before it times out. Components can use the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-subscribetovalidateconfigurationupdates">SubscribeToValidateConfigurationUpdates</a> IPC operation to receive notifications when
///       a deployment specifies a configuration update. Then, components can respond with the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-sendconfigurationvalidityreport">SendConfigurationValidityReport</a> IPC operation. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/create-deployments.html">Create deployments</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
public struct DeploymentConfigurationValidationPolicy: Equatable {
    /// <p>The amount of time in seconds that a component can validate its configuration updates. If
    ///       the validation time exceeds this timeout, then the deployment proceeds for the device.</p>
    ///          <p>Default: <code>30</code>
    ///          </p>
    public let timeoutInSeconds: Int

    public init (
        timeoutInSeconds: Int = 0
    )
    {
        self.timeoutInSeconds = timeoutInSeconds
    }
}

public enum DeploymentFailureHandlingPolicy {
    case doNothing
    case rollback
    case sdkUnknown(String)
}

extension DeploymentFailureHandlingPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentFailureHandlingPolicy] {
        return [
            .doNothing,
            .rollback,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .doNothing: return "DO_NOTHING"
        case .rollback: return "ROLLBACK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentFailureHandlingPolicy(rawValue: rawValue) ?? DeploymentFailureHandlingPolicy.sdkUnknown(rawValue)
    }
}

public enum DeploymentHistoryFilter {
    case all
    case latestOnly
    case sdkUnknown(String)
}

extension DeploymentHistoryFilter : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentHistoryFilter] {
        return [
            .all,
            .latestOnly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .latestOnly: return "LATEST_ONLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentHistoryFilter(rawValue: rawValue) ?? DeploymentHistoryFilter.sdkUnknown(rawValue)
    }
}

extension DeploymentIoTJobConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case abortConfig
        case jobExecutionsRolloutConfig
        case timeoutConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortConfig = abortConfig {
            try encodeContainer.encode(abortConfig, forKey: .abortConfig)
        }
        if let jobExecutionsRolloutConfig = jobExecutionsRolloutConfig {
            try encodeContainer.encode(jobExecutionsRolloutConfig, forKey: .jobExecutionsRolloutConfig)
        }
        if let timeoutConfig = timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(IoTJobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(IoTJobAbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(IoTJobTimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
    }
}

extension DeploymentIoTJobConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentIoTJobConfiguration(abortConfig: \(String(describing: abortConfig)), jobExecutionsRolloutConfig: \(String(describing: jobExecutionsRolloutConfig)), timeoutConfig: \(String(describing: timeoutConfig)))"}
}

/// <p>Contains information about an AWS IoT job configuration.</p>
public struct DeploymentIoTJobConfiguration: Equatable {
    /// <p>The stop configuration for the job. This configuration defines when and how to stop a job
    ///       rollout.</p>
    public let abortConfig: IoTJobAbortConfig?
    /// <p>The rollout configuration for the job. This configuration defines the rate at which the
    ///       job rolls out to the fleet of target devices.</p>
    public let jobExecutionsRolloutConfig: IoTJobExecutionsRolloutConfig?
    /// <p>The timeout configuration for the job. This configuration defines the amount of time each
    ///       device has to complete the job.</p>
    public let timeoutConfig: IoTJobTimeoutConfig?

    public init (
        abortConfig: IoTJobAbortConfig? = nil,
        jobExecutionsRolloutConfig: IoTJobExecutionsRolloutConfig? = nil,
        timeoutConfig: IoTJobTimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.timeoutConfig = timeoutConfig
    }
}

extension DeploymentPolicies: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentUpdatePolicy
        case configurationValidationPolicy
        case failureHandlingPolicy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentUpdatePolicy = componentUpdatePolicy {
            try encodeContainer.encode(componentUpdatePolicy, forKey: .componentUpdatePolicy)
        }
        if let configurationValidationPolicy = configurationValidationPolicy {
            try encodeContainer.encode(configurationValidationPolicy, forKey: .configurationValidationPolicy)
        }
        if let failureHandlingPolicy = failureHandlingPolicy {
            try encodeContainer.encode(failureHandlingPolicy.rawValue, forKey: .failureHandlingPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureHandlingPolicyDecoded = try containerValues.decodeIfPresent(DeploymentFailureHandlingPolicy.self, forKey: .failureHandlingPolicy)
        failureHandlingPolicy = failureHandlingPolicyDecoded
        let componentUpdatePolicyDecoded = try containerValues.decodeIfPresent(DeploymentComponentUpdatePolicy.self, forKey: .componentUpdatePolicy)
        componentUpdatePolicy = componentUpdatePolicyDecoded
        let configurationValidationPolicyDecoded = try containerValues.decodeIfPresent(DeploymentConfigurationValidationPolicy.self, forKey: .configurationValidationPolicy)
        configurationValidationPolicy = configurationValidationPolicyDecoded
    }
}

extension DeploymentPolicies: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentPolicies(componentUpdatePolicy: \(String(describing: componentUpdatePolicy)), configurationValidationPolicy: \(String(describing: configurationValidationPolicy)), failureHandlingPolicy: \(String(describing: failureHandlingPolicy)))"}
}

/// <p>Contains information about policies that define how a deployment updates components and
///       handles failure.</p>
public struct DeploymentPolicies: Equatable {
    /// <p>The component update policy for the configuration deployment. This policy defines when
    ///       it's safe to deploy the configuration to devices.</p>
    public let componentUpdatePolicy: DeploymentComponentUpdatePolicy?
    /// <p>The configuration validation policy for the configuration deployment. This policy defines
    ///       how long each component has to validate its configure updates.</p>
    public let configurationValidationPolicy: DeploymentConfigurationValidationPolicy?
    /// <p>The failure handling policy for the configuration deployment. This policy defines what to
    ///       do if the deployment fails.</p>
    ///          <p>Default: <code>ROLLBACK</code>
    ///          </p>
    public let failureHandlingPolicy: DeploymentFailureHandlingPolicy?

    public init (
        componentUpdatePolicy: DeploymentComponentUpdatePolicy? = nil,
        configurationValidationPolicy: DeploymentConfigurationValidationPolicy? = nil,
        failureHandlingPolicy: DeploymentFailureHandlingPolicy? = nil
    )
    {
        self.componentUpdatePolicy = componentUpdatePolicy
        self.configurationValidationPolicy = configurationValidationPolicy
        self.failureHandlingPolicy = failureHandlingPolicy
    }
}

public enum DeploymentStatus {
    case active
    case canceled
    case completed
    case failed
    case inactive
    case sdkUnknown(String)
}

extension DeploymentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentStatus] {
        return [
            .active,
            .canceled,
            .completed,
            .failed,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .canceled: return "CANCELED"
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
    }
}

extension DescribeComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeComponentInput(arn: \(String(describing: arn)))"}
}

extension DescribeComponentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeComponentInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComponentInput>
    public typealias MOutput = OperationOutput<DescribeComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComponentOutputError>
}

public struct DescribeComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComponentInput>
    public typealias MOutput = OperationOutput<DescribeComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComponentOutputError>
}

public struct DescribeComponentInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the component version.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DescribeComponentInputBody: Equatable {
}

extension DescribeComponentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeComponentOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeComponentOutputResponse(arn: \(String(describing: arn)), componentName: \(String(describing: componentName)), componentVersion: \(String(describing: componentVersion)), creationTimestamp: \(String(describing: creationTimestamp)), description: \(String(describing: description)), platforms: \(String(describing: platforms)), publisher: \(String(describing: publisher)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension DescribeComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.componentName = output.componentName
            self.componentVersion = output.componentVersion
            self.creationTimestamp = output.creationTimestamp
            self.description = output.description
            self.platforms = output.platforms
            self.publisher = output.publisher
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.componentName = nil
            self.componentVersion = nil
            self.creationTimestamp = nil
            self.description = nil
            self.platforms = nil
            self.publisher = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct DescribeComponentOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the component version.</p>
    public let arn: String?
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The version of the component.</p>
    public let componentVersion: String?
    /// <p>The time at which the component was created, expressed in ISO 8601 format.</p>
    public let creationTimestamp: Date?
    /// <p>The description of the component version.</p>
    public let description: String?
    /// <p>The platforms that the component version supports.</p>
    public let platforms: [ComponentPlatform]?
    /// <p>The publisher of the component version.</p>
    public let publisher: String?
    /// <p>The status of the component version in AWS IoT Greengrass V2. This status
    ///       is different from the status of the component on a core device.</p>
    public let status: CloudComponentStatus?
    /// <p>A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        componentName: String? = nil,
        componentVersion: String? = nil,
        creationTimestamp: Date? = nil,
        description: String? = nil,
        platforms: [ComponentPlatform]? = nil,
        publisher: String? = nil,
        status: CloudComponentStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.componentName = componentName
        self.componentVersion = componentVersion
        self.creationTimestamp = creationTimestamp
        self.description = description
        self.platforms = platforms
        self.publisher = publisher
        self.status = status
        self.tags = tags
    }
}

struct DescribeComponentOutputResponseBody: Equatable {
    public let arn: String?
    public let componentName: String?
    public let componentVersion: String?
    public let creationTimestamp: Date?
    public let publisher: String?
    public let description: String?
    public let status: CloudComponentStatus?
    public let platforms: [ComponentPlatform]?
    public let tags: [String:String]?
}

extension DescribeComponentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case componentName
        case componentVersion
        case creationTimestamp
        case description
        case platforms
        case publisher
        case status
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let publisherDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publisher)
        publisher = publisherDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudComponentStatus.self, forKey: .status)
        status = statusDecoded
        let platformsContainer = try containerValues.decodeIfPresent([ComponentPlatform?].self, forKey: .platforms)
        var platformsDecoded0:[ComponentPlatform]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [ComponentPlatform]()
            for structure0 in platformsContainer {
                if let structure0 = structure0 {
                    platformsDecoded0?.append(structure0)
                }
            }
        }
        platforms = platformsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EffectiveDeployment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case coreDeviceExecutionStatus
        case creationTimestamp
        case deploymentId
        case deploymentName
        case description
        case iotJobArn
        case iotJobId
        case modifiedTimestamp
        case reason
        case targetArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreDeviceExecutionStatus = coreDeviceExecutionStatus {
            try encodeContainer.encode(coreDeviceExecutionStatus.rawValue, forKey: .coreDeviceExecutionStatus)
        }
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentName = deploymentName {
            try encodeContainer.encode(deploymentName, forKey: .deploymentName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iotJobArn = iotJobArn {
            try encodeContainer.encode(iotJobArn, forKey: .iotJobArn)
        }
        if let iotJobId = iotJobId {
            try encodeContainer.encode(iotJobId, forKey: .iotJobId)
        }
        if let modifiedTimestamp = modifiedTimestamp {
            try encodeContainer.encode(modifiedTimestamp.timeIntervalSince1970, forKey: .modifiedTimestamp)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let iotJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iotJobId)
        iotJobId = iotJobIdDecoded
        let iotJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iotJobArn)
        iotJobArn = iotJobArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let coreDeviceExecutionStatusDecoded = try containerValues.decodeIfPresent(EffectiveDeploymentExecutionStatus.self, forKey: .coreDeviceExecutionStatus)
        coreDeviceExecutionStatus = coreDeviceExecutionStatusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
    }
}

extension EffectiveDeployment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EffectiveDeployment(coreDeviceExecutionStatus: \(String(describing: coreDeviceExecutionStatus)), creationTimestamp: \(String(describing: creationTimestamp)), deploymentId: \(String(describing: deploymentId)), deploymentName: \(String(describing: deploymentName)), description: \(String(describing: description)), iotJobArn: \(String(describing: iotJobArn)), iotJobId: \(String(describing: iotJobId)), modifiedTimestamp: \(String(describing: modifiedTimestamp)), reason: \(String(describing: reason)), targetArn: \(String(describing: targetArn)))"}
}

/// <p>Contains information about a deployment job that AWS IoT Greengrass sends to a AWS IoT Greengrass core device.</p>
public struct EffectiveDeployment: Equatable {
    /// <p>The status of the deployment job on the AWS IoT Greengrass core device.</p>
    public let coreDeviceExecutionStatus: EffectiveDeploymentExecutionStatus?
    /// <p>The time at which the deployment was created, expressed in ISO 8601 format.</p>
    public let creationTimestamp: Date?
    /// <p>The ID of the deployment.</p>
    public let deploymentId: String?
    /// <p>The name of the deployment.</p>
    ///          <p>You can create deployments without names. If you create a deployment without a name, the
    ///       AWS IoT Greengrass V2 console shows the deployment name as <code><targetType>:<targetName></code>,
    ///       where <code>targetType</code> and <code>targetName</code> are the type and name of the
    ///       deployment target.</p>
    public let deploymentName: String?
    /// <p>The description of the deployment job.</p>
    public let description: String?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the AWS IoT job that applies the deployment to target devices.</p>
    public let iotJobArn: String?
    /// <p>The ID of the AWS IoT job that applies the deployment to target devices.</p>
    public let iotJobId: String?
    /// <p>The time at which the deployment job was last modified, expressed in ISO 8601
    ///       format.</p>
    public let modifiedTimestamp: Date?
    /// <p>The reason code for the update, if the job was updated.</p>
    public let reason: String?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the target AWS IoT thing or thing group.</p>
    public let targetArn: String?

    public init (
        coreDeviceExecutionStatus: EffectiveDeploymentExecutionStatus? = nil,
        creationTimestamp: Date? = nil,
        deploymentId: String? = nil,
        deploymentName: String? = nil,
        description: String? = nil,
        iotJobArn: String? = nil,
        iotJobId: String? = nil,
        modifiedTimestamp: Date? = nil,
        reason: String? = nil,
        targetArn: String? = nil
    )
    {
        self.coreDeviceExecutionStatus = coreDeviceExecutionStatus
        self.creationTimestamp = creationTimestamp
        self.deploymentId = deploymentId
        self.deploymentName = deploymentName
        self.description = description
        self.iotJobArn = iotJobArn
        self.iotJobId = iotJobId
        self.modifiedTimestamp = modifiedTimestamp
        self.reason = reason
        self.targetArn = targetArn
    }
}

public enum EffectiveDeploymentExecutionStatus {
    case canceled
    case completed
    case failed
    case inProgress
    case queued
    case rejected
    case timedOut
    case sdkUnknown(String)
}

extension EffectiveDeploymentExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EffectiveDeploymentExecutionStatus] {
        return [
            .canceled,
            .completed,
            .failed,
            .inProgress,
            .queued,
            .rejected,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .queued: return "QUEUED"
        case .rejected: return "REJECTED"
        case .timedOut: return "TIMED_OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EffectiveDeploymentExecutionStatus(rawValue: rawValue) ?? EffectiveDeploymentExecutionStatus.sdkUnknown(rawValue)
    }
}

extension GetComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComponentInput(arn: \(String(describing: arn)), recipeOutputFormat: \(String(describing: recipeOutputFormat)))"}
}

extension GetComponentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetComponentInputHeadersMiddleware: Middleware {
    public let id: String = "GetComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComponentInput>
    public typealias MOutput = OperationOutput<GetComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComponentOutputError>
}

public struct GetComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let recipeOutputFormat = input.operationInput.recipeOutputFormat {
            let recipeOutputFormatQueryItem = URLQueryItem(name: "recipeOutputFormat".urlPercentEncoding(), value: String(recipeOutputFormat.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(recipeOutputFormatQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComponentInput>
    public typealias MOutput = OperationOutput<GetComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComponentOutputError>
}

public struct GetComponentInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the component version.</p>
    public let arn: String?
    /// <p>The format of the recipe.</p>
    public let recipeOutputFormat: RecipeOutputFormat?

    public init (
        arn: String? = nil,
        recipeOutputFormat: RecipeOutputFormat? = nil
    )
    {
        self.arn = arn
        self.recipeOutputFormat = recipeOutputFormat
    }
}

struct GetComponentInputBody: Equatable {
}

extension GetComponentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComponentOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComponentOutputResponse(recipe: \(String(describing: recipe)), recipeOutputFormat: \(String(describing: recipeOutputFormat)), tags: \(String(describing: tags)))"}
}

extension GetComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recipe = output.recipe
            self.recipeOutputFormat = output.recipeOutputFormat
            self.tags = output.tags
        } else {
            self.recipe = nil
            self.recipeOutputFormat = nil
            self.tags = nil
        }
    }
}

public struct GetComponentOutputResponse: Equatable {
    /// <p>The recipe of the component version.</p>
    public let recipe: Data?
    /// <p>The format of the recipe.</p>
    public let recipeOutputFormat: RecipeOutputFormat?
    /// <p>A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        recipe: Data? = nil,
        recipeOutputFormat: RecipeOutputFormat? = nil,
        tags: [String:String]? = nil
    )
    {
        self.recipe = recipe
        self.recipeOutputFormat = recipeOutputFormat
        self.tags = tags
    }
}

struct GetComponentOutputResponseBody: Equatable {
    public let recipeOutputFormat: RecipeOutputFormat?
    public let recipe: Data?
    public let tags: [String:String]?
}

extension GetComponentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recipe
        case recipeOutputFormat
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeOutputFormatDecoded = try containerValues.decodeIfPresent(RecipeOutputFormat.self, forKey: .recipeOutputFormat)
        recipeOutputFormat = recipeOutputFormatDecoded
        let recipeDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .recipe)
        recipe = recipeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetComponentVersionArtifactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComponentVersionArtifactInput(arn: \(String(describing: arn)), artifactName: \(String(describing: artifactName)))"}
}

extension GetComponentVersionArtifactInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetComponentVersionArtifactInputHeadersMiddleware: Middleware {
    public let id: String = "GetComponentVersionArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComponentVersionArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComponentVersionArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComponentVersionArtifactInput>
    public typealias MOutput = OperationOutput<GetComponentVersionArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComponentVersionArtifactOutputError>
}

public struct GetComponentVersionArtifactInputQueryItemMiddleware: Middleware {
    public let id: String = "GetComponentVersionArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComponentVersionArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComponentVersionArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComponentVersionArtifactInput>
    public typealias MOutput = OperationOutput<GetComponentVersionArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComponentVersionArtifactOutputError>
}

public struct GetComponentVersionArtifactInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the component version. Specify the ARN of a public component version.</p>
    public let arn: String?
    /// <p>The name of the artifact.</p>
    ///          <p>You can use the <a href="https://docs.aws.amazon.com/greengrass/v2/APIReference/API_GetComponent.html">GetComponent</a> operation to
    ///       download the component recipe, which includes the URI of the artifact. The artifact name is
    ///       the section of the URI after the scheme. For example, in the artifact URI
    ///         <code>greengrass:SomeArtifact.zip</code>, the artifact name is
    ///       <code>SomeArtifact.zip</code>.</p>
    public let artifactName: String?

    public init (
        arn: String? = nil,
        artifactName: String? = nil
    )
    {
        self.arn = arn
        self.artifactName = artifactName
    }
}

struct GetComponentVersionArtifactInputBody: Equatable {
}

extension GetComponentVersionArtifactInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetComponentVersionArtifactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentVersionArtifactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComponentVersionArtifactOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentVersionArtifactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComponentVersionArtifactOutputResponse(preSignedUrl: \(String(describing: preSignedUrl)))"}
}

extension GetComponentVersionArtifactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetComponentVersionArtifactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.preSignedUrl = output.preSignedUrl
        } else {
            self.preSignedUrl = nil
        }
    }
}

public struct GetComponentVersionArtifactOutputResponse: Equatable {
    /// <p>The URL of the artifact.</p>
    public let preSignedUrl: String?

    public init (
        preSignedUrl: String? = nil
    )
    {
        self.preSignedUrl = preSignedUrl
    }
}

struct GetComponentVersionArtifactOutputResponseBody: Equatable {
    public let preSignedUrl: String?
}

extension GetComponentVersionArtifactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case preSignedUrl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preSignedUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preSignedUrl)
        preSignedUrl = preSignedUrlDecoded
    }
}

extension GetCoreDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCoreDeviceInput(coreDeviceThingName: \(String(describing: coreDeviceThingName)))"}
}

extension GetCoreDeviceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCoreDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "GetCoreDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCoreDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCoreDeviceInput>
    public typealias MOutput = OperationOutput<GetCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCoreDeviceOutputError>
}

public struct GetCoreDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCoreDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCoreDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCoreDeviceInput>
    public typealias MOutput = OperationOutput<GetCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCoreDeviceOutputError>
}

public struct GetCoreDeviceInput: Equatable {
    /// <p>The name of the core device. This is also the name of the AWS IoT thing.</p>
    public let coreDeviceThingName: String?

    public init (
        coreDeviceThingName: String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
    }
}

struct GetCoreDeviceInputBody: Equatable {
}

extension GetCoreDeviceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCoreDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCoreDeviceOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCoreDeviceOutputResponse(architecture: \(String(describing: architecture)), coreDeviceThingName: \(String(describing: coreDeviceThingName)), coreVersion: \(String(describing: coreVersion)), lastStatusUpdateTimestamp: \(String(describing: lastStatusUpdateTimestamp)), platform: \(String(describing: platform)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension GetCoreDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCoreDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architecture = output.architecture
            self.coreDeviceThingName = output.coreDeviceThingName
            self.coreVersion = output.coreVersion
            self.lastStatusUpdateTimestamp = output.lastStatusUpdateTimestamp
            self.platform = output.platform
            self.status = output.status
            self.tags = output.tags
        } else {
            self.architecture = nil
            self.coreDeviceThingName = nil
            self.coreVersion = nil
            self.lastStatusUpdateTimestamp = nil
            self.platform = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetCoreDeviceOutputResponse: Equatable {
    /// <p>The computer architecture of the core device.</p>
    public let architecture: String?
    /// <p>The name of the core device. This is also the name of the AWS IoT thing.</p>
    public let coreDeviceThingName: String?
    /// <p>The version of the AWS IoT Greengrass Core software that the core device runs. This version is equivalent to
    ///       the version of the AWS IoT Greengrass nucleus component that runs on the core device. For more information,
    ///       see the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/greengrass-nucleus-component.html">AWS IoT Greengrass nucleus
    ///         component</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    public let coreVersion: String?
    /// <p>The time at which the core device's status last updated, expressed in ISO 8601
    ///       format.</p>
    public let lastStatusUpdateTimestamp: Date?
    /// <p>The operating system platform that the core device runs.</p>
    public let platform: String?
    /// <p>The status of the core device. The core device status can be:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HEALTHY</code> – The AWS IoT Greengrass Core software and all components run on the core device without issue.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNHEALTHY</code> – The AWS IoT Greengrass Core software or a component is in a failed state
    ///           on the core device.</p>
    ///             </li>
    ///          </ul>
    public let status: CoreDeviceStatus?
    /// <p>A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        architecture: String? = nil,
        coreDeviceThingName: String? = nil,
        coreVersion: String? = nil,
        lastStatusUpdateTimestamp: Date? = nil,
        platform: String? = nil,
        status: CoreDeviceStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.architecture = architecture
        self.coreDeviceThingName = coreDeviceThingName
        self.coreVersion = coreVersion
        self.lastStatusUpdateTimestamp = lastStatusUpdateTimestamp
        self.platform = platform
        self.status = status
        self.tags = tags
    }
}

struct GetCoreDeviceOutputResponseBody: Equatable {
    public let coreDeviceThingName: String?
    public let coreVersion: String?
    public let platform: String?
    public let architecture: String?
    public let status: CoreDeviceStatus?
    public let lastStatusUpdateTimestamp: Date?
    public let tags: [String:String]?
}

extension GetCoreDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case architecture
        case coreDeviceThingName
        case coreVersion
        case lastStatusUpdateTimestamp
        case platform
        case status
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreDeviceThingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .coreDeviceThingName)
        coreDeviceThingName = coreDeviceThingNameDecoded
        let coreVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .coreVersion)
        coreVersion = coreVersionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .architecture)
        architecture = architectureDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CoreDeviceStatus.self, forKey: .status)
        status = statusDecoded
        let lastStatusUpdateTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStatusUpdateTimestamp)
        lastStatusUpdateTimestamp = lastStatusUpdateTimestampDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentInput(deploymentId: \(String(describing: deploymentId)))"}
}

extension GetDeploymentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentInput>
    public typealias MOutput = OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentInput>
    public typealias MOutput = OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInput: Equatable {
    /// <p>The ID of the deployment.</p>
    public let deploymentId: String?

    public init (
        deploymentId: String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct GetDeploymentInputBody: Equatable {
}

extension GetDeploymentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentOutputResponse(components: \(String(describing: components)), creationTimestamp: \(String(describing: creationTimestamp)), deploymentId: \(String(describing: deploymentId)), deploymentName: \(String(describing: deploymentName)), deploymentPolicies: \(String(describing: deploymentPolicies)), deploymentStatus: \(String(describing: deploymentStatus)), iotJobArn: \(String(describing: iotJobArn)), iotJobConfiguration: \(String(describing: iotJobConfiguration)), iotJobId: \(String(describing: iotJobId)), isLatestForTarget: \(String(describing: isLatestForTarget)), revisionId: \(String(describing: revisionId)), tags: \(String(describing: tags)), targetArn: \(String(describing: targetArn)))"}
}

extension GetDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.components = output.components
            self.creationTimestamp = output.creationTimestamp
            self.deploymentId = output.deploymentId
            self.deploymentName = output.deploymentName
            self.deploymentPolicies = output.deploymentPolicies
            self.deploymentStatus = output.deploymentStatus
            self.iotJobArn = output.iotJobArn
            self.iotJobConfiguration = output.iotJobConfiguration
            self.iotJobId = output.iotJobId
            self.isLatestForTarget = output.isLatestForTarget
            self.revisionId = output.revisionId
            self.tags = output.tags
            self.targetArn = output.targetArn
        } else {
            self.components = nil
            self.creationTimestamp = nil
            self.deploymentId = nil
            self.deploymentName = nil
            self.deploymentPolicies = nil
            self.deploymentStatus = nil
            self.iotJobArn = nil
            self.iotJobConfiguration = nil
            self.iotJobId = nil
            self.isLatestForTarget = false
            self.revisionId = nil
            self.tags = nil
            self.targetArn = nil
        }
    }
}

public struct GetDeploymentOutputResponse: Equatable {
    /// <p>The components to deploy. This is a dictionary, where each key is the name of a component,
    ///         and each key's value is the version and configuration to deploy for that component.</p>
    public let components: [String:ComponentDeploymentSpecification]?
    /// <p>The time at which the deployment was created, expressed in ISO 8601 format.</p>
    public let creationTimestamp: Date?
    /// <p>The ID of the deployment.</p>
    public let deploymentId: String?
    /// <p>The name of the deployment.</p>
    ///          <p>You can create deployments without names. If you create a deployment without a name, the
    ///       AWS IoT Greengrass V2 console shows the deployment name as <code><targetType>:<targetName></code>,
    ///       where <code>targetType</code> and <code>targetName</code> are the type and name of the
    ///       deployment target.</p>
    public let deploymentName: String?
    /// <p>The deployment policies for the deployment. These policies define how the deployment
    ///       updates components and handles failure.</p>
    public let deploymentPolicies: DeploymentPolicies?
    /// <p>The status of the deployment.</p>
    public let deploymentStatus: DeploymentStatus?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the AWS IoT job that applies the deployment to target devices.</p>
    public let iotJobArn: String?
    /// <p>The job configuration for the deployment configuration. The job configuration specifies
    ///       the rollout, timeout, and stop configurations for the deployment configuration.</p>
    public let iotJobConfiguration: DeploymentIoTJobConfiguration?
    /// <p>The ID of the AWS IoT job that applies the deployment to target devices.</p>
    public let iotJobId: String?
    /// <p>Whether or not the deployment is the latest revision for its target.</p>
    public let isLatestForTarget: Bool
    /// <p>The revision number of the deployment.</p>
    public let revisionId: String?
    /// <p>A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    public let tags: [String:String]?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the target AWS IoT thing or thing group.</p>
    public let targetArn: String?

    public init (
        components: [String:ComponentDeploymentSpecification]? = nil,
        creationTimestamp: Date? = nil,
        deploymentId: String? = nil,
        deploymentName: String? = nil,
        deploymentPolicies: DeploymentPolicies? = nil,
        deploymentStatus: DeploymentStatus? = nil,
        iotJobArn: String? = nil,
        iotJobConfiguration: DeploymentIoTJobConfiguration? = nil,
        iotJobId: String? = nil,
        isLatestForTarget: Bool = false,
        revisionId: String? = nil,
        tags: [String:String]? = nil,
        targetArn: String? = nil
    )
    {
        self.components = components
        self.creationTimestamp = creationTimestamp
        self.deploymentId = deploymentId
        self.deploymentName = deploymentName
        self.deploymentPolicies = deploymentPolicies
        self.deploymentStatus = deploymentStatus
        self.iotJobArn = iotJobArn
        self.iotJobConfiguration = iotJobConfiguration
        self.iotJobId = iotJobId
        self.isLatestForTarget = isLatestForTarget
        self.revisionId = revisionId
        self.tags = tags
        self.targetArn = targetArn
    }
}

struct GetDeploymentOutputResponseBody: Equatable {
    public let targetArn: String?
    public let revisionId: String?
    public let deploymentId: String?
    public let deploymentName: String?
    public let deploymentStatus: DeploymentStatus?
    public let iotJobId: String?
    public let iotJobArn: String?
    public let components: [String:ComponentDeploymentSpecification]?
    public let deploymentPolicies: DeploymentPolicies?
    public let iotJobConfiguration: DeploymentIoTJobConfiguration?
    public let creationTimestamp: Date?
    public let isLatestForTarget: Bool
    public let tags: [String:String]?
}

extension GetDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case components
        case creationTimestamp
        case deploymentId
        case deploymentName
        case deploymentPolicies
        case deploymentStatus
        case iotJobArn
        case iotJobConfiguration
        case iotJobId
        case isLatestForTarget
        case revisionId
        case tags
        case targetArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let iotJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iotJobId)
        iotJobId = iotJobIdDecoded
        let iotJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iotJobArn)
        iotJobArn = iotJobArnDecoded
        let componentsContainer = try containerValues.decodeIfPresent([String: ComponentDeploymentSpecification?].self, forKey: .components)
        var componentsDecoded0: [String:ComponentDeploymentSpecification]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [String:ComponentDeploymentSpecification]()
            for (key0, componentdeploymentspecification0) in componentsContainer {
                if let componentdeploymentspecification0 = componentdeploymentspecification0 {
                    componentsDecoded0?[key0] = componentdeploymentspecification0
                }
            }
        }
        components = componentsDecoded0
        let deploymentPoliciesDecoded = try containerValues.decodeIfPresent(DeploymentPolicies.self, forKey: .deploymentPolicies)
        deploymentPolicies = deploymentPoliciesDecoded
        let iotJobConfigurationDecoded = try containerValues.decodeIfPresent(DeploymentIoTJobConfiguration.self, forKey: .iotJobConfiguration)
        iotJobConfiguration = iotJobConfigurationDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let isLatestForTargetDecoded = try containerValues.decode(Bool.self, forKey: .isLatestForTarget)
        isLatestForTarget = isLatestForTargetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InstalledComponent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentName
        case componentVersion
        case isRoot
        case lifecycleState
        case lifecycleStateDetails
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if isRoot != false {
            try encodeContainer.encode(isRoot, forKey: .isRoot)
        }
        if let lifecycleState = lifecycleState {
            try encodeContainer.encode(lifecycleState.rawValue, forKey: .lifecycleState)
        }
        if let lifecycleStateDetails = lifecycleStateDetails {
            try encodeContainer.encode(lifecycleStateDetails, forKey: .lifecycleStateDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let lifecycleStateDecoded = try containerValues.decodeIfPresent(InstalledComponentLifecycleState.self, forKey: .lifecycleState)
        lifecycleState = lifecycleStateDecoded
        let lifecycleStateDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lifecycleStateDetails)
        lifecycleStateDetails = lifecycleStateDetailsDecoded
        let isRootDecoded = try containerValues.decode(Bool.self, forKey: .isRoot)
        isRoot = isRootDecoded
    }
}

extension InstalledComponent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstalledComponent(componentName: \(String(describing: componentName)), componentVersion: \(String(describing: componentVersion)), isRoot: \(String(describing: isRoot)), lifecycleState: \(String(describing: lifecycleState)), lifecycleStateDetails: \(String(describing: lifecycleStateDetails)))"}
}

/// <p>Contains information about a component on a AWS IoT Greengrass core device.</p>
public struct InstalledComponent: Equatable {
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The version of the component.</p>
    public let componentVersion: String?
    /// <p>Whether or not the component is a root component.</p>
    public let isRoot: Bool
    /// <p>The lifecycle state of the component.</p>
    public let lifecycleState: InstalledComponentLifecycleState?
    /// <p>The details about the lifecycle state of the component.</p>
    public let lifecycleStateDetails: String?

    public init (
        componentName: String? = nil,
        componentVersion: String? = nil,
        isRoot: Bool = false,
        lifecycleState: InstalledComponentLifecycleState? = nil,
        lifecycleStateDetails: String? = nil
    )
    {
        self.componentName = componentName
        self.componentVersion = componentVersion
        self.isRoot = isRoot
        self.lifecycleState = lifecycleState
        self.lifecycleStateDetails = lifecycleStateDetails
    }
}

public enum InstalledComponentLifecycleState {
    case broken
    case errored
    case finished
    case installed
    case new
    case running
    case starting
    case stopping
    case sdkUnknown(String)
}

extension InstalledComponentLifecycleState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InstalledComponentLifecycleState] {
        return [
            .broken,
            .errored,
            .finished,
            .installed,
            .new,
            .running,
            .starting,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .broken: return "BROKEN"
        case .errored: return "ERRORED"
        case .finished: return "FINISHED"
        case .installed: return "INSTALLED"
        case .new: return "NEW"
        case .running: return "RUNNING"
        case .starting: return "STARTING"
        case .stopping: return "STOPPING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InstalledComponentLifecycleState(rawValue: rawValue) ?? InstalledComponentLifecycleState.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS IoT Greengrass can't process your request right now. Try again later.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    /// <p>The amount of time to wait before you retry the request.</p>
    public var retryAfterSeconds: Int

    public init (
        message: String? = nil,
        retryAfterSeconds: Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum IoTJobAbortAction {
    case cancel
    case sdkUnknown(String)
}

extension IoTJobAbortAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IoTJobAbortAction] {
        return [
            .cancel,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancel: return "CANCEL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IoTJobAbortAction(rawValue: rawValue) ?? IoTJobAbortAction.sdkUnknown(rawValue)
    }
}

extension IoTJobAbortConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case criteriaList
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criteriaList = criteriaList {
            var criteriaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .criteriaList)
            for iotjobabortcriterialist0 in criteriaList {
                try criteriaListContainer.encode(iotjobabortcriterialist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criteriaListContainer = try containerValues.decodeIfPresent([IoTJobAbortCriteria?].self, forKey: .criteriaList)
        var criteriaListDecoded0:[IoTJobAbortCriteria]? = nil
        if let criteriaListContainer = criteriaListContainer {
            criteriaListDecoded0 = [IoTJobAbortCriteria]()
            for structure0 in criteriaListContainer {
                if let structure0 = structure0 {
                    criteriaListDecoded0?.append(structure0)
                }
            }
        }
        criteriaList = criteriaListDecoded0
    }
}

extension IoTJobAbortConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IoTJobAbortConfig(criteriaList: \(String(describing: criteriaList)))"}
}

/// <p>Contains a list of criteria that define when and how to cancel a configuration
///       deployment.</p>
public struct IoTJobAbortConfig: Equatable {
    /// <p>The list of criteria that define when and how to cancel the configuration deployment.</p>
    public let criteriaList: [IoTJobAbortCriteria]?

    public init (
        criteriaList: [IoTJobAbortCriteria]? = nil
    )
    {
        self.criteriaList = criteriaList
    }
}

extension IoTJobAbortCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case failureType
        case minNumberOfExecutedThings
        case thresholdPercentage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let failureType = failureType {
            try encodeContainer.encode(failureType.rawValue, forKey: .failureType)
        }
        if minNumberOfExecutedThings != 0 {
            try encodeContainer.encode(minNumberOfExecutedThings, forKey: .minNumberOfExecutedThings)
        }
        if thresholdPercentage != 0.0 {
            try encodeContainer.encode(thresholdPercentage, forKey: .thresholdPercentage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureTypeDecoded = try containerValues.decodeIfPresent(IoTJobExecutionFailureType.self, forKey: .failureType)
        failureType = failureTypeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(IoTJobAbortAction.self, forKey: .action)
        action = actionDecoded
        let thresholdPercentageDecoded = try containerValues.decode(Double.self, forKey: .thresholdPercentage)
        thresholdPercentage = thresholdPercentageDecoded
        let minNumberOfExecutedThingsDecoded = try containerValues.decode(Int.self, forKey: .minNumberOfExecutedThings)
        minNumberOfExecutedThings = minNumberOfExecutedThingsDecoded
    }
}

extension IoTJobAbortCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IoTJobAbortCriteria(action: \(String(describing: action)), failureType: \(String(describing: failureType)), minNumberOfExecutedThings: \(String(describing: minNumberOfExecutedThings)), thresholdPercentage: \(String(describing: thresholdPercentage)))"}
}

/// <p>Contains criteria that define when and how to cancel a job.</p>
///          <p>The deployment stops if the following conditions are true:</p>
///          <ol>
///             <li>
///                <p>The number of things that receive the deployment exceeds the
///           <code>minNumberOfExecutedThings</code>.</p>
///             </li>
///             <li>
///                <p>The percentage of failures with type <code>failureType</code> exceeds the
///           <code>thresholdPercentage</code>.</p>
///             </li>
///          </ol>
public struct IoTJobAbortCriteria: Equatable {
    /// <p>The action to perform when the criteria are met.</p>
    public let action: IoTJobAbortAction?
    /// <p>The type of job deployment failure that can cancel a job.</p>
    public let failureType: IoTJobExecutionFailureType?
    /// <p>The minimum number of things that receive the configuration before the job can
    ///       cancel.</p>
    public let minNumberOfExecutedThings: Int
    /// <p>The minimum percentage of <code>failureType</code> failures that occur before the job can
    ///       cancel.</p>
    ///          <p>This parameter supports up to two digits after the decimal (for example, you can specify
    ///       <code>10.9</code> or <code>10.99</code>, but not <code>10.999</code>).</p>
    public let thresholdPercentage: Double

    public init (
        action: IoTJobAbortAction? = nil,
        failureType: IoTJobExecutionFailureType? = nil,
        minNumberOfExecutedThings: Int = 0,
        thresholdPercentage: Double = 0.0
    )
    {
        self.action = action
        self.failureType = failureType
        self.minNumberOfExecutedThings = minNumberOfExecutedThings
        self.thresholdPercentage = thresholdPercentage
    }
}

public enum IoTJobExecutionFailureType {
    case all
    case failed
    case rejected
    case timedOut
    case sdkUnknown(String)
}

extension IoTJobExecutionFailureType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IoTJobExecutionFailureType] {
        return [
            .all,
            .failed,
            .rejected,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .failed: return "FAILED"
        case .rejected: return "REJECTED"
        case .timedOut: return "TIMED_OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IoTJobExecutionFailureType(rawValue: rawValue) ?? IoTJobExecutionFailureType.sdkUnknown(rawValue)
    }
}

extension IoTJobExecutionsRolloutConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exponentialRate
        case maximumPerMinute
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exponentialRate = exponentialRate {
            try encodeContainer.encode(exponentialRate, forKey: .exponentialRate)
        }
        if maximumPerMinute != 0 {
            try encodeContainer.encode(maximumPerMinute, forKey: .maximumPerMinute)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exponentialRateDecoded = try containerValues.decodeIfPresent(IoTJobExponentialRolloutRate.self, forKey: .exponentialRate)
        exponentialRate = exponentialRateDecoded
        let maximumPerMinuteDecoded = try containerValues.decode(Int.self, forKey: .maximumPerMinute)
        maximumPerMinute = maximumPerMinuteDecoded
    }
}

extension IoTJobExecutionsRolloutConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IoTJobExecutionsRolloutConfig(exponentialRate: \(String(describing: exponentialRate)), maximumPerMinute: \(String(describing: maximumPerMinute)))"}
}

/// <p>Contains information about the rollout configuration for a job. This configuration defines
///       the rate at which the job deploys a configuration to a fleet of target devices.</p>
public struct IoTJobExecutionsRolloutConfig: Equatable {
    /// <p>The exponential rate to increase the job rollout rate.</p>
    public let exponentialRate: IoTJobExponentialRolloutRate?
    /// <p>The maximum number of devices that receive a pending job notification, per minute.</p>
    public let maximumPerMinute: Int

    public init (
        exponentialRate: IoTJobExponentialRolloutRate? = nil,
        maximumPerMinute: Int = 0
    )
    {
        self.exponentialRate = exponentialRate
        self.maximumPerMinute = maximumPerMinute
    }
}

extension IoTJobExponentialRolloutRate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baseRatePerMinute
        case incrementFactor
        case rateIncreaseCriteria
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if baseRatePerMinute != 0 {
            try encodeContainer.encode(baseRatePerMinute, forKey: .baseRatePerMinute)
        }
        if incrementFactor != 0.0 {
            try encodeContainer.encode(incrementFactor, forKey: .incrementFactor)
        }
        if let rateIncreaseCriteria = rateIncreaseCriteria {
            try encodeContainer.encode(rateIncreaseCriteria, forKey: .rateIncreaseCriteria)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseRatePerMinuteDecoded = try containerValues.decode(Int.self, forKey: .baseRatePerMinute)
        baseRatePerMinute = baseRatePerMinuteDecoded
        let incrementFactorDecoded = try containerValues.decode(Double.self, forKey: .incrementFactor)
        incrementFactor = incrementFactorDecoded
        let rateIncreaseCriteriaDecoded = try containerValues.decodeIfPresent(IoTJobRateIncreaseCriteria.self, forKey: .rateIncreaseCriteria)
        rateIncreaseCriteria = rateIncreaseCriteriaDecoded
    }
}

extension IoTJobExponentialRolloutRate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IoTJobExponentialRolloutRate(baseRatePerMinute: \(String(describing: baseRatePerMinute)), incrementFactor: \(String(describing: incrementFactor)), rateIncreaseCriteria: \(String(describing: rateIncreaseCriteria)))"}
}

/// <p>Contains information about an exponential rollout rate for a configuration deployment
///       job.</p>
public struct IoTJobExponentialRolloutRate: Equatable {
    /// <p>The minimum number of devices that receive a pending job notification, per minute, when
    ///       the job starts. This parameter defines the initial rollout rate of the job.</p>
    public let baseRatePerMinute: Int
    /// <p>The exponential factor to increase the rollout rate for the job.</p>
    ///          <p>This parameter supports up to one digit after the decimal (for example, you can specify
    ///       <code>1.5</code>, but not <code>1.55</code>).</p>
    public let incrementFactor: Double
    /// <p>The criteria to increase the rollout rate for the job.</p>
    public let rateIncreaseCriteria: IoTJobRateIncreaseCriteria?

    public init (
        baseRatePerMinute: Int = 0,
        incrementFactor: Double = 0.0,
        rateIncreaseCriteria: IoTJobRateIncreaseCriteria? = nil
    )
    {
        self.baseRatePerMinute = baseRatePerMinute
        self.incrementFactor = incrementFactor
        self.rateIncreaseCriteria = rateIncreaseCriteria
    }
}

extension IoTJobRateIncreaseCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case numberOfNotifiedThings
        case numberOfSucceededThings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfNotifiedThings != 0 {
            try encodeContainer.encode(numberOfNotifiedThings, forKey: .numberOfNotifiedThings)
        }
        if numberOfSucceededThings != 0 {
            try encodeContainer.encode(numberOfSucceededThings, forKey: .numberOfSucceededThings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfNotifiedThingsDecoded = try containerValues.decode(Int.self, forKey: .numberOfNotifiedThings)
        numberOfNotifiedThings = numberOfNotifiedThingsDecoded
        let numberOfSucceededThingsDecoded = try containerValues.decode(Int.self, forKey: .numberOfSucceededThings)
        numberOfSucceededThings = numberOfSucceededThingsDecoded
    }
}

extension IoTJobRateIncreaseCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IoTJobRateIncreaseCriteria(numberOfNotifiedThings: \(String(describing: numberOfNotifiedThings)), numberOfSucceededThings: \(String(describing: numberOfSucceededThings)))"}
}

/// <p>Contains information about criteria to meet before a job increases its rollout rate.
///       Specify either <code>numberOfNotifiedThings</code> or
///       <code>numberOfSucceededThings</code>.</p>
public struct IoTJobRateIncreaseCriteria: Equatable {
    /// <p>The number of devices to receive the job notification before the rollout rate
    ///       increases.</p>
    public let numberOfNotifiedThings: Int
    /// <p>The number of devices to successfully run the configuration job before the rollout rate
    ///       increases.</p>
    public let numberOfSucceededThings: Int

    public init (
        numberOfNotifiedThings: Int = 0,
        numberOfSucceededThings: Int = 0
    )
    {
        self.numberOfNotifiedThings = numberOfNotifiedThings
        self.numberOfSucceededThings = numberOfSucceededThings
    }
}

extension IoTJobTimeoutConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inProgressTimeoutInMinutes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if inProgressTimeoutInMinutes != 0 {
            try encodeContainer.encode(inProgressTimeoutInMinutes, forKey: .inProgressTimeoutInMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inProgressTimeoutInMinutesDecoded = try containerValues.decode(Int.self, forKey: .inProgressTimeoutInMinutes)
        inProgressTimeoutInMinutes = inProgressTimeoutInMinutesDecoded
    }
}

extension IoTJobTimeoutConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IoTJobTimeoutConfig(inProgressTimeoutInMinutes: \(String(describing: inProgressTimeoutInMinutes)))"}
}

/// <p>Contains information about the timeout configuration for a job.</p>
public struct IoTJobTimeoutConfig: Equatable {
    /// <p>The amount of time, in minutes, that devices have to complete the job. The timer starts
    ///       when the job status is set to <code>IN_PROGRESS</code>. If the job status doesn't change to a
    ///       terminal state before the time expires, then the job status is set to
    ///       <code>TIMED_OUT</code>.</p>
    ///          <p>The timeout interval must be between 1 minute and 7 days (10080 minutes).</p>
    public let inProgressTimeoutInMinutes: Int

    public init (
        inProgressTimeoutInMinutes: Int = 0
    )
    {
        self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
    }
}

extension LambdaContainerParams: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case devices
        case memorySizeInKB
        case mountROSysfs
        case volumes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for lambdadevicelist0 in devices {
                try devicesContainer.encode(lambdadevicelist0)
            }
        }
        if memorySizeInKB != 0 {
            try encodeContainer.encode(memorySizeInKB, forKey: .memorySizeInKB)
        }
        if mountROSysfs != false {
            try encodeContainer.encode(mountROSysfs, forKey: .mountROSysfs)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for lambdavolumelist0 in volumes {
                try volumesContainer.encode(lambdavolumelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memorySizeInKBDecoded = try containerValues.decode(Int.self, forKey: .memorySizeInKB)
        memorySizeInKB = memorySizeInKBDecoded
        let mountROSysfsDecoded = try containerValues.decode(Bool.self, forKey: .mountROSysfs)
        mountROSysfs = mountROSysfsDecoded
        let volumesContainer = try containerValues.decodeIfPresent([LambdaVolumeMount?].self, forKey: .volumes)
        var volumesDecoded0:[LambdaVolumeMount]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [LambdaVolumeMount]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
        let devicesContainer = try containerValues.decodeIfPresent([LambdaDeviceMount?].self, forKey: .devices)
        var devicesDecoded0:[LambdaDeviceMount]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [LambdaDeviceMount]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
    }
}

extension LambdaContainerParams: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaContainerParams(devices: \(String(describing: devices)), memorySizeInKB: \(String(describing: memorySizeInKB)), mountROSysfs: \(String(describing: mountROSysfs)), volumes: \(String(describing: volumes)))"}
}

/// <p>Contains information about a container in which AWS Lambda functions run on AWS IoT Greengrass core
///       devices.</p>
public struct LambdaContainerParams: Equatable {
    /// <p>The list of system devices that the container can access.</p>
    public let devices: [LambdaDeviceMount]?
    /// <p>The memory size of the container, expressed in kilobytes.</p>
    ///          <p>Default: <code>16384</code> (16 MB)</p>
    public let memorySizeInKB: Int
    /// <p>Whether or not the container can read information from the device's <code>/sys</code>
    ///       folder.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let mountROSysfs: Bool
    /// <p>The list of volumes that the container can access.</p>
    public let volumes: [LambdaVolumeMount]?

    public init (
        devices: [LambdaDeviceMount]? = nil,
        memorySizeInKB: Int = 0,
        mountROSysfs: Bool = false,
        volumes: [LambdaVolumeMount]? = nil
    )
    {
        self.devices = devices
        self.memorySizeInKB = memorySizeInKB
        self.mountROSysfs = mountROSysfs
        self.volumes = volumes
    }
}

extension LambdaDeviceMount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addGroupOwner
        case path
        case permission
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGroupOwner != false {
            try encodeContainer.encode(addGroupOwner, forKey: .addGroupOwner)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(LambdaFilesystemPermission.self, forKey: .permission)
        permission = permissionDecoded
        let addGroupOwnerDecoded = try containerValues.decode(Bool.self, forKey: .addGroupOwner)
        addGroupOwner = addGroupOwnerDecoded
    }
}

extension LambdaDeviceMount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaDeviceMount(addGroupOwner: \(String(describing: addGroupOwner)), path: \(String(describing: path)), permission: \(String(describing: permission)))"}
}

/// <p>Contains information about a device that Linux processes in a container can access.</p>
public struct LambdaDeviceMount: Equatable {
    /// <p>Whether or not to add the component's system user as an owner of the device.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let addGroupOwner: Bool
    /// <p>The mount path for the device in the file system.</p>
    public let path: String?
    /// <p>The permission to access the device: read/only (<code>ro</code>) or read/write
    ///       (<code>rw</code>).</p>
    ///          <p>Default: <code>ro</code>
    ///          </p>
    public let permission: LambdaFilesystemPermission?

    public init (
        addGroupOwner: Bool = false,
        path: String? = nil,
        permission: LambdaFilesystemPermission? = nil
    )
    {
        self.addGroupOwner = addGroupOwner
        self.path = path
        self.permission = permission
    }
}

extension LambdaEventSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case topic
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topic = topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topic)
        topic = topicDecoded
        let typeDecoded = try containerValues.decodeIfPresent(LambdaEventSourceType.self, forKey: .type)
        type = typeDecoded
    }
}

extension LambdaEventSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaEventSource(topic: \(String(describing: topic)), type: \(String(describing: type)))"}
}

/// <p>Contains information about an event source for an AWS Lambda function. The event source
///       defines the topics on which this Lambda function subscribes to receive messages that run the
///       function.</p>
public struct LambdaEventSource: Equatable {
    /// <p>The topic to which to subscribe to receive event messages.</p>
    public let topic: String?
    /// <p>The type of event source. Choose from the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PUB_SUB</code> – Subscribe to local publish/subscribe messages. This event
    ///           source type doesn't support MQTT wildcards (<code>+</code> and <code>#</code>) in the
    ///           event source topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IOT_CORE</code> – Subscribe to AWS IoT Core MQTT messages. This event source
    ///           type supports MQTT wildcards (<code>+</code> and <code>#</code>) in the event source
    ///           topic.</p>
    ///             </li>
    ///          </ul>
    public let type: LambdaEventSourceType?

    public init (
        topic: String? = nil,
        type: LambdaEventSourceType? = nil
    )
    {
        self.topic = topic
        self.type = type
    }
}

public enum LambdaEventSourceType {
    case iotCore
    case pubSub
    case sdkUnknown(String)
}

extension LambdaEventSourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LambdaEventSourceType] {
        return [
            .iotCore,
            .pubSub,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .iotCore: return "IOT_CORE"
        case .pubSub: return "PUB_SUB"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LambdaEventSourceType(rawValue: rawValue) ?? LambdaEventSourceType.sdkUnknown(rawValue)
    }
}

extension LambdaExecutionParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentVariables
        case eventSources
        case execArgs
        case inputPayloadEncodingType
        case linuxProcessParams
        case maxIdleTimeInSeconds
        case maxInstancesCount
        case maxQueueSize
        case pinned
        case statusTimeoutInSeconds
        case timeoutInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, lambdaenvironmentvariables0) in environmentVariables {
                try environmentVariablesContainer.encode(lambdaenvironmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let eventSources = eventSources {
            var eventSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSources)
            for lambdaeventsourcelist0 in eventSources {
                try eventSourcesContainer.encode(lambdaeventsourcelist0)
            }
        }
        if let execArgs = execArgs {
            var execArgsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .execArgs)
            for lambdaexecargslist0 in execArgs {
                try execArgsContainer.encode(lambdaexecargslist0)
            }
        }
        if let inputPayloadEncodingType = inputPayloadEncodingType {
            try encodeContainer.encode(inputPayloadEncodingType.rawValue, forKey: .inputPayloadEncodingType)
        }
        if let linuxProcessParams = linuxProcessParams {
            try encodeContainer.encode(linuxProcessParams, forKey: .linuxProcessParams)
        }
        if maxIdleTimeInSeconds != 0 {
            try encodeContainer.encode(maxIdleTimeInSeconds, forKey: .maxIdleTimeInSeconds)
        }
        if maxInstancesCount != 0 {
            try encodeContainer.encode(maxInstancesCount, forKey: .maxInstancesCount)
        }
        if maxQueueSize != 0 {
            try encodeContainer.encode(maxQueueSize, forKey: .maxQueueSize)
        }
        if pinned != false {
            try encodeContainer.encode(pinned, forKey: .pinned)
        }
        if statusTimeoutInSeconds != 0 {
            try encodeContainer.encode(statusTimeoutInSeconds, forKey: .statusTimeoutInSeconds)
        }
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourcesContainer = try containerValues.decodeIfPresent([LambdaEventSource?].self, forKey: .eventSources)
        var eventSourcesDecoded0:[LambdaEventSource]? = nil
        if let eventSourcesContainer = eventSourcesContainer {
            eventSourcesDecoded0 = [LambdaEventSource]()
            for structure0 in eventSourcesContainer {
                if let structure0 = structure0 {
                    eventSourcesDecoded0?.append(structure0)
                }
            }
        }
        eventSources = eventSourcesDecoded0
        let maxQueueSizeDecoded = try containerValues.decode(Int.self, forKey: .maxQueueSize)
        maxQueueSize = maxQueueSizeDecoded
        let maxInstancesCountDecoded = try containerValues.decode(Int.self, forKey: .maxInstancesCount)
        maxInstancesCount = maxInstancesCountDecoded
        let maxIdleTimeInSecondsDecoded = try containerValues.decode(Int.self, forKey: .maxIdleTimeInSeconds)
        maxIdleTimeInSeconds = maxIdleTimeInSecondsDecoded
        let timeoutInSecondsDecoded = try containerValues.decode(Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let statusTimeoutInSecondsDecoded = try containerValues.decode(Int.self, forKey: .statusTimeoutInSeconds)
        statusTimeoutInSeconds = statusTimeoutInSecondsDecoded
        let pinnedDecoded = try containerValues.decode(Bool.self, forKey: .pinned)
        pinned = pinnedDecoded
        let inputPayloadEncodingTypeDecoded = try containerValues.decodeIfPresent(LambdaInputPayloadEncodingType.self, forKey: .inputPayloadEncodingType)
        inputPayloadEncodingType = inputPayloadEncodingTypeDecoded
        let execArgsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .execArgs)
        var execArgsDecoded0:[String]? = nil
        if let execArgsContainer = execArgsContainer {
            execArgsDecoded0 = [String]()
            for string0 in execArgsContainer {
                if let string0 = string0 {
                    execArgsDecoded0?.append(string0)
                }
            }
        }
        execArgs = execArgsDecoded0
        let environmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [String:String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [String:String]()
            for (key0, string0) in environmentVariablesContainer {
                if let string0 = string0 {
                    environmentVariablesDecoded0?[key0] = string0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let linuxProcessParamsDecoded = try containerValues.decodeIfPresent(LambdaLinuxProcessParams.self, forKey: .linuxProcessParams)
        linuxProcessParams = linuxProcessParamsDecoded
    }
}

extension LambdaExecutionParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaExecutionParameters(environmentVariables: \(String(describing: environmentVariables)), eventSources: \(String(describing: eventSources)), execArgs: \(String(describing: execArgs)), inputPayloadEncodingType: \(String(describing: inputPayloadEncodingType)), linuxProcessParams: \(String(describing: linuxProcessParams)), maxIdleTimeInSeconds: \(String(describing: maxIdleTimeInSeconds)), maxInstancesCount: \(String(describing: maxInstancesCount)), maxQueueSize: \(String(describing: maxQueueSize)), pinned: \(String(describing: pinned)), statusTimeoutInSeconds: \(String(describing: statusTimeoutInSeconds)), timeoutInSeconds: \(String(describing: timeoutInSeconds)))"}
}

/// <p>Contains parameters for a Lambda function that runs on AWS IoT Greengrass.</p>
public struct LambdaExecutionParameters: Equatable {
    /// <p>The map of environment variables that are available to the Lambda function when it runs.</p>
    public let environmentVariables: [String:String]?
    /// <p>The list of event sources to which to subscribe to receive work messages. The Lambda
    ///       function runs when it receives a message from an event source. You can subscribe this function
    ///       to local publish/subscribe messages and AWS IoT Core MQTT messages.</p>
    public let eventSources: [LambdaEventSource]?
    /// <p>The list of arguments to pass to the Lambda function when it runs.</p>
    public let execArgs: [String]?
    /// <p>The encoding type that the Lambda function supports.</p>
    ///          <p>Default: <code>json</code>
    ///          </p>
    public let inputPayloadEncodingType: LambdaInputPayloadEncodingType?
    /// <p>The parameters for the Linux process that contains the Lambda function.</p>
    public let linuxProcessParams: LambdaLinuxProcessParams?
    /// <p>The maximum amount of time in seconds that a non-pinned Lambda function can idle before the
    ///       AWS IoT Greengrass Core software stops its process.</p>
    public let maxIdleTimeInSeconds: Int
    /// <p>The maximum number of instances that a non-pinned Lambda function can run at the same
    ///       time.</p>
    public let maxInstancesCount: Int
    /// <p>The maximum size of the message queue for the Lambda function component. The AWS IoT Greengrass core
    ///       stores messages in a FIFO (first-in-first-out) queue until it can run the Lambda function to
    ///       consume each message.</p>
    public let maxQueueSize: Int
    /// <p>Whether or not the Lambda function is pinned, or long-lived.</p>
    ///          <ul>
    ///             <li>
    ///                <p>A pinned Lambda function starts
    ///           when AWS IoT Greengrass starts and keeps running in its own container.</p>
    ///             </li>
    ///             <li>
    ///                <p>A non-pinned Lambda function starts only when it receives a work item and exists after
    ///           it idles for <code>maxIdleTimeInSeconds</code>. If the function has multiple work items,
    ///           the AWS IoT Greengrass Core software creates multiple instances of the function.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Default: <code>true</code>
    ///          </p>
    public let pinned: Bool
    /// <p>The interval in seconds at which a pinned (also known as long-lived) Lambda function
    ///       component sends status updates to the Lambda manager component.</p>
    public let statusTimeoutInSeconds: Int
    /// <p>The maximum amount of time in seconds that the Lambda function can process a work
    ///       item.</p>
    public let timeoutInSeconds: Int

    public init (
        environmentVariables: [String:String]? = nil,
        eventSources: [LambdaEventSource]? = nil,
        execArgs: [String]? = nil,
        inputPayloadEncodingType: LambdaInputPayloadEncodingType? = nil,
        linuxProcessParams: LambdaLinuxProcessParams? = nil,
        maxIdleTimeInSeconds: Int = 0,
        maxInstancesCount: Int = 0,
        maxQueueSize: Int = 0,
        pinned: Bool = false,
        statusTimeoutInSeconds: Int = 0,
        timeoutInSeconds: Int = 0
    )
    {
        self.environmentVariables = environmentVariables
        self.eventSources = eventSources
        self.execArgs = execArgs
        self.inputPayloadEncodingType = inputPayloadEncodingType
        self.linuxProcessParams = linuxProcessParams
        self.maxIdleTimeInSeconds = maxIdleTimeInSeconds
        self.maxInstancesCount = maxInstancesCount
        self.maxQueueSize = maxQueueSize
        self.pinned = pinned
        self.statusTimeoutInSeconds = statusTimeoutInSeconds
        self.timeoutInSeconds = timeoutInSeconds
    }
}

public enum LambdaFilesystemPermission {
    case ro
    case rw
    case sdkUnknown(String)
}

extension LambdaFilesystemPermission : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LambdaFilesystemPermission] {
        return [
            .ro,
            .rw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ro: return "ro"
        case .rw: return "rw"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LambdaFilesystemPermission(rawValue: rawValue) ?? LambdaFilesystemPermission.sdkUnknown(rawValue)
    }
}

extension LambdaFunctionRecipeSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentDependencies
        case componentLambdaParameters
        case componentName
        case componentPlatforms
        case componentVersion
        case lambdaArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentDependencies = componentDependencies {
            var componentDependenciesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .componentDependencies)
            for (dictKey0, componentdependencymap0) in componentDependencies {
                try componentDependenciesContainer.encode(componentdependencymap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let componentLambdaParameters = componentLambdaParameters {
            try encodeContainer.encode(componentLambdaParameters, forKey: .componentLambdaParameters)
        }
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentPlatforms = componentPlatforms {
            var componentPlatformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .componentPlatforms)
            for componentplatformlist0 in componentPlatforms {
                try componentPlatformsContainer.encode(componentplatformlist0)
            }
        }
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let lambdaArn = lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let componentPlatformsContainer = try containerValues.decodeIfPresent([ComponentPlatform?].self, forKey: .componentPlatforms)
        var componentPlatformsDecoded0:[ComponentPlatform]? = nil
        if let componentPlatformsContainer = componentPlatformsContainer {
            componentPlatformsDecoded0 = [ComponentPlatform]()
            for structure0 in componentPlatformsContainer {
                if let structure0 = structure0 {
                    componentPlatformsDecoded0?.append(structure0)
                }
            }
        }
        componentPlatforms = componentPlatformsDecoded0
        let componentDependenciesContainer = try containerValues.decodeIfPresent([String: ComponentDependencyRequirement?].self, forKey: .componentDependencies)
        var componentDependenciesDecoded0: [String:ComponentDependencyRequirement]? = nil
        if let componentDependenciesContainer = componentDependenciesContainer {
            componentDependenciesDecoded0 = [String:ComponentDependencyRequirement]()
            for (key0, componentdependencyrequirement0) in componentDependenciesContainer {
                if let componentdependencyrequirement0 = componentdependencyrequirement0 {
                    componentDependenciesDecoded0?[key0] = componentdependencyrequirement0
                }
            }
        }
        componentDependencies = componentDependenciesDecoded0
        let componentLambdaParametersDecoded = try containerValues.decodeIfPresent(LambdaExecutionParameters.self, forKey: .componentLambdaParameters)
        componentLambdaParameters = componentLambdaParametersDecoded
    }
}

extension LambdaFunctionRecipeSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionRecipeSource(componentDependencies: \(String(describing: componentDependencies)), componentLambdaParameters: \(String(describing: componentLambdaParameters)), componentName: \(String(describing: componentName)), componentPlatforms: \(String(describing: componentPlatforms)), componentVersion: \(String(describing: componentVersion)), lambdaArn: \(String(describing: lambdaArn)))"}
}

/// <p>Contains information about an AWS Lambda function to import to create a component.</p>
public struct LambdaFunctionRecipeSource: Equatable {
    /// <p>The component versions on which this Lambda function component depends.</p>
    public let componentDependencies: [String:ComponentDependencyRequirement]?
    /// <p>The system and runtime parameters for the Lambda function as it runs on the AWS IoT Greengrass core
    ///       device.</p>
    public let componentLambdaParameters: LambdaExecutionParameters?
    /// <p>The name of the component.</p>
    ///          <p>Defaults to the name of the Lambda function.</p>
    public let componentName: String?
    /// <p>The platforms that the component version supports.</p>
    public let componentPlatforms: [ComponentPlatform]?
    /// <p>The version of the component.</p>
    ///          <p>Defaults to the version of the Lambda function as a semantic version. For example, if your
    ///       function version is <code>3</code>, the component version becomes <code>3.0.0</code>.</p>
    public let componentVersion: String?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Lambda function. The ARN must include the version of the function to
    ///       import. You can't use version aliases like <code>$LATEST</code>.</p>
    public let lambdaArn: String?

    public init (
        componentDependencies: [String:ComponentDependencyRequirement]? = nil,
        componentLambdaParameters: LambdaExecutionParameters? = nil,
        componentName: String? = nil,
        componentPlatforms: [ComponentPlatform]? = nil,
        componentVersion: String? = nil,
        lambdaArn: String? = nil
    )
    {
        self.componentDependencies = componentDependencies
        self.componentLambdaParameters = componentLambdaParameters
        self.componentName = componentName
        self.componentPlatforms = componentPlatforms
        self.componentVersion = componentVersion
        self.lambdaArn = lambdaArn
    }
}

public enum LambdaInputPayloadEncodingType {
    case binary
    case json
    case sdkUnknown(String)
}

extension LambdaInputPayloadEncodingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LambdaInputPayloadEncodingType] {
        return [
            .binary,
            .json,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .binary: return "binary"
        case .json: return "json"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LambdaInputPayloadEncodingType(rawValue: rawValue) ?? LambdaInputPayloadEncodingType.sdkUnknown(rawValue)
    }
}

public enum LambdaIsolationMode {
    case greengrassContainer
    case noContainer
    case sdkUnknown(String)
}

extension LambdaIsolationMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LambdaIsolationMode] {
        return [
            .greengrassContainer,
            .noContainer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .greengrassContainer: return "GreengrassContainer"
        case .noContainer: return "NoContainer"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LambdaIsolationMode(rawValue: rawValue) ?? LambdaIsolationMode.sdkUnknown(rawValue)
    }
}

extension LambdaLinuxProcessParams: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerParams
        case isolationMode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerParams = containerParams {
            try encodeContainer.encode(containerParams, forKey: .containerParams)
        }
        if let isolationMode = isolationMode {
            try encodeContainer.encode(isolationMode.rawValue, forKey: .isolationMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isolationModeDecoded = try containerValues.decodeIfPresent(LambdaIsolationMode.self, forKey: .isolationMode)
        isolationMode = isolationModeDecoded
        let containerParamsDecoded = try containerValues.decodeIfPresent(LambdaContainerParams.self, forKey: .containerParams)
        containerParams = containerParamsDecoded
    }
}

extension LambdaLinuxProcessParams: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaLinuxProcessParams(containerParams: \(String(describing: containerParams)), isolationMode: \(String(describing: isolationMode)))"}
}

/// <p>Contains parameters for a Linux process that contains an AWS Lambda function.</p>
public struct LambdaLinuxProcessParams: Equatable {
    /// <p>The parameters for the container in which the Lambda function runs.</p>
    public let containerParams: LambdaContainerParams?
    /// <p>The isolation mode for the process that contains the Lambda function. The process can run
    ///       in an isolated runtime environment inside the AWS IoT Greengrass container, or as a regular process outside
    ///       any container.</p>
    ///          <p>Default: <code>GreengrassContainer</code>
    ///          </p>
    public let isolationMode: LambdaIsolationMode?

    public init (
        containerParams: LambdaContainerParams? = nil,
        isolationMode: LambdaIsolationMode? = nil
    )
    {
        self.containerParams = containerParams
        self.isolationMode = isolationMode
    }
}

extension LambdaVolumeMount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addGroupOwner
        case destinationPath
        case permission
        case sourcePath
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGroupOwner != false {
            try encodeContainer.encode(addGroupOwner, forKey: .addGroupOwner)
        }
        if let destinationPath = destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
        if let sourcePath = sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
        let destinationPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(LambdaFilesystemPermission.self, forKey: .permission)
        permission = permissionDecoded
        let addGroupOwnerDecoded = try containerValues.decode(Bool.self, forKey: .addGroupOwner)
        addGroupOwner = addGroupOwnerDecoded
    }
}

extension LambdaVolumeMount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaVolumeMount(addGroupOwner: \(String(describing: addGroupOwner)), destinationPath: \(String(describing: destinationPath)), permission: \(String(describing: permission)), sourcePath: \(String(describing: sourcePath)))"}
}

/// <p>Contains information about a volume that Linux processes in a container can access. When
///       you define a volume, the AWS IoT Greengrass Core software mounts the source files to the destination inside the
///       container.</p>
public struct LambdaVolumeMount: Equatable {
    /// <p>Whether or not to add the AWS IoT Greengrass user group as an owner of the volume.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let addGroupOwner: Bool
    /// <p>The path to the logical volume in the file system.</p>
    public let destinationPath: String?
    /// <p>The permission to access the volume: read/only (<code>ro</code>) or read/write
    ///         (<code>rw</code>).</p>
    ///          <p>Default: <code>ro</code>
    ///          </p>
    public let permission: LambdaFilesystemPermission?
    /// <p>The path to the physical volume in the file system.</p>
    public let sourcePath: String?

    public init (
        addGroupOwner: Bool = false,
        destinationPath: String? = nil,
        permission: LambdaFilesystemPermission? = nil,
        sourcePath: String? = nil
    )
    {
        self.addGroupOwner = addGroupOwner
        self.destinationPath = destinationPath
        self.permission = permission
        self.sourcePath = sourcePath
    }
}

extension ListComponentVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComponentVersionsInput(arn: \(String(describing: arn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListComponentVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListComponentVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListComponentVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentVersionsInput>
    public typealias MOutput = OperationOutput<ListComponentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentVersionsOutputError>
}

public struct ListComponentVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListComponentVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentVersionsInput>
    public typealias MOutput = OperationOutput<ListComponentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentVersionsOutputError>
}

public struct ListComponentVersionsInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the component version.</p>
    public let arn: String?
    /// <p>The maximum number of results to be returned per paginated request.</p>
    public let maxResults: Int
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComponentVersionsInputBody: Equatable {
}

extension ListComponentVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListComponentVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComponentVersionsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComponentVersionsOutputResponse(componentVersions: \(String(describing: componentVersions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListComponentVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComponentVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentVersions = output.componentVersions
            self.nextToken = output.nextToken
        } else {
            self.componentVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentVersionsOutputResponse: Equatable {
    /// <p>A list of versions that exist for the component.</p>
    public let componentVersions: [ComponentVersionListItem]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        componentVersions: [ComponentVersionListItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.componentVersions = componentVersions
        self.nextToken = nextToken
    }
}

struct ListComponentVersionsOutputResponseBody: Equatable {
    public let componentVersions: [ComponentVersionListItem]?
    public let nextToken: String?
}

extension ListComponentVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentVersions
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentVersionsContainer = try containerValues.decodeIfPresent([ComponentVersionListItem?].self, forKey: .componentVersions)
        var componentVersionsDecoded0:[ComponentVersionListItem]? = nil
        if let componentVersionsContainer = componentVersionsContainer {
            componentVersionsDecoded0 = [ComponentVersionListItem]()
            for structure0 in componentVersionsContainer {
                if let structure0 = structure0 {
                    componentVersionsDecoded0?.append(structure0)
                }
            }
        }
        componentVersions = componentVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComponentsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), scope: \(String(describing: scope)))"}
}

extension ListComponentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListComponentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListComponentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentsInput>
    public typealias MOutput = OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentsOutputError>
}

public struct ListComponentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListComponentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let scope = input.operationInput.scope {
            let scopeQueryItem = URLQueryItem(name: "scope".urlPercentEncoding(), value: String(scope.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(scopeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentsInput>
    public typealias MOutput = OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentsOutputError>
}

public struct ListComponentsInput: Equatable {
    /// <p>The maximum number of results to be returned per paginated request.</p>
    public let maxResults: Int
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>The scope of the components to list.</p>
    ///          <p>Default: <code>PRIVATE</code>
    ///          </p>
    public let scope: ComponentVisibilityScope?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        scope: ComponentVisibilityScope? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scope = scope
    }
}

struct ListComponentsInputBody: Equatable {
}

extension ListComponentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListComponentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComponentsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComponentsOutputResponse(components: \(String(describing: components)), nextToken: \(String(describing: nextToken)))"}
}

extension ListComponentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.components = output.components
            self.nextToken = output.nextToken
        } else {
            self.components = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutputResponse: Equatable {
    /// <p>A list that summarizes each component.</p>
    public let components: [Component]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        components: [Component]? = nil,
        nextToken: String? = nil
    )
    {
        self.components = components
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputResponseBody: Equatable {
    public let components: [Component]?
    public let nextToken: String?
}

extension ListComponentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case components
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentsContainer = try containerValues.decodeIfPresent([Component?].self, forKey: .components)
        var componentsDecoded0:[Component]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Component]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCoreDevicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCoreDevicesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), status: \(String(describing: status)), thingGroupArn: \(String(describing: thingGroupArn)))"}
}

extension ListCoreDevicesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCoreDevicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListCoreDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCoreDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCoreDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCoreDevicesInput>
    public typealias MOutput = OperationOutput<ListCoreDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCoreDevicesOutputError>
}

public struct ListCoreDevicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCoreDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCoreDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCoreDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let thingGroupArn = input.operationInput.thingGroupArn {
            let thingGroupArnQueryItem = URLQueryItem(name: "thingGroupArn".urlPercentEncoding(), value: String(thingGroupArn).urlPercentEncoding())
            input.builder.withQueryItem(thingGroupArnQueryItem)
        }
        if let status = input.operationInput.status {
            let statusQueryItem = URLQueryItem(name: "status".urlPercentEncoding(), value: String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCoreDevicesInput>
    public typealias MOutput = OperationOutput<ListCoreDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCoreDevicesOutputError>
}

public struct ListCoreDevicesInput: Equatable {
    /// <p>The maximum number of results to be returned per paginated request.</p>
    public let maxResults: Int
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>The core device status by which to filter. If you specify this parameter, the list
    ///       includes only core devices that have this status. Choose one of the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HEALTHY</code> – The AWS IoT Greengrass Core software and all components run on the core device without issue.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNHEALTHY</code> – The AWS IoT Greengrass Core software or a component is in a failed state
    ///           on the core device.</p>
    ///             </li>
    ///          </ul>
    public let status: CoreDeviceStatus?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the AWS IoT thing group by which to filter. If you specify this parameter, the
    ///       list includes only core devices that are members of this thing group.</p>
    public let thingGroupArn: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        status: CoreDeviceStatus? = nil,
        thingGroupArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.thingGroupArn = thingGroupArn
    }
}

struct ListCoreDevicesInputBody: Equatable {
}

extension ListCoreDevicesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCoreDevicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCoreDevicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCoreDevicesOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCoreDevicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCoreDevicesOutputResponse(coreDevices: \(String(describing: coreDevices)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCoreDevicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCoreDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreDevices = output.coreDevices
            self.nextToken = output.nextToken
        } else {
            self.coreDevices = nil
            self.nextToken = nil
        }
    }
}

public struct ListCoreDevicesOutputResponse: Equatable {
    /// <p>A list that summarizes each core device.</p>
    public let coreDevices: [CoreDevice]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        coreDevices: [CoreDevice]? = nil,
        nextToken: String? = nil
    )
    {
        self.coreDevices = coreDevices
        self.nextToken = nextToken
    }
}

struct ListCoreDevicesOutputResponseBody: Equatable {
    public let coreDevices: [CoreDevice]?
    public let nextToken: String?
}

extension ListCoreDevicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case coreDevices
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreDevicesContainer = try containerValues.decodeIfPresent([CoreDevice?].self, forKey: .coreDevices)
        var coreDevicesDecoded0:[CoreDevice]? = nil
        if let coreDevicesContainer = coreDevicesContainer {
            coreDevicesDecoded0 = [CoreDevice]()
            for structure0 in coreDevicesContainer {
                if let structure0 = structure0 {
                    coreDevicesDecoded0?.append(structure0)
                }
            }
        }
        coreDevices = coreDevicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeploymentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeploymentsInput(historyFilter: \(String(describing: historyFilter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), targetArn: \(String(describing: targetArn)))"}
}

extension ListDeploymentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDeploymentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeploymentsInput>
    public typealias MOutput = OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let historyFilter = input.operationInput.historyFilter {
            let historyFilterQueryItem = URLQueryItem(name: "historyFilter".urlPercentEncoding(), value: String(historyFilter.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(historyFilterQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let targetArn = input.operationInput.targetArn {
            let targetArnQueryItem = URLQueryItem(name: "targetArn".urlPercentEncoding(), value: String(targetArn).urlPercentEncoding())
            input.builder.withQueryItem(targetArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeploymentsInput>
    public typealias MOutput = OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInput: Equatable {
    /// <p>The filter for the list of deployments. Choose one of the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALL</code> – The list includes all deployments.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LATEST_ONLY</code> – The list includes only the latest revision of each
    ///           deployment.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Default: <code>LATEST_ONLY</code>
    ///          </p>
    public let historyFilter: DeploymentHistoryFilter?
    /// <p>The maximum number of results to be returned per paginated request.</p>
    public let maxResults: Int
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the target AWS IoT thing or thing group.</p>
    public let targetArn: String?

    public init (
        historyFilter: DeploymentHistoryFilter? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        targetArn: String? = nil
    )
    {
        self.historyFilter = historyFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetArn = targetArn
    }
}

struct ListDeploymentsInputBody: Equatable {
}

extension ListDeploymentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDeploymentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeploymentsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeploymentsOutputResponse(deployments: \(String(describing: deployments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeploymentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
            self.nextToken = output.nextToken
        } else {
            self.deployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutputResponse: Equatable {
    /// <p>A list that summarizes each deployment.</p>
    public let deployments: [Deployment]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        deployments: [Deployment]? = nil,
        nextToken: String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputResponseBody: Equatable {
    public let deployments: [Deployment]?
    public let nextToken: String?
}

extension ListDeploymentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deployments
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([Deployment?].self, forKey: .deployments)
        var deploymentsDecoded0:[Deployment]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [Deployment]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEffectiveDeploymentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEffectiveDeploymentsInput(coreDeviceThingName: \(String(describing: coreDeviceThingName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEffectiveDeploymentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEffectiveDeploymentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEffectiveDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEffectiveDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEffectiveDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEffectiveDeploymentsInput>
    public typealias MOutput = OperationOutput<ListEffectiveDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEffectiveDeploymentsOutputError>
}

public struct ListEffectiveDeploymentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEffectiveDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEffectiveDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEffectiveDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEffectiveDeploymentsInput>
    public typealias MOutput = OperationOutput<ListEffectiveDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEffectiveDeploymentsOutputError>
}

public struct ListEffectiveDeploymentsInput: Equatable {
    /// <p>The name of the core device. This is also the name of the AWS IoT thing.</p>
    public let coreDeviceThingName: String?
    /// <p>The maximum number of results to be returned per paginated request.</p>
    public let maxResults: Int
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?

    public init (
        coreDeviceThingName: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEffectiveDeploymentsInputBody: Equatable {
}

extension ListEffectiveDeploymentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEffectiveDeploymentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEffectiveDeploymentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEffectiveDeploymentsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEffectiveDeploymentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEffectiveDeploymentsOutputResponse(effectiveDeployments: \(String(describing: effectiveDeployments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEffectiveDeploymentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEffectiveDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.effectiveDeployments = output.effectiveDeployments
            self.nextToken = output.nextToken
        } else {
            self.effectiveDeployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListEffectiveDeploymentsOutputResponse: Equatable {
    /// <p>A list that summarizes each deployment on the core device.</p>
    public let effectiveDeployments: [EffectiveDeployment]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        effectiveDeployments: [EffectiveDeployment]? = nil,
        nextToken: String? = nil
    )
    {
        self.effectiveDeployments = effectiveDeployments
        self.nextToken = nextToken
    }
}

struct ListEffectiveDeploymentsOutputResponseBody: Equatable {
    public let effectiveDeployments: [EffectiveDeployment]?
    public let nextToken: String?
}

extension ListEffectiveDeploymentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case effectiveDeployments
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectiveDeploymentsContainer = try containerValues.decodeIfPresent([EffectiveDeployment?].self, forKey: .effectiveDeployments)
        var effectiveDeploymentsDecoded0:[EffectiveDeployment]? = nil
        if let effectiveDeploymentsContainer = effectiveDeploymentsContainer {
            effectiveDeploymentsDecoded0 = [EffectiveDeployment]()
            for structure0 in effectiveDeploymentsContainer {
                if let structure0 = structure0 {
                    effectiveDeploymentsDecoded0?.append(structure0)
                }
            }
        }
        effectiveDeployments = effectiveDeploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstalledComponentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstalledComponentsInput(coreDeviceThingName: \(String(describing: coreDeviceThingName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInstalledComponentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListInstalledComponentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInstalledComponentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstalledComponentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstalledComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstalledComponentsInput>
    public typealias MOutput = OperationOutput<ListInstalledComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstalledComponentsOutputError>
}

public struct ListInstalledComponentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInstalledComponentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstalledComponentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstalledComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstalledComponentsInput>
    public typealias MOutput = OperationOutput<ListInstalledComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstalledComponentsOutputError>
}

public struct ListInstalledComponentsInput: Equatable {
    /// <p>The name of the core device. This is also the name of the AWS IoT thing.</p>
    public let coreDeviceThingName: String?
    /// <p>The maximum number of results to be returned per paginated request.</p>
    public let maxResults: Int
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?

    public init (
        coreDeviceThingName: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstalledComponentsInputBody: Equatable {
}

extension ListInstalledComponentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListInstalledComponentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstalledComponentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstalledComponentsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstalledComponentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstalledComponentsOutputResponse(installedComponents: \(String(describing: installedComponents)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInstalledComponentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInstalledComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.installedComponents = output.installedComponents
            self.nextToken = output.nextToken
        } else {
            self.installedComponents = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstalledComponentsOutputResponse: Equatable {
    /// <p>A list that summarizes each component on the core device.</p>
    public let installedComponents: [InstalledComponent]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        installedComponents: [InstalledComponent]? = nil,
        nextToken: String? = nil
    )
    {
        self.installedComponents = installedComponents
        self.nextToken = nextToken
    }
}

struct ListInstalledComponentsOutputResponseBody: Equatable {
    public let installedComponents: [InstalledComponent]?
    public let nextToken: String?
}

extension ListInstalledComponentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case installedComponents
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let installedComponentsContainer = try containerValues.decodeIfPresent([InstalledComponent?].self, forKey: .installedComponents)
        var installedComponentsDecoded0:[InstalledComponent]? = nil
        if let installedComponentsContainer = installedComponentsContainer {
            installedComponentsDecoded0 = [InstalledComponent]()
            for structure0 in installedComponentsContainer {
                if let structure0 = structure0 {
                    installedComponentsDecoded0?.append(structure0)
                }
            }
        }
        installedComponents = installedComponentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum RecipeOutputFormat {
    case json
    case yaml
    case sdkUnknown(String)
}

extension RecipeOutputFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecipeOutputFormat] {
        return [
            .json,
            .yaml,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .json: return "JSON"
        case .yaml: return "YAML"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecipeOutputFormat(rawValue: rawValue) ?? RecipeOutputFormat.sdkUnknown(rawValue)
    }
}

public struct ResolveComponentCandidatesInputBodyMiddleware: Middleware {
    public let id: String = "ResolveComponentCandidatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResolveComponentCandidatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ResolveComponentCandidatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResolveComponentCandidatesInput>
    public typealias MOutput = OperationOutput<ResolveComponentCandidatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResolveComponentCandidatesOutputError>
}

extension ResolveComponentCandidatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolveComponentCandidatesInput(componentCandidates: \(String(describing: componentCandidates)), platform: \(String(describing: platform)))"}
}

extension ResolveComponentCandidatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentCandidates
        case platform
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentCandidates = componentCandidates {
            var componentCandidatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .componentCandidates)
            for componentcandidatelist0 in componentCandidates {
                try componentCandidatesContainer.encode(componentcandidatelist0)
            }
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
    }
}

public struct ResolveComponentCandidatesInputHeadersMiddleware: Middleware {
    public let id: String = "ResolveComponentCandidatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResolveComponentCandidatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ResolveComponentCandidatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResolveComponentCandidatesInput>
    public typealias MOutput = OperationOutput<ResolveComponentCandidatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResolveComponentCandidatesOutputError>
}

public struct ResolveComponentCandidatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ResolveComponentCandidatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResolveComponentCandidatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ResolveComponentCandidatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResolveComponentCandidatesInput>
    public typealias MOutput = OperationOutput<ResolveComponentCandidatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResolveComponentCandidatesOutputError>
}

public struct ResolveComponentCandidatesInput: Equatable {
    /// <p>The list of components to resolve.</p>
    public let componentCandidates: [ComponentCandidate]?
    /// <p>The platform to use to resolve compatible components.</p>
    public let platform: ComponentPlatform?

    public init (
        componentCandidates: [ComponentCandidate]? = nil,
        platform: ComponentPlatform? = nil
    )
    {
        self.componentCandidates = componentCandidates
        self.platform = platform
    }
}

struct ResolveComponentCandidatesInputBody: Equatable {
    public let platform: ComponentPlatform?
    public let componentCandidates: [ComponentCandidate]?
}

extension ResolveComponentCandidatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentCandidates
        case platform
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformDecoded = try containerValues.decodeIfPresent(ComponentPlatform.self, forKey: .platform)
        platform = platformDecoded
        let componentCandidatesContainer = try containerValues.decodeIfPresent([ComponentCandidate?].self, forKey: .componentCandidates)
        var componentCandidatesDecoded0:[ComponentCandidate]? = nil
        if let componentCandidatesContainer = componentCandidatesContainer {
            componentCandidatesDecoded0 = [ComponentCandidate]()
            for structure0 in componentCandidatesContainer {
                if let structure0 = structure0 {
                    componentCandidatesDecoded0?.append(structure0)
                }
            }
        }
        componentCandidates = componentCandidatesDecoded0
    }
}

extension ResolveComponentCandidatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResolveComponentCandidatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResolveComponentCandidatesOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResolveComponentCandidatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolveComponentCandidatesOutputResponse(resolvedComponentVersions: \(String(describing: resolvedComponentVersions)))"}
}

extension ResolveComponentCandidatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResolveComponentCandidatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolvedComponentVersions = output.resolvedComponentVersions
        } else {
            self.resolvedComponentVersions = nil
        }
    }
}

public struct ResolveComponentCandidatesOutputResponse: Equatable {
    /// <p>A list of components that meet the requirements that you specify in the request. This list
    ///       includes each component's recipe that you can use to install the component.</p>
    public let resolvedComponentVersions: [ResolvedComponentVersion]?

    public init (
        resolvedComponentVersions: [ResolvedComponentVersion]? = nil
    )
    {
        self.resolvedComponentVersions = resolvedComponentVersions
    }
}

struct ResolveComponentCandidatesOutputResponseBody: Equatable {
    public let resolvedComponentVersions: [ResolvedComponentVersion]?
}

extension ResolveComponentCandidatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolvedComponentVersions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolvedComponentVersionsContainer = try containerValues.decodeIfPresent([ResolvedComponentVersion?].self, forKey: .resolvedComponentVersions)
        var resolvedComponentVersionsDecoded0:[ResolvedComponentVersion]? = nil
        if let resolvedComponentVersionsContainer = resolvedComponentVersionsContainer {
            resolvedComponentVersionsDecoded0 = [ResolvedComponentVersion]()
            for structure0 in resolvedComponentVersionsContainer {
                if let structure0 = structure0 {
                    resolvedComponentVersionsDecoded0?.append(structure0)
                }
            }
        }
        resolvedComponentVersions = resolvedComponentVersionsDecoded0
    }
}

extension ResolvedComponentVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case componentName
        case componentVersion
        case recipe
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let recipe = recipe {
            try encodeContainer.encode(recipe.base64EncodedString(), forKey: .recipe)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let recipeDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .recipe)
        recipe = recipeDecoded
    }
}

extension ResolvedComponentVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolvedComponentVersion(arn: \(String(describing: arn)), componentName: \(String(describing: componentName)), componentVersion: \(String(describing: componentVersion)), recipe: \(String(describing: recipe)))"}
}

/// <p>Contains information about a component version that is compatible to run on a AWS IoT Greengrass core
///       device.</p>
public struct ResolvedComponentVersion: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the component version.</p>
    public let arn: String?
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The version of the component.</p>
    public let componentVersion: String?
    /// <p>The recipe of the component version.</p>
    public let recipe: Data?

    public init (
        arn: String? = nil,
        componentName: String? = nil,
        componentVersion: String? = nil,
        recipe: Data? = nil
    )
    {
        self.arn = arn
        self.componentName = componentName
        self.componentVersion = componentVersion
        self.recipe = recipe
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource can't be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ID of the resource that isn't found.</p>
    public var resourceId: String?
    /// <p>The type of the resource that isn't found.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request exceeds a service quota. For example, you might have the maximum number of
///       components that you can create.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The code for the quota in <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html">Service Quotas</a>.</p>
    public var quotaCode: String?
    /// <p>The ID of the resource that exceeds the service quota.</p>
    public var resourceId: String?
    /// <p>The type of the resource that exceeds the service quota.</p>
    public var resourceType: String?
    /// <p>The code for the service in <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html">Service Quotas</a>.</p>
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
    public let quotaCode: String?
    public let serviceCode: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource to tag.</p>
    public let resourceArn: String?
    /// <p>A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources</a> in the <i>AWS IoT Greengrass V2 Developer Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), retryAfterSeconds: \(String(describing: retryAfterSeconds)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request exceeded a request rate quota. For example, you might have exceeded the
///       amount of times that you can retrieve device or deployment status per second.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The code for the quota in <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html">Service Quotas</a>.</p>
    public var quotaCode: String?
    /// <p>The amount of time to wait before you retry the request.</p>
    public var retryAfterSeconds: Int
    /// <p>The code for the service in <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html">Service Quotas</a>.</p>
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        retryAfterSeconds: Int = 0,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
    public let quotaCode: String?
    public let serviceCode: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource to untag.</p>
    public let resourceArn: String?
    /// <p>A list of keys for tags to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(fields: \(String(describing: fields)), message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request isn't valid. This can occur if your request contains malformed JSON or
///       unsupported characters.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The list of fields that failed to validate.</p>
    public var fields: [ValidationExceptionField]?
    public var message: String?
    /// <p>The reason for the validation exception.</p>
    public var reason: ValidationExceptionReason?

    public init (
        fields: [ValidationExceptionField]? = nil,
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let reason: ValidationExceptionReason?
    public let fields: [ValidationExceptionField]?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fields
        case message
        case reason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ValidationExceptionField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationExceptionField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationExceptionField(message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>Contains information about a validation exception field.</p>
public struct ValidationExceptionField: Equatable {
    /// <p>The message of the exception field.</p>
    public let message: String?
    /// <p>The name of the exception field.</p>
    public let name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

public enum ValidationExceptionReason {
    case cannotParse
    case fieldValidationFailed
    case other
    case unknownOperation
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .cannotParse,
            .fieldValidationFailed,
            .other,
            .unknownOperation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cannotParse: return "CANNOT_PARSE"
        case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
        case .other: return "OTHER"
        case .unknownOperation: return "UNKNOWN_OPERATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}
