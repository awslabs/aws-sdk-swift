// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requestor does not have permission to access the target action or resource.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PanoramaClientTypes.AlternateSoftwareMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension PanoramaClientTypes {
    /// Details about a beta appliance software update.
    public struct AlternateSoftwareMetadata: Swift.Equatable {
        /// The appliance software version.
        public var version: Swift.String?

        public init (
            version: Swift.String? = nil
        )
        {
            self.version = version
        }
    }

}

extension PanoramaClientTypes.ApplicationInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceId = "ApplicationInstanceId"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
        case defaultRuntimeContextDeviceName = "DefaultRuntimeContextDeviceName"
        case description = "Description"
        case healthStatus = "HealthStatus"
        case name = "Name"
        case runtimeContextStates = "RuntimeContextStates"
        case status = "Status"
        case statusDescription = "StatusDescription"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationInstanceId = self.applicationInstanceId {
            try encodeContainer.encode(applicationInstanceId, forKey: .applicationInstanceId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let defaultRuntimeContextDevice = self.defaultRuntimeContextDevice {
            try encodeContainer.encode(defaultRuntimeContextDevice, forKey: .defaultRuntimeContextDevice)
        }
        if let defaultRuntimeContextDeviceName = self.defaultRuntimeContextDeviceName {
            try encodeContainer.encode(defaultRuntimeContextDeviceName, forKey: .defaultRuntimeContextDeviceName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let healthStatus = self.healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runtimeContextStates = runtimeContextStates {
            var runtimeContextStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runtimeContextStates)
            for reportedruntimecontextstate0 in runtimeContextStates {
                try runtimeContextStatesContainer.encode(reportedruntimecontextstate0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDescription = self.statusDescription {
            try encodeContainer.encode(statusDescription, forKey: .statusDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let applicationInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceId)
        applicationInstanceId = applicationInstanceIdDecoded
        let defaultRuntimeContextDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRuntimeContextDevice)
        defaultRuntimeContextDevice = defaultRuntimeContextDeviceDecoded
        let defaultRuntimeContextDeviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRuntimeContextDeviceName)
        defaultRuntimeContextDeviceName = defaultRuntimeContextDeviceNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ApplicationInstanceStatus.self, forKey: .status)
        status = statusDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ApplicationInstanceHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let statusDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDescription)
        statusDescription = statusDescriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let runtimeContextStatesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.ReportedRuntimeContextState?].self, forKey: .runtimeContextStates)
        var runtimeContextStatesDecoded0:[PanoramaClientTypes.ReportedRuntimeContextState]? = nil
        if let runtimeContextStatesContainer = runtimeContextStatesContainer {
            runtimeContextStatesDecoded0 = [PanoramaClientTypes.ReportedRuntimeContextState]()
            for structure0 in runtimeContextStatesContainer {
                if let structure0 = structure0 {
                    runtimeContextStatesDecoded0?.append(structure0)
                }
            }
        }
        runtimeContextStates = runtimeContextStatesDecoded0
    }
}

extension PanoramaClientTypes {
    /// An application instance on a device.
    public struct ApplicationInstance: Swift.Equatable {
        /// The application instance's ID.
        public var applicationInstanceId: Swift.String?
        /// The application instance's ARN.
        public var arn: Swift.String?
        /// When the application instance was created.
        public var createdTime: ClientRuntime.Date?
        /// The device's ID.
        public var defaultRuntimeContextDevice: Swift.String?
        /// The device's name.
        public var defaultRuntimeContextDeviceName: Swift.String?
        /// The application instance's description.
        public var description: Swift.String?
        /// The application instance's health status.
        public var healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus?
        /// The application instance's name.
        public var name: Swift.String?
        /// The application's state.
        public var runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]?
        /// The application instance's status.
        public var status: PanoramaClientTypes.ApplicationInstanceStatus?
        /// The application instance's status description.
        public var statusDescription: Swift.String?
        /// The application instance's tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            applicationInstanceId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            defaultRuntimeContextDevice: Swift.String? = nil,
            defaultRuntimeContextDeviceName: Swift.String? = nil,
            description: Swift.String? = nil,
            healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus? = nil,
            name: Swift.String? = nil,
            runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]? = nil,
            status: PanoramaClientTypes.ApplicationInstanceStatus? = nil,
            statusDescription: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.applicationInstanceId = applicationInstanceId
            self.arn = arn
            self.createdTime = createdTime
            self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
            self.defaultRuntimeContextDeviceName = defaultRuntimeContextDeviceName
            self.description = description
            self.healthStatus = healthStatus
            self.name = name
            self.runtimeContextStates = runtimeContextStates
            self.status = status
            self.statusDescription = statusDescription
            self.tags = tags
        }
    }

}

extension PanoramaClientTypes {
    public enum ApplicationInstanceHealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case notAvailable
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationInstanceHealthStatus] {
            return [
                .error,
                .notAvailable,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .notAvailable: return "NOT_AVAILABLE"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationInstanceHealthStatus(rawValue: rawValue) ?? ApplicationInstanceHealthStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum ApplicationInstanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deploymentError
        case deploymentFailed
        case deploymentInProgress
        case deploymentPending
        case deploymentRequested
        case deploymentSucceeded
        case removalFailed
        case removalInProgress
        case removalPending
        case removalRequested
        case removalSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationInstanceStatus] {
            return [
                .deploymentError,
                .deploymentFailed,
                .deploymentInProgress,
                .deploymentPending,
                .deploymentRequested,
                .deploymentSucceeded,
                .removalFailed,
                .removalInProgress,
                .removalPending,
                .removalRequested,
                .removalSucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deploymentError: return "DEPLOYMENT_ERROR"
            case .deploymentFailed: return "DEPLOYMENT_FAILED"
            case .deploymentInProgress: return "DEPLOYMENT_IN_PROGRESS"
            case .deploymentPending: return "DEPLOYMENT_PENDING"
            case .deploymentRequested: return "DEPLOYMENT_REQUESTED"
            case .deploymentSucceeded: return "DEPLOYMENT_SUCCEEDED"
            case .removalFailed: return "REMOVAL_FAILED"
            case .removalInProgress: return "REMOVAL_IN_PROGRESS"
            case .removalPending: return "REMOVAL_PENDING"
            case .removalRequested: return "REMOVAL_REQUESTED"
            case .removalSucceeded: return "REMOVAL_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationInstanceStatus(rawValue: rawValue) ?? ApplicationInstanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorArguments = output.errorArguments
            self.errorId = output.errorId
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.errorArguments = nil
            self.errorId = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The target resource is in use.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A list of attributes that led to the exception and their values.
    public var errorArguments: [PanoramaClientTypes.ConflictExceptionErrorArgument]?
    /// A unique ID for the error.
    public var errorId: Swift.String?
    /// This member is required.
    public var message: Swift.String?
    /// The resource's ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource's type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        errorArguments: [PanoramaClientTypes.ConflictExceptionErrorArgument]? = nil,
        errorId: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.errorArguments = errorArguments
        self.errorId = errorId
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let errorId: Swift.String?
    let errorArguments: [PanoramaClientTypes.ConflictExceptionErrorArgument]?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorArguments = "ErrorArguments"
        case errorId = "ErrorId"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let errorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorId)
        errorId = errorIdDecoded
        let errorArgumentsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.ConflictExceptionErrorArgument?].self, forKey: .errorArguments)
        var errorArgumentsDecoded0:[PanoramaClientTypes.ConflictExceptionErrorArgument]? = nil
        if let errorArgumentsContainer = errorArgumentsContainer {
            errorArgumentsDecoded0 = [PanoramaClientTypes.ConflictExceptionErrorArgument]()
            for structure0 in errorArgumentsContainer {
                if let structure0 = structure0 {
                    errorArgumentsDecoded0?.append(structure0)
                }
            }
        }
        errorArguments = errorArgumentsDecoded0
    }
}

extension PanoramaClientTypes.ConflictExceptionErrorArgument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PanoramaClientTypes {
    /// A conflict exception error argument.
    public struct ConflictExceptionErrorArgument: Swift.Equatable {
        /// The error argument's name.
        /// This member is required.
        public var name: Swift.String?
        /// The error argument's value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension PanoramaClientTypes {
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dhcp
        case staticIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .dhcp,
                .staticIp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dhcp: return "DHCP"
            case .staticIp: return "STATIC_IP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
        }
    }
}

extension CreateApplicationInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceIdToReplace = "ApplicationInstanceIdToReplace"
        case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
        case description = "Description"
        case manifestOverridesPayload = "ManifestOverridesPayload"
        case manifestPayload = "ManifestPayload"
        case name = "Name"
        case runtimeRoleArn = "RuntimeRoleArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationInstanceIdToReplace = self.applicationInstanceIdToReplace {
            try encodeContainer.encode(applicationInstanceIdToReplace, forKey: .applicationInstanceIdToReplace)
        }
        if let defaultRuntimeContextDevice = self.defaultRuntimeContextDevice {
            try encodeContainer.encode(defaultRuntimeContextDevice, forKey: .defaultRuntimeContextDevice)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let manifestOverridesPayload = self.manifestOverridesPayload {
            try encodeContainer.encode(manifestOverridesPayload, forKey: .manifestOverridesPayload)
        }
        if let manifestPayload = self.manifestPayload {
            try encodeContainer.encode(manifestPayload, forKey: .manifestPayload)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runtimeRoleArn = self.runtimeRoleArn {
            try encodeContainer.encode(runtimeRoleArn, forKey: .runtimeRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateApplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/application-instances"
    }
}

public struct CreateApplicationInstanceInput: Swift.Equatable {
    /// The ID of an application instance to replace with the new instance.
    public var applicationInstanceIdToReplace: Swift.String?
    /// A device's ID.
    /// This member is required.
    public var defaultRuntimeContextDevice: Swift.String?
    /// A description for the application instance.
    public var description: Swift.String?
    /// Setting overrides for the application manifest.
    public var manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload?
    /// The application's manifest document.
    /// This member is required.
    public var manifestPayload: PanoramaClientTypes.ManifestPayload?
    /// A name for the application instance.
    public var name: Swift.String?
    /// The ARN of a runtime role for the application instance.
    public var runtimeRoleArn: Swift.String?
    /// Tags for the application instance.
    public var tags: [Swift.String:Swift.String]?

    public init (
        applicationInstanceIdToReplace: Swift.String? = nil,
        defaultRuntimeContextDevice: Swift.String? = nil,
        description: Swift.String? = nil,
        manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload? = nil,
        manifestPayload: PanoramaClientTypes.ManifestPayload? = nil,
        name: Swift.String? = nil,
        runtimeRoleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationInstanceIdToReplace = applicationInstanceIdToReplace
        self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
        self.description = description
        self.manifestOverridesPayload = manifestOverridesPayload
        self.manifestPayload = manifestPayload
        self.name = name
        self.runtimeRoleArn = runtimeRoleArn
        self.tags = tags
    }
}

struct CreateApplicationInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let manifestPayload: PanoramaClientTypes.ManifestPayload?
    let manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload?
    let applicationInstanceIdToReplace: Swift.String?
    let runtimeRoleArn: Swift.String?
    let defaultRuntimeContextDevice: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateApplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceIdToReplace = "ApplicationInstanceIdToReplace"
        case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
        case description = "Description"
        case manifestOverridesPayload = "ManifestOverridesPayload"
        case manifestPayload = "ManifestPayload"
        case name = "Name"
        case runtimeRoleArn = "RuntimeRoleArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let manifestPayloadDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ManifestPayload.self, forKey: .manifestPayload)
        manifestPayload = manifestPayloadDecoded
        let manifestOverridesPayloadDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ManifestOverridesPayload.self, forKey: .manifestOverridesPayload)
        manifestOverridesPayload = manifestOverridesPayloadDecoded
        let applicationInstanceIdToReplaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceIdToReplace)
        applicationInstanceIdToReplace = applicationInstanceIdToReplaceDecoded
        let runtimeRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeRoleArn)
        runtimeRoleArn = runtimeRoleArnDecoded
        let defaultRuntimeContextDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRuntimeContextDevice)
        defaultRuntimeContextDevice = defaultRuntimeContextDeviceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateApplicationInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateApplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInstanceId = output.applicationInstanceId
        } else {
            self.applicationInstanceId = nil
        }
    }
}

public struct CreateApplicationInstanceOutputResponse: Swift.Equatable {
    /// The application instance's ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init (
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

struct CreateApplicationInstanceOutputResponseBody: Swift.Equatable {
    let applicationInstanceId: Swift.String?
}

extension CreateApplicationInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceId = "ApplicationInstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceId)
        applicationInstanceId = applicationInstanceIdDecoded
    }
}

extension CreateJobForDevicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
        case deviceJobConfig = "DeviceJobConfig"
        case jobType = "JobType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceIds = deviceIds {
            var deviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceIds)
            for deviceid0 in deviceIds {
                try deviceIdsContainer.encode(deviceid0)
            }
        }
        if let deviceJobConfig = self.deviceJobConfig {
            try encodeContainer.encode(deviceJobConfig, forKey: .deviceJobConfig)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
    }
}

extension CreateJobForDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct CreateJobForDevicesInput: Swift.Equatable {
    /// IDs of target devices.
    /// This member is required.
    public var deviceIds: [Swift.String]?
    /// Configuration settings for a software update job.
    public var deviceJobConfig: PanoramaClientTypes.DeviceJobConfig?
    /// The type of job to run.
    /// This member is required.
    public var jobType: PanoramaClientTypes.JobType?

    public init (
        deviceIds: [Swift.String]? = nil,
        deviceJobConfig: PanoramaClientTypes.DeviceJobConfig? = nil,
        jobType: PanoramaClientTypes.JobType? = nil
    )
    {
        self.deviceIds = deviceIds
        self.deviceJobConfig = deviceJobConfig
        self.jobType = jobType
    }
}

struct CreateJobForDevicesInputBody: Swift.Equatable {
    let deviceIds: [Swift.String]?
    let deviceJobConfig: PanoramaClientTypes.DeviceJobConfig?
    let jobType: PanoramaClientTypes.JobType?
}

extension CreateJobForDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
        case deviceJobConfig = "DeviceJobConfig"
        case jobType = "JobType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceIds)
        var deviceIdsDecoded0:[Swift.String]? = nil
        if let deviceIdsContainer = deviceIdsContainer {
            deviceIdsDecoded0 = [Swift.String]()
            for string0 in deviceIdsContainer {
                if let string0 = string0 {
                    deviceIdsDecoded0?.append(string0)
                }
            }
        }
        deviceIds = deviceIdsDecoded0
        let deviceJobConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceJobConfig.self, forKey: .deviceJobConfig)
        deviceJobConfig = deviceJobConfigDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
    }
}

extension CreateJobForDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJobForDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateJobForDevicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobForDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateJobForDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
        } else {
            self.jobs = nil
        }
    }
}

public struct CreateJobForDevicesOutputResponse: Swift.Equatable {
    /// A list of jobs.
    /// This member is required.
    public var jobs: [PanoramaClientTypes.Job]?

    public init (
        jobs: [PanoramaClientTypes.Job]? = nil
    )
    {
        self.jobs = jobs
    }
}

struct CreateJobForDevicesOutputResponseBody: Swift.Equatable {
    let jobs: [PanoramaClientTypes.Job]?
}

extension CreateJobForDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "Jobs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.Job?].self, forKey: .jobs)
        var jobsDecoded0:[PanoramaClientTypes.Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [PanoramaClientTypes.Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
    }
}

extension CreateNodeFromTemplateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobTags = "JobTags"
        case nodeDescription = "NodeDescription"
        case nodeName = "NodeName"
        case outputPackageName = "OutputPackageName"
        case outputPackageVersion = "OutputPackageVersion"
        case templateParameters = "TemplateParameters"
        case templateType = "TemplateType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobTags = jobTags {
            var jobTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobTags)
            for jobresourcetags0 in jobTags {
                try jobTagsContainer.encode(jobresourcetags0)
            }
        }
        if let nodeDescription = self.nodeDescription {
            try encodeContainer.encode(nodeDescription, forKey: .nodeDescription)
        }
        if let nodeName = self.nodeName {
            try encodeContainer.encode(nodeName, forKey: .nodeName)
        }
        if let outputPackageName = self.outputPackageName {
            try encodeContainer.encode(outputPackageName, forKey: .outputPackageName)
        }
        if let outputPackageVersion = self.outputPackageVersion {
            try encodeContainer.encode(outputPackageVersion, forKey: .outputPackageVersion)
        }
        if let templateParameters = templateParameters {
            var templateParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .templateParameters)
            for (dictKey0, templateParametersMap0) in templateParameters {
                try templateParametersContainer.encode(templateParametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

extension CreateNodeFromTemplateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages/template-job"
    }
}

public struct CreateNodeFromTemplateJobInput: Swift.Equatable {
    /// Tags for the job.
    public var jobTags: [PanoramaClientTypes.JobResourceTags]?
    /// A description for the node.
    public var nodeDescription: Swift.String?
    /// A name for the node.
    /// This member is required.
    public var nodeName: Swift.String?
    /// An output package name for the node.
    /// This member is required.
    public var outputPackageName: Swift.String?
    /// An output package version for the node.
    /// This member is required.
    public var outputPackageVersion: Swift.String?
    /// Template parameters for the node.
    /// This member is required.
    public var templateParameters: [Swift.String:Swift.String]?
    /// The type of node.
    /// This member is required.
    public var templateType: PanoramaClientTypes.TemplateType?

    public init (
        jobTags: [PanoramaClientTypes.JobResourceTags]? = nil,
        nodeDescription: Swift.String? = nil,
        nodeName: Swift.String? = nil,
        outputPackageName: Swift.String? = nil,
        outputPackageVersion: Swift.String? = nil,
        templateParameters: [Swift.String:Swift.String]? = nil,
        templateType: PanoramaClientTypes.TemplateType? = nil
    )
    {
        self.jobTags = jobTags
        self.nodeDescription = nodeDescription
        self.nodeName = nodeName
        self.outputPackageName = outputPackageName
        self.outputPackageVersion = outputPackageVersion
        self.templateParameters = templateParameters
        self.templateType = templateType
    }
}

struct CreateNodeFromTemplateJobInputBody: Swift.Equatable {
    let templateType: PanoramaClientTypes.TemplateType?
    let outputPackageName: Swift.String?
    let outputPackageVersion: Swift.String?
    let nodeName: Swift.String?
    let nodeDescription: Swift.String?
    let templateParameters: [Swift.String:Swift.String]?
    let jobTags: [PanoramaClientTypes.JobResourceTags]?
}

extension CreateNodeFromTemplateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobTags = "JobTags"
        case nodeDescription = "NodeDescription"
        case nodeName = "NodeName"
        case outputPackageName = "OutputPackageName"
        case outputPackageVersion = "OutputPackageVersion"
        case templateParameters = "TemplateParameters"
        case templateType = "TemplateType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let outputPackageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPackageName)
        outputPackageName = outputPackageNameDecoded
        let outputPackageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPackageVersion)
        outputPackageVersion = outputPackageVersionDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
        let nodeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeDescription)
        nodeDescription = nodeDescriptionDecoded
        let templateParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .templateParameters)
        var templateParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let templateParametersContainer = templateParametersContainer {
            templateParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, templatevalue0) in templateParametersContainer {
                if let templatevalue0 = templatevalue0 {
                    templateParametersDecoded0?[key0] = templatevalue0
                }
            }
        }
        templateParameters = templateParametersDecoded0
        let jobTagsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.JobResourceTags?].self, forKey: .jobTags)
        var jobTagsDecoded0:[PanoramaClientTypes.JobResourceTags]? = nil
        if let jobTagsContainer = jobTagsContainer {
            jobTagsDecoded0 = [PanoramaClientTypes.JobResourceTags]()
            for structure0 in jobTagsContainer {
                if let structure0 = structure0 {
                    jobTagsDecoded0?.append(structure0)
                }
            }
        }
        jobTags = jobTagsDecoded0
    }
}

extension CreateNodeFromTemplateJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNodeFromTemplateJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateNodeFromTemplateJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNodeFromTemplateJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateNodeFromTemplateJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct CreateNodeFromTemplateJobOutputResponse: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreateNodeFromTemplateJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CreateNodeFromTemplateJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CreatePackageImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case inputConfig = "InputConfig"
        case jobTags = "JobTags"
        case jobType = "JobType"
        case outputConfig = "OutputConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let inputConfig = self.inputConfig {
            try encodeContainer.encode(inputConfig, forKey: .inputConfig)
        }
        if let jobTags = jobTags {
            var jobTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobTags)
            for jobresourcetags0 in jobTags {
                try jobTagsContainer.encode(jobresourcetags0)
            }
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let outputConfig = self.outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
    }
}

extension CreatePackageImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages/import-jobs"
    }
}

public struct CreatePackageImportJobInput: Swift.Equatable {
    /// A client token for the package import job.
    /// This member is required.
    public var clientToken: Swift.String?
    /// An input config for the package import job.
    /// This member is required.
    public var inputConfig: PanoramaClientTypes.PackageImportJobInputConfig?
    /// Tags for the package import job.
    public var jobTags: [PanoramaClientTypes.JobResourceTags]?
    /// A job type for the package import job.
    /// This member is required.
    public var jobType: PanoramaClientTypes.PackageImportJobType?
    /// An output config for the package import job.
    /// This member is required.
    public var outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig?

    public init (
        clientToken: Swift.String? = nil,
        inputConfig: PanoramaClientTypes.PackageImportJobInputConfig? = nil,
        jobTags: [PanoramaClientTypes.JobResourceTags]? = nil,
        jobType: PanoramaClientTypes.PackageImportJobType? = nil,
        outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.inputConfig = inputConfig
        self.jobTags = jobTags
        self.jobType = jobType
        self.outputConfig = outputConfig
    }
}

struct CreatePackageImportJobInputBody: Swift.Equatable {
    let jobType: PanoramaClientTypes.PackageImportJobType?
    let inputConfig: PanoramaClientTypes.PackageImportJobInputConfig?
    let outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig?
    let clientToken: Swift.String?
    let jobTags: [PanoramaClientTypes.JobResourceTags]?
}

extension CreatePackageImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case inputConfig = "InputConfig"
        case jobTags = "JobTags"
        case jobType = "JobType"
        case outputConfig = "OutputConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobInputConfig.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobOutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobTagsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.JobResourceTags?].self, forKey: .jobTags)
        var jobTagsDecoded0:[PanoramaClientTypes.JobResourceTags]? = nil
        if let jobTagsContainer = jobTagsContainer {
            jobTagsDecoded0 = [PanoramaClientTypes.JobResourceTags]()
            for structure0 in jobTagsContainer {
                if let structure0 = structure0 {
                    jobTagsDecoded0?.append(structure0)
                }
            }
        }
        jobTags = jobTagsDecoded0
    }
}

extension CreatePackageImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePackageImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePackageImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePackageImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePackageImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct CreatePackageImportJobOutputResponse: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreatePackageImportJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CreatePackageImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CreatePackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageName = "PackageName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages"
    }
}

public struct CreatePackageInput: Swift.Equatable {
    /// A name for the package.
    /// This member is required.
    public var packageName: Swift.String?
    /// Tags for the package.
    public var tags: [Swift.String:Swift.String]?

    public init (
        packageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.packageName = packageName
        self.tags = tags
    }
}

struct CreatePackageInputBody: Swift.Equatable {
    let packageName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageName = "PackageName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.packageId = output.packageId
            self.storageLocation = output.storageLocation
        } else {
            self.arn = nil
            self.packageId = nil
            self.storageLocation = nil
        }
    }
}

public struct CreatePackageOutputResponse: Swift.Equatable {
    /// The package's ARN.
    public var arn: Swift.String?
    /// The package's ID.
    public var packageId: Swift.String?
    /// The package's storage location.
    /// This member is required.
    public var storageLocation: PanoramaClientTypes.StorageLocation?

    public init (
        arn: Swift.String? = nil,
        packageId: Swift.String? = nil,
        storageLocation: PanoramaClientTypes.StorageLocation? = nil
    )
    {
        self.arn = arn
        self.packageId = packageId
        self.storageLocation = storageLocation
    }
}

struct CreatePackageOutputResponseBody: Swift.Equatable {
    let packageId: Swift.String?
    let arn: Swift.String?
    let storageLocation: PanoramaClientTypes.StorageLocation?
}

extension CreatePackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case packageId = "PackageId"
        case storageLocation = "StorageLocation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let storageLocationDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.StorageLocation.self, forKey: .storageLocation)
        storageLocation = storageLocationDecoded
    }
}

extension DeleteDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceId = deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())"
    }
}

public struct DeleteDeviceInput: Swift.Equatable {
    /// The device's ID.
    /// This member is required.
    public var deviceId: Swift.String?

    public init (
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct DeleteDeviceInputBody: Swift.Equatable {
}

extension DeleteDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceId = output.deviceId
        } else {
            self.deviceId = nil
        }
    }
}

public struct DeleteDeviceOutputResponse: Swift.Equatable {
    /// The device's ID.
    public var deviceId: Swift.String?

    public init (
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct DeleteDeviceOutputResponseBody: Swift.Equatable {
    let deviceId: Swift.String?
}

extension DeleteDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension DeletePackageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if forceDelete != false {
                let forceDeleteQueryItem = ClientRuntime.URLQueryItem(name: "ForceDelete".urlPercentEncoding(), value: Swift.String(forceDelete).urlPercentEncoding())
                items.append(forceDeleteQueryItem)
            }
            return items
        }
    }
}

extension DeletePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageId = packageId else {
            return nil
        }
        return "/packages/\(packageId.urlPercentEncoding())"
    }
}

public struct DeletePackageInput: Swift.Equatable {
    /// Delete the package even if it has artifacts stored in its access point. Deletes the package's artifacts from Amazon S3.
    public var forceDelete: Swift.Bool
    /// The package's ID.
    /// This member is required.
    public var packageId: Swift.String?

    public init (
        forceDelete: Swift.Bool = false,
        packageId: Swift.String? = nil
    )
    {
        self.forceDelete = forceDelete
        self.packageId = packageId
    }
}

struct DeletePackageInputBody: Swift.Equatable {
}

extension DeletePackageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePackageOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeregisterPackageVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let updatedLatestPatchVersion = updatedLatestPatchVersion {
                let updatedLatestPatchVersionQueryItem = ClientRuntime.URLQueryItem(name: "UpdatedLatestPatchVersion".urlPercentEncoding(), value: Swift.String(updatedLatestPatchVersion).urlPercentEncoding())
                items.append(updatedLatestPatchVersionQueryItem)
            }
            if let ownerAccount = ownerAccount {
                let ownerAccountQueryItem = ClientRuntime.URLQueryItem(name: "OwnerAccount".urlPercentEncoding(), value: Swift.String(ownerAccount).urlPercentEncoding())
                items.append(ownerAccountQueryItem)
            }
            return items
        }
    }
}

extension DeregisterPackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageId = packageId else {
            return nil
        }
        guard let packageVersion = packageVersion else {
            return nil
        }
        guard let patchVersion = patchVersion else {
            return nil
        }
        return "/packages/\(packageId.urlPercentEncoding())/versions/\(packageVersion.urlPercentEncoding())/patch/\(patchVersion.urlPercentEncoding())"
    }
}

public struct DeregisterPackageVersionInput: Swift.Equatable {
    /// An owner account.
    public var ownerAccount: Swift.String?
    /// A package ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// A package version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// A patch version.
    /// This member is required.
    public var patchVersion: Swift.String?
    /// If the version was marked latest, the new version to maker as latest.
    public var updatedLatestPatchVersion: Swift.String?

    public init (
        ownerAccount: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil,
        updatedLatestPatchVersion: Swift.String? = nil
    )
    {
        self.ownerAccount = ownerAccount
        self.packageId = packageId
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
        self.updatedLatestPatchVersion = updatedLatestPatchVersion
    }
}

struct DeregisterPackageVersionInputBody: Swift.Equatable {
}

extension DeregisterPackageVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterPackageVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterPackageVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterPackageVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterPackageVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterPackageVersionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeApplicationInstanceDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationInstanceId = applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())/details"
    }
}

public struct DescribeApplicationInstanceDetailsInput: Swift.Equatable {
    /// The application instance's ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init (
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

struct DescribeApplicationInstanceDetailsInputBody: Swift.Equatable {
}

extension DescribeApplicationInstanceDetailsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeApplicationInstanceDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationInstanceDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeApplicationInstanceDetailsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationInstanceDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeApplicationInstanceDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInstanceId = output.applicationInstanceId
            self.applicationInstanceIdToReplace = output.applicationInstanceIdToReplace
            self.createdTime = output.createdTime
            self.defaultRuntimeContextDevice = output.defaultRuntimeContextDevice
            self.description = output.description
            self.manifestOverridesPayload = output.manifestOverridesPayload
            self.manifestPayload = output.manifestPayload
            self.name = output.name
        } else {
            self.applicationInstanceId = nil
            self.applicationInstanceIdToReplace = nil
            self.createdTime = nil
            self.defaultRuntimeContextDevice = nil
            self.description = nil
            self.manifestOverridesPayload = nil
            self.manifestPayload = nil
            self.name = nil
        }
    }
}

public struct DescribeApplicationInstanceDetailsOutputResponse: Swift.Equatable {
    /// The application instance's ID.
    public var applicationInstanceId: Swift.String?
    /// The ID of the application instance that this instance replaced.
    public var applicationInstanceIdToReplace: Swift.String?
    /// When the application instance was created.
    public var createdTime: ClientRuntime.Date?
    /// The application instance's default runtime context device.
    public var defaultRuntimeContextDevice: Swift.String?
    /// The application instance's description.
    public var description: Swift.String?
    /// Parameter overrides for the configuration manifest.
    public var manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload?
    /// The application instance's configuration manifest.
    public var manifestPayload: PanoramaClientTypes.ManifestPayload?
    /// The application instance's name.
    public var name: Swift.String?

    public init (
        applicationInstanceId: Swift.String? = nil,
        applicationInstanceIdToReplace: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        defaultRuntimeContextDevice: Swift.String? = nil,
        description: Swift.String? = nil,
        manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload? = nil,
        manifestPayload: PanoramaClientTypes.ManifestPayload? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.applicationInstanceIdToReplace = applicationInstanceIdToReplace
        self.createdTime = createdTime
        self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
        self.description = description
        self.manifestOverridesPayload = manifestOverridesPayload
        self.manifestPayload = manifestPayload
        self.name = name
    }
}

struct DescribeApplicationInstanceDetailsOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let defaultRuntimeContextDevice: Swift.String?
    let manifestPayload: PanoramaClientTypes.ManifestPayload?
    let manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload?
    let applicationInstanceIdToReplace: Swift.String?
    let createdTime: ClientRuntime.Date?
    let applicationInstanceId: Swift.String?
}

extension DescribeApplicationInstanceDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceId = "ApplicationInstanceId"
        case applicationInstanceIdToReplace = "ApplicationInstanceIdToReplace"
        case createdTime = "CreatedTime"
        case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
        case description = "Description"
        case manifestOverridesPayload = "ManifestOverridesPayload"
        case manifestPayload = "ManifestPayload"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultRuntimeContextDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRuntimeContextDevice)
        defaultRuntimeContextDevice = defaultRuntimeContextDeviceDecoded
        let manifestPayloadDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ManifestPayload.self, forKey: .manifestPayload)
        manifestPayload = manifestPayloadDecoded
        let manifestOverridesPayloadDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ManifestOverridesPayload.self, forKey: .manifestOverridesPayload)
        manifestOverridesPayload = manifestOverridesPayloadDecoded
        let applicationInstanceIdToReplaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceIdToReplace)
        applicationInstanceIdToReplace = applicationInstanceIdToReplaceDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let applicationInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceId)
        applicationInstanceId = applicationInstanceIdDecoded
    }
}

extension DescribeApplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationInstanceId = applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())"
    }
}

public struct DescribeApplicationInstanceInput: Swift.Equatable {
    /// The application instance's ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init (
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

struct DescribeApplicationInstanceInputBody: Swift.Equatable {
}

extension DescribeApplicationInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeApplicationInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeApplicationInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeApplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInstanceId = output.applicationInstanceId
            self.applicationInstanceIdToReplace = output.applicationInstanceIdToReplace
            self.arn = output.arn
            self.createdTime = output.createdTime
            self.defaultRuntimeContextDevice = output.defaultRuntimeContextDevice
            self.defaultRuntimeContextDeviceName = output.defaultRuntimeContextDeviceName
            self.description = output.description
            self.healthStatus = output.healthStatus
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.runtimeContextStates = output.runtimeContextStates
            self.runtimeRoleArn = output.runtimeRoleArn
            self.status = output.status
            self.statusDescription = output.statusDescription
            self.tags = output.tags
        } else {
            self.applicationInstanceId = nil
            self.applicationInstanceIdToReplace = nil
            self.arn = nil
            self.createdTime = nil
            self.defaultRuntimeContextDevice = nil
            self.defaultRuntimeContextDeviceName = nil
            self.description = nil
            self.healthStatus = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.runtimeContextStates = nil
            self.runtimeRoleArn = nil
            self.status = nil
            self.statusDescription = nil
            self.tags = nil
        }
    }
}

public struct DescribeApplicationInstanceOutputResponse: Swift.Equatable {
    /// The application instance's ID.
    public var applicationInstanceId: Swift.String?
    /// The ID of the application instance that this instance replaced.
    public var applicationInstanceIdToReplace: Swift.String?
    /// The application instance's ARN.
    public var arn: Swift.String?
    /// When the application instance was created.
    public var createdTime: ClientRuntime.Date?
    /// The device's ID.
    public var defaultRuntimeContextDevice: Swift.String?
    /// The device's bane.
    public var defaultRuntimeContextDeviceName: Swift.String?
    /// The application instance's description.
    public var description: Swift.String?
    /// The application instance's health status.
    public var healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus?
    /// The application instance was updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The application instance's name.
    public var name: Swift.String?
    /// The application instance's state.
    public var runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]?
    /// The application instance's runtime role ARN.
    public var runtimeRoleArn: Swift.String?
    /// The application instance's status.
    public var status: PanoramaClientTypes.ApplicationInstanceStatus?
    /// The application instance's status description.
    public var statusDescription: Swift.String?
    /// The application instance's tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        applicationInstanceId: Swift.String? = nil,
        applicationInstanceIdToReplace: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        defaultRuntimeContextDevice: Swift.String? = nil,
        defaultRuntimeContextDeviceName: Swift.String? = nil,
        description: Swift.String? = nil,
        healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]? = nil,
        runtimeRoleArn: Swift.String? = nil,
        status: PanoramaClientTypes.ApplicationInstanceStatus? = nil,
        statusDescription: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.applicationInstanceIdToReplace = applicationInstanceIdToReplace
        self.arn = arn
        self.createdTime = createdTime
        self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
        self.defaultRuntimeContextDeviceName = defaultRuntimeContextDeviceName
        self.description = description
        self.healthStatus = healthStatus
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.runtimeContextStates = runtimeContextStates
        self.runtimeRoleArn = runtimeRoleArn
        self.status = status
        self.statusDescription = statusDescription
        self.tags = tags
    }
}

struct DescribeApplicationInstanceOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let defaultRuntimeContextDevice: Swift.String?
    let defaultRuntimeContextDeviceName: Swift.String?
    let applicationInstanceIdToReplace: Swift.String?
    let runtimeRoleArn: Swift.String?
    let status: PanoramaClientTypes.ApplicationInstanceStatus?
    let healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus?
    let statusDescription: Swift.String?
    let createdTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let applicationInstanceId: Swift.String?
    let arn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]?
}

extension DescribeApplicationInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceId = "ApplicationInstanceId"
        case applicationInstanceIdToReplace = "ApplicationInstanceIdToReplace"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
        case defaultRuntimeContextDeviceName = "DefaultRuntimeContextDeviceName"
        case description = "Description"
        case healthStatus = "HealthStatus"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case runtimeContextStates = "RuntimeContextStates"
        case runtimeRoleArn = "RuntimeRoleArn"
        case status = "Status"
        case statusDescription = "StatusDescription"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultRuntimeContextDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRuntimeContextDevice)
        defaultRuntimeContextDevice = defaultRuntimeContextDeviceDecoded
        let defaultRuntimeContextDeviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRuntimeContextDeviceName)
        defaultRuntimeContextDeviceName = defaultRuntimeContextDeviceNameDecoded
        let applicationInstanceIdToReplaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceIdToReplace)
        applicationInstanceIdToReplace = applicationInstanceIdToReplaceDecoded
        let runtimeRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeRoleArn)
        runtimeRoleArn = runtimeRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ApplicationInstanceStatus.self, forKey: .status)
        status = statusDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ApplicationInstanceHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let statusDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDescription)
        statusDescription = statusDescriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let applicationInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceId)
        applicationInstanceId = applicationInstanceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let runtimeContextStatesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.ReportedRuntimeContextState?].self, forKey: .runtimeContextStates)
        var runtimeContextStatesDecoded0:[PanoramaClientTypes.ReportedRuntimeContextState]? = nil
        if let runtimeContextStatesContainer = runtimeContextStatesContainer {
            runtimeContextStatesDecoded0 = [PanoramaClientTypes.ReportedRuntimeContextState]()
            for structure0 in runtimeContextStatesContainer {
                if let structure0 = structure0 {
                    runtimeContextStatesDecoded0?.append(structure0)
                }
            }
        }
        runtimeContextStates = runtimeContextStatesDecoded0
    }
}

extension DescribeDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceId = deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())"
    }
}

public struct DescribeDeviceInput: Swift.Equatable {
    /// The device's ID.
    /// This member is required.
    public var deviceId: Swift.String?

    public init (
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct DescribeDeviceInputBody: Swift.Equatable {
}

extension DescribeDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDeviceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeDeviceJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeDeviceJobInputBody: Swift.Equatable {
}

extension DescribeDeviceJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDeviceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeviceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDeviceJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeviceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDeviceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdTime = output.createdTime
            self.deviceArn = output.deviceArn
            self.deviceId = output.deviceId
            self.deviceName = output.deviceName
            self.deviceType = output.deviceType
            self.imageVersion = output.imageVersion
            self.jobId = output.jobId
            self.jobType = output.jobType
            self.status = output.status
        } else {
            self.createdTime = nil
            self.deviceArn = nil
            self.deviceId = nil
            self.deviceName = nil
            self.deviceType = nil
            self.imageVersion = nil
            self.jobId = nil
            self.jobType = nil
            self.status = nil
        }
    }
}

public struct DescribeDeviceJobOutputResponse: Swift.Equatable {
    /// When the job was created.
    public var createdTime: ClientRuntime.Date?
    /// The device's ARN.
    public var deviceArn: Swift.String?
    /// The device's ID.
    public var deviceId: Swift.String?
    /// The device's name.
    public var deviceName: Swift.String?
    /// The device's type.
    public var deviceType: PanoramaClientTypes.DeviceType?
    /// For an OTA job, the target version of the device software.
    public var imageVersion: Swift.String?
    /// The job's ID.
    public var jobId: Swift.String?
    /// The job's type.
    public var jobType: PanoramaClientTypes.JobType?
    /// The job's status.
    public var status: PanoramaClientTypes.UpdateProgress?

    public init (
        createdTime: ClientRuntime.Date? = nil,
        deviceArn: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        deviceType: PanoramaClientTypes.DeviceType? = nil,
        imageVersion: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobType: PanoramaClientTypes.JobType? = nil,
        status: PanoramaClientTypes.UpdateProgress? = nil
    )
    {
        self.createdTime = createdTime
        self.deviceArn = deviceArn
        self.deviceId = deviceId
        self.deviceName = deviceName
        self.deviceType = deviceType
        self.imageVersion = imageVersion
        self.jobId = jobId
        self.jobType = jobType
        self.status = status
    }
}

struct DescribeDeviceJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
    let deviceId: Swift.String?
    let deviceArn: Swift.String?
    let deviceName: Swift.String?
    let deviceType: PanoramaClientTypes.DeviceType?
    let imageVersion: Swift.String?
    let status: PanoramaClientTypes.UpdateProgress?
    let createdTime: ClientRuntime.Date?
    let jobType: PanoramaClientTypes.JobType?
}

extension DescribeDeviceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case deviceArn = "DeviceArn"
        case deviceId = "DeviceId"
        case deviceName = "DeviceName"
        case deviceType = "DeviceType"
        case imageVersion = "ImageVersion"
        case jobId = "JobId"
        case jobType = "JobType"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceType.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let imageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageVersion)
        imageVersion = imageVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.UpdateProgress.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
    }
}

extension DescribeDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alternateSoftwares = output.alternateSoftwares
            self.arn = output.arn
            self.brand = output.brand
            self.createdTime = output.createdTime
            self.currentNetworkingStatus = output.currentNetworkingStatus
            self.currentSoftware = output.currentSoftware
            self.description = output.description
            self.deviceAggregatedStatus = output.deviceAggregatedStatus
            self.deviceConnectionStatus = output.deviceConnectionStatus
            self.deviceId = output.deviceId
            self.latestAlternateSoftware = output.latestAlternateSoftware
            self.latestDeviceJob = output.latestDeviceJob
            self.latestSoftware = output.latestSoftware
            self.leaseExpirationTime = output.leaseExpirationTime
            self.name = output.name
            self.networkingConfiguration = output.networkingConfiguration
            self.provisioningStatus = output.provisioningStatus
            self.serialNumber = output.serialNumber
            self.tags = output.tags
            self.type = output.type
        } else {
            self.alternateSoftwares = nil
            self.arn = nil
            self.brand = nil
            self.createdTime = nil
            self.currentNetworkingStatus = nil
            self.currentSoftware = nil
            self.description = nil
            self.deviceAggregatedStatus = nil
            self.deviceConnectionStatus = nil
            self.deviceId = nil
            self.latestAlternateSoftware = nil
            self.latestDeviceJob = nil
            self.latestSoftware = nil
            self.leaseExpirationTime = nil
            self.name = nil
            self.networkingConfiguration = nil
            self.provisioningStatus = nil
            self.serialNumber = nil
            self.tags = nil
            self.type = nil
        }
    }
}

public struct DescribeDeviceOutputResponse: Swift.Equatable {
    /// Beta software releases available for the device.
    public var alternateSoftwares: [PanoramaClientTypes.AlternateSoftwareMetadata]?
    /// The device's ARN.
    public var arn: Swift.String?
    /// The device's maker.
    public var brand: PanoramaClientTypes.DeviceBrand?
    /// When the device was created.
    public var createdTime: ClientRuntime.Date?
    /// The device's networking status.
    public var currentNetworkingStatus: PanoramaClientTypes.NetworkStatus?
    /// The device's current software version.
    public var currentSoftware: Swift.String?
    /// The device's description.
    public var description: Swift.String?
    /// A device's aggregated status. Including the device's connection status, provisioning status, and lease status.
    public var deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus?
    /// The device's connection status.
    public var deviceConnectionStatus: PanoramaClientTypes.DeviceConnectionStatus?
    /// The device's ID.
    public var deviceId: Swift.String?
    /// The most recent beta software release.
    public var latestAlternateSoftware: Swift.String?
    /// A device's latest job. Includes the target image version, and the job status.
    public var latestDeviceJob: PanoramaClientTypes.LatestDeviceJob?
    /// The latest software version available for the device.
    public var latestSoftware: Swift.String?
    /// The device's lease expiration time.
    public var leaseExpirationTime: ClientRuntime.Date?
    /// The device's name.
    public var name: Swift.String?
    /// The device's networking configuration.
    public var networkingConfiguration: PanoramaClientTypes.NetworkPayload?
    /// The device's provisioning status.
    public var provisioningStatus: PanoramaClientTypes.DeviceStatus?
    /// The device's serial number.
    public var serialNumber: Swift.String?
    /// The device's tags.
    public var tags: [Swift.String:Swift.String]?
    /// The device's type.
    public var type: PanoramaClientTypes.DeviceType?

    public init (
        alternateSoftwares: [PanoramaClientTypes.AlternateSoftwareMetadata]? = nil,
        arn: Swift.String? = nil,
        brand: PanoramaClientTypes.DeviceBrand? = nil,
        createdTime: ClientRuntime.Date? = nil,
        currentNetworkingStatus: PanoramaClientTypes.NetworkStatus? = nil,
        currentSoftware: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus? = nil,
        deviceConnectionStatus: PanoramaClientTypes.DeviceConnectionStatus? = nil,
        deviceId: Swift.String? = nil,
        latestAlternateSoftware: Swift.String? = nil,
        latestDeviceJob: PanoramaClientTypes.LatestDeviceJob? = nil,
        latestSoftware: Swift.String? = nil,
        leaseExpirationTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        networkingConfiguration: PanoramaClientTypes.NetworkPayload? = nil,
        provisioningStatus: PanoramaClientTypes.DeviceStatus? = nil,
        serialNumber: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: PanoramaClientTypes.DeviceType? = nil
    )
    {
        self.alternateSoftwares = alternateSoftwares
        self.arn = arn
        self.brand = brand
        self.createdTime = createdTime
        self.currentNetworkingStatus = currentNetworkingStatus
        self.currentSoftware = currentSoftware
        self.description = description
        self.deviceAggregatedStatus = deviceAggregatedStatus
        self.deviceConnectionStatus = deviceConnectionStatus
        self.deviceId = deviceId
        self.latestAlternateSoftware = latestAlternateSoftware
        self.latestDeviceJob = latestDeviceJob
        self.latestSoftware = latestSoftware
        self.leaseExpirationTime = leaseExpirationTime
        self.name = name
        self.networkingConfiguration = networkingConfiguration
        self.provisioningStatus = provisioningStatus
        self.serialNumber = serialNumber
        self.tags = tags
        self.type = type
    }
}

struct DescribeDeviceOutputResponseBody: Swift.Equatable {
    let deviceId: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let type: PanoramaClientTypes.DeviceType?
    let deviceConnectionStatus: PanoramaClientTypes.DeviceConnectionStatus?
    let createdTime: ClientRuntime.Date?
    let provisioningStatus: PanoramaClientTypes.DeviceStatus?
    let latestSoftware: Swift.String?
    let currentSoftware: Swift.String?
    let serialNumber: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let networkingConfiguration: PanoramaClientTypes.NetworkPayload?
    let currentNetworkingStatus: PanoramaClientTypes.NetworkStatus?
    let leaseExpirationTime: ClientRuntime.Date?
    let alternateSoftwares: [PanoramaClientTypes.AlternateSoftwareMetadata]?
    let latestAlternateSoftware: Swift.String?
    let brand: PanoramaClientTypes.DeviceBrand?
    let latestDeviceJob: PanoramaClientTypes.LatestDeviceJob?
    let deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus?
}

extension DescribeDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateSoftwares = "AlternateSoftwares"
        case arn = "Arn"
        case brand = "Brand"
        case createdTime = "CreatedTime"
        case currentNetworkingStatus = "CurrentNetworkingStatus"
        case currentSoftware = "CurrentSoftware"
        case description = "Description"
        case deviceAggregatedStatus = "DeviceAggregatedStatus"
        case deviceConnectionStatus = "DeviceConnectionStatus"
        case deviceId = "DeviceId"
        case latestAlternateSoftware = "LatestAlternateSoftware"
        case latestDeviceJob = "LatestDeviceJob"
        case latestSoftware = "LatestSoftware"
        case leaseExpirationTime = "LeaseExpirationTime"
        case name = "Name"
        case networkingConfiguration = "NetworkingConfiguration"
        case provisioningStatus = "ProvisioningStatus"
        case serialNumber = "SerialNumber"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceType.self, forKey: .type)
        type = typeDecoded
        let deviceConnectionStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceConnectionStatus.self, forKey: .deviceConnectionStatus)
        deviceConnectionStatus = deviceConnectionStatusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let provisioningStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceStatus.self, forKey: .provisioningStatus)
        provisioningStatus = provisioningStatusDecoded
        let latestSoftwareDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestSoftware)
        latestSoftware = latestSoftwareDecoded
        let currentSoftwareDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentSoftware)
        currentSoftware = currentSoftwareDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let networkingConfigurationDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NetworkPayload.self, forKey: .networkingConfiguration)
        networkingConfiguration = networkingConfigurationDecoded
        let currentNetworkingStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NetworkStatus.self, forKey: .currentNetworkingStatus)
        currentNetworkingStatus = currentNetworkingStatusDecoded
        let leaseExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .leaseExpirationTime)
        leaseExpirationTime = leaseExpirationTimeDecoded
        let alternateSoftwaresContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.AlternateSoftwareMetadata?].self, forKey: .alternateSoftwares)
        var alternateSoftwaresDecoded0:[PanoramaClientTypes.AlternateSoftwareMetadata]? = nil
        if let alternateSoftwaresContainer = alternateSoftwaresContainer {
            alternateSoftwaresDecoded0 = [PanoramaClientTypes.AlternateSoftwareMetadata]()
            for structure0 in alternateSoftwaresContainer {
                if let structure0 = structure0 {
                    alternateSoftwaresDecoded0?.append(structure0)
                }
            }
        }
        alternateSoftwares = alternateSoftwaresDecoded0
        let latestAlternateSoftwareDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestAlternateSoftware)
        latestAlternateSoftware = latestAlternateSoftwareDecoded
        let brandDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceBrand.self, forKey: .brand)
        brand = brandDecoded
        let latestDeviceJobDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.LatestDeviceJob.self, forKey: .latestDeviceJob)
        latestDeviceJob = latestDeviceJobDecoded
        let deviceAggregatedStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceAggregatedStatus.self, forKey: .deviceAggregatedStatus)
        deviceAggregatedStatus = deviceAggregatedStatusDecoded
    }
}

extension DescribeNodeFromTemplateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/packages/template-job/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeNodeFromTemplateJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeNodeFromTemplateJobInputBody: Swift.Equatable {
}

extension DescribeNodeFromTemplateJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeNodeFromTemplateJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNodeFromTemplateJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeNodeFromTemplateJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNodeFromTemplateJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeNodeFromTemplateJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdTime = output.createdTime
            self.jobId = output.jobId
            self.jobTags = output.jobTags
            self.lastUpdatedTime = output.lastUpdatedTime
            self.nodeDescription = output.nodeDescription
            self.nodeName = output.nodeName
            self.outputPackageName = output.outputPackageName
            self.outputPackageVersion = output.outputPackageVersion
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.templateParameters = output.templateParameters
            self.templateType = output.templateType
        } else {
            self.createdTime = nil
            self.jobId = nil
            self.jobTags = nil
            self.lastUpdatedTime = nil
            self.nodeDescription = nil
            self.nodeName = nil
            self.outputPackageName = nil
            self.outputPackageVersion = nil
            self.status = nil
            self.statusMessage = nil
            self.templateParameters = nil
            self.templateType = nil
        }
    }
}

public struct DescribeNodeFromTemplateJobOutputResponse: Swift.Equatable {
    /// When the job was created.
    /// This member is required.
    public var createdTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The job's tags.
    public var jobTags: [PanoramaClientTypes.JobResourceTags]?
    /// When the job was updated.
    /// This member is required.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The node's description.
    public var nodeDescription: Swift.String?
    /// The node's name.
    /// This member is required.
    public var nodeName: Swift.String?
    /// The job's output package name.
    /// This member is required.
    public var outputPackageName: Swift.String?
    /// The job's output package version.
    /// This member is required.
    public var outputPackageVersion: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: PanoramaClientTypes.NodeFromTemplateJobStatus?
    /// The job's status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The job's template parameters.
    /// This member is required.
    public var templateParameters: [Swift.String:Swift.String]?
    /// The job's template type.
    /// This member is required.
    public var templateType: PanoramaClientTypes.TemplateType?

    public init (
        createdTime: ClientRuntime.Date? = nil,
        jobId: Swift.String? = nil,
        jobTags: [PanoramaClientTypes.JobResourceTags]? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        nodeDescription: Swift.String? = nil,
        nodeName: Swift.String? = nil,
        outputPackageName: Swift.String? = nil,
        outputPackageVersion: Swift.String? = nil,
        status: PanoramaClientTypes.NodeFromTemplateJobStatus? = nil,
        statusMessage: Swift.String? = nil,
        templateParameters: [Swift.String:Swift.String]? = nil,
        templateType: PanoramaClientTypes.TemplateType? = nil
    )
    {
        self.createdTime = createdTime
        self.jobId = jobId
        self.jobTags = jobTags
        self.lastUpdatedTime = lastUpdatedTime
        self.nodeDescription = nodeDescription
        self.nodeName = nodeName
        self.outputPackageName = outputPackageName
        self.outputPackageVersion = outputPackageVersion
        self.status = status
        self.statusMessage = statusMessage
        self.templateParameters = templateParameters
        self.templateType = templateType
    }
}

struct DescribeNodeFromTemplateJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
    let status: PanoramaClientTypes.NodeFromTemplateJobStatus?
    let statusMessage: Swift.String?
    let createdTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let outputPackageName: Swift.String?
    let outputPackageVersion: Swift.String?
    let nodeName: Swift.String?
    let nodeDescription: Swift.String?
    let templateType: PanoramaClientTypes.TemplateType?
    let templateParameters: [Swift.String:Swift.String]?
    let jobTags: [PanoramaClientTypes.JobResourceTags]?
}

extension DescribeNodeFromTemplateJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case jobId = "JobId"
        case jobTags = "JobTags"
        case lastUpdatedTime = "LastUpdatedTime"
        case nodeDescription = "NodeDescription"
        case nodeName = "NodeName"
        case outputPackageName = "OutputPackageName"
        case outputPackageVersion = "OutputPackageVersion"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case templateParameters = "TemplateParameters"
        case templateType = "TemplateType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeFromTemplateJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let outputPackageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPackageName)
        outputPackageName = outputPackageNameDecoded
        let outputPackageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPackageVersion)
        outputPackageVersion = outputPackageVersionDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
        let nodeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeDescription)
        nodeDescription = nodeDescriptionDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let templateParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .templateParameters)
        var templateParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let templateParametersContainer = templateParametersContainer {
            templateParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, templatevalue0) in templateParametersContainer {
                if let templatevalue0 = templatevalue0 {
                    templateParametersDecoded0?[key0] = templatevalue0
                }
            }
        }
        templateParameters = templateParametersDecoded0
        let jobTagsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.JobResourceTags?].self, forKey: .jobTags)
        var jobTagsDecoded0:[PanoramaClientTypes.JobResourceTags]? = nil
        if let jobTagsContainer = jobTagsContainer {
            jobTagsDecoded0 = [PanoramaClientTypes.JobResourceTags]()
            for structure0 in jobTagsContainer {
                if let structure0 = structure0 {
                    jobTagsDecoded0?.append(structure0)
                }
            }
        }
        jobTags = jobTagsDecoded0
    }
}

extension DescribeNodeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ownerAccount = ownerAccount {
                let ownerAccountQueryItem = ClientRuntime.URLQueryItem(name: "OwnerAccount".urlPercentEncoding(), value: Swift.String(ownerAccount).urlPercentEncoding())
                items.append(ownerAccountQueryItem)
            }
            return items
        }
    }
}

extension DescribeNodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nodeId = nodeId else {
            return nil
        }
        return "/nodes/\(nodeId.urlPercentEncoding())"
    }
}

public struct DescribeNodeInput: Swift.Equatable {
    /// The node's ID.
    /// This member is required.
    public var nodeId: Swift.String?
    /// The account ID of the node's owner.
    public var ownerAccount: Swift.String?

    public init (
        nodeId: Swift.String? = nil,
        ownerAccount: Swift.String? = nil
    )
    {
        self.nodeId = nodeId
        self.ownerAccount = ownerAccount
    }
}

struct DescribeNodeInputBody: Swift.Equatable {
}

extension DescribeNodeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeNodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeNodeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeNodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetName = output.assetName
            self.category = output.category
            self.createdTime = output.createdTime
            self.description = output.description
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.nodeId = output.nodeId
            self.nodeInterface = output.nodeInterface
            self.ownerAccount = output.ownerAccount
            self.packageArn = output.packageArn
            self.packageId = output.packageId
            self.packageName = output.packageName
            self.packageVersion = output.packageVersion
            self.patchVersion = output.patchVersion
        } else {
            self.assetName = nil
            self.category = nil
            self.createdTime = nil
            self.description = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.nodeId = nil
            self.nodeInterface = nil
            self.ownerAccount = nil
            self.packageArn = nil
            self.packageId = nil
            self.packageName = nil
            self.packageVersion = nil
            self.patchVersion = nil
        }
    }
}

public struct DescribeNodeOutputResponse: Swift.Equatable {
    /// The node's asset name.
    public var assetName: Swift.String?
    /// The node's category.
    /// This member is required.
    public var category: PanoramaClientTypes.NodeCategory?
    /// When the node was created.
    /// This member is required.
    public var createdTime: ClientRuntime.Date?
    /// The node's description.
    /// This member is required.
    public var description: Swift.String?
    /// When the node was updated.
    /// This member is required.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The node's name.
    /// This member is required.
    public var name: Swift.String?
    /// The node's ID.
    /// This member is required.
    public var nodeId: Swift.String?
    /// The node's interface.
    /// This member is required.
    public var nodeInterface: PanoramaClientTypes.NodeInterface?
    /// The account ID of the node's owner.
    /// This member is required.
    public var ownerAccount: Swift.String?
    /// The node's ARN.
    public var packageArn: Swift.String?
    /// The node's package ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// The node's package name.
    /// This member is required.
    public var packageName: Swift.String?
    /// The node's package version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The node's patch version.
    /// This member is required.
    public var patchVersion: Swift.String?

    public init (
        assetName: Swift.String? = nil,
        category: PanoramaClientTypes.NodeCategory? = nil,
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        nodeId: Swift.String? = nil,
        nodeInterface: PanoramaClientTypes.NodeInterface? = nil,
        ownerAccount: Swift.String? = nil,
        packageArn: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil
    )
    {
        self.assetName = assetName
        self.category = category
        self.createdTime = createdTime
        self.description = description
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.nodeId = nodeId
        self.nodeInterface = nodeInterface
        self.ownerAccount = ownerAccount
        self.packageArn = packageArn
        self.packageId = packageId
        self.packageName = packageName
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
    }
}

struct DescribeNodeOutputResponseBody: Swift.Equatable {
    let nodeId: Swift.String?
    let name: Swift.String?
    let category: PanoramaClientTypes.NodeCategory?
    let ownerAccount: Swift.String?
    let packageName: Swift.String?
    let packageId: Swift.String?
    let packageArn: Swift.String?
    let packageVersion: Swift.String?
    let patchVersion: Swift.String?
    let nodeInterface: PanoramaClientTypes.NodeInterface?
    let assetName: Swift.String?
    let description: Swift.String?
    let createdTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension DescribeNodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetName = "AssetName"
        case category = "Category"
        case createdTime = "CreatedTime"
        case description = "Description"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case nodeId = "NodeId"
        case nodeInterface = "NodeInterface"
        case ownerAccount = "OwnerAccount"
        case packageArn = "PackageArn"
        case packageId = "PackageId"
        case packageName = "PackageName"
        case packageVersion = "PackageVersion"
        case patchVersion = "PatchVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeCategory.self, forKey: .category)
        category = categoryDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let packageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageArn)
        packageArn = packageArnDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let patchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchVersion)
        patchVersion = patchVersionDecoded
        let nodeInterfaceDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeInterface.self, forKey: .nodeInterface)
        nodeInterface = nodeInterfaceDecoded
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension DescribePackageImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/packages/import-jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribePackageImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribePackageImportJobInputBody: Swift.Equatable {
}

extension DescribePackageImportJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePackageImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePackageImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePackageImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePackageImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePackageImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.createdTime = output.createdTime
            self.inputConfig = output.inputConfig
            self.jobId = output.jobId
            self.jobTags = output.jobTags
            self.jobType = output.jobType
            self.lastUpdatedTime = output.lastUpdatedTime
            self.output = output.output
            self.outputConfig = output.outputConfig
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.clientToken = nil
            self.createdTime = nil
            self.inputConfig = nil
            self.jobId = nil
            self.jobTags = nil
            self.jobType = nil
            self.lastUpdatedTime = nil
            self.output = nil
            self.outputConfig = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribePackageImportJobOutputResponse: Swift.Equatable {
    /// The job's client token.
    public var clientToken: Swift.String?
    /// When the job was created.
    /// This member is required.
    public var createdTime: ClientRuntime.Date?
    /// The job's input config.
    /// This member is required.
    public var inputConfig: PanoramaClientTypes.PackageImportJobInputConfig?
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The job's tags.
    public var jobTags: [PanoramaClientTypes.JobResourceTags]?
    /// The job's type.
    /// This member is required.
    public var jobType: PanoramaClientTypes.PackageImportJobType?
    /// When the job was updated.
    /// This member is required.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The job's output.
    /// This member is required.
    public var output: PanoramaClientTypes.PackageImportJobOutput?
    /// The job's output config.
    /// This member is required.
    public var outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig?
    /// The job's status.
    /// This member is required.
    public var status: PanoramaClientTypes.PackageImportJobStatus?
    /// The job's status message.
    /// This member is required.
    public var statusMessage: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        inputConfig: PanoramaClientTypes.PackageImportJobInputConfig? = nil,
        jobId: Swift.String? = nil,
        jobTags: [PanoramaClientTypes.JobResourceTags]? = nil,
        jobType: PanoramaClientTypes.PackageImportJobType? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        output: PanoramaClientTypes.PackageImportJobOutput? = nil,
        outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig? = nil,
        status: PanoramaClientTypes.PackageImportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.createdTime = createdTime
        self.inputConfig = inputConfig
        self.jobId = jobId
        self.jobTags = jobTags
        self.jobType = jobType
        self.lastUpdatedTime = lastUpdatedTime
        self.output = output
        self.outputConfig = outputConfig
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct DescribePackageImportJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
    let clientToken: Swift.String?
    let jobType: PanoramaClientTypes.PackageImportJobType?
    let inputConfig: PanoramaClientTypes.PackageImportJobInputConfig?
    let outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig?
    let output: PanoramaClientTypes.PackageImportJobOutput?
    let createdTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let status: PanoramaClientTypes.PackageImportJobStatus?
    let statusMessage: Swift.String?
    let jobTags: [PanoramaClientTypes.JobResourceTags]?
}

extension DescribePackageImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case createdTime = "CreatedTime"
        case inputConfig = "InputConfig"
        case jobId = "JobId"
        case jobTags = "JobTags"
        case jobType = "JobType"
        case lastUpdatedTime = "LastUpdatedTime"
        case output = "Output"
        case outputConfig = "OutputConfig"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobInputConfig.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobOutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let outputDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobOutput.self, forKey: .output)
        output = outputDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let jobTagsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.JobResourceTags?].self, forKey: .jobTags)
        var jobTagsDecoded0:[PanoramaClientTypes.JobResourceTags]? = nil
        if let jobTagsContainer = jobTagsContainer {
            jobTagsDecoded0 = [PanoramaClientTypes.JobResourceTags]()
            for structure0 in jobTagsContainer {
                if let structure0 = structure0 {
                    jobTagsDecoded0?.append(structure0)
                }
            }
        }
        jobTags = jobTagsDecoded0
    }
}

extension DescribePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageId = packageId else {
            return nil
        }
        return "/packages/metadata/\(packageId.urlPercentEncoding())"
    }
}

public struct DescribePackageInput: Swift.Equatable {
    /// The package's ID.
    /// This member is required.
    public var packageId: Swift.String?

    public init (
        packageId: Swift.String? = nil
    )
    {
        self.packageId = packageId
    }
}

struct DescribePackageInputBody: Swift.Equatable {
}

extension DescribePackageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdTime = output.createdTime
            self.packageId = output.packageId
            self.packageName = output.packageName
            self.readAccessPrincipalArns = output.readAccessPrincipalArns
            self.storageLocation = output.storageLocation
            self.tags = output.tags
            self.writeAccessPrincipalArns = output.writeAccessPrincipalArns
        } else {
            self.arn = nil
            self.createdTime = nil
            self.packageId = nil
            self.packageName = nil
            self.readAccessPrincipalArns = nil
            self.storageLocation = nil
            self.tags = nil
            self.writeAccessPrincipalArns = nil
        }
    }
}

public struct DescribePackageOutputResponse: Swift.Equatable {
    /// The package's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the package was created.
    /// This member is required.
    public var createdTime: ClientRuntime.Date?
    /// The package's ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// The package's name.
    /// This member is required.
    public var packageName: Swift.String?
    /// ARNs of accounts that have read access to the package.
    public var readAccessPrincipalArns: [Swift.String]?
    /// The package's storage location.
    /// This member is required.
    public var storageLocation: PanoramaClientTypes.StorageLocation?
    /// The package's tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// ARNs of accounts that have write access to the package.
    public var writeAccessPrincipalArns: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        packageId: Swift.String? = nil,
        packageName: Swift.String? = nil,
        readAccessPrincipalArns: [Swift.String]? = nil,
        storageLocation: PanoramaClientTypes.StorageLocation? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        writeAccessPrincipalArns: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.packageId = packageId
        self.packageName = packageName
        self.readAccessPrincipalArns = readAccessPrincipalArns
        self.storageLocation = storageLocation
        self.tags = tags
        self.writeAccessPrincipalArns = writeAccessPrincipalArns
    }
}

struct DescribePackageOutputResponseBody: Swift.Equatable {
    let packageId: Swift.String?
    let packageName: Swift.String?
    let arn: Swift.String?
    let storageLocation: PanoramaClientTypes.StorageLocation?
    let readAccessPrincipalArns: [Swift.String]?
    let writeAccessPrincipalArns: [Swift.String]?
    let createdTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension DescribePackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case packageId = "PackageId"
        case packageName = "PackageName"
        case readAccessPrincipalArns = "ReadAccessPrincipalArns"
        case storageLocation = "StorageLocation"
        case tags = "Tags"
        case writeAccessPrincipalArns = "WriteAccessPrincipalArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let storageLocationDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.StorageLocation.self, forKey: .storageLocation)
        storageLocation = storageLocationDecoded
        let readAccessPrincipalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .readAccessPrincipalArns)
        var readAccessPrincipalArnsDecoded0:[Swift.String]? = nil
        if let readAccessPrincipalArnsContainer = readAccessPrincipalArnsContainer {
            readAccessPrincipalArnsDecoded0 = [Swift.String]()
            for string0 in readAccessPrincipalArnsContainer {
                if let string0 = string0 {
                    readAccessPrincipalArnsDecoded0?.append(string0)
                }
            }
        }
        readAccessPrincipalArns = readAccessPrincipalArnsDecoded0
        let writeAccessPrincipalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .writeAccessPrincipalArns)
        var writeAccessPrincipalArnsDecoded0:[Swift.String]? = nil
        if let writeAccessPrincipalArnsContainer = writeAccessPrincipalArnsContainer {
            writeAccessPrincipalArnsDecoded0 = [Swift.String]()
            for string0 in writeAccessPrincipalArnsContainer {
                if let string0 = string0 {
                    writeAccessPrincipalArnsDecoded0?.append(string0)
                }
            }
        }
        writeAccessPrincipalArns = writeAccessPrincipalArnsDecoded0
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribePackageVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let patchVersion = patchVersion {
                let patchVersionQueryItem = ClientRuntime.URLQueryItem(name: "PatchVersion".urlPercentEncoding(), value: Swift.String(patchVersion).urlPercentEncoding())
                items.append(patchVersionQueryItem)
            }
            if let ownerAccount = ownerAccount {
                let ownerAccountQueryItem = ClientRuntime.URLQueryItem(name: "OwnerAccount".urlPercentEncoding(), value: Swift.String(ownerAccount).urlPercentEncoding())
                items.append(ownerAccountQueryItem)
            }
            return items
        }
    }
}

extension DescribePackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageId = packageId else {
            return nil
        }
        guard let packageVersion = packageVersion else {
            return nil
        }
        return "/packages/metadata/\(packageId.urlPercentEncoding())/versions/\(packageVersion.urlPercentEncoding())"
    }
}

public struct DescribePackageVersionInput: Swift.Equatable {
    /// The version's owner account.
    public var ownerAccount: Swift.String?
    /// The version's ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// The version's version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The version's patch version.
    public var patchVersion: Swift.String?

    public init (
        ownerAccount: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil
    )
    {
        self.ownerAccount = ownerAccount
        self.packageId = packageId
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
    }
}

struct DescribePackageVersionInputBody: Swift.Equatable {
}

extension DescribePackageVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePackageVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePackageVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePackageVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePackageVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePackageVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isLatestPatch = output.isLatestPatch
            self.ownerAccount = output.ownerAccount
            self.packageArn = output.packageArn
            self.packageId = output.packageId
            self.packageName = output.packageName
            self.packageVersion = output.packageVersion
            self.patchVersion = output.patchVersion
            self.registeredTime = output.registeredTime
            self.status = output.status
            self.statusDescription = output.statusDescription
        } else {
            self.isLatestPatch = false
            self.ownerAccount = nil
            self.packageArn = nil
            self.packageId = nil
            self.packageName = nil
            self.packageVersion = nil
            self.patchVersion = nil
            self.registeredTime = nil
            self.status = nil
            self.statusDescription = nil
        }
    }
}

public struct DescribePackageVersionOutputResponse: Swift.Equatable {
    /// Whether the version is the latest available.
    /// This member is required.
    public var isLatestPatch: Swift.Bool
    /// The account ID of the version's owner.
    public var ownerAccount: Swift.String?
    /// The ARN of the package.
    public var packageArn: Swift.String?
    /// The version's ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// The version's name.
    /// This member is required.
    public var packageName: Swift.String?
    /// The version's version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The version's patch version.
    /// This member is required.
    public var patchVersion: Swift.String?
    /// The version's registered time.
    public var registeredTime: ClientRuntime.Date?
    /// The version's status.
    /// This member is required.
    public var status: PanoramaClientTypes.PackageVersionStatus?
    /// The version's status description.
    public var statusDescription: Swift.String?

    public init (
        isLatestPatch: Swift.Bool = false,
        ownerAccount: Swift.String? = nil,
        packageArn: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil,
        registeredTime: ClientRuntime.Date? = nil,
        status: PanoramaClientTypes.PackageVersionStatus? = nil,
        statusDescription: Swift.String? = nil
    )
    {
        self.isLatestPatch = isLatestPatch
        self.ownerAccount = ownerAccount
        self.packageArn = packageArn
        self.packageId = packageId
        self.packageName = packageName
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
        self.registeredTime = registeredTime
        self.status = status
        self.statusDescription = statusDescription
    }
}

struct DescribePackageVersionOutputResponseBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let packageId: Swift.String?
    let packageArn: Swift.String?
    let packageName: Swift.String?
    let packageVersion: Swift.String?
    let patchVersion: Swift.String?
    let isLatestPatch: Swift.Bool
    let status: PanoramaClientTypes.PackageVersionStatus?
    let statusDescription: Swift.String?
    let registeredTime: ClientRuntime.Date?
}

extension DescribePackageVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLatestPatch = "IsLatestPatch"
        case ownerAccount = "OwnerAccount"
        case packageArn = "PackageArn"
        case packageId = "PackageId"
        case packageName = "PackageName"
        case packageVersion = "PackageVersion"
        case patchVersion = "PatchVersion"
        case registeredTime = "RegisteredTime"
        case status = "Status"
        case statusDescription = "StatusDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let packageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageArn)
        packageArn = packageArnDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let patchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchVersion)
        patchVersion = patchVersionDecoded
        let isLatestPatchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLatestPatch) ?? false
        isLatestPatch = isLatestPatchDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDescription)
        statusDescription = statusDescriptionDecoded
        let registeredTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .registeredTime)
        registeredTime = registeredTimeDecoded
    }
}

extension PanoramaClientTypes {
    public enum DesiredState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case removed
        case running
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DesiredState] {
            return [
                .removed,
                .running,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .removed: return "REMOVED"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DesiredState(rawValue: rawValue) ?? DesiredState.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.Device: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brand = "Brand"
        case createdTime = "CreatedTime"
        case currentSoftware = "CurrentSoftware"
        case description = "Description"
        case deviceAggregatedStatus = "DeviceAggregatedStatus"
        case deviceId = "DeviceId"
        case lastUpdatedTime = "LastUpdatedTime"
        case latestDeviceJob = "LatestDeviceJob"
        case leaseExpirationTime = "LeaseExpirationTime"
        case name = "Name"
        case provisioningStatus = "ProvisioningStatus"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brand = self.brand {
            try encodeContainer.encode(brand.rawValue, forKey: .brand)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let currentSoftware = self.currentSoftware {
            try encodeContainer.encode(currentSoftware, forKey: .currentSoftware)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceAggregatedStatus = self.deviceAggregatedStatus {
            try encodeContainer.encode(deviceAggregatedStatus.rawValue, forKey: .deviceAggregatedStatus)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let latestDeviceJob = self.latestDeviceJob {
            try encodeContainer.encode(latestDeviceJob, forKey: .latestDeviceJob)
        }
        if let leaseExpirationTime = self.leaseExpirationTime {
            try encodeContainer.encodeTimestamp(leaseExpirationTime, format: .epochSeconds, forKey: .leaseExpirationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioningStatus = self.provisioningStatus {
            try encodeContainer.encode(provisioningStatus.rawValue, forKey: .provisioningStatus)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let provisioningStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceStatus.self, forKey: .provisioningStatus)
        provisioningStatus = provisioningStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let leaseExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .leaseExpirationTime)
        leaseExpirationTime = leaseExpirationTimeDecoded
        let brandDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceBrand.self, forKey: .brand)
        brand = brandDecoded
        let currentSoftwareDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentSoftware)
        currentSoftware = currentSoftwareDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceType.self, forKey: .type)
        type = typeDecoded
        let latestDeviceJobDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.LatestDeviceJob.self, forKey: .latestDeviceJob)
        latestDeviceJob = latestDeviceJobDecoded
        let deviceAggregatedStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceAggregatedStatus.self, forKey: .deviceAggregatedStatus)
        deviceAggregatedStatus = deviceAggregatedStatusDecoded
    }
}

extension PanoramaClientTypes {
    /// A device.
    public struct Device: Swift.Equatable {
        /// The device's maker.
        public var brand: PanoramaClientTypes.DeviceBrand?
        /// When the device was created.
        public var createdTime: ClientRuntime.Date?
        /// A device's current software.
        public var currentSoftware: Swift.String?
        /// A description for the device.
        public var description: Swift.String?
        /// A device's aggregated status. Including the device's connection status, provisioning status, and lease status.
        public var deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus?
        /// The device's ID.
        public var deviceId: Swift.String?
        /// When the device was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A device's latest job. Includes the target image version, and the update job status.
        public var latestDeviceJob: PanoramaClientTypes.LatestDeviceJob?
        /// The device's lease expiration time.
        public var leaseExpirationTime: ClientRuntime.Date?
        /// The device's name.
        public var name: Swift.String?
        /// The device's provisioning status.
        public var provisioningStatus: PanoramaClientTypes.DeviceStatus?
        /// The device's tags.
        public var tags: [Swift.String:Swift.String]?
        /// The device's type.
        public var type: PanoramaClientTypes.DeviceType?

        public init (
            brand: PanoramaClientTypes.DeviceBrand? = nil,
            createdTime: ClientRuntime.Date? = nil,
            currentSoftware: Swift.String? = nil,
            description: Swift.String? = nil,
            deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus? = nil,
            deviceId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            latestDeviceJob: PanoramaClientTypes.LatestDeviceJob? = nil,
            leaseExpirationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            provisioningStatus: PanoramaClientTypes.DeviceStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: PanoramaClientTypes.DeviceType? = nil
        )
        {
            self.brand = brand
            self.createdTime = createdTime
            self.currentSoftware = currentSoftware
            self.description = description
            self.deviceAggregatedStatus = deviceAggregatedStatus
            self.deviceId = deviceId
            self.lastUpdatedTime = lastUpdatedTime
            self.latestDeviceJob = latestDeviceJob
            self.leaseExpirationTime = leaseExpirationTime
            self.name = name
            self.provisioningStatus = provisioningStatus
            self.tags = tags
            self.type = type
        }
    }

}

extension PanoramaClientTypes {
    public enum DeviceAggregatedStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingProvisioning
        case deleting
        case error
        case failed
        case leaseExpired
        case offline
        case online
        case pending
        case rebooting
        case updateNeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceAggregatedStatus] {
            return [
                .awaitingProvisioning,
                .deleting,
                .error,
                .failed,
                .leaseExpired,
                .offline,
                .online,
                .pending,
                .rebooting,
                .updateNeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingProvisioning: return "AWAITING_PROVISIONING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .failed: return "FAILED"
            case .leaseExpired: return "LEASE_EXPIRED"
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .pending: return "PENDING"
            case .rebooting: return "REBOOTING"
            case .updateNeeded: return "UPDATE_NEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceAggregatedStatus(rawValue: rawValue) ?? DeviceAggregatedStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum DeviceBrand: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsPanorama
        case lenovo
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceBrand] {
            return [
                .awsPanorama,
                .lenovo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsPanorama: return "AWS_PANORAMA"
            case .lenovo: return "LENOVO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceBrand(rawValue: rawValue) ?? DeviceBrand.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum DeviceConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingCredentials
        case error
        case notAvailable
        case offline
        case online
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceConnectionStatus] {
            return [
                .awaitingCredentials,
                .error,
                .notAvailable,
                .offline,
                .online,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingCredentials: return "AWAITING_CREDENTIALS"
            case .error: return "ERROR"
            case .notAvailable: return "NOT_AVAILABLE"
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceConnectionStatus(rawValue: rawValue) ?? DeviceConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.DeviceJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case deviceId = "DeviceId"
        case deviceName = "DeviceName"
        case jobId = "JobId"
        case jobType = "JobType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
    }
}

extension PanoramaClientTypes {
    /// A job that runs on a device.
    public struct DeviceJob: Swift.Equatable {
        /// When the job was created.
        public var createdTime: ClientRuntime.Date?
        /// The ID of the target device.
        public var deviceId: Swift.String?
        /// The name of the target device
        public var deviceName: Swift.String?
        /// The job's ID.
        public var jobId: Swift.String?
        /// The job's type.
        public var jobType: PanoramaClientTypes.JobType?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            deviceId: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobType: PanoramaClientTypes.JobType? = nil
        )
        {
            self.createdTime = createdTime
            self.deviceId = deviceId
            self.deviceName = deviceName
            self.jobId = jobId
            self.jobType = jobType
        }
    }

}

extension PanoramaClientTypes.DeviceJobConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case otaJobConfig = "OTAJobConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let otaJobConfig = self.otaJobConfig {
            try encodeContainer.encode(otaJobConfig, forKey: .otaJobConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otaJobConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.OTAJobConfig.self, forKey: .otaJobConfig)
        otaJobConfig = otaJobConfigDecoded
    }
}

extension PanoramaClientTypes {
    /// A job's configuration.
    public struct DeviceJobConfig: Swift.Equatable {
        /// A configuration for an over-the-air (OTA) upgrade. Required for OTA jobs.
        public var otaJobConfig: PanoramaClientTypes.OTAJobConfig?

        public init (
            otaJobConfig: PanoramaClientTypes.OTAJobConfig? = nil
        )
        {
            self.otaJobConfig = otaJobConfig
        }
    }

}

extension PanoramaClientTypes {
    public enum DeviceReportedStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case installError
        case installInProgress
        case launched
        case launchError
        case removalFailed
        case removalInProgress
        case running
        case starting
        case stopped
        case stopping
        case stopError
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceReportedStatus] {
            return [
                .installError,
                .installInProgress,
                .launched,
                .launchError,
                .removalFailed,
                .removalInProgress,
                .running,
                .starting,
                .stopped,
                .stopping,
                .stopError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .installError: return "INSTALL_ERROR"
            case .installInProgress: return "INSTALL_IN_PROGRESS"
            case .launched: return "LAUNCHED"
            case .launchError: return "LAUNCH_ERROR"
            case .removalFailed: return "REMOVAL_FAILED"
            case .removalInProgress: return "REMOVAL_IN_PROGRESS"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .stopError: return "STOP_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceReportedStatus(rawValue: rawValue) ?? DeviceReportedStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingProvisioning
        case deleting
        case error
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .awaitingProvisioning,
                .deleting,
                .error,
                .failed,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingProvisioning: return "AWAITING_PROVISIONING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum DeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case panoramaAppliance
        case panoramaApplianceDeveloperKit
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceType] {
            return [
                .panoramaAppliance,
                .panoramaApplianceDeveloperKit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .panoramaAppliance: return "PANORAMA_APPLIANCE"
            case .panoramaApplianceDeveloperKit: return "PANORAMA_APPLIANCE_DEVELOPER_KIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceType(rawValue: rawValue) ?? DeviceType.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.EthernetPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionType = "ConnectionType"
        case staticIpConnectionInfo = "StaticIpConnectionInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionType = self.connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let staticIpConnectionInfo = self.staticIpConnectionInfo {
            try encodeContainer.encode(staticIpConnectionInfo, forKey: .staticIpConnectionInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let staticIpConnectionInfoDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.StaticIpConnectionInfo.self, forKey: .staticIpConnectionInfo)
        staticIpConnectionInfo = staticIpConnectionInfoDecoded
    }
}

extension PanoramaClientTypes {
    /// A device's network configuration.
    public struct EthernetPayload: Swift.Equatable {
        /// How the device gets an IP address.
        /// This member is required.
        public var connectionType: PanoramaClientTypes.ConnectionType?
        /// Network configuration for a static IP connection.
        public var staticIpConnectionInfo: PanoramaClientTypes.StaticIpConnectionInfo?

        public init (
            connectionType: PanoramaClientTypes.ConnectionType? = nil,
            staticIpConnectionInfo: PanoramaClientTypes.StaticIpConnectionInfo? = nil
        )
        {
            self.connectionType = connectionType
            self.staticIpConnectionInfo = staticIpConnectionInfo
        }
    }

}

extension PanoramaClientTypes.EthernetStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case hwAddress = "HwAddress"
        case ipAddress = "IpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus.rawValue, forKey: .connectionStatus)
        }
        if let hwAddress = self.hwAddress {
            try encodeContainer.encode(hwAddress, forKey: .hwAddress)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NetworkConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let hwAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hwAddress)
        hwAddress = hwAddressDecoded
    }
}

extension PanoramaClientTypes {
    /// A device's Ethernet status.
    public struct EthernetStatus: Swift.Equatable {
        /// The device's connection status.
        public var connectionStatus: PanoramaClientTypes.NetworkConnectionStatus?
        /// The device's physical address.
        public var hwAddress: Swift.String?
        /// The device's IP address.
        public var ipAddress: Swift.String?

        public init (
            connectionStatus: PanoramaClientTypes.NetworkConnectionStatus? = nil,
            hwAddress: Swift.String? = nil,
            ipAddress: Swift.String? = nil
        )
        {
            self.connectionStatus = connectionStatus
            self.hwAddress = hwAddress
            self.ipAddress = ipAddress
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error occurred.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The number of seconds a client should wait before retrying the call.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PanoramaClientTypes.Job: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension PanoramaClientTypes {
    /// A job for a device.
    public struct Job: Swift.Equatable {
        /// The target device's ID.
        public var deviceId: Swift.String?
        /// The job's ID.
        public var jobId: Swift.String?

        public init (
            deviceId: Swift.String? = nil,
            jobId: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.jobId = jobId
        }
    }

}

extension PanoramaClientTypes.JobResourceTags: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.JobResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PanoramaClientTypes {
    /// Tags for a job.
    public struct JobResourceTags: Swift.Equatable {
        /// The job's type.
        /// This member is required.
        public var resourceType: PanoramaClientTypes.JobResourceType?
        /// The job's tags.
        /// This member is required.
        public var tags: [Swift.String:Swift.String]?

        public init (
            resourceType: PanoramaClientTypes.JobResourceType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.resourceType = resourceType
            self.tags = tags
        }
    }

}

extension PanoramaClientTypes {
    public enum JobResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case package
        case sdkUnknown(Swift.String)

        public static var allCases: [JobResourceType] {
            return [
                .package,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .package: return "PACKAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobResourceType(rawValue: rawValue) ?? JobResourceType.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ota
        case reboot
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .ota,
                .reboot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ota: return "OTA"
            case .reboot: return "REBOOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.LatestDeviceJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageVersion = "ImageVersion"
        case jobType = "JobType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageVersion = self.imageVersion {
            try encodeContainer.encode(imageVersion, forKey: .imageVersion)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageVersion)
        imageVersion = imageVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.UpdateProgress.self, forKey: .status)
        status = statusDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
    }
}

extension PanoramaClientTypes {
    /// Returns information about the latest device job.
    public struct LatestDeviceJob: Swift.Equatable {
        /// The target version of the device software.
        public var imageVersion: Swift.String?
        /// The job's type.
        public var jobType: PanoramaClientTypes.JobType?
        /// Status of the latest device job.
        public var status: PanoramaClientTypes.UpdateProgress?

        public init (
            imageVersion: Swift.String? = nil,
            jobType: PanoramaClientTypes.JobType? = nil,
            status: PanoramaClientTypes.UpdateProgress? = nil
        )
        {
            self.imageVersion = imageVersion
            self.jobType = jobType
            self.status = status
        }
    }

}

extension ListApplicationInstanceDependenciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationInstanceDependenciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationInstanceId = applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())/package-dependencies"
    }
}

public struct ListApplicationInstanceDependenciesInput: Swift.Equatable {
    /// The application instance's ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?
    /// The maximum number of application instance dependencies to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        applicationInstanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationInstanceDependenciesInputBody: Swift.Equatable {
}

extension ListApplicationInstanceDependenciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationInstanceDependenciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationInstanceDependenciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApplicationInstanceDependenciesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationInstanceDependenciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApplicationInstanceDependenciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packageObjects = output.packageObjects
        } else {
            self.nextToken = nil
            self.packageObjects = nil
        }
    }
}

public struct ListApplicationInstanceDependenciesOutputResponse: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of package objects.
    public var packageObjects: [PanoramaClientTypes.PackageObject]?

    public init (
        nextToken: Swift.String? = nil,
        packageObjects: [PanoramaClientTypes.PackageObject]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageObjects = packageObjects
    }
}

struct ListApplicationInstanceDependenciesOutputResponseBody: Swift.Equatable {
    let packageObjects: [PanoramaClientTypes.PackageObject]?
    let nextToken: Swift.String?
}

extension ListApplicationInstanceDependenciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case packageObjects = "PackageObjects"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageObjectsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.PackageObject?].self, forKey: .packageObjects)
        var packageObjectsDecoded0:[PanoramaClientTypes.PackageObject]? = nil
        if let packageObjectsContainer = packageObjectsContainer {
            packageObjectsDecoded0 = [PanoramaClientTypes.PackageObject]()
            for structure0 in packageObjectsContainer {
                if let structure0 = structure0 {
                    packageObjectsDecoded0?.append(structure0)
                }
            }
        }
        packageObjects = packageObjectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationInstanceNodeInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationInstanceNodeInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationInstanceId = applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())/node-instances"
    }
}

public struct ListApplicationInstanceNodeInstancesInput: Swift.Equatable {
    /// The node instances' application instance ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?
    /// The maximum number of node instances to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        applicationInstanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationInstanceNodeInstancesInputBody: Swift.Equatable {
}

extension ListApplicationInstanceNodeInstancesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationInstanceNodeInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationInstanceNodeInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApplicationInstanceNodeInstancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationInstanceNodeInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApplicationInstanceNodeInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodeInstances = output.nodeInstances
        } else {
            self.nextToken = nil
            self.nodeInstances = nil
        }
    }
}

public struct ListApplicationInstanceNodeInstancesOutputResponse: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of node instances.
    public var nodeInstances: [PanoramaClientTypes.NodeInstance]?

    public init (
        nextToken: Swift.String? = nil,
        nodeInstances: [PanoramaClientTypes.NodeInstance]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodeInstances = nodeInstances
    }
}

struct ListApplicationInstanceNodeInstancesOutputResponseBody: Swift.Equatable {
    let nodeInstances: [PanoramaClientTypes.NodeInstance]?
    let nextToken: Swift.String?
}

extension ListApplicationInstanceNodeInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case nodeInstances = "NodeInstances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeInstancesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.NodeInstance?].self, forKey: .nodeInstances)
        var nodeInstancesDecoded0:[PanoramaClientTypes.NodeInstance]? = nil
        if let nodeInstancesContainer = nodeInstancesContainer {
            nodeInstancesDecoded0 = [PanoramaClientTypes.NodeInstance]()
            for structure0 in nodeInstancesContainer {
                if let structure0 = structure0 {
                    nodeInstancesDecoded0?.append(structure0)
                }
            }
        }
        nodeInstances = nodeInstancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let deviceId = deviceId {
                let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
                items.append(deviceIdQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let statusFilter = statusFilter {
                let statusFilterQueryItem = ClientRuntime.URLQueryItem(name: "statusFilter".urlPercentEncoding(), value: Swift.String(statusFilter.rawValue).urlPercentEncoding())
                items.append(statusFilterQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/application-instances"
    }
}

public struct ListApplicationInstancesInput: Swift.Equatable {
    /// The application instances' device ID.
    public var deviceId: Swift.String?
    /// The maximum number of application instances to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Only include instances with a specific status.
    public var statusFilter: PanoramaClientTypes.StatusFilter?

    public init (
        deviceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        statusFilter: PanoramaClientTypes.StatusFilter? = nil
    )
    {
        self.deviceId = deviceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.statusFilter = statusFilter
    }
}

struct ListApplicationInstancesInputBody: Swift.Equatable {
}

extension ListApplicationInstancesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApplicationInstancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApplicationInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInstances = output.applicationInstances
            self.nextToken = output.nextToken
        } else {
            self.applicationInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationInstancesOutputResponse: Swift.Equatable {
    /// A list of application instances.
    public var applicationInstances: [PanoramaClientTypes.ApplicationInstance]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        applicationInstances: [PanoramaClientTypes.ApplicationInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationInstances = applicationInstances
        self.nextToken = nextToken
    }
}

struct ListApplicationInstancesOutputResponseBody: Swift.Equatable {
    let applicationInstances: [PanoramaClientTypes.ApplicationInstance]?
    let nextToken: Swift.String?
}

extension ListApplicationInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstances = "ApplicationInstances"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInstancesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.ApplicationInstance?].self, forKey: .applicationInstances)
        var applicationInstancesDecoded0:[PanoramaClientTypes.ApplicationInstance]? = nil
        if let applicationInstancesContainer = applicationInstancesContainer {
            applicationInstancesDecoded0 = [PanoramaClientTypes.ApplicationInstance]()
            for structure0 in applicationInstancesContainer {
                if let structure0 = structure0 {
                    applicationInstancesDecoded0?.append(structure0)
                }
            }
        }
        applicationInstances = applicationInstancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDevicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nameFilter = nameFilter {
                let nameFilterQueryItem = ClientRuntime.URLQueryItem(name: "NameFilter".urlPercentEncoding(), value: Swift.String(nameFilter).urlPercentEncoding())
                items.append(nameFilterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let sortBy = sortBy {
                let sortByQueryItem = ClientRuntime.URLQueryItem(name: "SortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
                items.append(sortByQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "SortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let deviceAggregatedStatusFilter = deviceAggregatedStatusFilter {
                let deviceAggregatedStatusFilterQueryItem = ClientRuntime.URLQueryItem(name: "DeviceAggregatedStatusFilter".urlPercentEncoding(), value: Swift.String(deviceAggregatedStatusFilter.rawValue).urlPercentEncoding())
                items.append(deviceAggregatedStatusFilterQueryItem)
            }
            return items
        }
    }
}

extension ListDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/devices"
    }
}

public struct ListDevicesInput: Swift.Equatable {
    /// Filter based on a device's status.
    public var deviceAggregatedStatusFilter: PanoramaClientTypes.DeviceAggregatedStatus?
    /// The maximum number of devices to return in one page of results.
    public var maxResults: Swift.Int
    /// Filter based on device's name. Prefixes supported.
    public var nameFilter: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The target column to be sorted on. Default column sort is CREATED_TIME.
    public var sortBy: PanoramaClientTypes.ListDevicesSortBy?
    /// The sorting order for the returned list. SortOrder is DESCENDING by default based on CREATED_TIME. Otherwise, SortOrder is ASCENDING.
    public var sortOrder: PanoramaClientTypes.SortOrder?

    public init (
        deviceAggregatedStatusFilter: PanoramaClientTypes.DeviceAggregatedStatus? = nil,
        maxResults: Swift.Int = 0,
        nameFilter: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: PanoramaClientTypes.ListDevicesSortBy? = nil,
        sortOrder: PanoramaClientTypes.SortOrder? = nil
    )
    {
        self.deviceAggregatedStatusFilter = deviceAggregatedStatusFilter
        self.maxResults = maxResults
        self.nameFilter = nameFilter
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListDevicesInputBody: Swift.Equatable {
}

extension ListDevicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDevicesJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let deviceId = deviceId {
                let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "DeviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
                items.append(deviceIdQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDevicesJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct ListDevicesJobsInput: Swift.Equatable {
    /// Filter results by the job's target device ID.
    public var deviceId: Swift.String?
    /// The maximum number of device jobs to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDevicesJobsInputBody: Swift.Equatable {
}

extension ListDevicesJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDevicesJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicesJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDevicesJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicesJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDevicesJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceJobs = output.deviceJobs
            self.nextToken = output.nextToken
        } else {
            self.deviceJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicesJobsOutputResponse: Swift.Equatable {
    /// A list of jobs.
    public var deviceJobs: [PanoramaClientTypes.DeviceJob]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        deviceJobs: [PanoramaClientTypes.DeviceJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceJobs = deviceJobs
        self.nextToken = nextToken
    }
}

struct ListDevicesJobsOutputResponseBody: Swift.Equatable {
    let deviceJobs: [PanoramaClientTypes.DeviceJob]?
    let nextToken: Swift.String?
}

extension ListDevicesJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceJobs = "DeviceJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceJobsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.DeviceJob?].self, forKey: .deviceJobs)
        var deviceJobsDecoded0:[PanoramaClientTypes.DeviceJob]? = nil
        if let deviceJobsContainer = deviceJobsContainer {
            deviceJobsDecoded0 = [PanoramaClientTypes.DeviceJob]()
            for structure0 in deviceJobsContainer {
                if let structure0 = structure0 {
                    deviceJobsDecoded0?.append(structure0)
                }
            }
        }
        deviceJobs = deviceJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDevicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicesOutputResponse: Swift.Equatable {
    /// A list of devices.
    /// This member is required.
    public var devices: [PanoramaClientTypes.Device]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        devices: [PanoramaClientTypes.Device]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct ListDevicesOutputResponseBody: Swift.Equatable {
    let devices: [PanoramaClientTypes.Device]?
    let nextToken: Swift.String?
}

extension ListDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.Device?].self, forKey: .devices)
        var devicesDecoded0:[PanoramaClientTypes.Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [PanoramaClientTypes.Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PanoramaClientTypes {
    public enum ListDevicesSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdTime
        case deviceAggregatedStatus
        case deviceId
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [ListDevicesSortBy] {
            return [
                .createdTime,
                .deviceAggregatedStatus,
                .deviceId,
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdTime: return "CREATED_TIME"
            case .deviceAggregatedStatus: return "DEVICE_AGGREGATED_STATUS"
            case .deviceId: return "DEVICE_ID"
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListDevicesSortBy(rawValue: rawValue) ?? ListDevicesSortBy.sdkUnknown(rawValue)
        }
    }
}

extension ListNodeFromTemplateJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListNodeFromTemplateJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages/template-job"
    }
}

public struct ListNodeFromTemplateJobsInput: Swift.Equatable {
    /// The maximum number of node from template jobs to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNodeFromTemplateJobsInputBody: Swift.Equatable {
}

extension ListNodeFromTemplateJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListNodeFromTemplateJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNodeFromTemplateJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNodeFromTemplateJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNodeFromTemplateJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNodeFromTemplateJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodeFromTemplateJobs = output.nodeFromTemplateJobs
        } else {
            self.nextToken = nil
            self.nodeFromTemplateJobs = nil
        }
    }
}

public struct ListNodeFromTemplateJobsOutputResponse: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of jobs.
    /// This member is required.
    public var nodeFromTemplateJobs: [PanoramaClientTypes.NodeFromTemplateJob]?

    public init (
        nextToken: Swift.String? = nil,
        nodeFromTemplateJobs: [PanoramaClientTypes.NodeFromTemplateJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodeFromTemplateJobs = nodeFromTemplateJobs
    }
}

struct ListNodeFromTemplateJobsOutputResponseBody: Swift.Equatable {
    let nodeFromTemplateJobs: [PanoramaClientTypes.NodeFromTemplateJob]?
    let nextToken: Swift.String?
}

extension ListNodeFromTemplateJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case nodeFromTemplateJobs = "NodeFromTemplateJobs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeFromTemplateJobsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.NodeFromTemplateJob?].self, forKey: .nodeFromTemplateJobs)
        var nodeFromTemplateJobsDecoded0:[PanoramaClientTypes.NodeFromTemplateJob]? = nil
        if let nodeFromTemplateJobsContainer = nodeFromTemplateJobsContainer {
            nodeFromTemplateJobsDecoded0 = [PanoramaClientTypes.NodeFromTemplateJob]()
            for structure0 in nodeFromTemplateJobsContainer {
                if let structure0 = structure0 {
                    nodeFromTemplateJobsDecoded0?.append(structure0)
                }
            }
        }
        nodeFromTemplateJobs = nodeFromTemplateJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNodesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let patchVersion = patchVersion {
                let patchVersionQueryItem = ClientRuntime.URLQueryItem(name: "patchVersion".urlPercentEncoding(), value: Swift.String(patchVersion).urlPercentEncoding())
                items.append(patchVersionQueryItem)
            }
            if let category = category {
                let categoryQueryItem = ClientRuntime.URLQueryItem(name: "category".urlPercentEncoding(), value: Swift.String(category.rawValue).urlPercentEncoding())
                items.append(categoryQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let packageName = packageName {
                let packageNameQueryItem = ClientRuntime.URLQueryItem(name: "packageName".urlPercentEncoding(), value: Swift.String(packageName).urlPercentEncoding())
                items.append(packageNameQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let ownerAccount = ownerAccount {
                let ownerAccountQueryItem = ClientRuntime.URLQueryItem(name: "ownerAccount".urlPercentEncoding(), value: Swift.String(ownerAccount).urlPercentEncoding())
                items.append(ownerAccountQueryItem)
            }
            if let packageVersion = packageVersion {
                let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "packageVersion".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
                items.append(packageVersionQueryItem)
            }
            return items
        }
    }
}

extension ListNodesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/nodes"
    }
}

public struct ListNodesInput: Swift.Equatable {
    /// Search for nodes by category.
    public var category: PanoramaClientTypes.NodeCategory?
    /// The maximum number of nodes to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Search for nodes by the account ID of the nodes' owner.
    public var ownerAccount: Swift.String?
    /// Search for nodes by name.
    public var packageName: Swift.String?
    /// Search for nodes by version.
    public var packageVersion: Swift.String?
    /// Search for nodes by patch version.
    public var patchVersion: Swift.String?

    public init (
        category: PanoramaClientTypes.NodeCategory? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil
    )
    {
        self.category = category
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerAccount = ownerAccount
        self.packageName = packageName
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
    }
}

struct ListNodesInputBody: Swift.Equatable {
}

extension ListNodesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListNodesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNodesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNodesOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNodesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNodesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodes = output.nodes
        } else {
            self.nextToken = nil
            self.nodes = nil
        }
    }
}

public struct ListNodesOutputResponse: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of nodes.
    public var nodes: [PanoramaClientTypes.Node]?

    public init (
        nextToken: Swift.String? = nil,
        nodes: [PanoramaClientTypes.Node]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodes = nodes
    }
}

struct ListNodesOutputResponseBody: Swift.Equatable {
    let nodes: [PanoramaClientTypes.Node]?
    let nextToken: Swift.String?
}

extension ListNodesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case nodes = "Nodes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.Node?].self, forKey: .nodes)
        var nodesDecoded0:[PanoramaClientTypes.Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [PanoramaClientTypes.Node]()
            for structure0 in nodesContainer {
                if let structure0 = structure0 {
                    nodesDecoded0?.append(structure0)
                }
            }
        }
        nodes = nodesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPackageImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPackageImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages/import-jobs"
    }
}

public struct ListPackageImportJobsInput: Swift.Equatable {
    /// The maximum number of package import jobs to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPackageImportJobsInputBody: Swift.Equatable {
}

extension ListPackageImportJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackageImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackageImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPackageImportJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackageImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPackageImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packageImportJobs = output.packageImportJobs
        } else {
            self.nextToken = nil
            self.packageImportJobs = nil
        }
    }
}

public struct ListPackageImportJobsOutputResponse: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of package import jobs.
    /// This member is required.
    public var packageImportJobs: [PanoramaClientTypes.PackageImportJob]?

    public init (
        nextToken: Swift.String? = nil,
        packageImportJobs: [PanoramaClientTypes.PackageImportJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageImportJobs = packageImportJobs
    }
}

struct ListPackageImportJobsOutputResponseBody: Swift.Equatable {
    let packageImportJobs: [PanoramaClientTypes.PackageImportJob]?
    let nextToken: Swift.String?
}

extension ListPackageImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case packageImportJobs = "PackageImportJobs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageImportJobsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.PackageImportJob?].self, forKey: .packageImportJobs)
        var packageImportJobsDecoded0:[PanoramaClientTypes.PackageImportJob]? = nil
        if let packageImportJobsContainer = packageImportJobsContainer {
            packageImportJobsDecoded0 = [PanoramaClientTypes.PackageImportJob]()
            for structure0 in packageImportJobsContainer {
                if let structure0 = structure0 {
                    packageImportJobsDecoded0?.append(structure0)
                }
            }
        }
        packageImportJobs = packageImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPackagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages"
    }
}

public struct ListPackagesInput: Swift.Equatable {
    /// The maximum number of packages to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPackagesInputBody: Swift.Equatable {
}

extension ListPackagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPackagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPackagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packages = output.packages
        } else {
            self.nextToken = nil
            self.packages = nil
        }
    }
}

public struct ListPackagesOutputResponse: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of packages.
    public var packages: [PanoramaClientTypes.PackageListItem]?

    public init (
        nextToken: Swift.String? = nil,
        packages: [PanoramaClientTypes.PackageListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.packages = packages
    }
}

struct ListPackagesOutputResponseBody: Swift.Equatable {
    let packages: [PanoramaClientTypes.PackageListItem]?
    let nextToken: Swift.String?
}

extension ListPackagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case packages = "Packages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packagesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.PackageListItem?].self, forKey: .packages)
        var packagesDecoded0:[PanoramaClientTypes.PackageListItem]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [PanoramaClientTypes.PackageListItem]()
            for structure0 in packagesContainer {
                if let structure0 = structure0 {
                    packagesDecoded0?.append(structure0)
                }
            }
        }
        packages = packagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PanoramaClientTypes.ManifestOverridesPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloaddata = "PayloadData"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .payloaddata(payloaddata):
                try container.encode(payloaddata, forKey: .payloaddata)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let payloaddataDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .payloaddata)
        if let payloaddata = payloaddataDecoded {
            self = .payloaddata(payloaddata)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PanoramaClientTypes {
    /// Parameter overrides for an application instance. This is a JSON document that has a single key (PayloadData) where the value is an escaped string representation of the overrides document.
    public enum ManifestOverridesPayload: Swift.Equatable, Swift.Hashable {
        /// The overrides document.
        case payloaddata(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension PanoramaClientTypes.ManifestPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloaddata = "PayloadData"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .payloaddata(payloaddata):
                try container.encode(payloaddata, forKey: .payloaddata)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let payloaddataDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .payloaddata)
        if let payloaddata = payloaddataDecoded {
            self = .payloaddata(payloaddata)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PanoramaClientTypes {
    /// A application verion's manifest file. This is a JSON document that has a single key (PayloadData) where the value is an escaped string representation of the application manifest (graph.json). This file is located in the graphs folder in your application source.
    public enum ManifestPayload: Swift.Equatable, Swift.Hashable {
        /// The application manifest.
        case payloaddata(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension PanoramaClientTypes {
    public enum NetworkConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case connecting
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkConnectionStatus] {
            return [
                .connected,
                .connecting,
                .notConnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .connecting: return "CONNECTING"
            case .notConnected: return "NOT_CONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkConnectionStatus(rawValue: rawValue) ?? NetworkConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.NetworkPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ethernet0 = "Ethernet0"
        case ethernet1 = "Ethernet1"
        case ntp = "Ntp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ethernet0 = self.ethernet0 {
            try encodeContainer.encode(ethernet0, forKey: .ethernet0)
        }
        if let ethernet1 = self.ethernet1 {
            try encodeContainer.encode(ethernet1, forKey: .ethernet1)
        }
        if let ntp = self.ntp {
            try encodeContainer.encode(ntp, forKey: .ntp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ethernet0Decoded = try containerValues.decodeIfPresent(PanoramaClientTypes.EthernetPayload.self, forKey: .ethernet0)
        ethernet0 = ethernet0Decoded
        let ethernet1Decoded = try containerValues.decodeIfPresent(PanoramaClientTypes.EthernetPayload.self, forKey: .ethernet1)
        ethernet1 = ethernet1Decoded
        let ntpDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NtpPayload.self, forKey: .ntp)
        ntp = ntpDecoded
    }
}

extension PanoramaClientTypes {
    /// The network configuration for a device.
    public struct NetworkPayload: Swift.Equatable {
        /// Settings for Ethernet port 0.
        public var ethernet0: PanoramaClientTypes.EthernetPayload?
        /// Settings for Ethernet port 1.
        public var ethernet1: PanoramaClientTypes.EthernetPayload?
        /// Network time protocol (NTP) server settings.
        public var ntp: PanoramaClientTypes.NtpPayload?

        public init (
            ethernet0: PanoramaClientTypes.EthernetPayload? = nil,
            ethernet1: PanoramaClientTypes.EthernetPayload? = nil,
            ntp: PanoramaClientTypes.NtpPayload? = nil
        )
        {
            self.ethernet0 = ethernet0
            self.ethernet1 = ethernet1
            self.ntp = ntp
        }
    }

}

extension PanoramaClientTypes.NetworkStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ethernet0Status = "Ethernet0Status"
        case ethernet1Status = "Ethernet1Status"
        case lastUpdatedTime = "LastUpdatedTime"
        case ntpStatus = "NtpStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ethernet0Status = self.ethernet0Status {
            try encodeContainer.encode(ethernet0Status, forKey: .ethernet0Status)
        }
        if let ethernet1Status = self.ethernet1Status {
            try encodeContainer.encode(ethernet1Status, forKey: .ethernet1Status)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let ntpStatus = self.ntpStatus {
            try encodeContainer.encode(ntpStatus, forKey: .ntpStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ethernet0StatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.EthernetStatus.self, forKey: .ethernet0Status)
        ethernet0Status = ethernet0StatusDecoded
        let ethernet1StatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.EthernetStatus.self, forKey: .ethernet1Status)
        ethernet1Status = ethernet1StatusDecoded
        let ntpStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NtpStatus.self, forKey: .ntpStatus)
        ntpStatus = ntpStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension PanoramaClientTypes {
    /// The network status of a device.
    public struct NetworkStatus: Swift.Equatable {
        /// The status of Ethernet port 0.
        public var ethernet0Status: PanoramaClientTypes.EthernetStatus?
        /// The status of Ethernet port 1.
        public var ethernet1Status: PanoramaClientTypes.EthernetStatus?
        /// When the network status changed.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// Details about a network time protocol (NTP) server connection.
        public var ntpStatus: PanoramaClientTypes.NtpStatus?

        public init (
            ethernet0Status: PanoramaClientTypes.EthernetStatus? = nil,
            ethernet1Status: PanoramaClientTypes.EthernetStatus? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            ntpStatus: PanoramaClientTypes.NtpStatus? = nil
        )
        {
            self.ethernet0Status = ethernet0Status
            self.ethernet1Status = ethernet1Status
            self.lastUpdatedTime = lastUpdatedTime
            self.ntpStatus = ntpStatus
        }
    }

}

extension PanoramaClientTypes.Node: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case createdTime = "CreatedTime"
        case description = "Description"
        case name = "Name"
        case nodeId = "NodeId"
        case ownerAccount = "OwnerAccount"
        case packageArn = "PackageArn"
        case packageId = "PackageId"
        case packageName = "PackageName"
        case packageVersion = "PackageVersion"
        case patchVersion = "PatchVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nodeId = self.nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let packageArn = self.packageArn {
            try encodeContainer.encode(packageArn, forKey: .packageArn)
        }
        if let packageId = self.packageId {
            try encodeContainer.encode(packageId, forKey: .packageId)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
        if let patchVersion = self.patchVersion {
            try encodeContainer.encode(patchVersion, forKey: .patchVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeCategory.self, forKey: .category)
        category = categoryDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let packageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageArn)
        packageArn = packageArnDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let patchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchVersion)
        patchVersion = patchVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension PanoramaClientTypes {
    /// An application node that represents a camera stream, a model, code, or output.
    public struct Node: Swift.Equatable {
        /// The node's category.
        /// This member is required.
        public var category: PanoramaClientTypes.NodeCategory?
        /// When the node was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The node's description.
        public var description: Swift.String?
        /// The node's name.
        /// This member is required.
        public var name: Swift.String?
        /// The node's ID.
        /// This member is required.
        public var nodeId: Swift.String?
        /// The account ID of the node's owner.
        public var ownerAccount: Swift.String?
        /// The node's ARN.
        public var packageArn: Swift.String?
        /// The node's package ID.
        /// This member is required.
        public var packageId: Swift.String?
        /// The node's package name.
        /// This member is required.
        public var packageName: Swift.String?
        /// The node's package version.
        /// This member is required.
        public var packageVersion: Swift.String?
        /// The node's patch version.
        /// This member is required.
        public var patchVersion: Swift.String?

        public init (
            category: PanoramaClientTypes.NodeCategory? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            nodeId: Swift.String? = nil,
            ownerAccount: Swift.String? = nil,
            packageArn: Swift.String? = nil,
            packageId: Swift.String? = nil,
            packageName: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            patchVersion: Swift.String? = nil
        )
        {
            self.category = category
            self.createdTime = createdTime
            self.description = description
            self.name = name
            self.nodeId = nodeId
            self.ownerAccount = ownerAccount
            self.packageArn = packageArn
            self.packageId = packageId
            self.packageName = packageName
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }
    }

}

extension PanoramaClientTypes {
    public enum NodeCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case businessLogic
        case mediaSink
        case mediaSource
        case mlModel
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeCategory] {
            return [
                .businessLogic,
                .mediaSink,
                .mediaSource,
                .mlModel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .businessLogic: return "BUSINESS_LOGIC"
            case .mediaSink: return "MEDIA_SINK"
            case .mediaSource: return "MEDIA_SOURCE"
            case .mlModel: return "ML_MODEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeCategory(rawValue: rawValue) ?? NodeCategory.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.NodeFromTemplateJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case jobId = "JobId"
        case nodeName = "NodeName"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case templateType = "TemplateType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let nodeName = self.nodeName {
            try encodeContainer.encode(nodeName, forKey: .nodeName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeFromTemplateJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
    }
}

extension PanoramaClientTypes {
    /// A job to create a camera stream node.
    public struct NodeFromTemplateJob: Swift.Equatable {
        /// When the job was created.
        public var createdTime: ClientRuntime.Date?
        /// The job's ID.
        public var jobId: Swift.String?
        /// The node's name.
        public var nodeName: Swift.String?
        /// The job's status.
        public var status: PanoramaClientTypes.NodeFromTemplateJobStatus?
        /// The job's status message.
        public var statusMessage: Swift.String?
        /// The job's template type.
        public var templateType: PanoramaClientTypes.TemplateType?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            nodeName: Swift.String? = nil,
            status: PanoramaClientTypes.NodeFromTemplateJobStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateType: PanoramaClientTypes.TemplateType? = nil
        )
        {
            self.createdTime = createdTime
            self.jobId = jobId
            self.nodeName = nodeName
            self.status = status
            self.statusMessage = statusMessage
            self.templateType = templateType
        }
    }

}

extension PanoramaClientTypes {
    public enum NodeFromTemplateJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeFromTemplateJobStatus] {
            return [
                .failed,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeFromTemplateJobStatus(rawValue: rawValue) ?? NodeFromTemplateJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.NodeInputPort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case description = "Description"
        case maxConnections = "MaxConnections"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if maxConnections != 0 {
            try encodeContainer.encode(maxConnections, forKey: .maxConnections)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PortType.self, forKey: .type)
        type = typeDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let maxConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConnections) ?? 0
        maxConnections = maxConnectionsDecoded
    }
}

extension PanoramaClientTypes {
    /// A node input port.
    public struct NodeInputPort: Swift.Equatable {
        /// The input port's default value.
        public var defaultValue: Swift.String?
        /// The input port's description.
        public var description: Swift.String?
        /// The input port's max connections.
        public var maxConnections: Swift.Int
        /// The input port's name.
        public var name: Swift.String?
        /// The input port's type.
        public var type: PanoramaClientTypes.PortType?

        public init (
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            maxConnections: Swift.Int = 0,
            name: Swift.String? = nil,
            type: PanoramaClientTypes.PortType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.maxConnections = maxConnections
            self.name = name
            self.type = type
        }
    }

}

extension PanoramaClientTypes.NodeInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentStatus = "CurrentStatus"
        case nodeId = "NodeId"
        case nodeInstanceId = "NodeInstanceId"
        case nodeName = "NodeName"
        case packageName = "PackageName"
        case packagePatchVersion = "PackagePatchVersion"
        case packageVersion = "PackageVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentStatus = self.currentStatus {
            try encodeContainer.encode(currentStatus.rawValue, forKey: .currentStatus)
        }
        if let nodeId = self.nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
        if let nodeInstanceId = self.nodeInstanceId {
            try encodeContainer.encode(nodeInstanceId, forKey: .nodeInstanceId)
        }
        if let nodeName = self.nodeName {
            try encodeContainer.encode(nodeName, forKey: .nodeName)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packagePatchVersion = self.packagePatchVersion {
            try encodeContainer.encode(packagePatchVersion, forKey: .packagePatchVersion)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeInstanceId)
        nodeInstanceId = nodeInstanceIdDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let packagePatchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packagePatchVersion)
        packagePatchVersion = packagePatchVersionDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
        let currentStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeInstanceStatus.self, forKey: .currentStatus)
        currentStatus = currentStatusDecoded
    }
}

extension PanoramaClientTypes {
    /// A node instance.
    public struct NodeInstance: Swift.Equatable {
        /// The instance's current status.
        /// This member is required.
        public var currentStatus: PanoramaClientTypes.NodeInstanceStatus?
        /// The node's ID.
        public var nodeId: Swift.String?
        /// The instance's ID.
        /// This member is required.
        public var nodeInstanceId: Swift.String?
        /// The instance's name.
        public var nodeName: Swift.String?
        /// The instance's package name.
        public var packageName: Swift.String?
        /// The instance's package patch version.
        public var packagePatchVersion: Swift.String?
        /// The instance's package version.
        public var packageVersion: Swift.String?

        public init (
            currentStatus: PanoramaClientTypes.NodeInstanceStatus? = nil,
            nodeId: Swift.String? = nil,
            nodeInstanceId: Swift.String? = nil,
            nodeName: Swift.String? = nil,
            packageName: Swift.String? = nil,
            packagePatchVersion: Swift.String? = nil,
            packageVersion: Swift.String? = nil
        )
        {
            self.currentStatus = currentStatus
            self.nodeId = nodeId
            self.nodeInstanceId = nodeInstanceId
            self.nodeName = nodeName
            self.packageName = packageName
            self.packagePatchVersion = packagePatchVersion
            self.packageVersion = packageVersion
        }
    }

}

extension PanoramaClientTypes {
    public enum NodeInstanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case notAvailable
        case paused
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeInstanceStatus] {
            return [
                .error,
                .notAvailable,
                .paused,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .notAvailable: return "NOT_AVAILABLE"
            case .paused: return "PAUSED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeInstanceStatus(rawValue: rawValue) ?? NodeInstanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.NodeInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputs = "Inputs"
        case outputs = "Outputs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputs)
            for nodeinputport0 in inputs {
                try inputsContainer.encode(nodeinputport0)
            }
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for nodeoutputport0 in outputs {
                try outputsContainer.encode(nodeoutputport0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.NodeInputPort?].self, forKey: .inputs)
        var inputsDecoded0:[PanoramaClientTypes.NodeInputPort]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [PanoramaClientTypes.NodeInputPort]()
            for structure0 in inputsContainer {
                if let structure0 = structure0 {
                    inputsDecoded0?.append(structure0)
                }
            }
        }
        inputs = inputsDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.NodeOutputPort?].self, forKey: .outputs)
        var outputsDecoded0:[PanoramaClientTypes.NodeOutputPort]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [PanoramaClientTypes.NodeOutputPort]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

extension PanoramaClientTypes {
    /// A node interface.
    public struct NodeInterface: Swift.Equatable {
        /// The node interface's inputs.
        /// This member is required.
        public var inputs: [PanoramaClientTypes.NodeInputPort]?
        /// The node interface's outputs.
        /// This member is required.
        public var outputs: [PanoramaClientTypes.NodeOutputPort]?

        public init (
            inputs: [PanoramaClientTypes.NodeInputPort]? = nil,
            outputs: [PanoramaClientTypes.NodeOutputPort]? = nil
        )
        {
            self.inputs = inputs
            self.outputs = outputs
        }
    }

}

extension PanoramaClientTypes.NodeOutputPort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PortType.self, forKey: .type)
        type = typeDecoded
    }
}

extension PanoramaClientTypes {
    /// A node output port.
    public struct NodeOutputPort: Swift.Equatable {
        /// The output port's description.
        public var description: Swift.String?
        /// The output port's name.
        public var name: Swift.String?
        /// The output port's type.
        public var type: PanoramaClientTypes.PortType?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: PanoramaClientTypes.PortType? = nil
        )
        {
            self.description = description
            self.name = name
            self.type = type
        }
    }

}

extension PanoramaClientTypes.NodeSignal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeInstanceId = "NodeInstanceId"
        case signal = "Signal"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeInstanceId = self.nodeInstanceId {
            try encodeContainer.encode(nodeInstanceId, forKey: .nodeInstanceId)
        }
        if let signal = self.signal {
            try encodeContainer.encode(signal.rawValue, forKey: .signal)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeInstanceId)
        nodeInstanceId = nodeInstanceIdDecoded
        let signalDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeSignalValue.self, forKey: .signal)
        signal = signalDecoded
    }
}

extension PanoramaClientTypes {
    /// A signal to a camera node to start or stop processing video.
    public struct NodeSignal: Swift.Equatable {
        /// The camera node's name, from the application manifest.
        /// This member is required.
        public var nodeInstanceId: Swift.String?
        /// The signal value.
        /// This member is required.
        public var signal: PanoramaClientTypes.NodeSignalValue?

        public init (
            nodeInstanceId: Swift.String? = nil,
            signal: PanoramaClientTypes.NodeSignalValue? = nil
        )
        {
            self.nodeInstanceId = nodeInstanceId
            self.signal = signal
        }
    }

}

extension PanoramaClientTypes {
    public enum NodeSignalValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pause
        case resume
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeSignalValue] {
            return [
                .pause,
                .resume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pause: return "PAUSE"
            case .resume: return "RESUME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeSignalValue(rawValue: rawValue) ?? NodeSignalValue.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.NtpPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ntpServers = "NtpServers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ntpServers = ntpServers {
            var ntpServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ntpServers)
            for ipaddressorservername0 in ntpServers {
                try ntpServersContainer.encode(ipaddressorservername0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ntpServersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ntpServers)
        var ntpServersDecoded0:[Swift.String]? = nil
        if let ntpServersContainer = ntpServersContainer {
            ntpServersDecoded0 = [Swift.String]()
            for string0 in ntpServersContainer {
                if let string0 = string0 {
                    ntpServersDecoded0?.append(string0)
                }
            }
        }
        ntpServers = ntpServersDecoded0
    }
}

extension PanoramaClientTypes {
    /// Network time protocol (NTP) server settings. Use this option to connect to local NTP servers instead of pool.ntp.org.
    public struct NtpPayload: Swift.Equatable {
        /// NTP servers to use, in order of preference.
        /// This member is required.
        public var ntpServers: [Swift.String]?

        public init (
            ntpServers: [Swift.String]? = nil
        )
        {
            self.ntpServers = ntpServers
        }
    }

}

extension PanoramaClientTypes.NtpStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case ipAddress = "IpAddress"
        case ntpServerName = "NtpServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus.rawValue, forKey: .connectionStatus)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let ntpServerName = self.ntpServerName {
            try encodeContainer.encode(ntpServerName, forKey: .ntpServerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NetworkConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let ntpServerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ntpServerName)
        ntpServerName = ntpServerNameDecoded
    }
}

extension PanoramaClientTypes {
    /// Details about an NTP server connection.
    public struct NtpStatus: Swift.Equatable {
        /// The connection's status.
        public var connectionStatus: PanoramaClientTypes.NetworkConnectionStatus?
        /// The IP address of the server.
        public var ipAddress: Swift.String?
        /// The domain name of the server.
        public var ntpServerName: Swift.String?

        public init (
            connectionStatus: PanoramaClientTypes.NetworkConnectionStatus? = nil,
            ipAddress: Swift.String? = nil,
            ntpServerName: Swift.String? = nil
        )
        {
            self.connectionStatus = connectionStatus
            self.ipAddress = ipAddress
            self.ntpServerName = ntpServerName
        }
    }

}

extension PanoramaClientTypes.OTAJobConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageVersion = "ImageVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageVersion = self.imageVersion {
            try encodeContainer.encode(imageVersion, forKey: .imageVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageVersion)
        imageVersion = imageVersionDecoded
    }
}

extension PanoramaClientTypes {
    /// An over-the-air update (OTA) job configuration.
    public struct OTAJobConfig: Swift.Equatable {
        /// The target version of the device software.
        /// This member is required.
        public var imageVersion: Swift.String?

        public init (
            imageVersion: Swift.String? = nil
        )
        {
            self.imageVersion = imageVersion
        }
    }

}

extension PanoramaClientTypes.OutPutS3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case objectKey = "ObjectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKey = self.objectKey {
            try encodeContainer.encode(objectKey, forKey: .objectKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKey)
        objectKey = objectKeyDecoded
    }
}

extension PanoramaClientTypes {
    /// The location of an output object in Amazon S3.
    public struct OutPutS3Location: Swift.Equatable {
        /// The object's bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object's key.
        /// This member is required.
        public var objectKey: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }
    }

}

extension PanoramaClientTypes.PackageImportJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case jobId = "JobId"
        case jobType = "JobType"
        case lastUpdatedTime = "LastUpdatedTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension PanoramaClientTypes {
    /// A job to import a package version.
    public struct PackageImportJob: Swift.Equatable {
        /// When the job was created.
        public var createdTime: ClientRuntime.Date?
        /// The job's ID.
        public var jobId: Swift.String?
        /// The job's type.
        public var jobType: PanoramaClientTypes.PackageImportJobType?
        /// When the job was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The job's status.
        public var status: PanoramaClientTypes.PackageImportJobStatus?
        /// The job's status message.
        public var statusMessage: Swift.String?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            jobType: PanoramaClientTypes.PackageImportJobType? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            status: PanoramaClientTypes.PackageImportJobStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.jobId = jobId
            self.jobType = jobType
            self.lastUpdatedTime = lastUpdatedTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension PanoramaClientTypes.PackageImportJobInputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageVersionInputConfig = "PackageVersionInputConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageVersionInputConfig = self.packageVersionInputConfig {
            try encodeContainer.encode(packageVersionInputConfig, forKey: .packageVersionInputConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionInputConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageVersionInputConfig.self, forKey: .packageVersionInputConfig)
        packageVersionInputConfig = packageVersionInputConfigDecoded
    }
}

extension PanoramaClientTypes {
    /// A configuration for a package import job.
    public struct PackageImportJobInputConfig: Swift.Equatable {
        /// The package version's input configuration.
        public var packageVersionInputConfig: PanoramaClientTypes.PackageVersionInputConfig?

        public init (
            packageVersionInputConfig: PanoramaClientTypes.PackageVersionInputConfig? = nil
        )
        {
            self.packageVersionInputConfig = packageVersionInputConfig
        }
    }

}

extension PanoramaClientTypes.PackageImportJobOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputS3Location = "OutputS3Location"
        case packageId = "PackageId"
        case packageVersion = "PackageVersion"
        case patchVersion = "PatchVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3Location = self.outputS3Location {
            try encodeContainer.encode(outputS3Location, forKey: .outputS3Location)
        }
        if let packageId = self.packageId {
            try encodeContainer.encode(packageId, forKey: .packageId)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
        if let patchVersion = self.patchVersion {
            try encodeContainer.encode(patchVersion, forKey: .patchVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let patchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchVersion)
        patchVersion = patchVersionDecoded
        let outputS3LocationDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.OutPutS3Location.self, forKey: .outputS3Location)
        outputS3Location = outputS3LocationDecoded
    }
}

extension PanoramaClientTypes {
    /// Results of a package import job.
    public struct PackageImportJobOutput: Swift.Equatable {
        /// The package's output location.
        /// This member is required.
        public var outputS3Location: PanoramaClientTypes.OutPutS3Location?
        /// The package's ID.
        /// This member is required.
        public var packageId: Swift.String?
        /// The package's version.
        /// This member is required.
        public var packageVersion: Swift.String?
        /// The package's patch version.
        /// This member is required.
        public var patchVersion: Swift.String?

        public init (
            outputS3Location: PanoramaClientTypes.OutPutS3Location? = nil,
            packageId: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            patchVersion: Swift.String? = nil
        )
        {
            self.outputS3Location = outputS3Location
            self.packageId = packageId
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }
    }

}

extension PanoramaClientTypes.PackageImportJobOutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageVersionOutputConfig = "PackageVersionOutputConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageVersionOutputConfig = self.packageVersionOutputConfig {
            try encodeContainer.encode(packageVersionOutputConfig, forKey: .packageVersionOutputConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionOutputConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageVersionOutputConfig.self, forKey: .packageVersionOutputConfig)
        packageVersionOutputConfig = packageVersionOutputConfigDecoded
    }
}

extension PanoramaClientTypes {
    /// An output configuration for a package import job.
    public struct PackageImportJobOutputConfig: Swift.Equatable {
        /// The package version's output configuration.
        public var packageVersionOutputConfig: PanoramaClientTypes.PackageVersionOutputConfig?

        public init (
            packageVersionOutputConfig: PanoramaClientTypes.PackageVersionOutputConfig? = nil
        )
        {
            self.packageVersionOutputConfig = packageVersionOutputConfig
        }
    }

}

extension PanoramaClientTypes {
    public enum PackageImportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageImportJobStatus] {
            return [
                .failed,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageImportJobStatus(rawValue: rawValue) ?? PackageImportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum PackageImportJobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case marketplaceNodePackageVersion
        case nodePackageVersion
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageImportJobType] {
            return [
                .marketplaceNodePackageVersion,
                .nodePackageVersion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .marketplaceNodePackageVersion: return "MARKETPLACE_NODE_PACKAGE_VERSION"
            case .nodePackageVersion: return "NODE_PACKAGE_VERSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageImportJobType(rawValue: rawValue) ?? PackageImportJobType.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.PackageListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case packageId = "PackageId"
        case packageName = "PackageName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let packageId = self.packageId {
            try encodeContainer.encode(packageId, forKey: .packageId)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PanoramaClientTypes {
    /// A package summary.
    public struct PackageListItem: Swift.Equatable {
        /// The package's ARN.
        public var arn: Swift.String?
        /// When the package was created.
        public var createdTime: ClientRuntime.Date?
        /// The package's ID.
        public var packageId: Swift.String?
        /// The package's name.
        public var packageName: Swift.String?
        /// The package's tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            packageId: Swift.String? = nil,
            packageName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.packageId = packageId
            self.packageName = packageName
            self.tags = tags
        }
    }

}

extension PanoramaClientTypes.PackageObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case packageVersion = "PackageVersion"
        case patchVersion = "PatchVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
        if let patchVersion = self.patchVersion {
            try encodeContainer.encode(patchVersion, forKey: .patchVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let patchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchVersion)
        patchVersion = patchVersionDecoded
    }
}

extension PanoramaClientTypes {
    /// A package object.
    public struct PackageObject: Swift.Equatable {
        /// The object's name.
        /// This member is required.
        public var name: Swift.String?
        /// The object's package version.
        /// This member is required.
        public var packageVersion: Swift.String?
        /// The object's patch version.
        /// This member is required.
        public var patchVersion: Swift.String?

        public init (
            name: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            patchVersion: Swift.String? = nil
        )
        {
            self.name = name
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }
    }

}

extension PanoramaClientTypes.PackageVersionInputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location = "S3Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension PanoramaClientTypes {
    /// A package version input configuration.
    public struct PackageVersionInputConfig: Swift.Equatable {
        /// A location in Amazon S3.
        /// This member is required.
        public var s3Location: PanoramaClientTypes.S3Location?

        public init (
            s3Location: PanoramaClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension PanoramaClientTypes.PackageVersionOutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case markLatest = "MarkLatest"
        case packageName = "PackageName"
        case packageVersion = "PackageVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if markLatest != false {
            try encodeContainer.encode(markLatest, forKey: .markLatest)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let markLatestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .markLatest) ?? false
        markLatest = markLatestDecoded
    }
}

extension PanoramaClientTypes {
    /// A package version output configuration.
    public struct PackageVersionOutputConfig: Swift.Equatable {
        /// Indicates that the version is recommended for all users.
        public var markLatest: Swift.Bool
        /// The output's package name.
        /// This member is required.
        public var packageName: Swift.String?
        /// The output's package version.
        /// This member is required.
        public var packageVersion: Swift.String?

        public init (
            markLatest: Swift.Bool = false,
            packageName: Swift.String? = nil,
            packageVersion: Swift.String? = nil
        )
        {
            self.markLatest = markLatest
            self.packageName = packageName
            self.packageVersion = packageVersion
        }
    }

}

extension PanoramaClientTypes {
    public enum PackageVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case failed
        case registerCompleted
        case registerPending
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionStatus] {
            return [
                .deleting,
                .failed,
                .registerCompleted,
                .registerPending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .registerCompleted: return "REGISTER_COMPLETED"
            case .registerPending: return "REGISTER_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionStatus(rawValue: rawValue) ?? PackageVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum PortType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case float32
        case int32
        case media
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [PortType] {
            return [
                .boolean,
                .float32,
                .int32,
                .media,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .float32: return "FLOAT32"
            case .int32: return "INT32"
            case .media: return "MEDIA"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PortType(rawValue: rawValue) ?? PortType.sdkUnknown(rawValue)
        }
    }
}

extension ProvisionDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case networkingConfiguration = "NetworkingConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkingConfiguration = self.networkingConfiguration {
            try encodeContainer.encode(networkingConfiguration, forKey: .networkingConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension ProvisionDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/devices"
    }
}

public struct ProvisionDeviceInput: Swift.Equatable {
    /// A description for the device.
    public var description: Swift.String?
    /// A name for the device.
    /// This member is required.
    public var name: Swift.String?
    /// A networking configuration for the device.
    public var networkingConfiguration: PanoramaClientTypes.NetworkPayload?
    /// Tags for the device.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        networkingConfiguration: PanoramaClientTypes.NetworkPayload? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.networkingConfiguration = networkingConfiguration
        self.tags = tags
    }
}

struct ProvisionDeviceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let networkingConfiguration: PanoramaClientTypes.NetworkPayload?
}

extension ProvisionDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case networkingConfiguration = "NetworkingConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let networkingConfigurationDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NetworkPayload.self, forKey: .networkingConfiguration)
        networkingConfiguration = networkingConfigurationDecoded
    }
}

extension ProvisionDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ProvisionDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ProvisionDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ProvisionDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ProvisionDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.certificates = output.certificates
            self.deviceId = output.deviceId
            self.iotThingName = output.iotThingName
            self.status = output.status
        } else {
            self.arn = nil
            self.certificates = nil
            self.deviceId = nil
            self.iotThingName = nil
            self.status = nil
        }
    }
}

public struct ProvisionDeviceOutputResponse: Swift.Equatable {
    /// The device's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The device's configuration bundle.
    public var certificates: ClientRuntime.Data?
    /// The device's ID.
    public var deviceId: Swift.String?
    /// The device's IoT thing name.
    public var iotThingName: Swift.String?
    /// The device's status.
    /// This member is required.
    public var status: PanoramaClientTypes.DeviceStatus?

    public init (
        arn: Swift.String? = nil,
        certificates: ClientRuntime.Data? = nil,
        deviceId: Swift.String? = nil,
        iotThingName: Swift.String? = nil,
        status: PanoramaClientTypes.DeviceStatus? = nil
    )
    {
        self.arn = arn
        self.certificates = certificates
        self.deviceId = deviceId
        self.iotThingName = iotThingName
        self.status = status
    }
}

struct ProvisionDeviceOutputResponseBody: Swift.Equatable {
    let deviceId: Swift.String?
    let arn: Swift.String?
    let status: PanoramaClientTypes.DeviceStatus?
    let certificates: ClientRuntime.Data?
    let iotThingName: Swift.String?
}

extension ProvisionDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case certificates = "Certificates"
        case deviceId = "DeviceId"
        case iotThingName = "IotThingName"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceStatus.self, forKey: .status)
        status = statusDecoded
        let certificatesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .certificates)
        certificates = certificatesDecoded
        let iotThingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotThingName)
        iotThingName = iotThingNameDecoded
    }
}

extension RegisterPackageVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case markLatest = "MarkLatest"
        case ownerAccount = "OwnerAccount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if markLatest != false {
            try encodeContainer.encode(markLatest, forKey: .markLatest)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
    }
}

extension RegisterPackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageId = packageId else {
            return nil
        }
        guard let packageVersion = packageVersion else {
            return nil
        }
        guard let patchVersion = patchVersion else {
            return nil
        }
        return "/packages/\(packageId.urlPercentEncoding())/versions/\(packageVersion.urlPercentEncoding())/patch/\(patchVersion.urlPercentEncoding())"
    }
}

public struct RegisterPackageVersionInput: Swift.Equatable {
    /// Whether to mark the new version as the latest version.
    public var markLatest: Swift.Bool
    /// An owner account.
    public var ownerAccount: Swift.String?
    /// A package ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// A package version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// A patch version.
    /// This member is required.
    public var patchVersion: Swift.String?

    public init (
        markLatest: Swift.Bool = false,
        ownerAccount: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil
    )
    {
        self.markLatest = markLatest
        self.ownerAccount = ownerAccount
        self.packageId = packageId
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
    }
}

struct RegisterPackageVersionInputBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let markLatest: Swift.Bool
}

extension RegisterPackageVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case markLatest = "MarkLatest"
        case ownerAccount = "OwnerAccount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let markLatestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .markLatest) ?? false
        markLatest = markLatestDecoded
    }
}

extension RegisterPackageVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterPackageVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterPackageVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterPackageVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RegisterPackageVersionOutputResponse: Swift.Equatable {

    public init () { }
}

extension RemoveApplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationInstanceId = applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())"
    }
}

public struct RemoveApplicationInstanceInput: Swift.Equatable {
    /// An application instance ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init (
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

struct RemoveApplicationInstanceInputBody: Swift.Equatable {
}

extension RemoveApplicationInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveApplicationInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveApplicationInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveApplicationInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveApplicationInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveApplicationInstanceOutputResponse: Swift.Equatable {

    public init () { }
}

extension PanoramaClientTypes.ReportedRuntimeContextState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState = "DesiredState"
        case deviceReportedStatus = "DeviceReportedStatus"
        case deviceReportedTime = "DeviceReportedTime"
        case runtimeContextName = "RuntimeContextName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredState = self.desiredState {
            try encodeContainer.encode(desiredState.rawValue, forKey: .desiredState)
        }
        if let deviceReportedStatus = self.deviceReportedStatus {
            try encodeContainer.encode(deviceReportedStatus.rawValue, forKey: .deviceReportedStatus)
        }
        if let deviceReportedTime = self.deviceReportedTime {
            try encodeContainer.encodeTimestamp(deviceReportedTime, format: .epochSeconds, forKey: .deviceReportedTime)
        }
        if let runtimeContextName = self.runtimeContextName {
            try encodeContainer.encode(runtimeContextName, forKey: .runtimeContextName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredStateDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DesiredState.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
        let runtimeContextNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeContextName)
        runtimeContextName = runtimeContextNameDecoded
        let deviceReportedStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceReportedStatus.self, forKey: .deviceReportedStatus)
        deviceReportedStatus = deviceReportedStatusDecoded
        let deviceReportedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deviceReportedTime)
        deviceReportedTime = deviceReportedTimeDecoded
    }
}

extension PanoramaClientTypes {
    /// An application instance's state.
    public struct ReportedRuntimeContextState: Swift.Equatable {
        /// The application's desired state.
        /// This member is required.
        public var desiredState: PanoramaClientTypes.DesiredState?
        /// The application's reported status.
        /// This member is required.
        public var deviceReportedStatus: PanoramaClientTypes.DeviceReportedStatus?
        /// When the device reported the application's state.
        /// This member is required.
        public var deviceReportedTime: ClientRuntime.Date?
        /// The device's name.
        /// This member is required.
        public var runtimeContextName: Swift.String?

        public init (
            desiredState: PanoramaClientTypes.DesiredState? = nil,
            deviceReportedStatus: PanoramaClientTypes.DeviceReportedStatus? = nil,
            deviceReportedTime: ClientRuntime.Date? = nil,
            runtimeContextName: Swift.String? = nil
        )
        {
            self.desiredState = desiredState
            self.deviceReportedStatus = deviceReportedStatus
            self.deviceReportedTime = deviceReportedTime
            self.runtimeContextName = runtimeContextName
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The target resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The resource's ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource's type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension PanoramaClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case objectKey = "ObjectKey"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKey = self.objectKey {
            try encodeContainer.encode(objectKey, forKey: .objectKey)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKey)
        objectKey = objectKeyDecoded
    }
}

extension PanoramaClientTypes {
    /// A location in Amazon S3.
    public struct S3Location: Swift.Equatable {
        /// A bucket name.
        /// This member is required.
        public var bucketName: Swift.String?
        /// An object key.
        /// This member is required.
        public var objectKey: Swift.String?
        /// The bucket's Region.
        public var region: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
            self.region = region
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would cause a limit to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The name of the limit.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// The target resource's ID.
    public var resourceId: Swift.String?
    /// The target resource's type.
    public var resourceType: Swift.String?
    /// The name of the service.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension SignalApplicationInstanceNodeInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeSignals = "NodeSignals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeSignals = nodeSignals {
            var nodeSignalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeSignals)
            for nodesignal0 in nodeSignals {
                try nodeSignalsContainer.encode(nodesignal0)
            }
        }
    }
}

extension SignalApplicationInstanceNodeInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationInstanceId = applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())/node-signals"
    }
}

public struct SignalApplicationInstanceNodeInstancesInput: Swift.Equatable {
    /// An application instance ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?
    /// A list of signals.
    /// This member is required.
    public var nodeSignals: [PanoramaClientTypes.NodeSignal]?

    public init (
        applicationInstanceId: Swift.String? = nil,
        nodeSignals: [PanoramaClientTypes.NodeSignal]? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.nodeSignals = nodeSignals
    }
}

struct SignalApplicationInstanceNodeInstancesInputBody: Swift.Equatable {
    let nodeSignals: [PanoramaClientTypes.NodeSignal]?
}

extension SignalApplicationInstanceNodeInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeSignals = "NodeSignals"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeSignalsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.NodeSignal?].self, forKey: .nodeSignals)
        var nodeSignalsDecoded0:[PanoramaClientTypes.NodeSignal]? = nil
        if let nodeSignalsContainer = nodeSignalsContainer {
            nodeSignalsDecoded0 = [PanoramaClientTypes.NodeSignal]()
            for structure0 in nodeSignalsContainer {
                if let structure0 = structure0 {
                    nodeSignalsDecoded0?.append(structure0)
                }
            }
        }
        nodeSignals = nodeSignalsDecoded0
    }
}

extension SignalApplicationInstanceNodeInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SignalApplicationInstanceNodeInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SignalApplicationInstanceNodeInstancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SignalApplicationInstanceNodeInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SignalApplicationInstanceNodeInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInstanceId = output.applicationInstanceId
        } else {
            self.applicationInstanceId = nil
        }
    }
}

public struct SignalApplicationInstanceNodeInstancesOutputResponse: Swift.Equatable {
    /// An application instance ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init (
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

struct SignalApplicationInstanceNodeInstancesOutputResponseBody: Swift.Equatable {
    let applicationInstanceId: Swift.String?
}

extension SignalApplicationInstanceNodeInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceId = "ApplicationInstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceId)
        applicationInstanceId = applicationInstanceIdDecoded
    }
}

extension PanoramaClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.StaticIpConnectionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultGateway = "DefaultGateway"
        case dns = "Dns"
        case ipAddress = "IpAddress"
        case mask = "Mask"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultGateway = self.defaultGateway {
            try encodeContainer.encode(defaultGateway, forKey: .defaultGateway)
        }
        if let dns = dns {
            var dnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dns)
            for dns0 in dns {
                try dnsContainer.encode(dns0)
            }
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let mask = self.mask {
            try encodeContainer.encode(mask, forKey: .mask)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let maskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mask)
        mask = maskDecoded
        let dnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dns)
        var dnsDecoded0:[Swift.String]? = nil
        if let dnsContainer = dnsContainer {
            dnsDecoded0 = [Swift.String]()
            for string0 in dnsContainer {
                if let string0 = string0 {
                    dnsDecoded0?.append(string0)
                }
            }
        }
        dns = dnsDecoded0
        let defaultGatewayDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultGateway)
        defaultGateway = defaultGatewayDecoded
    }
}

extension PanoramaClientTypes {
    /// A static IP configuration.
    public struct StaticIpConnectionInfo: Swift.Equatable {
        /// The connection's default gateway.
        /// This member is required.
        public var defaultGateway: Swift.String?
        /// The connection's DNS address.
        /// This member is required.
        public var dns: [Swift.String]?
        /// The connection's IP address.
        /// This member is required.
        public var ipAddress: Swift.String?
        /// The connection's DNS mask.
        /// This member is required.
        public var mask: Swift.String?

        public init (
            defaultGateway: Swift.String? = nil,
            dns: [Swift.String]? = nil,
            ipAddress: Swift.String? = nil,
            mask: Swift.String? = nil
        )
        {
            self.defaultGateway = defaultGateway
            self.dns = dns
            self.ipAddress = ipAddress
            self.mask = mask
        }
    }

}

extension PanoramaClientTypes {
    public enum StatusFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deploymentError
        case deploymentFailed
        case deploymentSucceeded
        case processingDeployment
        case processingRemoval
        case removalFailed
        case removalSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusFilter] {
            return [
                .deploymentError,
                .deploymentFailed,
                .deploymentSucceeded,
                .processingDeployment,
                .processingRemoval,
                .removalFailed,
                .removalSucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deploymentError: return "DEPLOYMENT_ERROR"
            case .deploymentFailed: return "DEPLOYMENT_FAILED"
            case .deploymentSucceeded: return "DEPLOYMENT_SUCCEEDED"
            case .processingDeployment: return "PROCESSING_DEPLOYMENT"
            case .processingRemoval: return "PROCESSING_REMOVAL"
            case .removalFailed: return "REMOVAL_FAILED"
            case .removalSucceeded: return "REMOVAL_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusFilter(rawValue: rawValue) ?? StatusFilter.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.StorageLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binaryPrefixLocation = "BinaryPrefixLocation"
        case bucket = "Bucket"
        case generatedPrefixLocation = "GeneratedPrefixLocation"
        case manifestPrefixLocation = "ManifestPrefixLocation"
        case repoPrefixLocation = "RepoPrefixLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let binaryPrefixLocation = self.binaryPrefixLocation {
            try encodeContainer.encode(binaryPrefixLocation, forKey: .binaryPrefixLocation)
        }
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let generatedPrefixLocation = self.generatedPrefixLocation {
            try encodeContainer.encode(generatedPrefixLocation, forKey: .generatedPrefixLocation)
        }
        if let manifestPrefixLocation = self.manifestPrefixLocation {
            try encodeContainer.encode(manifestPrefixLocation, forKey: .manifestPrefixLocation)
        }
        if let repoPrefixLocation = self.repoPrefixLocation {
            try encodeContainer.encode(repoPrefixLocation, forKey: .repoPrefixLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let repoPrefixLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repoPrefixLocation)
        repoPrefixLocation = repoPrefixLocationDecoded
        let generatedPrefixLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedPrefixLocation)
        generatedPrefixLocation = generatedPrefixLocationDecoded
        let binaryPrefixLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .binaryPrefixLocation)
        binaryPrefixLocation = binaryPrefixLocationDecoded
        let manifestPrefixLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestPrefixLocation)
        manifestPrefixLocation = manifestPrefixLocationDecoded
    }
}

extension PanoramaClientTypes {
    /// A storage location.
    public struct StorageLocation: Swift.Equatable {
        /// The location's binary prefix.
        /// This member is required.
        public var binaryPrefixLocation: Swift.String?
        /// The location's bucket.
        /// This member is required.
        public var bucket: Swift.String?
        /// The location's generated prefix.
        /// This member is required.
        public var generatedPrefixLocation: Swift.String?
        /// The location's manifest prefix.
        /// This member is required.
        public var manifestPrefixLocation: Swift.String?
        /// The location's repo prefix.
        /// This member is required.
        public var repoPrefixLocation: Swift.String?

        public init (
            binaryPrefixLocation: Swift.String? = nil,
            bucket: Swift.String? = nil,
            generatedPrefixLocation: Swift.String? = nil,
            manifestPrefixLocation: Swift.String? = nil,
            repoPrefixLocation: Swift.String? = nil
        )
        {
            self.binaryPrefixLocation = binaryPrefixLocation
            self.bucket = bucket
            self.generatedPrefixLocation = generatedPrefixLocation
            self.manifestPrefixLocation = manifestPrefixLocation
            self.repoPrefixLocation = repoPrefixLocation
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension PanoramaClientTypes {
    public enum TemplateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rtspCameraStream
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateType] {
            return [
                .rtspCameraStream,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rtspCameraStream: return "RTSP_CAMERA_STREAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateType(rawValue: rawValue) ?? TemplateType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDeviceMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateDeviceMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceId = deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())"
    }
}

public struct UpdateDeviceMetadataInput: Swift.Equatable {
    /// A description for the device.
    public var description: Swift.String?
    /// The device's ID.
    /// This member is required.
    public var deviceId: Swift.String?

    public init (
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil
    )
    {
        self.description = description
        self.deviceId = deviceId
    }
}

struct UpdateDeviceMetadataInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateDeviceMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDeviceMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDeviceMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDeviceMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceId = output.deviceId
        } else {
            self.deviceId = nil
        }
    }
}

public struct UpdateDeviceMetadataOutputResponse: Swift.Equatable {
    /// The device's ID.
    public var deviceId: Swift.String?

    public init (
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct UpdateDeviceMetadataOutputResponseBody: Swift.Equatable {
    let deviceId: Swift.String?
}

extension UpdateDeviceMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension PanoramaClientTypes {
    public enum UpdateProgress: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case downloading
        case failed
        case inProgress
        case pending
        case rebooting
        case verifying
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateProgress] {
            return [
                .completed,
                .downloading,
                .failed,
                .inProgress,
                .pending,
                .rebooting,
                .verifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .downloading: return "DOWNLOADING"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .rebooting: return "REBOOTING"
            case .verifying: return "VERIFYING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateProgress(rawValue: rawValue) ?? UpdateProgress.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorArguments = output.errorArguments
            self.errorId = output.errorId
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.errorArguments = nil
            self.errorId = nil
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request contains an invalid parameter value.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A list of attributes that led to the exception and their values.
    public var errorArguments: [PanoramaClientTypes.ValidationExceptionErrorArgument]?
    /// A unique ID for the error.
    public var errorId: Swift.String?
    /// A list of request parameters that failed validation.
    public var fields: [PanoramaClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason that validation failed.
    public var reason: PanoramaClientTypes.ValidationExceptionReason?

    public init (
        errorArguments: [PanoramaClientTypes.ValidationExceptionErrorArgument]? = nil,
        errorId: Swift.String? = nil,
        fields: [PanoramaClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: PanoramaClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.errorArguments = errorArguments
        self.errorId = errorId
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: PanoramaClientTypes.ValidationExceptionReason?
    let errorId: Swift.String?
    let errorArguments: [PanoramaClientTypes.ValidationExceptionErrorArgument]?
    let fields: [PanoramaClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorArguments = "ErrorArguments"
        case errorId = "ErrorId"
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let errorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorId)
        errorId = errorIdDecoded
        let errorArgumentsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.ValidationExceptionErrorArgument?].self, forKey: .errorArguments)
        var errorArgumentsDecoded0:[PanoramaClientTypes.ValidationExceptionErrorArgument]? = nil
        if let errorArgumentsContainer = errorArgumentsContainer {
            errorArgumentsDecoded0 = [PanoramaClientTypes.ValidationExceptionErrorArgument]()
            for structure0 in errorArgumentsContainer {
                if let structure0 = structure0 {
                    errorArgumentsDecoded0?.append(structure0)
                }
            }
        }
        errorArguments = errorArgumentsDecoded0
        let fieldsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[PanoramaClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [PanoramaClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension PanoramaClientTypes.ValidationExceptionErrorArgument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PanoramaClientTypes {
    /// A validation exception error argument.
    public struct ValidationExceptionErrorArgument: Swift.Equatable {
        /// The argument's name.
        /// This member is required.
        public var name: Swift.String?
        /// The argument's value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension PanoramaClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PanoramaClientTypes {
    /// A validation exception field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The field's message.
        /// This member is required.
        public var message: Swift.String?
        /// The field's name.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension PanoramaClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
