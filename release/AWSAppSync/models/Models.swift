// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have access to perform this operation on this resource.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.AdditionalAuthenticationProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
        case lambdaAuthorizerConfig
        case openIDConnectConfig
        case userPoolConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let lambdaAuthorizerConfig = lambdaAuthorizerConfig {
            try encodeContainer.encode(lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
        }
        if let openIDConnectConfig = openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let userPoolConfig = userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CognitoUserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let lambdaAuthorizerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaAuthorizerConfig.self, forKey: .lambdaAuthorizerConfig)
        lambdaAuthorizerConfig = lambdaAuthorizerConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an additional authentication provider.
    public struct AdditionalAuthenticationProvider: Swift.Equatable {
        /// The authentication type: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
        public var authenticationType: AppSyncClientTypes.AuthenticationType?
        /// Configuration for Lambda function authorization.
        public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
        /// The OIDC configuration.
        public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
        /// The Amazon Cognito user pool configuration.
        public var userPoolConfig: AppSyncClientTypes.CognitoUserPoolConfig?

        public init (
            authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
            lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
            openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
            userPoolConfig: AppSyncClientTypes.CognitoUserPoolConfig? = nil
        )
        {
            self.authenticationType = authenticationType
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.openIDConnectConfig = openIDConnectConfig
            self.userPoolConfig = userPoolConfig
        }
    }

}

extension AppSyncClientTypes.ApiAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId
        case associationStatus
        case deploymentDetail
        case domainName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let associationStatus = associationStatus {
            try encodeContainer.encode(associationStatus.rawValue, forKey: .associationStatus)
        }
        if let deploymentDetail = deploymentDetail {
            try encodeContainer.encode(deploymentDetail, forKey: .deploymentDetail)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let deploymentDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentDetail)
        deploymentDetail = deploymentDetailDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an ApiAssociation object.
    public struct ApiAssociation: Swift.Equatable {
        /// The API ID.
        public var apiId: Swift.String?
        /// Identifies the status of an association.
        ///
        /// * PROCESSING: The API association is being created. You cannot modify association requests during processing.
        ///
        /// * SUCCESS: The API association was successful. You can modify associations after success.
        ///
        /// * FAILED: The API association has failed. You can modify associations after failure.
        public var associationStatus: AppSyncClientTypes.AssociationStatus?
        /// Details about the last deployment status.
        public var deploymentDetail: Swift.String?
        /// The domain name.
        public var domainName: Swift.String?

        public init (
            apiId: Swift.String? = nil,
            associationStatus: AppSyncClientTypes.AssociationStatus? = nil,
            deploymentDetail: Swift.String? = nil,
            domainName: Swift.String? = nil
        )
        {
            self.apiId = apiId
            self.associationStatus = associationStatus
            self.deploymentDetail = deploymentDetail
            self.domainName = domainName
        }
    }

}

extension AppSyncClientTypes.ApiCache: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case atRestEncryptionEnabled
        case status
        case transitEncryptionEnabled
        case ttl
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCachingBehavior = apiCachingBehavior {
            try encodeContainer.encode(apiCachingBehavior.rawValue, forKey: .apiCachingBehavior)
        }
        if atRestEncryptionEnabled != false {
            try encodeContainer.encode(atRestEncryptionEnabled, forKey: .atRestEncryptionEnabled)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if transitEncryptionEnabled != false {
            try encodeContainer.encode(transitEncryptionEnabled, forKey: .transitEncryptionEnabled)
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decode(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let apiCachingBehaviorDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCachingBehavior.self, forKey: .apiCachingBehavior)
        apiCachingBehavior = apiCachingBehaviorDecoded
        let transitEncryptionEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .transitEncryptionEnabled)
        transitEncryptionEnabled = transitEncryptionEnabledDecoded
        let atRestEncryptionEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .atRestEncryptionEnabled)
        atRestEncryptionEnabled = atRestEncryptionEnabledDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCacheType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCacheStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppSyncClientTypes {
    /// The ApiCache object.
    public struct ApiCache: Swift.Equatable {
        /// Caching behavior.
        ///
        /// * FULL_REQUEST_CACHING: All requests are fully cached.
        ///
        /// * PER_RESOLVER_CACHING: Individual resolvers that you specify are cached.
        public var apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
        /// At-rest encryption flag for cache. You cannot update this setting after creation.
        public var atRestEncryptionEnabled: Swift.Bool
        /// The cache instance status.
        ///
        /// * AVAILABLE: The instance is available for use.
        ///
        /// * CREATING: The instance is currently creating.
        ///
        /// * DELETING: The instance is currently deleting.
        ///
        /// * MODIFYING: The instance is currently modifying.
        ///
        /// * FAILED: The instance has failed creation.
        public var status: AppSyncClientTypes.ApiCacheStatus?
        /// Transit encryption flag when connecting to cache. You cannot update this setting after creation.
        public var transitEncryptionEnabled: Swift.Bool
        /// TTL in seconds for cache entries. Valid values are 1–3,600 seconds.
        public var ttl: Swift.Int
        /// The cache instance type. Valid values are
        ///
        /// * SMALL
        ///
        /// * MEDIUM
        ///
        /// * LARGE
        ///
        /// * XLARGE
        ///
        /// * LARGE_2X
        ///
        /// * LARGE_4X
        ///
        /// * LARGE_8X (not available in all regions)
        ///
        /// * LARGE_12X
        ///
        ///
        /// Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used. The following legacy instance types are available, but their use is discouraged:
        ///
        /// * T2_SMALL: A t2.small instance type.
        ///
        /// * T2_MEDIUM: A t2.medium instance type.
        ///
        /// * R4_LARGE: A r4.large instance type.
        ///
        /// * R4_XLARGE: A r4.xlarge instance type.
        ///
        /// * R4_2XLARGE: A r4.2xlarge instance type.
        ///
        /// * R4_4XLARGE: A r4.4xlarge instance type.
        ///
        /// * R4_8XLARGE: A r4.8xlarge instance type.
        public var type: AppSyncClientTypes.ApiCacheType?

        public init (
            apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior? = nil,
            atRestEncryptionEnabled: Swift.Bool = false,
            status: AppSyncClientTypes.ApiCacheStatus? = nil,
            transitEncryptionEnabled: Swift.Bool = false,
            ttl: Swift.Int = 0,
            type: AppSyncClientTypes.ApiCacheType? = nil
        )
        {
            self.apiCachingBehavior = apiCachingBehavior
            self.atRestEncryptionEnabled = atRestEncryptionEnabled
            self.status = status
            self.transitEncryptionEnabled = transitEncryptionEnabled
            self.ttl = ttl
            self.type = type
        }
    }

}

extension AppSyncClientTypes {
    public enum ApiCacheStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiCacheStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .modifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .modifying: return "MODIFYING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiCacheStatus(rawValue: rawValue) ?? ApiCacheStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum ApiCacheType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case large
        case large12x
        case large2x
        case large4x
        case large8x
        case medium
        case r42xlarge
        case r44xlarge
        case r48xlarge
        case r4Large
        case r4Xlarge
        case small
        case t2Medium
        case t2Small
        case xlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiCacheType] {
            return [
                .large,
                .large12x,
                .large2x,
                .large4x,
                .large8x,
                .medium,
                .r42xlarge,
                .r44xlarge,
                .r48xlarge,
                .r4Large,
                .r4Xlarge,
                .small,
                .t2Medium,
                .t2Small,
                .xlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .large12x: return "LARGE_12X"
            case .large2x: return "LARGE_2X"
            case .large4x: return "LARGE_4X"
            case .large8x: return "LARGE_8X"
            case .medium: return "MEDIUM"
            case .r42xlarge: return "R4_2XLARGE"
            case .r44xlarge: return "R4_4XLARGE"
            case .r48xlarge: return "R4_8XLARGE"
            case .r4Large: return "R4_LARGE"
            case .r4Xlarge: return "R4_XLARGE"
            case .small: return "SMALL"
            case .t2Medium: return "T2_MEDIUM"
            case .t2Small: return "T2_SMALL"
            case .xlarge: return "XLARGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiCacheType(rawValue: rawValue) ?? ApiCacheType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum ApiCachingBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullRequestCaching
        case perResolverCaching
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiCachingBehavior] {
            return [
                .fullRequestCaching,
                .perResolverCaching,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullRequestCaching: return "FULL_REQUEST_CACHING"
            case .perResolverCaching: return "PER_RESOLVER_CACHING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiCachingBehavior(rawValue: rawValue) ?? ApiCachingBehavior.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.ApiKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletes
        case description
        case expires
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deletes != 0 {
            try encodeContainer.encode(deletes, forKey: .deletes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if expires != 0 {
            try encodeContainer.encode(expires, forKey: .expires)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expiresDecoded = try containerValues.decode(Swift.Int.self, forKey: .expires)
        expires = expiresDecoded
        let deletesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deletes)
        deletes = deletesDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an API key. Customers invoke AppSync GraphQL API operations with API keys as an identity mechanism. There are two key versions: da1: We introduced this version at launch in November 2017. These keys always expire after 7 days. Amazon DynamoDB TTL manages key expiration. These keys ceased to be valid after February 21, 2018, and they should no longer be used.
    ///
    /// * ListApiKeys returns the expiration time in milliseconds.
    ///
    /// * CreateApiKey returns the expiration time in milliseconds.
    ///
    /// * UpdateApiKey is not available for this key version.
    ///
    /// * DeleteApiKey deletes the item from the table.
    ///
    /// * Expiration is stored in DynamoDB as milliseconds. This results in a bug where keys are not automatically deleted because DynamoDB expects the TTL to be stored in seconds. As a one-time action, we deleted these keys from the table on February 21, 2018.
    ///
    ///
    /// da2: We introduced this version in February 2018 when AppSync added support to extend key expiration.
    ///
    /// * ListApiKeys returns the expiration time and deletion time in seconds.
    ///
    /// * CreateApiKey returns the expiration time and deletion time in seconds and accepts a user-provided expiration time in seconds.
    ///
    /// * UpdateApiKey returns the expiration time and and deletion time in seconds and accepts a user-provided expiration time in seconds. Expired API keys are kept for 60 days after the expiration time. You can update the key expiration time as long as the key isn't deleted.
    ///
    /// * DeleteApiKey deletes the item from the table.
    ///
    /// * Expiration is stored in DynamoDB as seconds. After the expiration time, using the key to authenticate will fail. However, you can reinstate the key before deletion.
    ///
    /// * Deletion is stored in DynamoDB as seconds. The key is deleted after deletion time.
    public struct ApiKey: Swift.Equatable {
        /// The time after which the API key is deleted. The date is represented as seconds since the epoch, rounded down to the nearest hour.
        public var deletes: Swift.Int
        /// A description of the purpose of the API key.
        public var description: Swift.String?
        /// The time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour.
        public var expires: Swift.Int
        /// The API key ID.
        public var id: Swift.String?

        public init (
            deletes: Swift.Int = 0,
            description: Swift.String? = nil,
            expires: Swift.Int = 0,
            id: Swift.String? = nil
        )
        {
            self.deletes = deletes
            self.description = description
            self.expires = expires
            self.id = id
        }
    }

}

extension ApiKeyLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApiKeyLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The API key exceeded a limit. Try your request again.
public struct ApiKeyLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApiKeyLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApiKeyLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiKeyValidityOutOfBoundsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApiKeyValidityOutOfBoundsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The API key expiration must be set to a value between 1 and 365 days from creation (for CreateApiKey) or from update (for UpdateApiKey).
public struct ApiKeyValidityOutOfBoundsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApiKeyValidityOutOfBoundsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApiKeyValidityOutOfBoundsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApiLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The GraphQL API exceeded a limit. Try your request again.
public struct ApiLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApiLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApiLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
    }
}

extension AssociateApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/apiassociation"
    }
}

public struct AssociateApiInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.domainName = domainName
    }
}

struct AssociateApiInputBody: Swift.Equatable {
    let apiId: Swift.String?
}

extension AssociateApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
    }
}

extension AssociateApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateApiOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiAssociation = output.apiAssociation
        } else {
            self.apiAssociation = nil
        }
    }
}

public struct AssociateApiOutputResponse: Swift.Equatable {
    /// The ApiAssociation object.
    public var apiAssociation: AppSyncClientTypes.ApiAssociation?

    public init (
        apiAssociation: AppSyncClientTypes.ApiAssociation? = nil
    )
    {
        self.apiAssociation = apiAssociation
    }
}

struct AssociateApiOutputResponseBody: Swift.Equatable {
    let apiAssociation: AppSyncClientTypes.ApiAssociation?
}

extension AssociateApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAssociation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiAssociationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiAssociation.self, forKey: .apiAssociation)
        apiAssociation = apiAssociationDecoded
    }
}

extension AppSyncClientTypes {
    public enum AssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case processing
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationStatus] {
            return [
                .failed,
                .processing,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationStatus(rawValue: rawValue) ?? AssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonCognitoUserPools
        case apiKey
        case awsIam
        case awsLambda
        case openidConnect
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .amazonCognitoUserPools,
                .apiKey,
                .awsIam,
                .awsLambda,
                .openidConnect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonCognitoUserPools: return "AMAZON_COGNITO_USER_POOLS"
            case .apiKey: return "API_KEY"
            case .awsIam: return "AWS_IAM"
            case .awsLambda: return "AWS_LAMBDA"
            case .openidConnect: return "OPENID_CONNECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationType(rawValue: rawValue) ?? AuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.AuthorizationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationType
        case awsIamConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let awsIamConfig = awsIamConfig {
            try encodeContainer.encode(awsIamConfig, forKey: .awsIamConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let awsIamConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AwsIamConfig.self, forKey: .awsIamConfig)
        awsIamConfig = awsIamConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// The authorization configuration in case the HTTP endpoint requires authorization.
    public struct AuthorizationConfig: Swift.Equatable {
        /// The authorization type that the HTTP endpoint requires.
        ///
        /// * AWS_IAM: The authorization type is Signature Version 4 (SigV4).
        /// This member is required.
        public var authorizationType: AppSyncClientTypes.AuthorizationType?
        /// The Identity and Access Management (IAM) settings.
        public var awsIamConfig: AppSyncClientTypes.AwsIamConfig?

        public init (
            authorizationType: AppSyncClientTypes.AuthorizationType? = nil,
            awsIamConfig: AppSyncClientTypes.AwsIamConfig? = nil
        )
        {
            self.authorizationType = authorizationType
            self.awsIamConfig = awsIamConfig
        }
    }

}

extension AppSyncClientTypes {
    public enum AuthorizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsIam
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationType] {
            return [
                .awsIam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizationType(rawValue: rawValue) ?? AuthorizationType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.AwsIamConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingRegion
        case signingServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingRegion = signingRegion {
            try encodeContainer.encode(signingRegion, forKey: .signingRegion)
        }
        if let signingServiceName = signingServiceName {
            try encodeContainer.encode(signingServiceName, forKey: .signingServiceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingRegion)
        signingRegion = signingRegionDecoded
        let signingServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingServiceName)
        signingServiceName = signingServiceNameDecoded
    }
}

extension AppSyncClientTypes {
    /// The Identity and Access Management (IAM) configuration.
    public struct AwsIamConfig: Swift.Equatable {
        /// The signing Amazon Web Services Region for IAM authorization.
        public var signingRegion: Swift.String?
        /// The signing service name for IAM authorization.
        public var signingServiceName: Swift.String?

        public init (
            signingRegion: Swift.String? = nil,
            signingServiceName: Swift.String? = nil
        )
        {
            self.signingRegion = signingRegion
            self.signingServiceName = signingServiceName
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is not well formed. For example, a value is invalid or a required field is missing. Check the field values, and then try again.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.CachingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingKeys
        case ttl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingKeys = cachingKeys {
            var cachingKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cachingKeys)
            for cachingkeys0 in cachingKeys {
                try cachingKeysContainer.encode(cachingkeys0)
            }
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decode(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let cachingKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cachingKeys)
        var cachingKeysDecoded0:[Swift.String]? = nil
        if let cachingKeysContainer = cachingKeysContainer {
            cachingKeysDecoded0 = [Swift.String]()
            for string0 in cachingKeysContainer {
                if let string0 = string0 {
                    cachingKeysDecoded0?.append(string0)
                }
            }
        }
        cachingKeys = cachingKeysDecoded0
    }
}

extension AppSyncClientTypes {
    /// The caching configuration for a resolver that has caching activated.
    public struct CachingConfig: Swift.Equatable {
        /// The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
        public var cachingKeys: [Swift.String]?
        /// The TTL in seconds for a resolver that has caching activated. Valid values are 1–3,600 seconds.
        public var ttl: Swift.Int

        public init (
            cachingKeys: [Swift.String]? = nil,
            ttl: Swift.Int = 0
        )
        {
            self.cachingKeys = cachingKeys
            self.ttl = ttl
        }
    }

}

extension AppSyncClientTypes.CognitoUserPoolConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIdClientRegex
        case awsRegion
        case userPoolId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIdClientRegex = appIdClientRegex {
            try encodeContainer.encode(appIdClientRegex, forKey: .appIdClientRegex)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let appIdClientRegexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appIdClientRegex)
        appIdClientRegex = appIdClientRegexDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an Amazon Cognito user pool configuration.
    public struct CognitoUserPoolConfig: Swift.Equatable {
        /// A regular expression for validating the incoming Amazon Cognito user pool app client ID.
        public var appIdClientRegex: Swift.String?
        /// The Amazon Web Services Region in which the user pool was created.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The user pool ID.
        /// This member is required.
        public var userPoolId: Swift.String?

        public init (
            appIdClientRegex: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            userPoolId: Swift.String? = nil
        )
        {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.userPoolId = userPoolId
        }
    }

}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Another modification is in progress at this time and it must complete before you can make your change.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes {
    public enum ConflictDetectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictDetectionType] {
            return [
                .none,
                .version,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .version: return "VERSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictDetectionType(rawValue: rawValue) ?? ConflictDetectionType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum ConflictHandlerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automerge
        case lambda
        case `none`
        case optimisticConcurrency
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictHandlerType] {
            return [
                .automerge,
                .lambda,
                .none,
                .optimisticConcurrency,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automerge: return "AUTOMERGE"
            case .lambda: return "LAMBDA"
            case .none: return "NONE"
            case .optimisticConcurrency: return "OPTIMISTIC_CONCURRENCY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictHandlerType(rawValue: rawValue) ?? ConflictHandlerType.sdkUnknown(rawValue)
        }
    }
}

extension CreateApiCacheInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case atRestEncryptionEnabled
        case transitEncryptionEnabled
        case ttl
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCachingBehavior = apiCachingBehavior {
            try encodeContainer.encode(apiCachingBehavior.rawValue, forKey: .apiCachingBehavior)
        }
        if atRestEncryptionEnabled != false {
            try encodeContainer.encode(atRestEncryptionEnabled, forKey: .atRestEncryptionEnabled)
        }
        if transitEncryptionEnabled != false {
            try encodeContainer.encode(transitEncryptionEnabled, forKey: .transitEncryptionEnabled)
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateApiCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches"
    }
}

/// Represents the input of a CreateApiCache operation.
public struct CreateApiCacheInput: Swift.Equatable {
    /// Caching behavior.
    ///
    /// * FULL_REQUEST_CACHING: All requests are fully cached.
    ///
    /// * PER_RESOLVER_CACHING: Individual resolvers that you specify are cached.
    /// This member is required.
    public var apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// At-rest encryption flag for cache. You cannot update this setting after creation.
    public var atRestEncryptionEnabled: Swift.Bool
    /// Transit encryption flag when connecting to cache. You cannot update this setting after creation.
    public var transitEncryptionEnabled: Swift.Bool
    /// TTL in seconds for cache entries. Valid values are 1–3,600 seconds.
    /// This member is required.
    public var ttl: Swift.Int
    /// The cache instance type. Valid values are
    ///
    /// * SMALL
    ///
    /// * MEDIUM
    ///
    /// * LARGE
    ///
    /// * XLARGE
    ///
    /// * LARGE_2X
    ///
    /// * LARGE_4X
    ///
    /// * LARGE_8X (not available in all regions)
    ///
    /// * LARGE_12X
    ///
    ///
    /// Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used. The following legacy instance types are available, but their use is discouraged:
    ///
    /// * T2_SMALL: A t2.small instance type.
    ///
    /// * T2_MEDIUM: A t2.medium instance type.
    ///
    /// * R4_LARGE: A r4.large instance type.
    ///
    /// * R4_XLARGE: A r4.xlarge instance type.
    ///
    /// * R4_2XLARGE: A r4.2xlarge instance type.
    ///
    /// * R4_4XLARGE: A r4.4xlarge instance type.
    ///
    /// * R4_8XLARGE: A r4.8xlarge instance type.
    /// This member is required.
    public var type: AppSyncClientTypes.ApiCacheType?

    public init (
        apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior? = nil,
        apiId: Swift.String? = nil,
        atRestEncryptionEnabled: Swift.Bool = false,
        transitEncryptionEnabled: Swift.Bool = false,
        ttl: Swift.Int = 0,
        type: AppSyncClientTypes.ApiCacheType? = nil
    )
    {
        self.apiCachingBehavior = apiCachingBehavior
        self.apiId = apiId
        self.atRestEncryptionEnabled = atRestEncryptionEnabled
        self.transitEncryptionEnabled = transitEncryptionEnabled
        self.ttl = ttl
        self.type = type
    }
}

struct CreateApiCacheInputBody: Swift.Equatable {
    let ttl: Swift.Int
    let transitEncryptionEnabled: Swift.Bool
    let atRestEncryptionEnabled: Swift.Bool
    let apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    let type: AppSyncClientTypes.ApiCacheType?
}

extension CreateApiCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case atRestEncryptionEnabled
        case transitEncryptionEnabled
        case ttl
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decode(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let transitEncryptionEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .transitEncryptionEnabled)
        transitEncryptionEnabled = transitEncryptionEnabledDecoded
        let atRestEncryptionEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .atRestEncryptionEnabled)
        atRestEncryptionEnabled = atRestEncryptionEnabledDecoded
        let apiCachingBehaviorDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCachingBehavior.self, forKey: .apiCachingBehavior)
        apiCachingBehavior = apiCachingBehaviorDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCacheType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateApiCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiCacheOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApiCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiCache = output.apiCache
        } else {
            self.apiCache = nil
        }
    }
}

/// Represents the output of a CreateApiCache operation.
public struct CreateApiCacheOutputResponse: Swift.Equatable {
    /// The ApiCache object.
    public var apiCache: AppSyncClientTypes.ApiCache?

    public init (
        apiCache: AppSyncClientTypes.ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

struct CreateApiCacheOutputResponseBody: Swift.Equatable {
    let apiCache: AppSyncClientTypes.ApiCache?
}

extension CreateApiCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCache
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCacheDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCache.self, forKey: .apiCache)
        apiCache = apiCacheDecoded
    }
}

extension CreateApiKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expires
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if expires != 0 {
            try encodeContainer.encode(expires, forKey: .expires)
        }
    }
}

extension CreateApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/apikeys"
    }
}

public struct CreateApiKeyInput: Swift.Equatable {
    /// The ID for your GraphQL API.
    /// This member is required.
    public var apiId: Swift.String?
    /// A description of the purpose of the API key.
    public var description: Swift.String?
    /// From the creation time, the time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour. The default value for this parameter is 7 days from creation time. For more information, see .
    public var expires: Swift.Int

    public init (
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        expires: Swift.Int = 0
    )
    {
        self.apiId = apiId
        self.description = description
        self.expires = expires
    }
}

struct CreateApiKeyInputBody: Swift.Equatable {
    let description: Swift.String?
    let expires: Swift.Int
}

extension CreateApiKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expires
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expiresDecoded = try containerValues.decode(Swift.Int.self, forKey: .expires)
        expires = expiresDecoded
    }
}

extension CreateApiKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApiKeyLimitExceededException" : self = .apiKeyLimitExceededException(try ApiKeyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApiKeyValidityOutOfBoundsException" : self = .apiKeyValidityOutOfBoundsException(try ApiKeyValidityOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiKeyOutputError: Swift.Error, Swift.Equatable {
    case apiKeyLimitExceededException(ApiKeyLimitExceededException)
    case apiKeyValidityOutOfBoundsException(ApiKeyValidityOutOfBoundsException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApiKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKey = output.apiKey
        } else {
            self.apiKey = nil
        }
    }
}

public struct CreateApiKeyOutputResponse: Swift.Equatable {
    /// The API key.
    public var apiKey: AppSyncClientTypes.ApiKey?

    public init (
        apiKey: AppSyncClientTypes.ApiKey? = nil
    )
    {
        self.apiKey = apiKey
    }
}

struct CreateApiKeyOutputResponseBody: Swift.Equatable {
    let apiKey: AppSyncClientTypes.ApiKey?
}

extension CreateApiKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiKey.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

extension CreateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case name
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dynamodbConfig = dynamodbConfig {
            try encodeContainer.encode(dynamodbConfig, forKey: .dynamodbConfig)
        }
        if let elasticsearchConfig = elasticsearchConfig {
            try encodeContainer.encode(elasticsearchConfig, forKey: .elasticsearchConfig)
        }
        if let httpConfig = httpConfig {
            try encodeContainer.encode(httpConfig, forKey: .httpConfig)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openSearchServiceConfig = openSearchServiceConfig {
            try encodeContainer.encode(openSearchServiceConfig, forKey: .openSearchServiceConfig)
        }
        if let relationalDatabaseConfig = relationalDatabaseConfig {
            try encodeContainer.encode(relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources"
    }
}

public struct CreateDataSourceInput: Swift.Equatable {
    /// The API ID for the GraphQL API for the DataSource.
    /// This member is required.
    public var apiId: Swift.String?
    /// A description of the DataSource.
    public var description: Swift.String?
    /// Amazon DynamoDB settings.
    public var dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    /// Amazon OpenSearch Service settings. As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. For new data sources, use [CreateDataSourceRequest$openSearchServiceConfig] to create an OpenSearch data source.
    public var elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    /// HTTP endpoint settings.
    public var httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    /// Lambda settings.
    public var lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    /// A user-supplied name for the DataSource.
    /// This member is required.
    public var name: Swift.String?
    /// Amazon OpenSearch Service settings.
    public var openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    /// Relational database settings.
    public var relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
    /// The Identity and Access Management (IAM) service role Amazon Resource Name (ARN) for the data source. The system assumes this role when accessing the data source.
    public var serviceRoleArn: Swift.String?
    /// The type of the DataSource.
    /// This member is required.
    public var type: AppSyncClientTypes.DataSourceType?

    public init (
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig? = nil,
        elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig? = nil,
        httpConfig: AppSyncClientTypes.HttpDataSourceConfig? = nil,
        lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig? = nil,
        name: Swift.String? = nil,
        openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig? = nil,
        relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig? = nil,
        serviceRoleArn: Swift.String? = nil,
        type: AppSyncClientTypes.DataSourceType? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.dynamodbConfig = dynamodbConfig
        self.elasticsearchConfig = elasticsearchConfig
        self.httpConfig = httpConfig
        self.lambdaConfig = lambdaConfig
        self.name = name
        self.openSearchServiceConfig = openSearchServiceConfig
        self.relationalDatabaseConfig = relationalDatabaseConfig
        self.serviceRoleArn = serviceRoleArn
        self.type = type
    }
}

struct CreateDataSourceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let type: AppSyncClientTypes.DataSourceType?
    let serviceRoleArn: Swift.String?
    let dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    let lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    let elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    let openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    let httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    let relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
}

extension CreateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case name
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let dynamodbConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DynamodbDataSourceConfig.self, forKey: .dynamodbConfig)
        dynamodbConfig = dynamodbConfigDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaDataSourceConfig.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let elasticsearchConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ElasticsearchDataSourceConfig.self, forKey: .elasticsearchConfig)
        elasticsearchConfig = elasticsearchConfigDecoded
        let openSearchServiceConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenSearchServiceDataSourceConfig.self, forKey: .openSearchServiceConfig)
        openSearchServiceConfig = openSearchServiceConfigDecoded
        let httpConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.HttpDataSourceConfig.self, forKey: .httpConfig)
        httpConfig = httpConfigDecoded
        let relationalDatabaseConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RelationalDatabaseDataSourceConfig.self, forKey: .relationalDatabaseConfig)
        relationalDatabaseConfig = relationalDatabaseConfigDecoded
    }
}

extension CreateDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataSourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct CreateDataSourceOutputResponse: Swift.Equatable {
    /// The DataSource object.
    public var dataSource: AppSyncClientTypes.DataSource?

    public init (
        dataSource: AppSyncClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct CreateDataSourceOutputResponseBody: Swift.Equatable {
    let dataSource: AppSyncClientTypes.DataSource?
}

extension CreateDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

extension CreateDomainNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case description
        case domainName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension CreateDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/domainnames"
    }
}

public struct CreateDomainNameInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the certificate. This can be an Certificate Manager (ACM) certificate or an Identity and Access Management (IAM) server certificate.
    /// This member is required.
    public var certificateArn: Swift.String?
    /// A description of the DomainName.
    public var description: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        certificateArn: Swift.String? = nil,
        description: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.description = description
        self.domainName = domainName
    }
}

struct CreateDomainNameInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let certificateArn: Swift.String?
    let description: Swift.String?
}

extension CreateDomainNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case description
        case domainName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateDomainNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainNameOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainNameConfig = output.domainNameConfig
        } else {
            self.domainNameConfig = nil
        }
    }
}

public struct CreateDomainNameOutputResponse: Swift.Equatable {
    /// The configuration for the DomainName.
    public var domainNameConfig: AppSyncClientTypes.DomainNameConfig?

    public init (
        domainNameConfig: AppSyncClientTypes.DomainNameConfig? = nil
    )
    {
        self.domainNameConfig = domainNameConfig
    }
}

struct CreateDomainNameOutputResponseBody: Swift.Equatable {
    let domainNameConfig: AppSyncClientTypes.DomainNameConfig?
}

extension CreateDomainNameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNameConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DomainNameConfig.self, forKey: .domainNameConfig)
        domainNameConfig = domainNameConfigDecoded
    }
}

extension CreateFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceName
        case description
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

extension CreateFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions"
    }
}

public struct CreateFunctionInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The FunctionDataSource name.
    /// This member is required.
    public var dataSourceName: Swift.String?
    /// The Function description.
    public var description: Swift.String?
    /// The version of the request mapping template. Currently, the supported value is 2018-05-29.
    /// This member is required.
    public var functionVersion: Swift.String?
    /// The Function name. The function name does not have to be unique.
    /// This member is required.
    public var name: Swift.String?
    /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
    public var requestMappingTemplate: Swift.String?
    /// The Function response mapping template.
    public var responseMappingTemplate: Swift.String?
    /// Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
    public var syncConfig: AppSyncClientTypes.SyncConfig?

    public init (
        apiId: Swift.String? = nil,
        dataSourceName: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil
    )
    {
        self.apiId = apiId
        self.dataSourceName = dataSourceName
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
    }
}

struct CreateFunctionInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let dataSourceName: Swift.String?
    let requestMappingTemplate: Swift.String?
    let responseMappingTemplate: Swift.String?
    let functionVersion: Swift.String?
    let syncConfig: AppSyncClientTypes.SyncConfig?
}

extension CreateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceName
        case description
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
    }
}

extension CreateFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFunctionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functionConfiguration = output.functionConfiguration
        } else {
            self.functionConfiguration = nil
        }
    }
}

public struct CreateFunctionOutputResponse: Swift.Equatable {
    /// The Function object.
    public var functionConfiguration: AppSyncClientTypes.FunctionConfiguration?

    public init (
        functionConfiguration: AppSyncClientTypes.FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

struct CreateFunctionOutputResponseBody: Swift.Equatable {
    let functionConfiguration: AppSyncClientTypes.FunctionConfiguration?
}

extension CreateFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
    }
}

extension CreateGraphqlApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case name
        case openIDConnectConfig
        case tags
        case userPoolConfig
        case xrayEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthenticationProviders = additionalAuthenticationProviders {
            var additionalAuthenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthenticationProviders)
            for additionalauthenticationproviders0 in additionalAuthenticationProviders {
                try additionalAuthenticationProvidersContainer.encode(additionalauthenticationproviders0)
            }
        }
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let lambdaAuthorizerConfig = lambdaAuthorizerConfig {
            try encodeContainer.encode(lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
        }
        if let logConfig = logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openIDConnectConfig = openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userPoolConfig = userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
        if xrayEnabled != false {
            try encodeContainer.encode(xrayEnabled, forKey: .xrayEnabled)
        }
    }
}

extension CreateGraphqlApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/apis"
    }
}

public struct CreateGraphqlApiInput: Swift.Equatable {
    /// A list of additional authentication providers for the GraphqlApi API.
    public var additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    /// The authentication type: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
    /// This member is required.
    public var authenticationType: AppSyncClientTypes.AuthenticationType?
    /// Configuration for Lambda function authorization.
    public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
    /// The Amazon CloudWatch Logs configuration.
    public var logConfig: AppSyncClientTypes.LogConfig?
    /// A user-supplied name for the GraphqlApi.
    /// This member is required.
    public var name: Swift.String?
    /// The OIDC configuration.
    public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    /// A TagMap object.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Cognito user pool configuration.
    public var userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    /// A flag indicating whether to use X-Ray tracing for the GraphqlApi.
    public var xrayEnabled: Swift.Bool

    public init (
        additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil,
        authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
        lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
        logConfig: AppSyncClientTypes.LogConfig? = nil,
        name: Swift.String? = nil,
        openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userPoolConfig: AppSyncClientTypes.UserPoolConfig? = nil,
        xrayEnabled: Swift.Bool = false
    )
    {
        self.additionalAuthenticationProviders = additionalAuthenticationProviders
        self.authenticationType = authenticationType
        self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
        self.logConfig = logConfig
        self.name = name
        self.openIDConnectConfig = openIDConnectConfig
        self.tags = tags
        self.userPoolConfig = userPoolConfig
        self.xrayEnabled = xrayEnabled
    }
}

struct CreateGraphqlApiInputBody: Swift.Equatable {
    let name: Swift.String?
    let logConfig: AppSyncClientTypes.LogConfig?
    let authenticationType: AppSyncClientTypes.AuthenticationType?
    let userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    let openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    let tags: [Swift.String:Swift.String]?
    let additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    let xrayEnabled: Swift.Bool
    let lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
}

extension CreateGraphqlApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case name
        case openIDConnectConfig
        case tags
        case userPoolConfig
        case xrayEnabled
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LogConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.UserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let additionalAuthenticationProvidersContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.AdditionalAuthenticationProvider?].self, forKey: .additionalAuthenticationProviders)
        var additionalAuthenticationProvidersDecoded0:[AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil
        if let additionalAuthenticationProvidersContainer = additionalAuthenticationProvidersContainer {
            additionalAuthenticationProvidersDecoded0 = [AppSyncClientTypes.AdditionalAuthenticationProvider]()
            for structure0 in additionalAuthenticationProvidersContainer {
                if let structure0 = structure0 {
                    additionalAuthenticationProvidersDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthenticationProviders = additionalAuthenticationProvidersDecoded0
        let xrayEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .xrayEnabled)
        xrayEnabled = xrayEnabledDecoded
        let lambdaAuthorizerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaAuthorizerConfig.self, forKey: .lambdaAuthorizerConfig)
        lambdaAuthorizerConfig = lambdaAuthorizerConfigDecoded
    }
}

extension CreateGraphqlApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGraphqlApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApiLimitExceededException" : self = .apiLimitExceededException(try ApiLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGraphqlApiOutputError: Swift.Error, Swift.Equatable {
    case apiLimitExceededException(ApiLimitExceededException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGraphqlApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGraphqlApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.graphqlApi = output.graphqlApi
        } else {
            self.graphqlApi = nil
        }
    }
}

public struct CreateGraphqlApiOutputResponse: Swift.Equatable {
    /// The GraphqlApi.
    public var graphqlApi: AppSyncClientTypes.GraphqlApi?

    public init (
        graphqlApi: AppSyncClientTypes.GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

struct CreateGraphqlApiOutputResponseBody: Swift.Equatable {
    let graphqlApi: AppSyncClientTypes.GraphqlApi?
}

extension CreateGraphqlApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphqlApi
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApiDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphqlApi.self, forKey: .graphqlApi)
        graphqlApi = graphqlApiDecoded
    }
}

extension CreateResolverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case dataSourceName
        case fieldName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingConfig = cachingConfig {
            try encodeContainer.encode(cachingConfig, forKey: .cachingConfig)
        }
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let fieldName = fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let kind = kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let pipelineConfig = pipelineConfig {
            try encodeContainer.encode(pipelineConfig, forKey: .pipelineConfig)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

extension CreateResolverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers"
    }
}

public struct CreateResolverInput: Swift.Equatable {
    /// The ID for the GraphQL API for which the resolver is being created.
    /// This member is required.
    public var apiId: Swift.String?
    /// The caching configuration for the resolver.
    public var cachingConfig: AppSyncClientTypes.CachingConfig?
    /// The name of the data source for which the resolver is being created.
    public var dataSourceName: Swift.String?
    /// The name of the field to attach the resolver to.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The resolver type.
    ///
    /// * UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.
    ///
    /// * PIPELINE: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of Function objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.
    public var kind: AppSyncClientTypes.ResolverKind?
    /// The PipelineConfig.
    public var pipelineConfig: AppSyncClientTypes.PipelineConfig?
    /// The mapping template to use for requests. A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL). VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.
    public var requestMappingTemplate: Swift.String?
    /// The mapping template to use for responses from the data source.
    public var responseMappingTemplate: Swift.String?
    /// The SyncConfig for a resolver attached to a versioned data source.
    public var syncConfig: AppSyncClientTypes.SyncConfig?
    /// The name of the Type.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        cachingConfig: AppSyncClientTypes.CachingConfig? = nil,
        dataSourceName: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        kind: AppSyncClientTypes.ResolverKind? = nil,
        pipelineConfig: AppSyncClientTypes.PipelineConfig? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.cachingConfig = cachingConfig
        self.dataSourceName = dataSourceName
        self.fieldName = fieldName
        self.kind = kind
        self.pipelineConfig = pipelineConfig
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
        self.typeName = typeName
    }
}

struct CreateResolverInputBody: Swift.Equatable {
    let fieldName: Swift.String?
    let dataSourceName: Swift.String?
    let requestMappingTemplate: Swift.String?
    let responseMappingTemplate: Swift.String?
    let kind: AppSyncClientTypes.ResolverKind?
    let pipelineConfig: AppSyncClientTypes.PipelineConfig?
    let syncConfig: AppSyncClientTypes.SyncConfig?
    let cachingConfig: AppSyncClientTypes.CachingConfig?
}

extension CreateResolverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case dataSourceName
        case fieldName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let kindDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ResolverKind.self, forKey: .kind)
        kind = kindDecoded
        let pipelineConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.PipelineConfig.self, forKey: .pipelineConfig)
        pipelineConfig = pipelineConfigDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let cachingConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CachingConfig.self, forKey: .cachingConfig)
        cachingConfig = cachingConfigDecoded
    }
}

extension CreateResolverOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResolverOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResolverOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResolverOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResolverOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolver = output.resolver
        } else {
            self.resolver = nil
        }
    }
}

public struct CreateResolverOutputResponse: Swift.Equatable {
    /// The Resolver object.
    public var resolver: AppSyncClientTypes.Resolver?

    public init (
        resolver: AppSyncClientTypes.Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

struct CreateResolverOutputResponseBody: Swift.Equatable {
    let resolver: AppSyncClientTypes.Resolver?
}

extension CreateResolverOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolver
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.Resolver.self, forKey: .resolver)
        resolver = resolverDecoded
    }
}

extension CreateTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case format
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
    }
}

extension CreateTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types"
    }
}

public struct CreateTypeInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type definition, in GraphQL Schema Definition Language (SDL) format. For more information, see the [GraphQL SDL documentation](http://graphql.org/learn/schema/).
    /// This member is required.
    public var definition: Swift.String?
    /// The type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?

    public init (
        apiId: Swift.String? = nil,
        definition: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
        self.format = format
    }
}

struct CreateTypeInputBody: Swift.Equatable {
    let definition: Swift.String?
    let format: AppSyncClientTypes.TypeDefinitionFormat?
}

extension CreateTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case format
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.TypeDefinitionFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreateTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTypeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.type = output.type
        } else {
            self.type = nil
        }
    }
}

public struct CreateTypeOutputResponse: Swift.Equatable {
    /// The Type object.
    public var type: AppSyncClientTypes.ModelType?

    public init (
        type: AppSyncClientTypes.ModelType? = nil
    )
    {
        self.type = type
    }
}

struct CreateTypeOutputResponseBody: Swift.Equatable {
    let type: AppSyncClientTypes.ModelType?
}

extension CreateTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AppSyncClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceArn
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case name
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceArn = dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dynamodbConfig = dynamodbConfig {
            try encodeContainer.encode(dynamodbConfig, forKey: .dynamodbConfig)
        }
        if let elasticsearchConfig = elasticsearchConfig {
            try encodeContainer.encode(elasticsearchConfig, forKey: .elasticsearchConfig)
        }
        if let httpConfig = httpConfig {
            try encodeContainer.encode(httpConfig, forKey: .httpConfig)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openSearchServiceConfig = openSearchServiceConfig {
            try encodeContainer.encode(openSearchServiceConfig, forKey: .openSearchServiceConfig)
        }
        if let relationalDatabaseConfig = relationalDatabaseConfig {
            try encodeContainer.encode(relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let dynamodbConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DynamodbDataSourceConfig.self, forKey: .dynamodbConfig)
        dynamodbConfig = dynamodbConfigDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaDataSourceConfig.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let elasticsearchConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ElasticsearchDataSourceConfig.self, forKey: .elasticsearchConfig)
        elasticsearchConfig = elasticsearchConfigDecoded
        let openSearchServiceConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenSearchServiceDataSourceConfig.self, forKey: .openSearchServiceConfig)
        openSearchServiceConfig = openSearchServiceConfigDecoded
        let httpConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.HttpDataSourceConfig.self, forKey: .httpConfig)
        httpConfig = httpConfigDecoded
        let relationalDatabaseConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RelationalDatabaseDataSourceConfig.self, forKey: .relationalDatabaseConfig)
        relationalDatabaseConfig = relationalDatabaseConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a data source.
    public struct DataSource: Swift.Equatable {
        /// The data source Amazon Resource Name (ARN).
        public var dataSourceArn: Swift.String?
        /// The description of the data source.
        public var description: Swift.String?
        /// DynamoDB settings.
        public var dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
        /// Amazon OpenSearch Service settings.
        public var elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
        /// HTTP endpoint settings.
        public var httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
        /// Lambda settings.
        public var lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
        /// The name of the data source.
        public var name: Swift.String?
        /// Amazon OpenSearch Service settings.
        public var openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
        /// Relational database settings.
        public var relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
        /// The Identity and Access Management (IAM) service role Amazon Resource Name (ARN) for the data source. The system assumes this role when accessing the data source.
        public var serviceRoleArn: Swift.String?
        /// The type of the data source.
        ///
        /// * AWS_LAMBDA: The data source is an Lambda function.
        ///
        /// * AMAZON_DYNAMODB: The data source is an Amazon DynamoDB table.
        ///
        /// * AMAZON_ELASTICSEARCH: The data source is an Amazon OpenSearch Service domain.
        ///
        /// * AMAZON_OPENSEARCH_SERVICE: The data source is an Amazon OpenSearch Service domain.
        ///
        /// * NONE: There is no data source. Use this type when you want to invoke a GraphQL operation without connecting to a data source, such as when you're performing data transformation with resolvers or invoking a subscription from a mutation.
        ///
        /// * HTTP: The data source is an HTTP endpoint.
        ///
        /// * RELATIONAL_DATABASE: The data source is a relational database.
        public var type: AppSyncClientTypes.DataSourceType?

        public init (
            dataSourceArn: Swift.String? = nil,
            description: Swift.String? = nil,
            dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig? = nil,
            elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig? = nil,
            httpConfig: AppSyncClientTypes.HttpDataSourceConfig? = nil,
            lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig? = nil,
            name: Swift.String? = nil,
            openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig? = nil,
            relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig? = nil,
            serviceRoleArn: Swift.String? = nil,
            type: AppSyncClientTypes.DataSourceType? = nil
        )
        {
            self.dataSourceArn = dataSourceArn
            self.description = description
            self.dynamodbConfig = dynamodbConfig
            self.elasticsearchConfig = elasticsearchConfig
            self.httpConfig = httpConfig
            self.lambdaConfig = lambdaConfig
            self.name = name
            self.openSearchServiceConfig = openSearchServiceConfig
            self.relationalDatabaseConfig = relationalDatabaseConfig
            self.serviceRoleArn = serviceRoleArn
            self.type = type
        }
    }

}

extension AppSyncClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonDynamodb
        case amazonElasticsearch
        case amazonOpensearchService
        case awsLambda
        case http
        case `none`
        case relationalDatabase
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .amazonDynamodb,
                .amazonElasticsearch,
                .amazonOpensearchService,
                .awsLambda,
                .http,
                .none,
                .relationalDatabase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonDynamodb: return "AMAZON_DYNAMODB"
            case .amazonElasticsearch: return "AMAZON_ELASTICSEARCH"
            case .amazonOpensearchService: return "AMAZON_OPENSEARCH_SERVICE"
            case .awsLambda: return "AWS_LAMBDA"
            case .http: return "HTTP"
            case .none: return "NONE"
            case .relationalDatabase: return "RELATIONAL_DATABASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum DefaultAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [DefaultAction] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DefaultAction(rawValue: rawValue) ?? DefaultAction.sdkUnknown(rawValue)
        }
    }
}

extension DeleteApiCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches"
    }
}

/// Represents the input of a DeleteApiCache operation.
public struct DeleteApiCacheInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteApiCacheInputBody: Swift.Equatable {
}

extension DeleteApiCacheInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiCacheOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Represents the output of a DeleteApiCache operation.
public struct DeleteApiCacheOutputResponse: Swift.Equatable {

}

extension DeleteApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/apikeys/\(id.urlPercentEncoding())"
    }
}

public struct DeleteApiKeyInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The ID for the API key.
    /// This member is required.
    public var id: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.id = id
    }
}

struct DeleteApiKeyInputBody: Swift.Equatable {
}

extension DeleteApiKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiKeyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApiKeyOutputResponse: Swift.Equatable {

}

extension DeleteDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources/\(name.urlPercentEncoding())"
    }
}

public struct DeleteDataSourceInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.name = name
    }
}

struct DeleteDataSourceInputBody: Swift.Equatable {
}

extension DeleteDataSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataSourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDataSourceOutputResponse: Swift.Equatable {

}

extension DeleteDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())"
    }
}

public struct DeleteDomainNameInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainNameInputBody: Swift.Equatable {
}

extension DeleteDomainNameInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainNameOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDomainNameOutputResponse: Swift.Equatable {

}

extension DeleteFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let functionId = functionId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())"
    }
}

public struct DeleteFunctionInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The Function ID.
    /// This member is required.
    public var functionId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        functionId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
    }
}

struct DeleteFunctionInputBody: Swift.Equatable {
}

extension DeleteFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionOutputResponse: Swift.Equatable {

}

extension DeleteGraphqlApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())"
    }
}

public struct DeleteGraphqlApiInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteGraphqlApiInputBody: Swift.Equatable {
}

extension DeleteGraphqlApiInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGraphqlApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGraphqlApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGraphqlApiOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGraphqlApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGraphqlApiOutputResponse: Swift.Equatable {

}

extension DeleteResolverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        guard let fieldName = fieldName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers/\(fieldName.urlPercentEncoding())"
    }
}

public struct DeleteResolverInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The resolver field name.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The name of the resolver type.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.fieldName = fieldName
        self.typeName = typeName
    }
}

struct DeleteResolverInputBody: Swift.Equatable {
}

extension DeleteResolverInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResolverOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResolverOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResolverOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResolverOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResolverOutputResponse: Swift.Equatable {

}

extension DeleteTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())"
    }
}

public struct DeleteTypeInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.typeName = typeName
    }
}

struct DeleteTypeInputBody: Swift.Equatable {
}

extension DeleteTypeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTypeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTypeOutputResponse: Swift.Equatable {

}

extension AppSyncClientTypes.DeltaSyncConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseTableTTL
        case deltaSyncTableName
        case deltaSyncTableTTL
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if baseTableTTL != 0 {
            try encodeContainer.encode(baseTableTTL, forKey: .baseTableTTL)
        }
        if let deltaSyncTableName = deltaSyncTableName {
            try encodeContainer.encode(deltaSyncTableName, forKey: .deltaSyncTableName)
        }
        if deltaSyncTableTTL != 0 {
            try encodeContainer.encode(deltaSyncTableTTL, forKey: .deltaSyncTableTTL)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseTableTTLDecoded = try containerValues.decode(Swift.Int.self, forKey: .baseTableTTL)
        baseTableTTL = baseTableTTLDecoded
        let deltaSyncTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deltaSyncTableName)
        deltaSyncTableName = deltaSyncTableNameDecoded
        let deltaSyncTableTTLDecoded = try containerValues.decode(Swift.Int.self, forKey: .deltaSyncTableTTL)
        deltaSyncTableTTL = deltaSyncTableTTLDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a Delta Sync configuration.
    public struct DeltaSyncConfig: Swift.Equatable {
        /// The number of minutes that an Item is stored in the data source.
        public var baseTableTTL: Swift.Int
        /// The Delta Sync table name.
        public var deltaSyncTableName: Swift.String?
        /// The number of minutes that a Delta Sync log entry is stored in the Delta Sync table.
        public var deltaSyncTableTTL: Swift.Int

        public init (
            baseTableTTL: Swift.Int = 0,
            deltaSyncTableName: Swift.String? = nil,
            deltaSyncTableTTL: Swift.Int = 0
        )
        {
            self.baseTableTTL = baseTableTTL
            self.deltaSyncTableName = deltaSyncTableName
            self.deltaSyncTableTTL = deltaSyncTableTTL
        }
    }

}

extension DisassociateApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/apiassociation"
    }
}

public struct DisassociateApiInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DisassociateApiInputBody: Swift.Equatable {
}

extension DisassociateApiInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateApiOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateApiOutputResponse: Swift.Equatable {

}

extension AppSyncClientTypes.DomainNameConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsyncDomainName
        case certificateArn
        case description
        case domainName
        case hostedZoneId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsyncDomainName = appsyncDomainName {
            try encodeContainer.encode(appsyncDomainName, forKey: .appsyncDomainName)
        }
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let hostedZoneId = hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let appsyncDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appsyncDomainName)
        appsyncDomainName = appsyncDomainNameDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a configuration for a custom domain.
    public struct DomainNameConfig: Swift.Equatable {
        /// The domain name that AppSync provides.
        public var appsyncDomainName: Swift.String?
        /// The Amazon Resource Name (ARN) of the certificate. This can be an Certificate Manager (ACM) certificate or an Identity and Access Management (IAM) server certificate.
        public var certificateArn: Swift.String?
        /// A description of the DomainName configuration.
        public var description: Swift.String?
        /// The domain name.
        public var domainName: Swift.String?
        /// The ID of your Amazon Route 53 hosted zone.
        public var hostedZoneId: Swift.String?

        public init (
            appsyncDomainName: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            description: Swift.String? = nil,
            domainName: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil
        )
        {
            self.appsyncDomainName = appsyncDomainName
            self.certificateArn = certificateArn
            self.description = description
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }
    }

}

extension AppSyncClientTypes.DynamodbDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case deltaSyncConfig
        case tableName
        case useCallerCredentials
        case versioned
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let deltaSyncConfig = deltaSyncConfig {
            try encodeContainer.encode(deltaSyncConfig, forKey: .deltaSyncConfig)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if useCallerCredentials != false {
            try encodeContainer.encode(useCallerCredentials, forKey: .useCallerCredentials)
        }
        if versioned != false {
            try encodeContainer.encode(versioned, forKey: .versioned)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let useCallerCredentialsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useCallerCredentials)
        useCallerCredentials = useCallerCredentialsDecoded
        let deltaSyncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DeltaSyncConfig.self, forKey: .deltaSyncConfig)
        deltaSyncConfig = deltaSyncConfigDecoded
        let versionedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .versioned)
        versioned = versionedDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an Amazon DynamoDB data source configuration.
    public struct DynamodbDataSourceConfig: Swift.Equatable {
        /// The Amazon Web Services Region.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The DeltaSyncConfig for a versioned data source.
        public var deltaSyncConfig: AppSyncClientTypes.DeltaSyncConfig?
        /// The table name.
        /// This member is required.
        public var tableName: Swift.String?
        /// Set to TRUE to use Amazon Cognito credentials with this data source.
        public var useCallerCredentials: Swift.Bool
        /// Set to TRUE to use Conflict Detection and Resolution with this data source.
        public var versioned: Swift.Bool

        public init (
            awsRegion: Swift.String? = nil,
            deltaSyncConfig: AppSyncClientTypes.DeltaSyncConfig? = nil,
            tableName: Swift.String? = nil,
            useCallerCredentials: Swift.Bool = false,
            versioned: Swift.Bool = false
        )
        {
            self.awsRegion = awsRegion
            self.deltaSyncConfig = deltaSyncConfig
            self.tableName = tableName
            self.useCallerCredentials = useCallerCredentials
            self.versioned = versioned
        }
    }

}

extension AppSyncClientTypes.ElasticsearchDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an OpenSearch data source configuration. As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. For new data sources, use [OpenSearchServiceDataSourceConfig] to specify an OpenSearch data source.
    public struct ElasticsearchDataSourceConfig: Swift.Equatable {
        /// The Amazon Web Services Region.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The endpoint.
        /// This member is required.
        public var endpoint: Swift.String?

        public init (
            awsRegion: Swift.String? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.endpoint = endpoint
        }
    }

}

extension AppSyncClientTypes {
    public enum FieldLogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case error
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldLogLevel] {
            return [
                .all,
                .error,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .error: return "ERROR"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FieldLogLevel(rawValue: rawValue) ?? FieldLogLevel.sdkUnknown(rawValue)
        }
    }
}

extension FlushApiCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/FlushCache"
    }
}

/// Represents the input of a FlushApiCache operation.
public struct FlushApiCacheInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct FlushApiCacheInputBody: Swift.Equatable {
}

extension FlushApiCacheInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension FlushApiCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension FlushApiCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FlushApiCacheOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension FlushApiCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Represents the output of a FlushApiCache operation.
public struct FlushApiCacheOutputResponse: Swift.Equatable {

}

extension AppSyncClientTypes.FunctionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceName
        case description
        case functionArn
        case functionId
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionId = functionId {
            try encodeContainer.encode(functionId, forKey: .functionId)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionId)
        functionId = functionIdDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// A function is a reusable entity. You can use multiple functions to compose the resolver logic.
    public struct FunctionConfiguration: Swift.Equatable {
        /// The name of the DataSource.
        public var dataSourceName: Swift.String?
        /// The Function description.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the Function object.
        public var functionArn: Swift.String?
        /// A unique ID representing the Function object.
        public var functionId: Swift.String?
        /// The version of the request mapping template. Currently, only the 2018-05-29 version of the template is supported.
        public var functionVersion: Swift.String?
        /// The name of the Function object.
        public var name: Swift.String?
        /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
        public var requestMappingTemplate: Swift.String?
        /// The Function response mapping template.
        public var responseMappingTemplate: Swift.String?
        /// Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
        public var syncConfig: AppSyncClientTypes.SyncConfig?

        public init (
            dataSourceName: Swift.String? = nil,
            description: Swift.String? = nil,
            functionArn: Swift.String? = nil,
            functionId: Swift.String? = nil,
            functionVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            requestMappingTemplate: Swift.String? = nil,
            responseMappingTemplate: Swift.String? = nil,
            syncConfig: AppSyncClientTypes.SyncConfig? = nil
        )
        {
            self.dataSourceName = dataSourceName
            self.description = description
            self.functionArn = functionArn
            self.functionId = functionId
            self.functionVersion = functionVersion
            self.name = name
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
            self.syncConfig = syncConfig
        }
    }

}

extension GetApiAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/apiassociation"
    }
}

public struct GetApiAssociationInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetApiAssociationInputBody: Swift.Equatable {
}

extension GetApiAssociationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApiAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApiAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiAssociation = output.apiAssociation
        } else {
            self.apiAssociation = nil
        }
    }
}

public struct GetApiAssociationOutputResponse: Swift.Equatable {
    /// The ApiAssociation object.
    public var apiAssociation: AppSyncClientTypes.ApiAssociation?

    public init (
        apiAssociation: AppSyncClientTypes.ApiAssociation? = nil
    )
    {
        self.apiAssociation = apiAssociation
    }
}

struct GetApiAssociationOutputResponseBody: Swift.Equatable {
    let apiAssociation: AppSyncClientTypes.ApiAssociation?
}

extension GetApiAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAssociation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiAssociationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiAssociation.self, forKey: .apiAssociation)
        apiAssociation = apiAssociationDecoded
    }
}

extension GetApiCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches"
    }
}

/// Represents the input of a GetApiCache operation.
public struct GetApiCacheInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetApiCacheInputBody: Swift.Equatable {
}

extension GetApiCacheInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApiCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiCacheOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApiCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiCache = output.apiCache
        } else {
            self.apiCache = nil
        }
    }
}

/// Represents the output of a GetApiCache operation.
public struct GetApiCacheOutputResponse: Swift.Equatable {
    /// The ApiCache object.
    public var apiCache: AppSyncClientTypes.ApiCache?

    public init (
        apiCache: AppSyncClientTypes.ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

struct GetApiCacheOutputResponseBody: Swift.Equatable {
    let apiCache: AppSyncClientTypes.ApiCache?
}

extension GetApiCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCache
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCacheDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCache.self, forKey: .apiCache)
        apiCache = apiCacheDecoded
    }
}

extension GetDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources/\(name.urlPercentEncoding())"
    }
}

public struct GetDataSourceInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.name = name
    }
}

struct GetDataSourceInputBody: Swift.Equatable {
}

extension GetDataSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataSourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct GetDataSourceOutputResponse: Swift.Equatable {
    /// The DataSource object.
    public var dataSource: AppSyncClientTypes.DataSource?

    public init (
        dataSource: AppSyncClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct GetDataSourceOutputResponseBody: Swift.Equatable {
    let dataSource: AppSyncClientTypes.DataSource?
}

extension GetDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

extension GetDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())"
    }
}

public struct GetDomainNameInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetDomainNameInputBody: Swift.Equatable {
}

extension GetDomainNameInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainNameOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainNameConfig = output.domainNameConfig
        } else {
            self.domainNameConfig = nil
        }
    }
}

public struct GetDomainNameOutputResponse: Swift.Equatable {
    /// The configuration for the DomainName.
    public var domainNameConfig: AppSyncClientTypes.DomainNameConfig?

    public init (
        domainNameConfig: AppSyncClientTypes.DomainNameConfig? = nil
    )
    {
        self.domainNameConfig = domainNameConfig
    }
}

struct GetDomainNameOutputResponseBody: Swift.Equatable {
    let domainNameConfig: AppSyncClientTypes.DomainNameConfig?
}

extension GetDomainNameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNameConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DomainNameConfig.self, forKey: .domainNameConfig)
        domainNameConfig = domainNameConfigDecoded
    }
}

extension GetFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let functionId = functionId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())"
    }
}

public struct GetFunctionInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The Function ID.
    /// This member is required.
    public var functionId: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        functionId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
    }
}

struct GetFunctionInputBody: Swift.Equatable {
}

extension GetFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functionConfiguration = output.functionConfiguration
        } else {
            self.functionConfiguration = nil
        }
    }
}

public struct GetFunctionOutputResponse: Swift.Equatable {
    /// The Function object.
    public var functionConfiguration: AppSyncClientTypes.FunctionConfiguration?

    public init (
        functionConfiguration: AppSyncClientTypes.FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

struct GetFunctionOutputResponseBody: Swift.Equatable {
    let functionConfiguration: AppSyncClientTypes.FunctionConfiguration?
}

extension GetFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
    }
}

extension GetGraphqlApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())"
    }
}

public struct GetGraphqlApiInput: Swift.Equatable {
    /// The API ID for the GraphQL API.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetGraphqlApiInputBody: Swift.Equatable {
}

extension GetGraphqlApiInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGraphqlApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGraphqlApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGraphqlApiOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGraphqlApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetGraphqlApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.graphqlApi = output.graphqlApi
        } else {
            self.graphqlApi = nil
        }
    }
}

public struct GetGraphqlApiOutputResponse: Swift.Equatable {
    /// The GraphqlApi object.
    public var graphqlApi: AppSyncClientTypes.GraphqlApi?

    public init (
        graphqlApi: AppSyncClientTypes.GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

struct GetGraphqlApiOutputResponseBody: Swift.Equatable {
    let graphqlApi: AppSyncClientTypes.GraphqlApi?
}

extension GetGraphqlApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphqlApi
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApiDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphqlApi.self, forKey: .graphqlApi)
        graphqlApi = graphqlApiDecoded
    }
}

extension GetIntrospectionSchemaInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let includeDirectives = includeDirectives {
            let includeDirectivesQueryItem = ClientRuntime.URLQueryItem(name: "includeDirectives".urlPercentEncoding(), value: Swift.String(includeDirectives).urlPercentEncoding())
            items.append(includeDirectivesQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        return items
    }
}

extension GetIntrospectionSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/schema"
    }
}

public struct GetIntrospectionSchemaInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The schema format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.OutputType?
    /// A flag that specifies whether the schema introspection should contain directives.
    public var includeDirectives: Swift.Bool?

    public init (
        apiId: Swift.String? = nil,
        format: AppSyncClientTypes.OutputType? = nil,
        includeDirectives: Swift.Bool? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.includeDirectives = includeDirectives
    }
}

struct GetIntrospectionSchemaInputBody: Swift.Equatable {
}

extension GetIntrospectionSchemaInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIntrospectionSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntrospectionSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "GraphQLSchemaException" : self = .graphQLSchemaException(try GraphQLSchemaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntrospectionSchemaOutputError: Swift.Error, Swift.Equatable {
    case graphQLSchemaException(GraphQLSchemaException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntrospectionSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.schema = data
        } else {
            self.schema = nil
        }
    }
}

public struct GetIntrospectionSchemaOutputResponse: Swift.Equatable {
    /// The schema, in GraphQL Schema Definition Language (SDL) format. For more information, see the [GraphQL SDL documentation](http://graphql.org/learn/schema/).
    public var schema: ClientRuntime.Data?

    public init (
        schema: ClientRuntime.Data? = nil
    )
    {
        self.schema = schema
    }
}

struct GetIntrospectionSchemaOutputResponseBody: Swift.Equatable {
    let schema: ClientRuntime.Data?
}

extension GetIntrospectionSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schema
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension GetResolverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        guard let fieldName = fieldName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers/\(fieldName.urlPercentEncoding())"
    }
}

public struct GetResolverInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The resolver field name.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The resolver type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.fieldName = fieldName
        self.typeName = typeName
    }
}

struct GetResolverInputBody: Swift.Equatable {
}

extension GetResolverInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResolverOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResolverOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolver = output.resolver
        } else {
            self.resolver = nil
        }
    }
}

public struct GetResolverOutputResponse: Swift.Equatable {
    /// The Resolver object.
    public var resolver: AppSyncClientTypes.Resolver?

    public init (
        resolver: AppSyncClientTypes.Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

struct GetResolverOutputResponseBody: Swift.Equatable {
    let resolver: AppSyncClientTypes.Resolver?
}

extension GetResolverOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolver
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.Resolver.self, forKey: .resolver)
        resolver = resolverDecoded
    }
}

extension GetSchemaCreationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/schemacreation"
    }
}

public struct GetSchemaCreationStatusInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init (
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetSchemaCreationStatusInputBody: Swift.Equatable {
}

extension GetSchemaCreationStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSchemaCreationStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSchemaCreationStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSchemaCreationStatusOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSchemaCreationStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSchemaCreationStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.status = output.status
        } else {
            self.details = nil
            self.status = nil
        }
    }
}

public struct GetSchemaCreationStatusOutputResponse: Swift.Equatable {
    /// Detailed information about the status of the schema creation operation.
    public var details: Swift.String?
    /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When the schema is in the ACTIVE state, you can add data.
    public var status: AppSyncClientTypes.SchemaStatus?

    public init (
        details: Swift.String? = nil,
        status: AppSyncClientTypes.SchemaStatus? = nil
    )
    {
        self.details = details
        self.status = status
    }
}

struct GetSchemaCreationStatusOutputResponseBody: Swift.Equatable {
    let status: AppSyncClientTypes.SchemaStatus?
    let details: Swift.String?
}

extension GetSchemaCreationStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SchemaStatus.self, forKey: .status)
        status = statusDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
    }
}

extension GetTypeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        return items
    }
}

extension GetTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())"
    }
}

public struct GetTypeInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.typeName = typeName
    }
}

struct GetTypeInputBody: Swift.Equatable {
}

extension GetTypeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTypeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.type = output.type
        } else {
            self.type = nil
        }
    }
}

public struct GetTypeOutputResponse: Swift.Equatable {
    /// The Type object.
    public var type: AppSyncClientTypes.ModelType?

    public init (
        type: AppSyncClientTypes.ModelType? = nil
    )
    {
        self.type = type
    }
}

struct GetTypeOutputResponseBody: Swift.Equatable {
    let type: AppSyncClientTypes.ModelType?
}

extension GetTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension GraphQLSchemaException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GraphQLSchemaExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The GraphQL schema is not valid.
public struct GraphQLSchemaException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct GraphQLSchemaExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension GraphQLSchemaExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.GraphqlApi: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case apiId
        case arn
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case name
        case openIDConnectConfig
        case tags
        case uris
        case userPoolConfig
        case wafWebAclArn
        case xrayEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthenticationProviders = additionalAuthenticationProviders {
            var additionalAuthenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthenticationProviders)
            for additionalauthenticationproviders0 in additionalAuthenticationProviders {
                try additionalAuthenticationProvidersContainer.encode(additionalauthenticationproviders0)
            }
        }
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let lambdaAuthorizerConfig = lambdaAuthorizerConfig {
            try encodeContainer.encode(lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
        }
        if let logConfig = logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openIDConnectConfig = openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uris = uris {
            var urisContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .uris)
            for (dictKey0, mapofstringtostring0) in uris {
                try urisContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userPoolConfig = userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
        if let wafWebAclArn = wafWebAclArn {
            try encodeContainer.encode(wafWebAclArn, forKey: .wafWebAclArn)
        }
        if xrayEnabled != false {
            try encodeContainer.encode(xrayEnabled, forKey: .xrayEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LogConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.UserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let urisContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .uris)
        var urisDecoded0: [Swift.String:Swift.String]? = nil
        if let urisContainer = urisContainer {
            urisDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in urisContainer {
                if let string0 = string0 {
                    urisDecoded0?[key0] = string0
                }
            }
        }
        uris = urisDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let additionalAuthenticationProvidersContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.AdditionalAuthenticationProvider?].self, forKey: .additionalAuthenticationProviders)
        var additionalAuthenticationProvidersDecoded0:[AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil
        if let additionalAuthenticationProvidersContainer = additionalAuthenticationProvidersContainer {
            additionalAuthenticationProvidersDecoded0 = [AppSyncClientTypes.AdditionalAuthenticationProvider]()
            for structure0 in additionalAuthenticationProvidersContainer {
                if let structure0 = structure0 {
                    additionalAuthenticationProvidersDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthenticationProviders = additionalAuthenticationProvidersDecoded0
        let xrayEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .xrayEnabled)
        xrayEnabled = xrayEnabledDecoded
        let wafWebAclArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wafWebAclArn)
        wafWebAclArn = wafWebAclArnDecoded
        let lambdaAuthorizerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaAuthorizerConfig.self, forKey: .lambdaAuthorizerConfig)
        lambdaAuthorizerConfig = lambdaAuthorizerConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a GraphQL API.
    public struct GraphqlApi: Swift.Equatable {
        /// A list of additional authentication providers for the GraphqlApi API.
        public var additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
        /// The API ID.
        public var apiId: Swift.String?
        /// The Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The authentication type.
        public var authenticationType: AppSyncClientTypes.AuthenticationType?
        /// Configuration for Lambda function authorization.
        public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
        /// The Amazon CloudWatch Logs configuration.
        public var logConfig: AppSyncClientTypes.LogConfig?
        /// The API name.
        public var name: Swift.String?
        /// The OpenID Connect configuration.
        public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
        /// The tags.
        public var tags: [Swift.String:Swift.String]?
        /// The URIs.
        public var uris: [Swift.String:Swift.String]?
        /// The Amazon Cognito user pool configuration.
        public var userPoolConfig: AppSyncClientTypes.UserPoolConfig?
        /// The ARN of the WAF access control list (ACL) associated with this GraphqlApi, if one exists.
        public var wafWebAclArn: Swift.String?
        /// A flag indicating whether to use X-Ray tracing for this GraphqlApi.
        public var xrayEnabled: Swift.Bool

        public init (
            additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil,
            apiId: Swift.String? = nil,
            arn: Swift.String? = nil,
            authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
            lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
            logConfig: AppSyncClientTypes.LogConfig? = nil,
            name: Swift.String? = nil,
            openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            uris: [Swift.String:Swift.String]? = nil,
            userPoolConfig: AppSyncClientTypes.UserPoolConfig? = nil,
            wafWebAclArn: Swift.String? = nil,
            xrayEnabled: Swift.Bool = false
        )
        {
            self.additionalAuthenticationProviders = additionalAuthenticationProviders
            self.apiId = apiId
            self.arn = arn
            self.authenticationType = authenticationType
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.logConfig = logConfig
            self.name = name
            self.openIDConnectConfig = openIDConnectConfig
            self.tags = tags
            self.uris = uris
            self.userPoolConfig = userPoolConfig
            self.wafWebAclArn = wafWebAclArn
            self.xrayEnabled = xrayEnabled
        }
    }

}

extension AppSyncClientTypes.HttpDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationConfig
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationConfig = authorizationConfig {
            try encodeContainer.encode(authorizationConfig, forKey: .authorizationConfig)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let authorizationConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthorizationConfig.self, forKey: .authorizationConfig)
        authorizationConfig = authorizationConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an HTTP data source configuration.
    public struct HttpDataSourceConfig: Swift.Equatable {
        /// The authorization configuration in case the HTTP endpoint requires authorization.
        public var authorizationConfig: AppSyncClientTypes.AuthorizationConfig?
        /// The HTTP URL endpoint. You can specify either the domain name or IP, and port combination, and the URL scheme must be HTTP or HTTPS. If you don't specify the port, AppSync uses the default port 80 for the HTTP endpoint and port 443 for HTTPS endpoints.
        public var endpoint: Swift.String?

        public init (
            authorizationConfig: AppSyncClientTypes.AuthorizationConfig? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.authorizationConfig = authorizationConfig
            self.endpoint = endpoint
        }
    }

}

extension InternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal AppSync error occurred. Try your request again.
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.LambdaAuthorizerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerResultTtlInSeconds
        case authorizerUri
        case identityValidationExpression
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if authorizerResultTtlInSeconds != 0 {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerUri = authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let identityValidationExpression = identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerResultTtlInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
    }
}

extension AppSyncClientTypes {
    /// A LambdaAuthorizerConfig specifies how to authorize AppSync API access when using the AWS_LAMBDA authorizer mode. Be aware that an AppSync API can have only one Lambda authorizer configured at a time.
    public struct LambdaAuthorizerConfig: Swift.Equatable {
        /// The number of seconds a response should be cached for. The default is 5 minutes (300 seconds). The Lambda function can override this by returning a ttlOverride key in its response. A value of 0 disables caching of responses.
        public var authorizerResultTtlInSeconds: Swift.Int
        /// The Amazon Resource Name (ARN) of the Lambda function to be called for authorization. This can be a standard Lambda ARN, a version ARN (.../v3), or an alias ARN. Note: This Lambda function must have the following resource-based policy assigned to it. When configuring Lambda authorizers in the console, this is done for you. To use the Command Line Interface (CLI), run the following: aws lambda add-permission --function-name "arn:aws:lambda:us-east-2:111122223333:function:my-function" --statement-id "appsync" --principal appsync.amazonaws.com --action lambda:InvokeFunction
        /// This member is required.
        public var authorizerUri: Swift.String?
        /// A regular expression for validation of tokens before the Lambda function is called.
        public var identityValidationExpression: Swift.String?

        public init (
            authorizerResultTtlInSeconds: Swift.Int = 0,
            authorizerUri: Swift.String? = nil,
            identityValidationExpression: Swift.String? = nil
        )
        {
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerUri = authorizerUri
            self.identityValidationExpression = identityValidationExpression
        }
    }

}

extension AppSyncClientTypes.LambdaConflictHandlerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaConflictHandlerArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaConflictHandlerArn = lambdaConflictHandlerArn {
            try encodeContainer.encode(lambdaConflictHandlerArn, forKey: .lambdaConflictHandlerArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaConflictHandlerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaConflictHandlerArn)
        lambdaConflictHandlerArn = lambdaConflictHandlerArnDecoded
    }
}

extension AppSyncClientTypes {
    /// The LambdaConflictHandlerConfig object when configuring LAMBDA as the Conflict Handler.
    public struct LambdaConflictHandlerConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the Lambda function to use as the Conflict Handler.
        public var lambdaConflictHandlerArn: Swift.String?

        public init (
            lambdaConflictHandlerArn: Swift.String? = nil
        )
        {
            self.lambdaConflictHandlerArn = lambdaConflictHandlerArn
        }
    }

}

extension AppSyncClientTypes.LambdaDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaFunctionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaFunctionArn = lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an Lambda data source configuration.
    public struct LambdaDataSourceConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the Lambda function.
        /// This member is required.
        public var lambdaFunctionArn: Swift.String?

        public init (
            lambdaFunctionArn: Swift.String? = nil
        )
        {
            self.lambdaFunctionArn = lambdaFunctionArn
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeded a limit. Try your request again.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApiKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListApiKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/apikeys"
    }
}

public struct ListApiKeysInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApiKeysInputBody: Swift.Equatable {
}

extension ListApiKeysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApiKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApiKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApiKeysOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApiKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApiKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKeys = output.apiKeys
            self.nextToken = output.nextToken
        } else {
            self.apiKeys = nil
            self.nextToken = nil
        }
    }
}

public struct ListApiKeysOutputResponse: Swift.Equatable {
    /// The ApiKey objects.
    public var apiKeys: [AppSyncClientTypes.ApiKey]?
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        apiKeys: [AppSyncClientTypes.ApiKey]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiKeys = apiKeys
        self.nextToken = nextToken
    }
}

struct ListApiKeysOutputResponseBody: Swift.Equatable {
    let apiKeys: [AppSyncClientTypes.ApiKey]?
    let nextToken: Swift.String?
}

extension ListApiKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeys
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeysContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.ApiKey?].self, forKey: .apiKeys)
        var apiKeysDecoded0:[AppSyncClientTypes.ApiKey]? = nil
        if let apiKeysContainer = apiKeysContainer {
            apiKeysDecoded0 = [AppSyncClientTypes.ApiKey]()
            for structure0 in apiKeysContainer {
                if let structure0 = structure0 {
                    apiKeysDecoded0?.append(structure0)
                }
            }
        }
        apiKeys = apiKeysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDataSourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources"
    }
}

public struct ListDataSourcesInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSourcesInputBody: Swift.Equatable {
}

extension ListDataSourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSourcesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSources = output.dataSources
            self.nextToken = output.nextToken
        } else {
            self.dataSources = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourcesOutputResponse: Swift.Equatable {
    /// The DataSource objects.
    public var dataSources: [AppSyncClientTypes.DataSource]?
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        dataSources: [AppSyncClientTypes.DataSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSources = dataSources
        self.nextToken = nextToken
    }
}

struct ListDataSourcesOutputResponseBody: Swift.Equatable {
    let dataSources: [AppSyncClientTypes.DataSource]?
    let nextToken: Swift.String?
}

extension ListDataSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSources
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourcesContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[AppSyncClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [AppSyncClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainNamesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDomainNamesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/domainnames"
    }
}

public struct ListDomainNamesInput: Swift.Equatable {
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int
    /// The API token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainNamesInputBody: Swift.Equatable {
}

extension ListDomainNamesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainNamesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainNamesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainNamesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainNamesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDomainNamesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainNameConfigs = output.domainNameConfigs
            self.nextToken = output.nextToken
        } else {
            self.domainNameConfigs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainNamesOutputResponse: Swift.Equatable {
    /// Lists configurations for multiple domain names.
    public var domainNameConfigs: [AppSyncClientTypes.DomainNameConfig]?
    /// The API token.
    public var nextToken: Swift.String?

    public init (
        domainNameConfigs: [AppSyncClientTypes.DomainNameConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainNameConfigs = domainNameConfigs
        self.nextToken = nextToken
    }
}

struct ListDomainNamesOutputResponseBody: Swift.Equatable {
    let domainNameConfigs: [AppSyncClientTypes.DomainNameConfig]?
    let nextToken: Swift.String?
}

extension ListDomainNamesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNameConfigs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameConfigsContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.DomainNameConfig?].self, forKey: .domainNameConfigs)
        var domainNameConfigsDecoded0:[AppSyncClientTypes.DomainNameConfig]? = nil
        if let domainNameConfigsContainer = domainNameConfigsContainer {
            domainNameConfigsDecoded0 = [AppSyncClientTypes.DomainNameConfig]()
            for structure0 in domainNameConfigsContainer {
                if let structure0 = structure0 {
                    domainNameConfigsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigs = domainNameConfigsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFunctionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFunctionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions"
    }
}

public struct ListFunctionsInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFunctionsInputBody: Swift.Equatable {
}

extension ListFunctionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFunctionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functions = output.functions
            self.nextToken = output.nextToken
        } else {
            self.functions = nil
            self.nextToken = nil
        }
    }
}

public struct ListFunctionsOutputResponse: Swift.Equatable {
    /// A list of Function objects.
    public var functions: [AppSyncClientTypes.FunctionConfiguration]?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        functions: [AppSyncClientTypes.FunctionConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functions = functions
        self.nextToken = nextToken
    }
}

struct ListFunctionsOutputResponseBody: Swift.Equatable {
    let functions: [AppSyncClientTypes.FunctionConfiguration]?
    let nextToken: Swift.String?
}

extension ListFunctionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionsContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.FunctionConfiguration?].self, forKey: .functions)
        var functionsDecoded0:[AppSyncClientTypes.FunctionConfiguration]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [AppSyncClientTypes.FunctionConfiguration]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGraphqlApisInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGraphqlApisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/apis"
    }
}

public struct ListGraphqlApisInput: Swift.Equatable {
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGraphqlApisInputBody: Swift.Equatable {
}

extension ListGraphqlApisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGraphqlApisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGraphqlApisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGraphqlApisOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGraphqlApisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGraphqlApisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.graphqlApis = output.graphqlApis
            self.nextToken = output.nextToken
        } else {
            self.graphqlApis = nil
            self.nextToken = nil
        }
    }
}

public struct ListGraphqlApisOutputResponse: Swift.Equatable {
    /// The GraphqlApi objects.
    public var graphqlApis: [AppSyncClientTypes.GraphqlApi]?
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        graphqlApis: [AppSyncClientTypes.GraphqlApi]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphqlApis = graphqlApis
        self.nextToken = nextToken
    }
}

struct ListGraphqlApisOutputResponseBody: Swift.Equatable {
    let graphqlApis: [AppSyncClientTypes.GraphqlApi]?
    let nextToken: Swift.String?
}

extension ListGraphqlApisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphqlApis
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApisContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.GraphqlApi?].self, forKey: .graphqlApis)
        var graphqlApisDecoded0:[AppSyncClientTypes.GraphqlApi]? = nil
        if let graphqlApisContainer = graphqlApisContainer {
            graphqlApisDecoded0 = [AppSyncClientTypes.GraphqlApi]()
            for structure0 in graphqlApisContainer {
                if let structure0 = structure0 {
                    graphqlApisDecoded0?.append(structure0)
                }
            }
        }
        graphqlApis = graphqlApisDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResolversByFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListResolversByFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let functionId = functionId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())/resolvers"
    }
}

public struct ListResolversByFunctionInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The function ID.
    /// This member is required.
    public var functionId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        functionId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolversByFunctionInputBody: Swift.Equatable {
}

extension ListResolversByFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListResolversByFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolversByFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolversByFunctionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolversByFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResolversByFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolvers = output.resolvers
        } else {
            self.nextToken = nil
            self.resolvers = nil
        }
    }
}

public struct ListResolversByFunctionOutputResponse: Swift.Equatable {
    /// An identifier that you can use to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The list of resolvers.
    public var resolvers: [AppSyncClientTypes.Resolver]?

    public init (
        nextToken: Swift.String? = nil,
        resolvers: [AppSyncClientTypes.Resolver]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolvers = resolvers
    }
}

struct ListResolversByFunctionOutputResponseBody: Swift.Equatable {
    let resolvers: [AppSyncClientTypes.Resolver]?
    let nextToken: Swift.String?
}

extension ListResolversByFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resolvers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolversContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.Resolver?].self, forKey: .resolvers)
        var resolversDecoded0:[AppSyncClientTypes.Resolver]? = nil
        if let resolversContainer = resolversContainer {
            resolversDecoded0 = [AppSyncClientTypes.Resolver]()
            for structure0 in resolversContainer {
                if let structure0 = structure0 {
                    resolversDecoded0?.append(structure0)
                }
            }
        }
        resolvers = resolversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResolversInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListResolversInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers"
    }
}

public struct ListResolversInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.typeName = typeName
    }
}

struct ListResolversInputBody: Swift.Equatable {
}

extension ListResolversInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListResolversOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolversOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolversOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolversOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResolversOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolvers = output.resolvers
        } else {
            self.nextToken = nil
            self.resolvers = nil
        }
    }
}

public struct ListResolversOutputResponse: Swift.Equatable {
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The Resolver objects.
    public var resolvers: [AppSyncClientTypes.Resolver]?

    public init (
        nextToken: Swift.String? = nil,
        resolvers: [AppSyncClientTypes.Resolver]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolvers = resolvers
    }
}

struct ListResolversOutputResponseBody: Swift.Equatable {
    let resolvers: [AppSyncClientTypes.Resolver]?
    let nextToken: Swift.String?
}

extension ListResolversOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resolvers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolversContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.Resolver?].self, forKey: .resolvers)
        var resolversDecoded0:[AppSyncClientTypes.Resolver]? = nil
        if let resolversContainer = resolversContainer {
            resolversDecoded0 = [AppSyncClientTypes.Resolver]()
            for structure0 in resolversContainer {
                if let structure0 = structure0 {
                    resolversDecoded0?.append(structure0)
                }
            }
        }
        resolvers = resolversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The GraphqlApi Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A TagMap object.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTypesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        return items
    }
}

extension ListTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types"
    }
}

public struct ListTypesInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTypesInputBody: Swift.Equatable {
}

extension ListTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTypesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.types = output.types
        } else {
            self.nextToken = nil
            self.types = nil
        }
    }
}

public struct ListTypesOutputResponse: Swift.Equatable {
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The Type objects.
    public var types: [AppSyncClientTypes.ModelType]?

    public init (
        nextToken: Swift.String? = nil,
        types: [AppSyncClientTypes.ModelType]? = nil
    )
    {
        self.nextToken = nextToken
        self.types = types
    }
}

struct ListTypesOutputResponseBody: Swift.Equatable {
    let types: [AppSyncClientTypes.ModelType]?
    let nextToken: Swift.String?
}

extension ListTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case types
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typesContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.ModelType?].self, forKey: .types)
        var typesDecoded0:[AppSyncClientTypes.ModelType]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [AppSyncClientTypes.ModelType]()
            for structure0 in typesContainer {
                if let structure0 = structure0 {
                    typesDecoded0?.append(structure0)
                }
            }
        }
        types = typesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AppSyncClientTypes.LogConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsRoleArn
        case excludeVerboseContent
        case fieldLogLevel
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsRoleArn = cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if excludeVerboseContent != false {
            try encodeContainer.encode(excludeVerboseContent, forKey: .excludeVerboseContent)
        }
        if let fieldLogLevel = fieldLogLevel {
            try encodeContainer.encode(fieldLogLevel.rawValue, forKey: .fieldLogLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLogLevelDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.FieldLogLevel.self, forKey: .fieldLogLevel)
        fieldLogLevel = fieldLogLevelDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let excludeVerboseContentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .excludeVerboseContent)
        excludeVerboseContent = excludeVerboseContentDecoded
    }
}

extension AppSyncClientTypes {
    /// The Amazon CloudWatch Logs configuration.
    public struct LogConfig: Swift.Equatable {
        /// The service role that AppSync assumes to publish to CloudWatch logs in your account.
        /// This member is required.
        public var cloudWatchLogsRoleArn: Swift.String?
        /// Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging level.
        public var excludeVerboseContent: Swift.Bool
        /// The field logging level. Values can be NONE, ERROR, or ALL.
        ///
        /// * NONE: No field-level logs are captured.
        ///
        /// * ERROR: Logs the following information only for the fields that are in error:
        ///
        /// * The error section in the server response.
        ///
        /// * Field-level errors.
        ///
        /// * The generated request/response functions that got resolved for error fields.
        ///
        ///
        ///
        ///
        /// * ALL: The following information is logged for all fields in the query:
        ///
        /// * Field-level tracing information.
        ///
        /// * The generated request/response functions that got resolved for each field.
        /// This member is required.
        public var fieldLogLevel: AppSyncClientTypes.FieldLogLevel?

        public init (
            cloudWatchLogsRoleArn: Swift.String? = nil,
            excludeVerboseContent: Swift.Bool = false,
            fieldLogLevel: AppSyncClientTypes.FieldLogLevel? = nil
        )
        {
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.excludeVerboseContent = excludeVerboseContent
            self.fieldLogLevel = fieldLogLevel
        }
    }

}

extension AppSyncClientTypes.ModelType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case definition
        case description
        case format
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.TypeDefinitionFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in the request was not found. Check the resource, and then try again.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.OpenIDConnectConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authTTL
        case clientId
        case iatTTL
        case issuer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if authTTL != 0 {
            try encodeContainer.encode(authTTL, forKey: .authTTL)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if iatTTL != 0 {
            try encodeContainer.encode(iatTTL, forKey: .iatTTL)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let iatTTLDecoded = try containerValues.decode(Swift.Int.self, forKey: .iatTTL)
        iatTTL = iatTTLDecoded
        let authTTLDecoded = try containerValues.decode(Swift.Int.self, forKey: .authTTL)
        authTTL = authTTLDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an OpenID Connect (OIDC) configuration.
    public struct OpenIDConnectConfig: Swift.Equatable {
        /// The number of milliseconds that a token is valid after being authenticated.
        public var authTTL: Swift.Int
        /// The client identifier of the relying party at the OpenID identity provider. This identifier is typically obtained when the relying party is registered with the OpenID identity provider. You can specify a regular expression so that AppSync can validate against multiple client identifiers at a time.
        public var clientId: Swift.String?
        /// The number of milliseconds that a token is valid after it's issued to a user.
        public var iatTTL: Swift.Int
        /// The issuer for the OIDC configuration. The issuer returned by discovery must exactly match the value of iss in the ID token.
        /// This member is required.
        public var issuer: Swift.String?

        public init (
            authTTL: Swift.Int = 0,
            clientId: Swift.String? = nil,
            iatTTL: Swift.Int = 0,
            issuer: Swift.String? = nil
        )
        {
            self.authTTL = authTTL
            self.clientId = clientId
            self.iatTTL = iatTTL
            self.issuer = issuer
        }
    }

}

extension AppSyncClientTypes.OpenSearchServiceDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an OpenSearch data source configuration.
    public struct OpenSearchServiceDataSourceConfig: Swift.Equatable {
        /// The Amazon Web Services Region.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The endpoint.
        /// This member is required.
        public var endpoint: Swift.String?

        public init (
            awsRegion: Swift.String? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.endpoint = endpoint
        }
    }

}

extension AppSyncClientTypes {
    public enum OutputType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case sdl
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputType] {
            return [
                .json,
                .sdl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .sdl: return "SDL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputType(rawValue: rawValue) ?? OutputType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.PipelineConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functions)
            for functionsids0 in functions {
                try functionsContainer.encode(functionsids0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .functions)
        var functionsDecoded0:[Swift.String]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Swift.String]()
            for string0 in functionsContainer {
                if let string0 = string0 {
                    functionsDecoded0?.append(string0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension AppSyncClientTypes {
    /// The pipeline configuration for a resolver of kind PIPELINE.
    public struct PipelineConfig: Swift.Equatable {
        /// A list of Function objects.
        public var functions: [Swift.String]?

        public init (
            functions: [Swift.String]? = nil
        )
        {
            self.functions = functions
        }
    }

}

extension AppSyncClientTypes.RdsHttpEndpointConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case awsSecretStoreArn
        case databaseName
        case dbClusterIdentifier
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let awsSecretStoreArn = awsSecretStoreArn {
            try encodeContainer.encode(awsSecretStoreArn, forKey: .awsSecretStoreArn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dbClusterIdentifier = dbClusterIdentifier {
            try encodeContainer.encode(dbClusterIdentifier, forKey: .dbClusterIdentifier)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let dbClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterIdentifier)
        dbClusterIdentifier = dbClusterIdentifierDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let awsSecretStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsSecretStoreArn)
        awsSecretStoreArn = awsSecretStoreArnDecoded
    }
}

extension AppSyncClientTypes {
    /// The Amazon Relational Database Service (Amazon RDS) HTTP endpoint configuration.
    public struct RdsHttpEndpointConfig: Swift.Equatable {
        /// Amazon Web Services Region for Amazon RDS HTTP endpoint.
        public var awsRegion: Swift.String?
        /// Amazon Web Services secret store Amazon Resource Name (ARN) for database credentials.
        public var awsSecretStoreArn: Swift.String?
        /// Logical database name.
        public var databaseName: Swift.String?
        /// Amazon RDS cluster Amazon Resource Name (ARN).
        public var dbClusterIdentifier: Swift.String?
        /// Logical schema name.
        public var schema: Swift.String?

        public init (
            awsRegion: Swift.String? = nil,
            awsSecretStoreArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dbClusterIdentifier: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.awsSecretStoreArn = awsSecretStoreArn
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.schema = schema
        }
    }

}

extension AppSyncClientTypes.RelationalDatabaseDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsHttpEndpointConfig
        case relationalDatabaseSourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rdsHttpEndpointConfig = rdsHttpEndpointConfig {
            try encodeContainer.encode(rdsHttpEndpointConfig, forKey: .rdsHttpEndpointConfig)
        }
        if let relationalDatabaseSourceType = relationalDatabaseSourceType {
            try encodeContainer.encode(relationalDatabaseSourceType.rawValue, forKey: .relationalDatabaseSourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relationalDatabaseSourceTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RelationalDatabaseSourceType.self, forKey: .relationalDatabaseSourceType)
        relationalDatabaseSourceType = relationalDatabaseSourceTypeDecoded
        let rdsHttpEndpointConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RdsHttpEndpointConfig.self, forKey: .rdsHttpEndpointConfig)
        rdsHttpEndpointConfig = rdsHttpEndpointConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a relational database data source configuration.
    public struct RelationalDatabaseDataSourceConfig: Swift.Equatable {
        /// Amazon RDS HTTP endpoint settings.
        public var rdsHttpEndpointConfig: AppSyncClientTypes.RdsHttpEndpointConfig?
        /// Source type for the relational database.
        ///
        /// * RDS_HTTP_ENDPOINT: The relational database source type is an Amazon Relational Database Service (Amazon RDS) HTTP endpoint.
        public var relationalDatabaseSourceType: AppSyncClientTypes.RelationalDatabaseSourceType?

        public init (
            rdsHttpEndpointConfig: AppSyncClientTypes.RdsHttpEndpointConfig? = nil,
            relationalDatabaseSourceType: AppSyncClientTypes.RelationalDatabaseSourceType? = nil
        )
        {
            self.rdsHttpEndpointConfig = rdsHttpEndpointConfig
            self.relationalDatabaseSourceType = relationalDatabaseSourceType
        }
    }

}

extension AppSyncClientTypes {
    public enum RelationalDatabaseSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rdsHttpEndpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationalDatabaseSourceType] {
            return [
                .rdsHttpEndpoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rdsHttpEndpoint: return "RDS_HTTP_ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelationalDatabaseSourceType(rawValue: rawValue) ?? RelationalDatabaseSourceType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.Resolver: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case dataSourceName
        case fieldName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case resolverArn
        case responseMappingTemplate
        case syncConfig
        case typeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingConfig = cachingConfig {
            try encodeContainer.encode(cachingConfig, forKey: .cachingConfig)
        }
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let fieldName = fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let kind = kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let pipelineConfig = pipelineConfig {
            try encodeContainer.encode(pipelineConfig, forKey: .pipelineConfig)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let resolverArn = resolverArn {
            try encodeContainer.encode(resolverArn, forKey: .resolverArn)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let resolverArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverArn)
        resolverArn = resolverArnDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let kindDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ResolverKind.self, forKey: .kind)
        kind = kindDecoded
        let pipelineConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.PipelineConfig.self, forKey: .pipelineConfig)
        pipelineConfig = pipelineConfigDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let cachingConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CachingConfig.self, forKey: .cachingConfig)
        cachingConfig = cachingConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a resolver.
    public struct Resolver: Swift.Equatable {
        /// The caching configuration for the resolver.
        public var cachingConfig: AppSyncClientTypes.CachingConfig?
        /// The resolver data source name.
        public var dataSourceName: Swift.String?
        /// The resolver field name.
        public var fieldName: Swift.String?
        /// The resolver type.
        ///
        /// * UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.
        ///
        /// * PIPELINE: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of Function objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.
        public var kind: AppSyncClientTypes.ResolverKind?
        /// The PipelineConfig.
        public var pipelineConfig: AppSyncClientTypes.PipelineConfig?
        /// The request mapping template.
        public var requestMappingTemplate: Swift.String?
        /// The resolver Amazon Resource Name (ARN).
        public var resolverArn: Swift.String?
        /// The response mapping template.
        public var responseMappingTemplate: Swift.String?
        /// The SyncConfig for a resolver attached to a versioned data source.
        public var syncConfig: AppSyncClientTypes.SyncConfig?
        /// The resolver type name.
        public var typeName: Swift.String?

        public init (
            cachingConfig: AppSyncClientTypes.CachingConfig? = nil,
            dataSourceName: Swift.String? = nil,
            fieldName: Swift.String? = nil,
            kind: AppSyncClientTypes.ResolverKind? = nil,
            pipelineConfig: AppSyncClientTypes.PipelineConfig? = nil,
            requestMappingTemplate: Swift.String? = nil,
            resolverArn: Swift.String? = nil,
            responseMappingTemplate: Swift.String? = nil,
            syncConfig: AppSyncClientTypes.SyncConfig? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.cachingConfig = cachingConfig
            self.dataSourceName = dataSourceName
            self.fieldName = fieldName
            self.kind = kind
            self.pipelineConfig = pipelineConfig
            self.requestMappingTemplate = requestMappingTemplate
            self.resolverArn = resolverArn
            self.responseMappingTemplate = responseMappingTemplate
            self.syncConfig = syncConfig
            self.typeName = typeName
        }
    }

}

extension AppSyncClientTypes {
    public enum ResolverKind: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pipeline
        case unit
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverKind] {
            return [
                .pipeline,
                .unit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pipeline: return "PIPELINE"
            case .unit: return "UNIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverKind(rawValue: rawValue) ?? ResolverKind.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum SchemaStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case failed
        case notapplicable
        case processing
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaStatus] {
            return [
                .active,
                .deleting,
                .failed,
                .notapplicable,
                .processing,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .notapplicable: return "NOT_APPLICABLE"
            case .processing: return "PROCESSING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaStatus(rawValue: rawValue) ?? SchemaStatus.sdkUnknown(rawValue)
        }
    }
}

extension StartSchemaCreationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition.base64EncodedString(), forKey: .definition)
        }
    }
}

extension StartSchemaCreationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/schemacreation"
    }
}

public struct StartSchemaCreationInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The schema definition, in GraphQL schema language format.
    /// This member is required.
    public var definition: ClientRuntime.Data?

    public init (
        apiId: Swift.String? = nil,
        definition: ClientRuntime.Data? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
    }
}

struct StartSchemaCreationInputBody: Swift.Equatable {
    let definition: ClientRuntime.Data?
}

extension StartSchemaCreationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension StartSchemaCreationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSchemaCreationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSchemaCreationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSchemaCreationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSchemaCreationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct StartSchemaCreationOutputResponse: Swift.Equatable {
    /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When the schema is in the ACTIVE state, you can add data.
    public var status: AppSyncClientTypes.SchemaStatus?

    public init (
        status: AppSyncClientTypes.SchemaStatus? = nil
    )
    {
        self.status = status
    }
}

struct StartSchemaCreationOutputResponseBody: Swift.Equatable {
    let status: AppSyncClientTypes.SchemaStatus?
}

extension StartSchemaCreationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SchemaStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppSyncClientTypes.SyncConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetection
        case conflictHandler
        case lambdaConflictHandlerConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetection = conflictDetection {
            try encodeContainer.encode(conflictDetection.rawValue, forKey: .conflictDetection)
        }
        if let conflictHandler = conflictHandler {
            try encodeContainer.encode(conflictHandler.rawValue, forKey: .conflictHandler)
        }
        if let lambdaConflictHandlerConfig = lambdaConflictHandlerConfig {
            try encodeContainer.encode(lambdaConflictHandlerConfig, forKey: .lambdaConflictHandlerConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictHandlerDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ConflictHandlerType.self, forKey: .conflictHandler)
        conflictHandler = conflictHandlerDecoded
        let conflictDetectionDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ConflictDetectionType.self, forKey: .conflictDetection)
        conflictDetection = conflictDetectionDecoded
        let lambdaConflictHandlerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaConflictHandlerConfig.self, forKey: .lambdaConflictHandlerConfig)
        lambdaConflictHandlerConfig = lambdaConflictHandlerConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
    public struct SyncConfig: Swift.Equatable {
        /// The Conflict Detection strategy to use.
        ///
        /// * VERSION: Detect conflicts based on object versions for this resolver.
        ///
        /// * NONE: Do not detect conflicts when invoking this resolver.
        public var conflictDetection: AppSyncClientTypes.ConflictDetectionType?
        /// The Conflict Resolution strategy to perform in the event of a conflict.
        ///
        /// * OPTIMISTIC_CONCURRENCY: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.
        ///
        /// * AUTOMERGE: Resolve conflicts with the Automerge conflict resolution strategy.
        ///
        /// * LAMBDA: Resolve conflicts with an Lambda function supplied in the LambdaConflictHandlerConfig.
        public var conflictHandler: AppSyncClientTypes.ConflictHandlerType?
        /// The LambdaConflictHandlerConfig when configuring LAMBDA as the Conflict Handler.
        public var lambdaConflictHandlerConfig: AppSyncClientTypes.LambdaConflictHandlerConfig?

        public init (
            conflictDetection: AppSyncClientTypes.ConflictDetectionType? = nil,
            conflictHandler: AppSyncClientTypes.ConflictHandlerType? = nil,
            lambdaConflictHandlerConfig: AppSyncClientTypes.LambdaConflictHandlerConfig? = nil
        )
        {
            self.conflictDetection = conflictDetection
            self.conflictHandler = conflictHandler
            self.lambdaConflictHandlerConfig = lambdaConflictHandlerConfig
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The GraphqlApi Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A TagMap object.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension AppSyncClientTypes {
    /// Describes a type.
    public struct ModelType: Swift.Equatable {
        /// The type Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The type definition.
        public var definition: Swift.String?
        /// The type description.
        public var description: Swift.String?
        /// The type format: SDL or JSON.
        public var format: AppSyncClientTypes.TypeDefinitionFormat?
        /// The type name.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            definition: Swift.String? = nil,
            description: Swift.String? = nil,
            format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.definition = definition
            self.description = description
            self.format = format
            self.name = name
        }
    }

}

extension AppSyncClientTypes {
    public enum TypeDefinitionFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case sdl
        case sdkUnknown(Swift.String)

        public static var allCases: [TypeDefinitionFormat] {
            return [
                .json,
                .sdl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .sdl: return "SDL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TypeDefinitionFormat(rawValue: rawValue) ?? TypeDefinitionFormat.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You aren't authorized to perform this operation.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The GraphqlApi Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of TagKey objects.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateApiCacheInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case ttl
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCachingBehavior = apiCachingBehavior {
            try encodeContainer.encode(apiCachingBehavior.rawValue, forKey: .apiCachingBehavior)
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateApiCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches/update"
    }
}

/// Represents the input of a UpdateApiCache operation.
public struct UpdateApiCacheInput: Swift.Equatable {
    /// Caching behavior.
    ///
    /// * FULL_REQUEST_CACHING: All requests are fully cached.
    ///
    /// * PER_RESOLVER_CACHING: Individual resolvers that you specify are cached.
    /// This member is required.
    public var apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// TTL in seconds for cache entries. Valid values are 1–3,600 seconds.
    /// This member is required.
    public var ttl: Swift.Int
    /// The cache instance type. Valid values are
    ///
    /// * SMALL
    ///
    /// * MEDIUM
    ///
    /// * LARGE
    ///
    /// * XLARGE
    ///
    /// * LARGE_2X
    ///
    /// * LARGE_4X
    ///
    /// * LARGE_8X (not available in all regions)
    ///
    /// * LARGE_12X
    ///
    ///
    /// Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used. The following legacy instance types are available, but their use is discouraged:
    ///
    /// * T2_SMALL: A t2.small instance type.
    ///
    /// * T2_MEDIUM: A t2.medium instance type.
    ///
    /// * R4_LARGE: A r4.large instance type.
    ///
    /// * R4_XLARGE: A r4.xlarge instance type.
    ///
    /// * R4_2XLARGE: A r4.2xlarge instance type.
    ///
    /// * R4_4XLARGE: A r4.4xlarge instance type.
    ///
    /// * R4_8XLARGE: A r4.8xlarge instance type.
    /// This member is required.
    public var type: AppSyncClientTypes.ApiCacheType?

    public init (
        apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior? = nil,
        apiId: Swift.String? = nil,
        ttl: Swift.Int = 0,
        type: AppSyncClientTypes.ApiCacheType? = nil
    )
    {
        self.apiCachingBehavior = apiCachingBehavior
        self.apiId = apiId
        self.ttl = ttl
        self.type = type
    }
}

struct UpdateApiCacheInputBody: Swift.Equatable {
    let ttl: Swift.Int
    let apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    let type: AppSyncClientTypes.ApiCacheType?
}

extension UpdateApiCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case ttl
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decode(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let apiCachingBehaviorDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCachingBehavior.self, forKey: .apiCachingBehavior)
        apiCachingBehavior = apiCachingBehaviorDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCacheType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UpdateApiCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiCacheOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApiCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiCache = output.apiCache
        } else {
            self.apiCache = nil
        }
    }
}

/// Represents the output of a UpdateApiCache operation.
public struct UpdateApiCacheOutputResponse: Swift.Equatable {
    /// The ApiCache object.
    public var apiCache: AppSyncClientTypes.ApiCache?

    public init (
        apiCache: AppSyncClientTypes.ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

struct UpdateApiCacheOutputResponseBody: Swift.Equatable {
    let apiCache: AppSyncClientTypes.ApiCache?
}

extension UpdateApiCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCache
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCacheDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCache.self, forKey: .apiCache)
        apiCache = apiCacheDecoded
    }
}

extension UpdateApiKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expires
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if expires != 0 {
            try encodeContainer.encode(expires, forKey: .expires)
        }
    }
}

extension UpdateApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/apikeys/\(id.urlPercentEncoding())"
    }
}

public struct UpdateApiKeyInput: Swift.Equatable {
    /// The ID for the GraphQL API.
    /// This member is required.
    public var apiId: Swift.String?
    /// A description of the purpose of the API key.
    public var description: Swift.String?
    /// From the update time, the time after which the API key expires. The date is represented as seconds since the epoch. For more information, see .
    public var expires: Swift.Int
    /// The API key ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        expires: Swift.Int = 0,
        id: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.expires = expires
        self.id = id
    }
}

struct UpdateApiKeyInputBody: Swift.Equatable {
    let description: Swift.String?
    let expires: Swift.Int
}

extension UpdateApiKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expires
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expiresDecoded = try containerValues.decode(Swift.Int.self, forKey: .expires)
        expires = expiresDecoded
    }
}

extension UpdateApiKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApiKeyValidityOutOfBoundsException" : self = .apiKeyValidityOutOfBoundsException(try ApiKeyValidityOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiKeyOutputError: Swift.Error, Swift.Equatable {
    case apiKeyValidityOutOfBoundsException(ApiKeyValidityOutOfBoundsException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApiKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKey = output.apiKey
        } else {
            self.apiKey = nil
        }
    }
}

public struct UpdateApiKeyOutputResponse: Swift.Equatable {
    /// The API key.
    public var apiKey: AppSyncClientTypes.ApiKey?

    public init (
        apiKey: AppSyncClientTypes.ApiKey? = nil
    )
    {
        self.apiKey = apiKey
    }
}

struct UpdateApiKeyOutputResponseBody: Swift.Equatable {
    let apiKey: AppSyncClientTypes.ApiKey?
}

extension UpdateApiKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiKey.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

extension UpdateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dynamodbConfig = dynamodbConfig {
            try encodeContainer.encode(dynamodbConfig, forKey: .dynamodbConfig)
        }
        if let elasticsearchConfig = elasticsearchConfig {
            try encodeContainer.encode(elasticsearchConfig, forKey: .elasticsearchConfig)
        }
        if let httpConfig = httpConfig {
            try encodeContainer.encode(httpConfig, forKey: .httpConfig)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let openSearchServiceConfig = openSearchServiceConfig {
            try encodeContainer.encode(openSearchServiceConfig, forKey: .openSearchServiceConfig)
        }
        if let relationalDatabaseConfig = relationalDatabaseConfig {
            try encodeContainer.encode(relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources/\(name.urlPercentEncoding())"
    }
}

public struct UpdateDataSourceInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The new description for the data source.
    public var description: Swift.String?
    /// The new Amazon DynamoDB configuration.
    public var dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    /// The new OpenSearch configuration. As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. Instead, use [UpdateDataSourceRequest$openSearchServiceConfig] to update an OpenSearch data source.
    public var elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    /// The new HTTP endpoint configuration.
    public var httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    /// The new Lambda configuration.
    public var lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    /// The new name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The new OpenSearch configuration.
    public var openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    /// The new relational database configuration.
    public var relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
    /// The new service role Amazon Resource Name (ARN) for the data source.
    public var serviceRoleArn: Swift.String?
    /// The new data source type.
    /// This member is required.
    public var type: AppSyncClientTypes.DataSourceType?

    public init (
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig? = nil,
        elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig? = nil,
        httpConfig: AppSyncClientTypes.HttpDataSourceConfig? = nil,
        lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig? = nil,
        name: Swift.String? = nil,
        openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig? = nil,
        relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig? = nil,
        serviceRoleArn: Swift.String? = nil,
        type: AppSyncClientTypes.DataSourceType? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.dynamodbConfig = dynamodbConfig
        self.elasticsearchConfig = elasticsearchConfig
        self.httpConfig = httpConfig
        self.lambdaConfig = lambdaConfig
        self.name = name
        self.openSearchServiceConfig = openSearchServiceConfig
        self.relationalDatabaseConfig = relationalDatabaseConfig
        self.serviceRoleArn = serviceRoleArn
        self.type = type
    }
}

struct UpdateDataSourceInputBody: Swift.Equatable {
    let description: Swift.String?
    let type: AppSyncClientTypes.DataSourceType?
    let serviceRoleArn: Swift.String?
    let dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    let lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    let elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    let openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    let httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    let relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
}

extension UpdateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let dynamodbConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DynamodbDataSourceConfig.self, forKey: .dynamodbConfig)
        dynamodbConfig = dynamodbConfigDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaDataSourceConfig.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let elasticsearchConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ElasticsearchDataSourceConfig.self, forKey: .elasticsearchConfig)
        elasticsearchConfig = elasticsearchConfigDecoded
        let openSearchServiceConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenSearchServiceDataSourceConfig.self, forKey: .openSearchServiceConfig)
        openSearchServiceConfig = openSearchServiceConfigDecoded
        let httpConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.HttpDataSourceConfig.self, forKey: .httpConfig)
        httpConfig = httpConfigDecoded
        let relationalDatabaseConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RelationalDatabaseDataSourceConfig.self, forKey: .relationalDatabaseConfig)
        relationalDatabaseConfig = relationalDatabaseConfigDecoded
    }
}

extension UpdateDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct UpdateDataSourceOutputResponse: Swift.Equatable {
    /// The updated DataSource object.
    public var dataSource: AppSyncClientTypes.DataSource?

    public init (
        dataSource: AppSyncClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct UpdateDataSourceOutputResponseBody: Swift.Equatable {
    let dataSource: AppSyncClientTypes.DataSource?
}

extension UpdateDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

extension UpdateDomainNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())"
    }
}

public struct UpdateDomainNameInput: Swift.Equatable {
    /// A description of the DomainName.
    public var description: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        description: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.description = description
        self.domainName = domainName
    }
}

struct UpdateDomainNameInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateDomainNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDomainNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainNameOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainNameConfig = output.domainNameConfig
        } else {
            self.domainNameConfig = nil
        }
    }
}

public struct UpdateDomainNameOutputResponse: Swift.Equatable {
    /// The configuration for the DomainName.
    public var domainNameConfig: AppSyncClientTypes.DomainNameConfig?

    public init (
        domainNameConfig: AppSyncClientTypes.DomainNameConfig? = nil
    )
    {
        self.domainNameConfig = domainNameConfig
    }
}

struct UpdateDomainNameOutputResponseBody: Swift.Equatable {
    let domainNameConfig: AppSyncClientTypes.DomainNameConfig?
}

extension UpdateDomainNameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNameConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DomainNameConfig.self, forKey: .domainNameConfig)
        domainNameConfig = domainNameConfigDecoded
    }
}

extension UpdateFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceName
        case description
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

extension UpdateFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let functionId = functionId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())"
    }
}

public struct UpdateFunctionInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The FunctionDataSource name.
    /// This member is required.
    public var dataSourceName: Swift.String?
    /// The Function description.
    public var description: Swift.String?
    /// The function ID.
    /// This member is required.
    public var functionId: Swift.String?
    /// The version of the request mapping template. Currently, the supported value is 2018-05-29.
    /// This member is required.
    public var functionVersion: Swift.String?
    /// The Function name.
    /// This member is required.
    public var name: Swift.String?
    /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
    public var requestMappingTemplate: Swift.String?
    /// The Function request mapping template.
    public var responseMappingTemplate: Swift.String?
    /// Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
    public var syncConfig: AppSyncClientTypes.SyncConfig?

    public init (
        apiId: Swift.String? = nil,
        dataSourceName: Swift.String? = nil,
        description: Swift.String? = nil,
        functionId: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil
    )
    {
        self.apiId = apiId
        self.dataSourceName = dataSourceName
        self.description = description
        self.functionId = functionId
        self.functionVersion = functionVersion
        self.name = name
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
    }
}

struct UpdateFunctionInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let dataSourceName: Swift.String?
    let requestMappingTemplate: Swift.String?
    let responseMappingTemplate: Swift.String?
    let functionVersion: Swift.String?
    let syncConfig: AppSyncClientTypes.SyncConfig?
}

extension UpdateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceName
        case description
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
    }
}

extension UpdateFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functionConfiguration = output.functionConfiguration
        } else {
            self.functionConfiguration = nil
        }
    }
}

public struct UpdateFunctionOutputResponse: Swift.Equatable {
    /// The Function object.
    public var functionConfiguration: AppSyncClientTypes.FunctionConfiguration?

    public init (
        functionConfiguration: AppSyncClientTypes.FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

struct UpdateFunctionOutputResponseBody: Swift.Equatable {
    let functionConfiguration: AppSyncClientTypes.FunctionConfiguration?
}

extension UpdateFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
    }
}

extension UpdateGraphqlApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case name
        case openIDConnectConfig
        case userPoolConfig
        case xrayEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthenticationProviders = additionalAuthenticationProviders {
            var additionalAuthenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthenticationProviders)
            for additionalauthenticationproviders0 in additionalAuthenticationProviders {
                try additionalAuthenticationProvidersContainer.encode(additionalauthenticationproviders0)
            }
        }
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let lambdaAuthorizerConfig = lambdaAuthorizerConfig {
            try encodeContainer.encode(lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
        }
        if let logConfig = logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openIDConnectConfig = openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let userPoolConfig = userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
        if xrayEnabled != false {
            try encodeContainer.encode(xrayEnabled, forKey: .xrayEnabled)
        }
    }
}

extension UpdateGraphqlApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())"
    }
}

public struct UpdateGraphqlApiInput: Swift.Equatable {
    /// A list of additional authentication providers for the GraphqlApi API.
    public var additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The new authentication type for the GraphqlApi object.
    public var authenticationType: AppSyncClientTypes.AuthenticationType?
    /// Configuration for Lambda function authorization.
    public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
    /// The Amazon CloudWatch Logs configuration for the GraphqlApi object.
    public var logConfig: AppSyncClientTypes.LogConfig?
    /// The new name for the GraphqlApi object.
    /// This member is required.
    public var name: Swift.String?
    /// The OpenID Connect configuration for the GraphqlApi object.
    public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    /// The new Amazon Cognito user pool configuration for the ~GraphqlApi object.
    public var userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    /// A flag indicating whether to use X-Ray tracing for the GraphqlApi.
    public var xrayEnabled: Swift.Bool

    public init (
        additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil,
        apiId: Swift.String? = nil,
        authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
        lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
        logConfig: AppSyncClientTypes.LogConfig? = nil,
        name: Swift.String? = nil,
        openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
        userPoolConfig: AppSyncClientTypes.UserPoolConfig? = nil,
        xrayEnabled: Swift.Bool = false
    )
    {
        self.additionalAuthenticationProviders = additionalAuthenticationProviders
        self.apiId = apiId
        self.authenticationType = authenticationType
        self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
        self.logConfig = logConfig
        self.name = name
        self.openIDConnectConfig = openIDConnectConfig
        self.userPoolConfig = userPoolConfig
        self.xrayEnabled = xrayEnabled
    }
}

struct UpdateGraphqlApiInputBody: Swift.Equatable {
    let name: Swift.String?
    let logConfig: AppSyncClientTypes.LogConfig?
    let authenticationType: AppSyncClientTypes.AuthenticationType?
    let userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    let openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    let additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    let xrayEnabled: Swift.Bool
    let lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
}

extension UpdateGraphqlApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case name
        case openIDConnectConfig
        case userPoolConfig
        case xrayEnabled
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LogConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.UserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let additionalAuthenticationProvidersContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.AdditionalAuthenticationProvider?].self, forKey: .additionalAuthenticationProviders)
        var additionalAuthenticationProvidersDecoded0:[AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil
        if let additionalAuthenticationProvidersContainer = additionalAuthenticationProvidersContainer {
            additionalAuthenticationProvidersDecoded0 = [AppSyncClientTypes.AdditionalAuthenticationProvider]()
            for structure0 in additionalAuthenticationProvidersContainer {
                if let structure0 = structure0 {
                    additionalAuthenticationProvidersDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthenticationProviders = additionalAuthenticationProvidersDecoded0
        let xrayEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .xrayEnabled)
        xrayEnabled = xrayEnabledDecoded
        let lambdaAuthorizerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaAuthorizerConfig.self, forKey: .lambdaAuthorizerConfig)
        lambdaAuthorizerConfig = lambdaAuthorizerConfigDecoded
    }
}

extension UpdateGraphqlApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGraphqlApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGraphqlApiOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGraphqlApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateGraphqlApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.graphqlApi = output.graphqlApi
        } else {
            self.graphqlApi = nil
        }
    }
}

public struct UpdateGraphqlApiOutputResponse: Swift.Equatable {
    /// The updated GraphqlApi object.
    public var graphqlApi: AppSyncClientTypes.GraphqlApi?

    public init (
        graphqlApi: AppSyncClientTypes.GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

struct UpdateGraphqlApiOutputResponseBody: Swift.Equatable {
    let graphqlApi: AppSyncClientTypes.GraphqlApi?
}

extension UpdateGraphqlApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphqlApi
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApiDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphqlApi.self, forKey: .graphqlApi)
        graphqlApi = graphqlApiDecoded
    }
}

extension UpdateResolverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case dataSourceName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingConfig = cachingConfig {
            try encodeContainer.encode(cachingConfig, forKey: .cachingConfig)
        }
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let kind = kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let pipelineConfig = pipelineConfig {
            try encodeContainer.encode(pipelineConfig, forKey: .pipelineConfig)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

extension UpdateResolverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        guard let fieldName = fieldName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers/\(fieldName.urlPercentEncoding())"
    }
}

public struct UpdateResolverInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The caching configuration for the resolver.
    public var cachingConfig: AppSyncClientTypes.CachingConfig?
    /// The new data source name.
    public var dataSourceName: Swift.String?
    /// The new field name.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The resolver type.
    ///
    /// * UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.
    ///
    /// * PIPELINE: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of Function objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.
    public var kind: AppSyncClientTypes.ResolverKind?
    /// The PipelineConfig.
    public var pipelineConfig: AppSyncClientTypes.PipelineConfig?
    /// The new request mapping template. A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL). VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.
    public var requestMappingTemplate: Swift.String?
    /// The new response mapping template.
    public var responseMappingTemplate: Swift.String?
    /// The SyncConfig for a resolver attached to a versioned data source.
    public var syncConfig: AppSyncClientTypes.SyncConfig?
    /// The new type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        cachingConfig: AppSyncClientTypes.CachingConfig? = nil,
        dataSourceName: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        kind: AppSyncClientTypes.ResolverKind? = nil,
        pipelineConfig: AppSyncClientTypes.PipelineConfig? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.cachingConfig = cachingConfig
        self.dataSourceName = dataSourceName
        self.fieldName = fieldName
        self.kind = kind
        self.pipelineConfig = pipelineConfig
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
        self.typeName = typeName
    }
}

struct UpdateResolverInputBody: Swift.Equatable {
    let dataSourceName: Swift.String?
    let requestMappingTemplate: Swift.String?
    let responseMappingTemplate: Swift.String?
    let kind: AppSyncClientTypes.ResolverKind?
    let pipelineConfig: AppSyncClientTypes.PipelineConfig?
    let syncConfig: AppSyncClientTypes.SyncConfig?
    let cachingConfig: AppSyncClientTypes.CachingConfig?
}

extension UpdateResolverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case dataSourceName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let kindDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ResolverKind.self, forKey: .kind)
        kind = kindDecoded
        let pipelineConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.PipelineConfig.self, forKey: .pipelineConfig)
        pipelineConfig = pipelineConfigDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let cachingConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CachingConfig.self, forKey: .cachingConfig)
        cachingConfig = cachingConfigDecoded
    }
}

extension UpdateResolverOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResolverOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResolverOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResolverOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateResolverOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolver = output.resolver
        } else {
            self.resolver = nil
        }
    }
}

public struct UpdateResolverOutputResponse: Swift.Equatable {
    /// The updated Resolver object.
    public var resolver: AppSyncClientTypes.Resolver?

    public init (
        resolver: AppSyncClientTypes.Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

struct UpdateResolverOutputResponseBody: Swift.Equatable {
    let resolver: AppSyncClientTypes.Resolver?
}

extension UpdateResolverOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolver
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.Resolver.self, forKey: .resolver)
        resolver = resolverDecoded
    }
}

extension UpdateTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case format
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
    }
}

extension UpdateTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())"
    }
}

public struct UpdateTypeInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The new definition.
    public var definition: Swift.String?
    /// The new type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The new type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        apiId: Swift.String? = nil,
        definition: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
        self.format = format
        self.typeName = typeName
    }
}

struct UpdateTypeInputBody: Swift.Equatable {
    let definition: Swift.String?
    let format: AppSyncClientTypes.TypeDefinitionFormat?
}

extension UpdateTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case format
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.TypeDefinitionFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension UpdateTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTypeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.type = output.type
        } else {
            self.type = nil
        }
    }
}

public struct UpdateTypeOutputResponse: Swift.Equatable {
    /// The updated Type object.
    public var type: AppSyncClientTypes.ModelType?

    public init (
        type: AppSyncClientTypes.ModelType? = nil
    )
    {
        self.type = type
    }
}

struct UpdateTypeOutputResponseBody: Swift.Equatable {
    let type: AppSyncClientTypes.ModelType?
}

extension UpdateTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AppSyncClientTypes.UserPoolConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIdClientRegex
        case awsRegion
        case defaultAction
        case userPoolId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIdClientRegex = appIdClientRegex {
            try encodeContainer.encode(appIdClientRegex, forKey: .appIdClientRegex)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let defaultAction = defaultAction {
            try encodeContainer.encode(defaultAction.rawValue, forKey: .defaultAction)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DefaultAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let appIdClientRegexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appIdClientRegex)
        appIdClientRegex = appIdClientRegexDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an Amazon Cognito user pool configuration.
    public struct UserPoolConfig: Swift.Equatable {
        /// A regular expression for validating the incoming Amazon Cognito user pool app client ID.
        public var appIdClientRegex: Swift.String?
        /// The Amazon Web Services Region in which the user pool was created.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The action that you want your GraphQL API to take when a request that uses Amazon Cognito user pool authentication doesn't match the Amazon Cognito user pool configuration.
        /// This member is required.
        public var defaultAction: AppSyncClientTypes.DefaultAction?
        /// The user pool ID.
        /// This member is required.
        public var userPoolId: Swift.String?

        public init (
            appIdClientRegex: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            defaultAction: AppSyncClientTypes.DefaultAction? = nil,
            userPoolId: Swift.String? = nil
        )
        {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.defaultAction = defaultAction
            self.userPoolId = userPoolId
        }
    }

}
