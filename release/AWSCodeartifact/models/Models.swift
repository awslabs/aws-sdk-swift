// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation did not succeed because of an unauthorized access attempt.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeartifactClientTypes.AssetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hashes
        case name
        case size
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashes = hashes {
            var hashesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .hashes)
            for (dictKey0, assethashes0) in hashes {
                try hashesContainer.encode(assethashes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let hashesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .hashes)
        var hashesDecoded0: [Swift.String:Swift.String]? = nil
        if let hashesContainer = hashesContainer {
            hashesDecoded0 = [Swift.String:Swift.String]()
            for (key0, hashvalue0) in hashesContainer {
                if let hashvalue0 = hashvalue0 {
                    hashesDecoded0?[key0] = hashvalue0
                }
            }
        }
        hashes = hashesDecoded0
    }
}

extension CodeartifactClientTypes {
    /// Contains details about a package version asset.
    public struct AssetSummary: Swift.Equatable {
        /// The hashes of the asset.
        public var hashes: [Swift.String:Swift.String]?
        /// The name of the asset.
        /// This member is required.
        public var name: Swift.String?
        /// The size of the asset.
        public var size: Swift.Int?

        public init (
            hashes: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            size: Swift.Int? = nil
        )
        {
            self.hashes = hashes
            self.name = name
            self.size = size
        }
    }

}

extension AssociateExternalConnectionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let externalConnection = externalConnection {
            let externalConnectionQueryItem = ClientRuntime.URLQueryItem(name: "external-connection".urlPercentEncoding(), value: Swift.String(externalConnection).urlPercentEncoding())
            items.append(externalConnectionQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension AssociateExternalConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository/external-connection"
    }
}

public struct AssociateExternalConnectionInput: Swift.Equatable {
    /// The name of the domain that contains the repository.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The name of the external connection to add to the repository. The following values are supported:
    ///
    /// * public:npmjs - for the npm public repository.
    ///
    /// * public:pypi - for the Python Package Index.
    ///
    /// * public:maven-central - for Maven Central.
    ///
    /// * public:maven-googleandroid - for the Google Android repository.
    ///
    /// * public:maven-gradleplugins - for the Gradle plugins repository.
    ///
    /// * public:maven-commonsware - for the CommonsWare Android repository.
    /// This member is required.
    public var externalConnection: Swift.String?
    /// The name of the repository to which the external connection is added.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        externalConnection: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.externalConnection = externalConnection
        self.repository = repository
    }
}

struct AssociateExternalConnectionInputBody: Swift.Equatable {
}

extension AssociateExternalConnectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateExternalConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateExternalConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateExternalConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateExternalConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateExternalConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct AssociateExternalConnectionOutputResponse: Swift.Equatable {
    /// Information about the connected repository after processing the request.
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init (
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct AssociateExternalConnectionOutputResponseBody: Swift.Equatable {
    let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension AssociateExternalConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation did not succeed because prerequisites are not met.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of AWS resource.
    public var resourceType: CodeartifactClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CodeartifactClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: CodeartifactClientTypes.ResourceType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CopyPackageVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowOverwrite
        case includeFromUpstream
        case versionRevisions
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowOverwrite = allowOverwrite {
            try encodeContainer.encode(allowOverwrite, forKey: .allowOverwrite)
        }
        if let includeFromUpstream = includeFromUpstream {
            try encodeContainer.encode(includeFromUpstream, forKey: .includeFromUpstream)
        }
        if let versionRevisions = versionRevisions {
            var versionRevisionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .versionRevisions)
            for (dictKey0, packageversionrevisionmap0) in versionRevisions {
                try versionRevisionsContainer.encode(packageversionrevisionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversionlist0 in versions {
                try versionsContainer.encode(packageversionlist0)
            }
        }
    }
}

extension CopyPackageVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let sourceRepository = sourceRepository {
            let sourceRepositoryQueryItem = ClientRuntime.URLQueryItem(name: "source-repository".urlPercentEncoding(), value: Swift.String(sourceRepository).urlPercentEncoding())
            items.append(sourceRepositoryQueryItem)
        }
        if let destinationRepository = destinationRepository {
            let destinationRepositoryQueryItem = ClientRuntime.URLQueryItem(name: "destination-repository".urlPercentEncoding(), value: Swift.String(destinationRepository).urlPercentEncoding())
            items.append(destinationRepositoryQueryItem)
        }
        if let package = package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension CopyPackageVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/versions/copy"
    }
}

public struct CopyPackageVersionsInput: Swift.Equatable {
    /// Set to true to overwrite a package version that already exists in the destination repository. If set to false and the package version already exists in the destination repository, the package version is returned in the failedVersions field of the response with an ALREADY_EXISTS error code.
    public var allowOverwrite: Swift.Bool?
    /// The name of the repository into which package versions are copied.
    /// This member is required.
    public var destinationRepository: Swift.String?
    /// The name of the domain that contains the source and destination repositories.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The format of the package that is copied. The valid package types are:
    ///
    /// * npm: A Node Package Manager (npm) package.
    ///
    /// * pypi: A Python Package Index (PyPI) package.
    ///
    /// * maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// Set to true to copy packages from repositories that are upstream from the source repository to the destination repository. The default setting is false. For more information, see [Working with upstream repositories](https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html).
    public var includeFromUpstream: Swift.Bool?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The name of the package that is copied.
    /// This member is required.
    public var package: Swift.String?
    /// The name of the repository that contains the package versions to copy.
    /// This member is required.
    public var sourceRepository: Swift.String?
    /// A list of key-value pairs. The keys are package versions and the values are package version revisions. A CopyPackageVersion operation succeeds if the specified versions in the source repository match the specified package version revision. You must specify versions or versionRevisions. You cannot specify both.
    public var versionRevisions: [Swift.String:Swift.String]?
    /// The versions of the package to copy. You must specify versions or versionRevisions. You cannot specify both.
    public var versions: [Swift.String]?

    public init (
        allowOverwrite: Swift.Bool? = nil,
        destinationRepository: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        includeFromUpstream: Swift.Bool? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        sourceRepository: Swift.String? = nil,
        versionRevisions: [Swift.String:Swift.String]? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.allowOverwrite = allowOverwrite
        self.destinationRepository = destinationRepository
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.includeFromUpstream = includeFromUpstream
        self.namespace = namespace
        self.package = package
        self.sourceRepository = sourceRepository
        self.versionRevisions = versionRevisions
        self.versions = versions
    }
}

struct CopyPackageVersionsInputBody: Swift.Equatable {
    let versions: [Swift.String]?
    let versionRevisions: [Swift.String:Swift.String]?
    let allowOverwrite: Swift.Bool?
    let includeFromUpstream: Swift.Bool?
}

extension CopyPackageVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowOverwrite
        case includeFromUpstream
        case versionRevisions
        case versions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let versionRevisionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .versionRevisions)
        var versionRevisionsDecoded0: [Swift.String:Swift.String]? = nil
        if let versionRevisionsContainer = versionRevisionsContainer {
            versionRevisionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, packageversionrevision0) in versionRevisionsContainer {
                if let packageversionrevision0 = packageversionrevision0 {
                    versionRevisionsDecoded0?[key0] = packageversionrevision0
                }
            }
        }
        versionRevisions = versionRevisionsDecoded0
        let allowOverwriteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowOverwrite)
        allowOverwrite = allowOverwriteDecoded
        let includeFromUpstreamDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeFromUpstream)
        includeFromUpstream = includeFromUpstreamDecoded
    }
}

extension CopyPackageVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyPackageVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyPackageVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyPackageVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyPackageVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct CopyPackageVersionsOutputResponse: Swift.Equatable {
    /// A map of package versions that failed to copy and their error codes. The possible error codes are in the PackageVersionError data type. They are:
    ///
    /// * ALREADY_EXISTS
    ///
    /// * MISMATCHED_REVISION
    ///
    /// * MISMATCHED_STATUS
    ///
    /// * NOT_ALLOWED
    ///
    /// * NOT_FOUND
    ///
    /// * SKIPPED
    public var failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
    /// A list of the package versions that were successfully copied to your repository.
    public var successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?

    public init (
        failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil,
        successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct CopyPackageVersionsOutputResponseBody: Swift.Equatable {
    let successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?
    let failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
}

extension CopyPackageVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

extension CreateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKey
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        return items
    }
}

extension CreateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain"
    }
}

public struct CreateDomainInput: Swift.Equatable {
    /// The name of the domain to create. All domain names in an AWS Region that are in the same AWS account must be unique. The domain name is used as the prefix in DNS hostnames. Do not use sensitive information in a domain name because it is publicly discoverable.
    /// This member is required.
    public var domain: Swift.String?
    /// The encryption key for the domain. This is used to encrypt content stored in a domain. An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key alias ARN. To specify an encryptionKey, your IAM role must have kms:DescribeKey and kms:CreateGrant permissions on the encryption key that is used. For more information, see [DescribeKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestSyntax) in the AWS Key Management Service API Reference and [AWS KMS API Permissions Reference](https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html) in the AWS Key Management Service Developer Guide. CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your domain. For more information, see [Using symmetric and asymmetric keys](https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html) in the AWS Key Management Service Developer Guide.
    public var encryptionKey: Swift.String?
    /// One or more tag key-value pairs for the domain.
    public var tags: [CodeartifactClientTypes.Tag]?

    public init (
        domain: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        tags: [CodeartifactClientTypes.Tag]? = nil
    )
    {
        self.domain = domain
        self.encryptionKey = encryptionKey
        self.tags = tags
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    let encryptionKey: Swift.String?
    let tags: [CodeartifactClientTypes.Tag]?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKey
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeartifactClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeartifactClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct CreateDomainOutputResponse: Swift.Equatable {
    /// Contains information about the created domain after processing the request.
    public var domain: CodeartifactClientTypes.DomainDescription?

    public init (
        domain: CodeartifactClientTypes.DomainDescription? = nil
    )
    {
        self.domain = domain
    }
}

struct CreateDomainOutputResponseBody: Swift.Equatable {
    let domain: CodeartifactClientTypes.DomainDescription?
}

extension CreateDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainDescription.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension CreateRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
        case upstreams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let upstreams = upstreams {
            var upstreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .upstreams)
            for upstreamrepositorylist0 in upstreams {
                try upstreamsContainer.encode(upstreamrepositorylist0)
            }
        }
    }
}

extension CreateRepositoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension CreateRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository"
    }
}

public struct CreateRepositoryInput: Swift.Equatable {
    /// A description of the created repository.
    public var description: Swift.String?
    /// The name of the domain that contains the created repository.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The name of the repository to create.
    /// This member is required.
    public var repository: Swift.String?
    /// One or more tag key-value pairs for the repository.
    public var tags: [CodeartifactClientTypes.Tag]?
    /// A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more information, see [Working with upstream repositories](https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html).
    public var upstreams: [CodeartifactClientTypes.UpstreamRepository]?

    public init (
        description: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil,
        tags: [CodeartifactClientTypes.Tag]? = nil,
        upstreams: [CodeartifactClientTypes.UpstreamRepository]? = nil
    )
    {
        self.description = description
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
        self.tags = tags
        self.upstreams = upstreams
    }
}

struct CreateRepositoryInputBody: Swift.Equatable {
    let description: Swift.String?
    let upstreams: [CodeartifactClientTypes.UpstreamRepository]?
    let tags: [CodeartifactClientTypes.Tag]?
}

extension CreateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
        case upstreams
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let upstreamsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.UpstreamRepository?].self, forKey: .upstreams)
        var upstreamsDecoded0:[CodeartifactClientTypes.UpstreamRepository]? = nil
        if let upstreamsContainer = upstreamsContainer {
            upstreamsDecoded0 = [CodeartifactClientTypes.UpstreamRepository]()
            for structure0 in upstreamsContainer {
                if let structure0 = structure0 {
                    upstreamsDecoded0?.append(structure0)
                }
            }
        }
        upstreams = upstreamsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeartifactClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeartifactClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct CreateRepositoryOutputResponse: Swift.Equatable {
    /// Information about the created repository after processing the request.
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init (
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct CreateRepositoryOutputResponseBody: Swift.Equatable {
    let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension CreateRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension DeleteDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        return items
    }
}

extension DeleteDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain"
    }
}

public struct DeleteDomainInput: Swift.Equatable {
    /// The name of the domain to delete.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
}

extension DeleteDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct DeleteDomainOutputResponse: Swift.Equatable {
    /// Contains information about the deleted domain after processing the request.
    public var domain: CodeartifactClientTypes.DomainDescription?

    public init (
        domain: CodeartifactClientTypes.DomainDescription? = nil
    )
    {
        self.domain = domain
    }
}

struct DeleteDomainOutputResponseBody: Swift.Equatable {
    let domain: CodeartifactClientTypes.DomainDescription?
}

extension DeleteDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainDescription.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DeleteDomainPermissionsPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let policyRevision = policyRevision {
            let policyRevisionQueryItem = ClientRuntime.URLQueryItem(name: "policy-revision".urlPercentEncoding(), value: Swift.String(policyRevision).urlPercentEncoding())
            items.append(policyRevisionQueryItem)
        }
        return items
    }
}

extension DeleteDomainPermissionsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain/permissions/policy"
    }
}

public struct DeleteDomainPermissionsPolicyInput: Swift.Equatable {
    /// The name of the domain associated with the resource policy to be deleted.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The current revision of the resource policy to be deleted. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy.
    public var policyRevision: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        policyRevision: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyRevision = policyRevision
    }
}

struct DeleteDomainPermissionsPolicyInputBody: Swift.Equatable {
}

extension DeleteDomainPermissionsPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainPermissionsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainPermissionsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainPermissionsPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainPermissionsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDomainPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DeleteDomainPermissionsPolicyOutputResponse: Swift.Equatable {
    /// Information about the deleted resource policy after processing the request.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init (
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct DeleteDomainPermissionsPolicyOutputResponseBody: Swift.Equatable {
    let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension DeleteDomainPermissionsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension DeletePackageVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedStatus = expectedStatus {
            try encodeContainer.encode(expectedStatus.rawValue, forKey: .expectedStatus)
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversionlist0 in versions {
                try versionsContainer.encode(packageversionlist0)
            }
        }
    }
}

extension DeletePackageVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let package = package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension DeletePackageVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/versions/delete"
    }
}

public struct DeletePackageVersionsInput: Swift.Equatable {
    /// The name of the domain that contains the package to delete.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The expected status of the package version to delete. Valid values are:
    ///
    /// * Published
    ///
    /// * Unfinished
    ///
    /// * Unlisted
    ///
    /// * Archived
    ///
    /// * Disposed
    public var expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
    /// The format of the package versions to delete. The valid values are:
    ///
    /// * npm
    ///
    /// * pypi
    ///
    /// * maven
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The name of the package with the versions to delete.
    /// This member is required.
    public var package: Swift.String?
    /// The name of the repository that contains the package versions to delete.
    /// This member is required.
    public var repository: Swift.String?
    /// An array of strings that specify the versions of the package to delete.
    /// This member is required.
    public var versions: [Swift.String]?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        expectedStatus: CodeartifactClientTypes.PackageVersionStatus? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.expectedStatus = expectedStatus
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.versions = versions
    }
}

struct DeletePackageVersionsInputBody: Swift.Equatable {
    let versions: [Swift.String]?
    let expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
}

extension DeletePackageVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case versions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let expectedStatusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .expectedStatus)
        expectedStatus = expectedStatusDecoded
    }
}

extension DeletePackageVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePackageVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePackageVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePackageVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeletePackageVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct DeletePackageVersionsOutputResponse: Swift.Equatable {
    /// A PackageVersionError object that contains a map of errors codes for the deleted package that failed. The possible error codes are:
    ///
    /// * ALREADY_EXISTS
    ///
    /// * MISMATCHED_REVISION
    ///
    /// * MISMATCHED_STATUS
    ///
    /// * NOT_ALLOWED
    ///
    /// * NOT_FOUND
    ///
    /// * SKIPPED
    public var failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
    /// A list of the package versions that were successfully deleted.
    public var successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?

    public init (
        failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil,
        successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct DeletePackageVersionsOutputResponseBody: Swift.Equatable {
    let successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?
    let failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
}

extension DeletePackageVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

extension DeleteRepositoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension DeleteRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository"
    }
}

public struct DeleteRepositoryInput: Swift.Equatable {
    /// The name of the domain that contains the repository to delete.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The name of the repository to delete.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
    }
}

struct DeleteRepositoryInputBody: Swift.Equatable {
}

extension DeleteRepositoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DeleteRepositoryOutputResponse: Swift.Equatable {
    /// Information about the deleted repository after processing the request.
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init (
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct DeleteRepositoryOutputResponseBody: Swift.Equatable {
    let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension DeleteRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension DeleteRepositoryPermissionsPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let policyRevision = policyRevision {
            let policyRevisionQueryItem = ClientRuntime.URLQueryItem(name: "policy-revision".urlPercentEncoding(), value: Swift.String(policyRevision).urlPercentEncoding())
            items.append(policyRevisionQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension DeleteRepositoryPermissionsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository/permissions/policies"
    }
}

public struct DeleteRepositoryPermissionsPolicyInput: Swift.Equatable {
    /// The name of the domain that contains the repository associated with the resource policy to be deleted.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The revision of the repository's resource policy to be deleted. This revision is used for optimistic locking, which prevents others from accidentally overwriting your changes to the repository's resource policy.
    public var policyRevision: Swift.String?
    /// The name of the repository that is associated with the resource policy to be deleted
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        policyRevision: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyRevision = policyRevision
        self.repository = repository
    }
}

struct DeleteRepositoryPermissionsPolicyInputBody: Swift.Equatable {
}

extension DeleteRepositoryPermissionsPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRepositoryPermissionsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryPermissionsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryPermissionsPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryPermissionsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRepositoryPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DeleteRepositoryPermissionsPolicyOutputResponse: Swift.Equatable {
    /// Information about the deleted policy after processing the request.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init (
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct DeleteRepositoryPermissionsPolicyOutputResponseBody: Swift.Equatable {
    let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension DeleteRepositoryPermissionsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension DescribeDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        return items
    }
}

extension DescribeDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain"
    }
}

public struct DescribeDomainInput: Swift.Equatable {
    /// A string that specifies the name of the requested domain.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
    }
}

struct DescribeDomainInputBody: Swift.Equatable {
}

extension DescribeDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct DescribeDomainOutputResponse: Swift.Equatable {
    /// Information about a domain. A domain is a container for repositories. When you create a domain, it is empty until you add one or more repositories.
    public var domain: CodeartifactClientTypes.DomainDescription?

    public init (
        domain: CodeartifactClientTypes.DomainDescription? = nil
    )
    {
        self.domain = domain
    }
}

struct DescribeDomainOutputResponseBody: Swift.Equatable {
    let domain: CodeartifactClientTypes.DomainDescription?
}

extension DescribeDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainDescription.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DescribePackageVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let package = package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let packageVersion = packageVersion {
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            items.append(packageVersionQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension DescribePackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/version"
    }
}

public struct DescribePackageVersionInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the package version.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A format that specifies the type of the requested package version. The valid values are:
    ///
    /// * npm
    ///
    /// * pypi
    ///
    /// * maven
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The name of the requested package version.
    /// This member is required.
    public var package: Swift.String?
    /// A string that contains the package version (for example, 3.5.2).
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The name of the repository that contains the package version.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct DescribePackageVersionInputBody: Swift.Equatable {
}

extension DescribePackageVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePackageVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePackageVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePackageVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePackageVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePackageVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.packageVersion = output.packageVersion
        } else {
            self.packageVersion = nil
        }
    }
}

public struct DescribePackageVersionOutputResponse: Swift.Equatable {
    /// A [PackageVersionDescription](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionDescription.html) object that contains information about the requested package version.
    /// This member is required.
    public var packageVersion: CodeartifactClientTypes.PackageVersionDescription?

    public init (
        packageVersion: CodeartifactClientTypes.PackageVersionDescription? = nil
    )
    {
        self.packageVersion = packageVersion
    }
}

struct DescribePackageVersionOutputResponseBody: Swift.Equatable {
    let packageVersion: CodeartifactClientTypes.PackageVersionDescription?
}

extension DescribePackageVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionDescription.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
    }
}

extension DescribeRepositoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension DescribeRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository"
    }
}

public struct DescribeRepositoryInput: Swift.Equatable {
    /// The name of the domain that contains the repository to describe.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A string that specifies the name of the requested repository.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
    }
}

struct DescribeRepositoryInputBody: Swift.Equatable {
}

extension DescribeRepositoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DescribeRepositoryOutputResponse: Swift.Equatable {
    /// A RepositoryDescription object that contains the requested repository information.
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init (
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct DescribeRepositoryOutputResponseBody: Swift.Equatable {
    let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension DescribeRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension DisassociateExternalConnectionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let externalConnection = externalConnection {
            let externalConnectionQueryItem = ClientRuntime.URLQueryItem(name: "external-connection".urlPercentEncoding(), value: Swift.String(externalConnection).urlPercentEncoding())
            items.append(externalConnectionQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension DisassociateExternalConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository/external-connection"
    }
}

public struct DisassociateExternalConnectionInput: Swift.Equatable {
    /// The name of the domain that contains the repository from which to remove the external repository.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The name of the external connection to be removed from the repository.
    /// This member is required.
    public var externalConnection: Swift.String?
    /// The name of the repository from which the external connection will be removed.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        externalConnection: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.externalConnection = externalConnection
        self.repository = repository
    }
}

struct DisassociateExternalConnectionInputBody: Swift.Equatable {
}

extension DisassociateExternalConnectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateExternalConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateExternalConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateExternalConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateExternalConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateExternalConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DisassociateExternalConnectionOutputResponse: Swift.Equatable {
    /// The repository associated with the removed external connection.
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init (
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct DisassociateExternalConnectionOutputResponseBody: Swift.Equatable {
    let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension DisassociateExternalConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension DisposePackageVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case versionRevisions
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedStatus = expectedStatus {
            try encodeContainer.encode(expectedStatus.rawValue, forKey: .expectedStatus)
        }
        if let versionRevisions = versionRevisions {
            var versionRevisionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .versionRevisions)
            for (dictKey0, packageversionrevisionmap0) in versionRevisions {
                try versionRevisionsContainer.encode(packageversionrevisionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversionlist0 in versions {
                try versionsContainer.encode(packageversionlist0)
            }
        }
    }
}

extension DisposePackageVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let package = package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension DisposePackageVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/versions/dispose"
    }
}

public struct DisposePackageVersionsInput: Swift.Equatable {
    /// The name of the domain that contains the repository you want to dispose.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The expected status of the package version to dispose. Valid values are:
    ///
    /// * Published
    ///
    /// * Unfinished
    ///
    /// * Unlisted
    ///
    /// * Archived
    ///
    /// * Disposed
    public var expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
    /// A format that specifies the type of package versions you want to dispose. The valid values are:
    ///
    /// * npm
    ///
    /// * pypi
    ///
    /// * maven
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The name of the package with the versions you want to dispose.
    /// This member is required.
    public var package: Swift.String?
    /// The name of the repository that contains the package versions you want to dispose.
    /// This member is required.
    public var repository: Swift.String?
    /// The revisions of the package versions you want to dispose.
    public var versionRevisions: [Swift.String:Swift.String]?
    /// The versions of the package you want to dispose.
    /// This member is required.
    public var versions: [Swift.String]?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        expectedStatus: CodeartifactClientTypes.PackageVersionStatus? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        versionRevisions: [Swift.String:Swift.String]? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.expectedStatus = expectedStatus
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.versionRevisions = versionRevisions
        self.versions = versions
    }
}

struct DisposePackageVersionsInputBody: Swift.Equatable {
    let versions: [Swift.String]?
    let versionRevisions: [Swift.String:Swift.String]?
    let expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
}

extension DisposePackageVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case versionRevisions
        case versions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let versionRevisionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .versionRevisions)
        var versionRevisionsDecoded0: [Swift.String:Swift.String]? = nil
        if let versionRevisionsContainer = versionRevisionsContainer {
            versionRevisionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, packageversionrevision0) in versionRevisionsContainer {
                if let packageversionrevision0 = packageversionrevision0 {
                    versionRevisionsDecoded0?[key0] = packageversionrevision0
                }
            }
        }
        versionRevisions = versionRevisionsDecoded0
        let expectedStatusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .expectedStatus)
        expectedStatus = expectedStatusDecoded
    }
}

extension DisposePackageVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisposePackageVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisposePackageVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisposePackageVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisposePackageVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct DisposePackageVersionsOutputResponse: Swift.Equatable {
    /// A PackageVersionError object that contains a map of errors codes for the disposed package versions that failed. The possible error codes are:
    ///
    /// * ALREADY_EXISTS
    ///
    /// * MISMATCHED_REVISION
    ///
    /// * MISMATCHED_STATUS
    ///
    /// * NOT_ALLOWED
    ///
    /// * NOT_FOUND
    ///
    /// * SKIPPED
    public var failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
    /// A list of the package versions that were successfully disposed.
    public var successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?

    public init (
        failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil,
        successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct DisposePackageVersionsOutputResponseBody: Swift.Equatable {
    let successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?
    let failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
}

extension DisposePackageVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

extension CodeartifactClientTypes.DomainDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assetSizeBytes
        case createdTime
        case encryptionKey
        case name
        case owner
        case repositoryCount
        case s3BucketArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if assetSizeBytes != 0 {
            try encodeContainer.encode(assetSizeBytes, forKey: .assetSizeBytes)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if repositoryCount != 0 {
            try encodeContainer.encode(repositoryCount, forKey: .repositoryCount)
        }
        if let s3BucketArn = s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let repositoryCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .repositoryCount)
        repositoryCount = repositoryCountDecoded
        let assetSizeBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .assetSizeBytes)
        assetSizeBytes = assetSizeBytesDecoded
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
    }
}

extension CodeartifactClientTypes {
    /// Information about a domain. A domain is a container for repositories. When you create a domain, it is empty until you add one or more repositories.
    public struct DomainDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the domain.
        public var arn: Swift.String?
        /// The total size of all assets in the domain.
        public var assetSizeBytes: Swift.Int
        /// A timestamp that represents the date and time the domain was created.
        public var createdTime: ClientRuntime.Date?
        /// The ARN of an AWS Key Management Service (AWS KMS) key associated with a domain.
        public var encryptionKey: Swift.String?
        /// The name of the domain.
        public var name: Swift.String?
        /// The AWS account ID that owns the domain.
        public var owner: Swift.String?
        /// The number of repositories in the domain.
        public var repositoryCount: Swift.Int
        /// The Amazon Resource Name (ARN) of the Amazon S3 bucket that is used to store package assets in the domain.
        public var s3BucketArn: Swift.String?
        /// The current status of a domain. The valid values are
        ///
        /// * Active
        ///
        /// * Deleted
        public var status: CodeartifactClientTypes.DomainStatus?

        public init (
            arn: Swift.String? = nil,
            assetSizeBytes: Swift.Int = 0,
            createdTime: ClientRuntime.Date? = nil,
            encryptionKey: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            repositoryCount: Swift.Int = 0,
            s3BucketArn: Swift.String? = nil,
            status: CodeartifactClientTypes.DomainStatus? = nil
        )
        {
            self.arn = arn
            self.assetSizeBytes = assetSizeBytes
            self.createdTime = createdTime
            self.encryptionKey = encryptionKey
            self.name = name
            self.owner = owner
            self.repositoryCount = repositoryCount
            self.s3BucketArn = s3BucketArn
            self.status = status
        }
    }

}

extension CodeartifactClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .deleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleted: return "Deleted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes.DomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case encryptionKey
        case name
        case owner
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension CodeartifactClientTypes {
    /// Information about a domain, including its name, Amazon Resource Name (ARN), and status. The [ListDomains](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListDomains.html) operation returns a list of DomainSummary objects.
    public struct DomainSummary: Swift.Equatable {
        /// The ARN of the domain.
        public var arn: Swift.String?
        /// A timestamp that contains the date and time the domain was created.
        public var createdTime: ClientRuntime.Date?
        /// The key used to encrypt the domain.
        public var encryptionKey: Swift.String?
        /// The name of the domain.
        public var name: Swift.String?
        /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public var owner: Swift.String?
        /// A string that contains the status of the domain. The valid values are:
        ///
        /// * Active
        ///
        /// * Deleted
        public var status: CodeartifactClientTypes.DomainStatus?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            encryptionKey: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            status: CodeartifactClientTypes.DomainStatus? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.encryptionKey = encryptionKey
            self.name = name
            self.owner = owner
            self.status = status
        }
    }

}

extension CodeartifactClientTypes {
    public enum ExternalConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalConnectionStatus] {
            return [
                .available,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExternalConnectionStatus(rawValue: rawValue) ?? ExternalConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetAuthorizationTokenInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let durationSeconds = durationSeconds {
            let durationSecondsQueryItem = ClientRuntime.URLQueryItem(name: "duration".urlPercentEncoding(), value: Swift.String(durationSeconds).urlPercentEncoding())
            items.append(durationSecondsQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        return items
    }
}

extension GetAuthorizationTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/authorization-token"
    }
}

public struct GetAuthorizationTokenInput: Swift.Equatable {
    /// The name of the domain that is in scope for the generated authorization token.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The time, in seconds, that the generated authorization token is valid. Valid values are 0 and any number between 900 (15 minutes) and 43200 (12 hours). A value of 0 will set the expiration of the authorization token to the same expiration of the user's role's temporary credentials.
    public var durationSeconds: Swift.Int?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        durationSeconds: Swift.Int? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.durationSeconds = durationSeconds
    }
}

struct GetAuthorizationTokenInputBody: Swift.Equatable {
}

extension GetAuthorizationTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizationTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizationTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizationTokenOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizationTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAuthorizationTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorizationToken = output.authorizationToken
            self.expiration = output.expiration
        } else {
            self.authorizationToken = nil
            self.expiration = nil
        }
    }
}

public struct GetAuthorizationTokenOutputResponse: Swift.Equatable {
    /// The returned authentication token.
    public var authorizationToken: Swift.String?
    /// A timestamp that specifies the date and time the authorization token expires.
    public var expiration: ClientRuntime.Date?

    public init (
        authorizationToken: Swift.String? = nil,
        expiration: ClientRuntime.Date? = nil
    )
    {
        self.authorizationToken = authorizationToken
        self.expiration = expiration
    }
}

struct GetAuthorizationTokenOutputResponseBody: Swift.Equatable {
    let authorizationToken: Swift.String?
    let expiration: ClientRuntime.Date?
}

extension GetAuthorizationTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationToken
        case expiration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationToken)
        authorizationToken = authorizationTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension GetDomainPermissionsPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        return items
    }
}

extension GetDomainPermissionsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain/permissions/policy"
    }
}

public struct GetDomainPermissionsPolicyInput: Swift.Equatable {
    /// The name of the domain to which the resource policy is attached.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
    }
}

struct GetDomainPermissionsPolicyInputBody: Swift.Equatable {
}

extension GetDomainPermissionsPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainPermissionsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainPermissionsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainPermissionsPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainPermissionsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDomainPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetDomainPermissionsPolicyOutputResponse: Swift.Equatable {
    /// The returned resource policy.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init (
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetDomainPermissionsPolicyOutputResponseBody: Swift.Equatable {
    let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension GetDomainPermissionsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetPackageVersionAssetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let package = package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let packageVersion = packageVersion {
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            items.append(packageVersionQueryItem)
        }
        if let packageVersionRevision = packageVersionRevision {
            let packageVersionRevisionQueryItem = ClientRuntime.URLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(packageVersionRevision).urlPercentEncoding())
            items.append(packageVersionRevisionQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        if let asset = asset {
            let assetQueryItem = ClientRuntime.URLQueryItem(name: "asset".urlPercentEncoding(), value: Swift.String(asset).urlPercentEncoding())
            items.append(assetQueryItem)
        }
        return items
    }
}

extension GetPackageVersionAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/version/asset"
    }
}

public struct GetPackageVersionAssetInput: Swift.Equatable {
    /// The name of the requested asset.
    /// This member is required.
    public var asset: Swift.String?
    /// The name of the domain that contains the repository that contains the package version with the requested asset.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A format that specifies the type of the package version with the requested asset file. The valid values are:
    ///
    /// * npm
    ///
    /// * pypi
    ///
    /// * maven
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The name of the package that contains the requested asset.
    /// This member is required.
    public var package: Swift.String?
    /// A string that contains the package version (for example, 3.5.2).
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The name of the package version revision that contains the requested asset.
    public var packageVersionRevision: Swift.String?
    /// The repository that contains the package version with the requested asset.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        asset: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        packageVersionRevision: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.asset = asset
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.packageVersionRevision = packageVersionRevision
        self.repository = repository
    }
}

struct GetPackageVersionAssetInputBody: Swift.Equatable {
}

extension GetPackageVersionAssetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPackageVersionAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPackageVersionAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPackageVersionAssetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPackageVersionAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let assetNameHeaderValue = httpResponse.headers.value(for: "X-AssetName") {
            self.assetName = assetNameHeaderValue
        } else {
            self.assetName = nil
        }
        if let packageVersionHeaderValue = httpResponse.headers.value(for: "X-PackageVersion") {
            self.packageVersion = packageVersionHeaderValue
        } else {
            self.packageVersion = nil
        }
        if let packageVersionRevisionHeaderValue = httpResponse.headers.value(for: "X-PackageVersionRevision") {
            self.packageVersionRevision = packageVersionRevisionHeaderValue
        } else {
            self.packageVersionRevision = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader
            self.asset = data
        } else {
            self.asset = nil
        }
    }
}

public struct GetPackageVersionAssetOutputResponse: Swift.Equatable {
    /// The binary file, or asset, that is downloaded.
    public var asset: ClientRuntime.ByteStream?
    /// The name of the asset that is downloaded.
    public var assetName: Swift.String?
    /// A string that contains the package version (for example, 3.5.2).
    public var packageVersion: Swift.String?
    /// The name of the package version revision that contains the downloaded asset.
    public var packageVersionRevision: Swift.String?

    public init (
        asset: ClientRuntime.ByteStream? = nil,
        assetName: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        packageVersionRevision: Swift.String? = nil
    )
    {
        self.asset = asset
        self.assetName = assetName
        self.packageVersion = packageVersion
        self.packageVersionRevision = packageVersionRevision
    }
}

struct GetPackageVersionAssetOutputResponseBody: Swift.Equatable {
    let asset: ClientRuntime.ByteStream?
}

extension GetPackageVersionAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asset
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .asset)
        asset = assetDecoded
    }
}

extension GetPackageVersionReadmeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let package = package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let packageVersion = packageVersion {
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            items.append(packageVersionQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension GetPackageVersionReadmeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/version/readme"
    }
}

public struct GetPackageVersionReadmeInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the package version with the requested readme file.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A format that specifies the type of the package version with the requested readme file. The valid values are:
    ///
    /// * npm
    ///
    /// * pypi
    ///
    /// * maven
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The name of the package version that contains the requested readme file.
    /// This member is required.
    public var package: Swift.String?
    /// A string that contains the package version (for example, 3.5.2).
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The repository that contains the package with the requested readme file.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct GetPackageVersionReadmeInputBody: Swift.Equatable {
}

extension GetPackageVersionReadmeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPackageVersionReadmeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPackageVersionReadmeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPackageVersionReadmeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPackageVersionReadmeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPackageVersionReadmeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.namespace = output.namespace
            self.package = output.package
            self.readme = output.readme
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.format = nil
            self.namespace = nil
            self.package = nil
            self.readme = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct GetPackageVersionReadmeOutputResponse: Swift.Equatable {
    /// The format of the package with the requested readme file. Valid format types are:
    ///
    /// * npm
    ///
    /// * pypi
    ///
    /// * maven
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The name of the package that contains the returned readme file.
    public var package: Swift.String?
    /// The text of the returned readme file.
    public var readme: Swift.String?
    /// The version of the package with the requested readme file.
    public var version: Swift.String?
    /// The current revision associated with the package version.
    public var versionRevision: Swift.String?

    public init (
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        readme: Swift.String? = nil,
        version: Swift.String? = nil,
        versionRevision: Swift.String? = nil
    )
    {
        self.format = format
        self.namespace = namespace
        self.package = package
        self.readme = readme
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct GetPackageVersionReadmeOutputResponseBody: Swift.Equatable {
    let format: CodeartifactClientTypes.PackageFormat?
    let namespace: Swift.String?
    let package: Swift.String?
    let version: Swift.String?
    let versionRevision: Swift.String?
    let readme: Swift.String?
}

extension GetPackageVersionReadmeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case namespace
        case package
        case readme
        case version
        case versionRevision
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let readmeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readme)
        readme = readmeDecoded
    }
}

extension GetRepositoryEndpointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension GetRepositoryEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository/endpoint"
    }
}

public struct GetRepositoryEndpointInput: Swift.Equatable {
    /// The name of the domain that contains the repository.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain that contains the repository. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// Returns which endpoint of a repository to return. A repository has one endpoint for each package format:
    ///
    /// * npm
    ///
    /// * pypi
    ///
    /// * maven
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The name of the repository.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.repository = repository
    }
}

struct GetRepositoryEndpointInputBody: Swift.Equatable {
}

extension GetRepositoryEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRepositoryEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRepositoryEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repositoryEndpoint = output.repositoryEndpoint
        } else {
            self.repositoryEndpoint = nil
        }
    }
}

public struct GetRepositoryEndpointOutputResponse: Swift.Equatable {
    /// A string that specifies the URL of the returned endpoint.
    public var repositoryEndpoint: Swift.String?

    public init (
        repositoryEndpoint: Swift.String? = nil
    )
    {
        self.repositoryEndpoint = repositoryEndpoint
    }
}

struct GetRepositoryEndpointOutputResponseBody: Swift.Equatable {
    let repositoryEndpoint: Swift.String?
}

extension GetRepositoryEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryEndpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryEndpoint)
        repositoryEndpoint = repositoryEndpointDecoded
    }
}

extension GetRepositoryPermissionsPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension GetRepositoryPermissionsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository/permissions/policy"
    }
}

public struct GetRepositoryPermissionsPolicyInput: Swift.Equatable {
    /// The name of the domain containing the repository whose associated resource policy is to be retrieved.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The name of the repository whose associated resource policy is to be retrieved.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
    }
}

struct GetRepositoryPermissionsPolicyInputBody: Swift.Equatable {
}

extension GetRepositoryPermissionsPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRepositoryPermissionsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryPermissionsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryPermissionsPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryPermissionsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRepositoryPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetRepositoryPermissionsPolicyOutputResponse: Swift.Equatable {
    /// The returned resource policy.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init (
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetRepositoryPermissionsPolicyOutputResponseBody: Swift.Equatable {
    let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension GetRepositoryPermissionsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension CodeartifactClientTypes {
    public enum HashAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case md5
        case sha1
        case sha256
        case sha512
        case sdkUnknown(Swift.String)

        public static var allCases: [HashAlgorithm] {
            return [
                .md5,
                .sha1,
                .sha256,
                .sha512,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .md5: return "MD5"
            case .sha1: return "SHA-1"
            case .sha256: return "SHA-256"
            case .sha512: return "SHA-512"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HashAlgorithm(rawValue: rawValue) ?? HashAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation did not succeed because of an error that occurred inside AWS CodeArtifact.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeartifactClientTypes.LicenseInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details of the license data.
    public struct LicenseInfo: Swift.Equatable {
        /// Name of the license.
        public var name: Swift.String?
        /// The URL for license data.
        public var url: Swift.String?

        public init (
            name: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.name = name
            self.url = url
        }
    }

}

extension ListDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domains"
    }
}

public struct ListDomainsInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutputResponse: Swift.Equatable {
    /// The returned list of [DomainSummary](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_DomainSummary.html) objects.
    public var domains: [CodeartifactClientTypes.DomainSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        domains: [CodeartifactClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputResponseBody: Swift.Equatable {
    let domains: [CodeartifactClientTypes.DomainSummary]?
    let nextToken: Swift.String?
}

extension ListDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[CodeartifactClientTypes.DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [CodeartifactClientTypes.DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPackageVersionAssetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let package = package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let packageVersion = packageVersion {
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            items.append(packageVersionQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension ListPackageVersionAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/version/assets"
    }
}

public struct ListPackageVersionAssetsInput: Swift.Equatable {
    /// The name of the domain that contains the repository associated with the package version assets.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The format of the package that contains the returned package version assets. The valid package types are:
    ///
    /// * npm: A Node Package Manager (npm) package.
    ///
    /// * pypi: A Python Package Index (PyPI) package.
    ///
    /// * maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the package that contains the returned package version assets.
    /// This member is required.
    public var package: Swift.String?
    /// A string that contains the package version (for example, 3.5.2).
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The name of the repository that contains the package that contains the returned package version assets.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct ListPackageVersionAssetsInputBody: Swift.Equatable {
}

extension ListPackageVersionAssetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackageVersionAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackageVersionAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackageVersionAssetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackageVersionAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPackageVersionAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assets = output.assets
            self.format = output.format
            self.namespace = output.namespace
            self.nextToken = output.nextToken
            self.package = output.package
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.assets = nil
            self.format = nil
            self.namespace = nil
            self.nextToken = nil
            self.package = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct ListPackageVersionAssetsOutputResponse: Swift.Equatable {
    /// The returned list of [AssetSummary](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_AssetSummary.html) objects.
    public var assets: [CodeartifactClientTypes.AssetSummary]?
    /// The format of the package that contains the returned package version assets.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the package that contains the returned package version assets.
    public var package: Swift.String?
    /// The version of the package associated with the returned assets.
    public var version: Swift.String?
    /// The current revision associated with the package version.
    public var versionRevision: Swift.String?

    public init (
        assets: [CodeartifactClientTypes.AssetSummary]? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        version: Swift.String? = nil,
        versionRevision: Swift.String? = nil
    )
    {
        self.assets = assets
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct ListPackageVersionAssetsOutputResponseBody: Swift.Equatable {
    let format: CodeartifactClientTypes.PackageFormat?
    let namespace: Swift.String?
    let package: Swift.String?
    let version: Swift.String?
    let versionRevision: Swift.String?
    let nextToken: Swift.String?
    let assets: [CodeartifactClientTypes.AssetSummary]?
}

extension ListPackageVersionAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets
        case format
        case namespace
        case nextToken
        case package
        case version
        case versionRevision
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let assetsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.AssetSummary?].self, forKey: .assets)
        var assetsDecoded0:[CodeartifactClientTypes.AssetSummary]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [CodeartifactClientTypes.AssetSummary]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
    }
}

extension ListPackageVersionDependenciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let package = package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let packageVersion = packageVersion {
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            items.append(packageVersionQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension ListPackageVersionDependenciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/version/dependencies"
    }
}

public struct ListPackageVersionDependenciesInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the requested package version dependencies.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The format of the package with the requested dependencies. The valid package types are:
    ///
    /// * npm: A Node Package Manager (npm) package.
    ///
    /// * pypi: A Python Package Index (PyPI) package.
    ///
    /// * maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the package versions' package.
    /// This member is required.
    public var package: Swift.String?
    /// A string that contains the package version (for example, 3.5.2).
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The name of the repository that contains the requested package version.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct ListPackageVersionDependenciesInputBody: Swift.Equatable {
}

extension ListPackageVersionDependenciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackageVersionDependenciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackageVersionDependenciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackageVersionDependenciesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackageVersionDependenciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPackageVersionDependenciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dependencies = output.dependencies
            self.format = output.format
            self.namespace = output.namespace
            self.nextToken = output.nextToken
            self.package = output.package
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.dependencies = nil
            self.format = nil
            self.namespace = nil
            self.nextToken = nil
            self.package = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct ListPackageVersionDependenciesOutputResponse: Swift.Equatable {
    /// The returned list of [PackageDependency](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageDependency.html) objects.
    public var dependencies: [CodeartifactClientTypes.PackageDependency]?
    /// A format that specifies the type of the package that contains the returned dependencies. The valid values are:
    ///
    /// * npm
    ///
    /// * pypi
    ///
    /// * maven
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the package that contains the returned package versions dependencies.
    public var package: Swift.String?
    /// The version of the package that is specified in the request.
    public var version: Swift.String?
    /// The current revision associated with the package version.
    public var versionRevision: Swift.String?

    public init (
        dependencies: [CodeartifactClientTypes.PackageDependency]? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        version: Swift.String? = nil,
        versionRevision: Swift.String? = nil
    )
    {
        self.dependencies = dependencies
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct ListPackageVersionDependenciesOutputResponseBody: Swift.Equatable {
    let format: CodeartifactClientTypes.PackageFormat?
    let namespace: Swift.String?
    let package: Swift.String?
    let version: Swift.String?
    let versionRevision: Swift.String?
    let nextToken: Swift.String?
    let dependencies: [CodeartifactClientTypes.PackageDependency]?
}

extension ListPackageVersionDependenciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencies
        case format
        case namespace
        case nextToken
        case package
        case version
        case versionRevision
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dependenciesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.PackageDependency?].self, forKey: .dependencies)
        var dependenciesDecoded0:[CodeartifactClientTypes.PackageDependency]? = nil
        if let dependenciesContainer = dependenciesContainer {
            dependenciesDecoded0 = [CodeartifactClientTypes.PackageDependency]()
            for structure0 in dependenciesContainer {
                if let structure0 = structure0 {
                    dependenciesDecoded0?.append(structure0)
                }
            }
        }
        dependencies = dependenciesDecoded0
    }
}

extension ListPackageVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let package = package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let sortBy = sortBy {
            let sortByQueryItem = ClientRuntime.URLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        if let status = status {
            let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListPackageVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/versions"
    }
}

public struct ListPackageVersionsInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the returned package versions.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The format of the returned packages. The valid package types are:
    ///
    /// * npm: A Node Package Manager (npm) package.
    ///
    /// * pypi: A Python Package Index (PyPI) package.
    ///
    /// * maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the package for which you want to return a list of package versions.
    /// This member is required.
    public var package: Swift.String?
    /// The name of the repository that contains the package.
    /// This member is required.
    public var repository: Swift.String?
    /// How to sort the returned list of package versions.
    public var sortBy: CodeartifactClientTypes.PackageVersionSortType?
    /// A string that specifies the status of the package versions to include in the returned list. It can be one of the following:
    ///
    /// * Published
    ///
    /// * Unfinished
    ///
    /// * Unlisted
    ///
    /// * Archived
    ///
    /// * Disposed
    public var status: CodeartifactClientTypes.PackageVersionStatus?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        sortBy: CodeartifactClientTypes.PackageVersionSortType? = nil,
        status: CodeartifactClientTypes.PackageVersionStatus? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.repository = repository
        self.sortBy = sortBy
        self.status = status
    }
}

struct ListPackageVersionsInputBody: Swift.Equatable {
}

extension ListPackageVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackageVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackageVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackageVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackageVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPackageVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.defaultDisplayVersion = output.defaultDisplayVersion
            self.format = output.format
            self.namespace = output.namespace
            self.nextToken = output.nextToken
            self.package = output.package
            self.versions = output.versions
        } else {
            self.defaultDisplayVersion = nil
            self.format = nil
            self.namespace = nil
            self.nextToken = nil
            self.package = nil
            self.versions = nil
        }
    }
}

public struct ListPackageVersionsOutputResponse: Swift.Equatable {
    /// The default package version to display. This depends on the package format:
    ///
    /// * For Maven and PyPI packages, it's the most recently published package version.
    ///
    /// * For npm packages, it's the version referenced by the latest tag. If the latest tag is not set, it's the most recently published package version.
    public var defaultDisplayVersion: Swift.String?
    /// A format of the package. Valid package format values are:
    ///
    /// * npm
    ///
    /// * pypi
    ///
    /// * maven
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the package.
    public var package: Swift.String?
    /// The returned list of [PackageVersionSummary](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionSummary.html) objects.
    public var versions: [CodeartifactClientTypes.PackageVersionSummary]?

    public init (
        defaultDisplayVersion: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        versions: [CodeartifactClientTypes.PackageVersionSummary]? = nil
    )
    {
        self.defaultDisplayVersion = defaultDisplayVersion
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.versions = versions
    }
}

struct ListPackageVersionsOutputResponseBody: Swift.Equatable {
    let defaultDisplayVersion: Swift.String?
    let format: CodeartifactClientTypes.PackageFormat?
    let namespace: Swift.String?
    let package: Swift.String?
    let versions: [CodeartifactClientTypes.PackageVersionSummary]?
    let nextToken: Swift.String?
}

extension ListPackageVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultDisplayVersion
        case format
        case namespace
        case nextToken
        case package
        case versions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultDisplayVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultDisplayVersion)
        defaultDisplayVersion = defaultDisplayVersionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.PackageVersionSummary?].self, forKey: .versions)
        var versionsDecoded0:[CodeartifactClientTypes.PackageVersionSummary]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [CodeartifactClientTypes.PackageVersionSummary]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPackagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let packagePrefix = packagePrefix {
            let packagePrefixQueryItem = ClientRuntime.URLQueryItem(name: "package-prefix".urlPercentEncoding(), value: Swift.String(packagePrefix).urlPercentEncoding())
            items.append(packagePrefixQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension ListPackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/packages"
    }
}

public struct ListPackagesInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the requested list of packages.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The format of the packages. The valid package types are:
    ///
    /// * npm: A Node Package Manager (npm) package.
    ///
    /// * pypi: A Python Package Index (PyPI) package.
    ///
    /// * maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A prefix used to filter returned packages. Only packages with names that start with packagePrefix are returned.
    public var packagePrefix: Swift.String?
    /// The name of the repository from which packages are to be listed.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        packagePrefix: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.packagePrefix = packagePrefix
        self.repository = repository
    }
}

struct ListPackagesInputBody: Swift.Equatable {
}

extension ListPackagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPackagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packages = output.packages
        } else {
            self.nextToken = nil
            self.packages = nil
        }
    }
}

public struct ListPackagesOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The list of returned [PackageSummary](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageSummary.html) objects.
    public var packages: [CodeartifactClientTypes.PackageSummary]?

    public init (
        nextToken: Swift.String? = nil,
        packages: [CodeartifactClientTypes.PackageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.packages = packages
    }
}

struct ListPackagesOutputResponseBody: Swift.Equatable {
    let packages: [CodeartifactClientTypes.PackageSummary]?
    let nextToken: Swift.String?
}

extension ListPackagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case packages
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packagesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.PackageSummary?].self, forKey: .packages)
        var packagesDecoded0:[CodeartifactClientTypes.PackageSummary]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [CodeartifactClientTypes.PackageSummary]()
            for structure0 in packagesContainer {
                if let structure0 = structure0 {
                    packagesDecoded0?.append(structure0)
                }
            }
        }
        packages = packagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRepositoriesInDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let repositoryPrefix = repositoryPrefix {
            let repositoryPrefixQueryItem = ClientRuntime.URLQueryItem(name: "repository-prefix".urlPercentEncoding(), value: Swift.String(repositoryPrefix).urlPercentEncoding())
            items.append(repositoryPrefixQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let administratorAccount = administratorAccount {
            let administratorAccountQueryItem = ClientRuntime.URLQueryItem(name: "administrator-account".urlPercentEncoding(), value: Swift.String(administratorAccount).urlPercentEncoding())
            items.append(administratorAccountQueryItem)
        }
        return items
    }
}

extension ListRepositoriesInDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain/repositories"
    }
}

public struct ListRepositoriesInDomainInput: Swift.Equatable {
    /// Filter the list of repositories to only include those that are managed by the AWS account ID.
    public var administratorAccount: Swift.String?
    /// The name of the domain that contains the returned list of repositories.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A prefix used to filter returned repositories. Only repositories with names that start with repositoryPrefix are returned.
    public var repositoryPrefix: Swift.String?

    public init (
        administratorAccount: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryPrefix: Swift.String? = nil
    )
    {
        self.administratorAccount = administratorAccount
        self.domain = domain
        self.domainOwner = domainOwner
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryPrefix = repositoryPrefix
    }
}

struct ListRepositoriesInDomainInputBody: Swift.Equatable {
}

extension ListRepositoriesInDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRepositoriesInDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoriesInDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRepositoriesInDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoriesInDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRepositoriesInDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct ListRepositoriesInDomainOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The returned list of repositories.
    public var repositories: [CodeartifactClientTypes.RepositorySummary]?

    public init (
        nextToken: Swift.String? = nil,
        repositories: [CodeartifactClientTypes.RepositorySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesInDomainOutputResponseBody: Swift.Equatable {
    let repositories: [CodeartifactClientTypes.RepositorySummary]?
    let nextToken: Swift.String?
}

extension ListRepositoriesInDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.RepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeartifactClientTypes.RepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeartifactClientTypes.RepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRepositoriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let repositoryPrefix = repositoryPrefix {
            let repositoryPrefixQueryItem = ClientRuntime.URLQueryItem(name: "repository-prefix".urlPercentEncoding(), value: Swift.String(repositoryPrefix).urlPercentEncoding())
            items.append(repositoryPrefixQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repositories"
    }
}

public struct ListRepositoriesInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A prefix used to filter returned repositories. Only repositories with names that start with repositoryPrefix are returned.
    public var repositoryPrefix: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryPrefix: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryPrefix = repositoryPrefix
    }
}

struct ListRepositoriesInputBody: Swift.Equatable {
}

extension ListRepositoriesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRepositoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRepositoriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct ListRepositoriesOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The returned list of [RepositorySummary](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_RepositorySummary.html) objects.
    public var repositories: [CodeartifactClientTypes.RepositorySummary]?

    public init (
        nextToken: Swift.String? = nil,
        repositories: [CodeartifactClientTypes.RepositorySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesOutputResponseBody: Swift.Equatable {
    let repositories: [CodeartifactClientTypes.RepositorySummary]?
    let nextToken: Swift.String?
}

extension ListRepositoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.RepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeartifactClientTypes.RepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeartifactClientTypes.RepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceArn = resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to get tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tag key and value pairs associated with the specified resource.
    public var tags: [CodeartifactClientTypes.Tag]?

    public init (
        tags: [CodeartifactClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [CodeartifactClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeartifactClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeartifactClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodeartifactClientTypes.PackageDependency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencyType
        case namespace
        case package
        case versionRequirement
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependencyType = dependencyType {
            try encodeContainer.encode(dependencyType, forKey: .dependencyType)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let package = package {
            try encodeContainer.encode(package, forKey: .package)
        }
        if let versionRequirement = versionRequirement {
            try encodeContainer.encode(versionRequirement, forKey: .versionRequirement)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let dependencyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dependencyType)
        dependencyType = dependencyTypeDecoded
        let versionRequirementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRequirement)
        versionRequirement = versionRequirementDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about a package dependency.
    public struct PackageDependency: Swift.Equatable {
        /// The type of a package dependency. The possible values depend on the package type. Example types are compile, runtime, and test for Maven packages, and dev, prod, and optional for npm packages.
        public var dependencyType: Swift.String?
        /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
        ///
        /// * The namespace of a Maven package is its groupId.
        ///
        /// * The namespace of an npm package is its scope.
        ///
        /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public var namespace: Swift.String?
        /// The name of the package that this package depends on.
        public var package: Swift.String?
        /// The required version, or version range, of the package that this package depends on. The version format is specific to the package type. For example, the following are possible valid required versions: 1.2.3, ^2.3.4, or 4.x.
        public var versionRequirement: Swift.String?

        public init (
            dependencyType: Swift.String? = nil,
            namespace: Swift.String? = nil,
            package: Swift.String? = nil,
            versionRequirement: Swift.String? = nil
        )
        {
            self.dependencyType = dependencyType
            self.namespace = namespace
            self.package = package
            self.versionRequirement = versionRequirement
        }
    }

}

extension CodeartifactClientTypes {
    public enum PackageFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case maven
        case npm
        case nuget
        case pypi
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageFormat] {
            return [
                .maven,
                .npm,
                .nuget,
                .pypi,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .maven: return "maven"
            case .npm: return "npm"
            case .nuget: return "nuget"
            case .pypi: return "pypi"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageFormat(rawValue: rawValue) ?? PackageFormat.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes.PackageSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case namespace
        case package
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let package = package {
            try encodeContainer.encode(package, forKey: .package)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about a package, including its format, namespace, and name. The [ListPackages](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackages.html) operation returns a list of PackageSummary objects.
    public struct PackageSummary: Swift.Equatable {
        /// The format of the package. Valid values are:
        ///
        /// * npm
        ///
        /// * pypi
        ///
        /// * maven
        public var format: CodeartifactClientTypes.PackageFormat?
        /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
        ///
        /// * The namespace of a Maven package is its groupId.
        ///
        /// * The namespace of an npm package is its scope.
        ///
        /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public var namespace: Swift.String?
        /// The name of the package.
        public var package: Swift.String?

        public init (
            format: CodeartifactClientTypes.PackageFormat? = nil,
            namespace: Swift.String? = nil,
            package: Swift.String? = nil
        )
        {
            self.format = format
            self.namespace = namespace
            self.package = package
        }
    }

}

extension CodeartifactClientTypes.PackageVersionDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case format
        case homePage
        case licenses
        case namespace
        case packageName
        case publishedTime
        case revision
        case sourceCodeRepository
        case status
        case summary
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let homePage = homePage {
            try encodeContainer.encode(homePage, forKey: .homePage)
        }
        if let licenses = licenses {
            var licensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenses)
            for licenseinfolist0 in licenses {
                try licensesContainer.encode(licenseinfolist0)
            }
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let packageName = packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let publishedTime = publishedTime {
            try encodeContainer.encode(publishedTime.timeIntervalSince1970, forKey: .publishedTime)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let sourceCodeRepository = sourceCodeRepository {
            try encodeContainer.encode(sourceCodeRepository, forKey: .sourceCodeRepository)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .summary)
        summary = summaryDecoded
        let homePageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePage)
        homePage = homePageDecoded
        let sourceCodeRepositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeRepository)
        sourceCodeRepository = sourceCodeRepositoryDecoded
        let publishedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .publishedTime)
        publishedTime = publishedTimeDecoded
        let licensesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.LicenseInfo?].self, forKey: .licenses)
        var licensesDecoded0:[CodeartifactClientTypes.LicenseInfo]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [CodeartifactClientTypes.LicenseInfo]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about a package version.
    public struct PackageVersionDescription: Swift.Equatable {
        /// The name of the package that is displayed. The displayName varies depending on the package version's format. For example, if an npm package is named ui, is in the namespace vue, and has the format npm, then the displayName is @vue/ui.
        public var displayName: Swift.String?
        /// The format of the package version. The valid package formats are:
        ///
        /// * npm: A Node Package Manager (npm) package.
        ///
        /// * pypi: A Python Package Index (PyPI) package.
        ///
        /// * maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        public var format: CodeartifactClientTypes.PackageFormat?
        /// The homepage associated with the package.
        public var homePage: Swift.String?
        /// Information about licenses associated with the package version.
        public var licenses: [CodeartifactClientTypes.LicenseInfo]?
        /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
        ///
        /// * The namespace of a Maven package is its groupId.
        ///
        /// * The namespace of an npm package is its scope.
        ///
        /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public var namespace: Swift.String?
        /// The name of the requested package.
        public var packageName: Swift.String?
        /// A timestamp that contains the date and time the package version was published.
        public var publishedTime: ClientRuntime.Date?
        /// The revision of the package version.
        public var revision: Swift.String?
        /// The repository for the source code in the package version, or the source code used to build it.
        public var sourceCodeRepository: Swift.String?
        /// A string that contains the status of the package version. It can be one of the following:
        ///
        /// * Published
        ///
        /// * Unfinished
        ///
        /// * Unlisted
        ///
        /// * Archived
        ///
        /// * Disposed
        public var status: CodeartifactClientTypes.PackageVersionStatus?
        /// A summary of the package version. The summary is extracted from the package. The information in and detail level of the summary depends on the package version's format.
        public var summary: Swift.String?
        /// The version of the package.
        public var version: Swift.String?

        public init (
            displayName: Swift.String? = nil,
            format: CodeartifactClientTypes.PackageFormat? = nil,
            homePage: Swift.String? = nil,
            licenses: [CodeartifactClientTypes.LicenseInfo]? = nil,
            namespace: Swift.String? = nil,
            packageName: Swift.String? = nil,
            publishedTime: ClientRuntime.Date? = nil,
            revision: Swift.String? = nil,
            sourceCodeRepository: Swift.String? = nil,
            status: CodeartifactClientTypes.PackageVersionStatus? = nil,
            summary: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.format = format
            self.homePage = homePage
            self.licenses = licenses
            self.namespace = namespace
            self.packageName = packageName
            self.publishedTime = publishedTime
            self.revision = revision
            self.sourceCodeRepository = sourceCodeRepository
            self.status = status
            self.summary = summary
            self.version = version
        }
    }

}

extension CodeartifactClientTypes.PackageVersionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CodeartifactClientTypes {
    /// An error associated with package.
    public struct PackageVersionError: Swift.Equatable {
        /// The error code associated with the error. Valid error codes are:
        ///
        /// * ALREADY_EXISTS
        ///
        /// * MISMATCHED_REVISION
        ///
        /// * MISMATCHED_STATUS
        ///
        /// * NOT_ALLOWED
        ///
        /// * NOT_FOUND
        ///
        /// * SKIPPED
        public var errorCode: CodeartifactClientTypes.PackageVersionErrorCode?
        /// The error message associated with the error.
        public var errorMessage: Swift.String?

        public init (
            errorCode: CodeartifactClientTypes.PackageVersionErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension CodeartifactClientTypes {
    public enum PackageVersionErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alreadyExists
        case mismatchedRevision
        case mismatchedStatus
        case notAllowed
        case notFound
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionErrorCode] {
            return [
                .alreadyExists,
                .mismatchedRevision,
                .mismatchedStatus,
                .notAllowed,
                .notFound,
                .skipped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alreadyExists: return "ALREADY_EXISTS"
            case .mismatchedRevision: return "MISMATCHED_REVISION"
            case .mismatchedStatus: return "MISMATCHED_STATUS"
            case .notAllowed: return "NOT_ALLOWED"
            case .notFound: return "NOT_FOUND"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionErrorCode(rawValue: rawValue) ?? PackageVersionErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes {
    public enum PackageVersionSortType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case publishedTime
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionSortType] {
            return [
                .publishedTime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .publishedTime: return "PUBLISHED_TIME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionSortType(rawValue: rawValue) ?? PackageVersionSortType.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes {
    public enum PackageVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archived
        case deleted
        case disposed
        case published
        case unfinished
        case unlisted
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionStatus] {
            return [
                .archived,
                .deleted,
                .disposed,
                .published,
                .unfinished,
                .unlisted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archived: return "Archived"
            case .deleted: return "Deleted"
            case .disposed: return "Disposed"
            case .published: return "Published"
            case .unfinished: return "Unfinished"
            case .unlisted: return "Unlisted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionStatus(rawValue: rawValue) ?? PackageVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes.PackageVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revision
        case status
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about a package version, including its status, version, and revision. The [ListPackageVersions](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackageVersions.html) operation returns a list of PackageVersionSummary objects.
    public struct PackageVersionSummary: Swift.Equatable {
        /// The revision associated with a package version.
        public var revision: Swift.String?
        /// A string that contains the status of the package version. It can be one of the following:
        ///
        /// * Published
        ///
        /// * Unfinished
        ///
        /// * Unlisted
        ///
        /// * Archived
        ///
        /// * Disposed
        /// This member is required.
        public var status: CodeartifactClientTypes.PackageVersionStatus?
        /// Information about a package version.
        /// This member is required.
        public var version: Swift.String?

        public init (
            revision: Swift.String? = nil,
            status: CodeartifactClientTypes.PackageVersionStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.revision = revision
            self.status = status
            self.version = version
        }
    }

}

extension PutDomainPermissionsPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case domainOwner
        case policyDocument
        case policyRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let domainOwner = domainOwner {
            try encodeContainer.encode(domainOwner, forKey: .domainOwner)
        }
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyRevision = policyRevision {
            try encodeContainer.encode(policyRevision, forKey: .policyRevision)
        }
    }
}

extension PutDomainPermissionsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain/permissions/policy"
    }
}

public struct PutDomainPermissionsPolicyInput: Swift.Equatable {
    /// The name of the domain on which to set the resource policy.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided domain.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The current revision of the resource policy to be set. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy.
    public var policyRevision: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyRevision: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyDocument = policyDocument
        self.policyRevision = policyRevision
    }
}

struct PutDomainPermissionsPolicyInputBody: Swift.Equatable {
    let domain: Swift.String?
    let domainOwner: Swift.String?
    let policyRevision: Swift.String?
    let policyDocument: Swift.String?
}

extension PutDomainPermissionsPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case domainOwner
        case policyDocument
        case policyRevision
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let domainOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainOwner)
        domainOwner = domainOwnerDecoded
        let policyRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyRevision)
        policyRevision = policyRevisionDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutDomainPermissionsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDomainPermissionsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDomainPermissionsPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDomainPermissionsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutDomainPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct PutDomainPermissionsPolicyOutputResponse: Swift.Equatable {
    /// The resource policy that was set after processing the request.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init (
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct PutDomainPermissionsPolicyOutputResponseBody: Swift.Equatable {
    let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension PutDomainPermissionsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutRepositoryPermissionsPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument
        case policyRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyRevision = policyRevision {
            try encodeContainer.encode(policyRevision, forKey: .policyRevision)
        }
    }
}

extension PutRepositoryPermissionsPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension PutRepositoryPermissionsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository/permissions/policy"
    }
}

public struct PutRepositoryPermissionsPolicyInput: Swift.Equatable {
    /// The name of the domain containing the repository to set the resource policy on.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided repository.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// Sets the revision of the resource policy that specifies permissions to access the repository. This revision is used for optimistic locking, which prevents others from overwriting your changes to the repository's resource policy.
    public var policyRevision: Swift.String?
    /// The name of the repository to set the resource policy on.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyRevision: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyDocument = policyDocument
        self.policyRevision = policyRevision
        self.repository = repository
    }
}

struct PutRepositoryPermissionsPolicyInputBody: Swift.Equatable {
    let policyRevision: Swift.String?
    let policyDocument: Swift.String?
}

extension PutRepositoryPermissionsPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument
        case policyRevision
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyRevision)
        policyRevision = policyRevisionDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutRepositoryPermissionsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRepositoryPermissionsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRepositoryPermissionsPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRepositoryPermissionsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutRepositoryPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct PutRepositoryPermissionsPolicyOutputResponse: Swift.Equatable {
    /// The resource policy that was set after processing the request.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init (
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct PutRepositoryPermissionsPolicyOutputResponseBody: Swift.Equatable {
    let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension PutRepositoryPermissionsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension CodeartifactClientTypes.RepositoryDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorAccount
        case arn
        case description
        case domainName
        case domainOwner
        case externalConnections
        case name
        case upstreams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorAccount = administratorAccount {
            try encodeContainer.encode(administratorAccount, forKey: .administratorAccount)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainOwner = domainOwner {
            try encodeContainer.encode(domainOwner, forKey: .domainOwner)
        }
        if let externalConnections = externalConnections {
            var externalConnectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalConnections)
            for repositoryexternalconnectioninfolist0 in externalConnections {
                try externalConnectionsContainer.encode(repositoryexternalconnectioninfolist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let upstreams = upstreams {
            var upstreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .upstreams)
            for upstreamrepositoryinfolist0 in upstreams {
                try upstreamsContainer.encode(upstreamrepositoryinfolist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let administratorAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorAccount)
        administratorAccount = administratorAccountDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainOwner)
        domainOwner = domainOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let upstreamsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.UpstreamRepositoryInfo?].self, forKey: .upstreams)
        var upstreamsDecoded0:[CodeartifactClientTypes.UpstreamRepositoryInfo]? = nil
        if let upstreamsContainer = upstreamsContainer {
            upstreamsDecoded0 = [CodeartifactClientTypes.UpstreamRepositoryInfo]()
            for structure0 in upstreamsContainer {
                if let structure0 = structure0 {
                    upstreamsDecoded0?.append(structure0)
                }
            }
        }
        upstreams = upstreamsDecoded0
        let externalConnectionsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.RepositoryExternalConnectionInfo?].self, forKey: .externalConnections)
        var externalConnectionsDecoded0:[CodeartifactClientTypes.RepositoryExternalConnectionInfo]? = nil
        if let externalConnectionsContainer = externalConnectionsContainer {
            externalConnectionsDecoded0 = [CodeartifactClientTypes.RepositoryExternalConnectionInfo]()
            for structure0 in externalConnectionsContainer {
                if let structure0 = structure0 {
                    externalConnectionsDecoded0?.append(structure0)
                }
            }
        }
        externalConnections = externalConnectionsDecoded0
    }
}

extension CodeartifactClientTypes {
    /// The details of a repository stored in AWS CodeArtifact. A CodeArtifact repository contains a set of package versions, each of which maps to a set of assets. Repositories are polyglota single repository can contain packages of any supported type. Each repository exposes endpoints for fetching and publishing packages using tools like the npm CLI, the Maven CLI (mvn), and pip. You can create up to 100 repositories per AWS account.
    public struct RepositoryDescription: Swift.Equatable {
        /// The 12-digit account number of the AWS account that manages the repository.
        public var administratorAccount: Swift.String?
        /// The Amazon Resource Name (ARN) of the repository.
        public var arn: Swift.String?
        /// A text description of the repository.
        public var description: Swift.String?
        /// The name of the domain that contains the repository.
        public var domainName: Swift.String?
        /// The 12-digit account number of the AWS account that owns the domain that contains the repository. It does not include dashes or spaces.
        public var domainOwner: Swift.String?
        /// An array of external connections associated with the repository.
        public var externalConnections: [CodeartifactClientTypes.RepositoryExternalConnectionInfo]?
        /// The name of the repository.
        public var name: Swift.String?
        /// A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more information, see [Working with upstream repositories](https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html).
        public var upstreams: [CodeartifactClientTypes.UpstreamRepositoryInfo]?

        public init (
            administratorAccount: Swift.String? = nil,
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainOwner: Swift.String? = nil,
            externalConnections: [CodeartifactClientTypes.RepositoryExternalConnectionInfo]? = nil,
            name: Swift.String? = nil,
            upstreams: [CodeartifactClientTypes.UpstreamRepositoryInfo]? = nil
        )
        {
            self.administratorAccount = administratorAccount
            self.arn = arn
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.externalConnections = externalConnections
            self.name = name
            self.upstreams = upstreams
        }
    }

}

extension CodeartifactClientTypes.RepositoryExternalConnectionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalConnectionName
        case packageFormat
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalConnectionName = externalConnectionName {
            try encodeContainer.encode(externalConnectionName, forKey: .externalConnectionName)
        }
        if let packageFormat = packageFormat {
            try encodeContainer.encode(packageFormat.rawValue, forKey: .packageFormat)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalConnectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalConnectionName)
        externalConnectionName = externalConnectionNameDecoded
        let packageFormatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .packageFormat)
        packageFormat = packageFormatDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ExternalConnectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeartifactClientTypes {
    /// Contains information about the external connection of a repository.
    public struct RepositoryExternalConnectionInfo: Swift.Equatable {
        /// The name of the external connection associated with a repository.
        public var externalConnectionName: Swift.String?
        /// The package format associated with a repository's external connection. The valid package formats are:
        ///
        /// * npm: A Node Package Manager (npm) package.
        ///
        /// * pypi: A Python Package Index (PyPI) package.
        ///
        /// * maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        public var packageFormat: CodeartifactClientTypes.PackageFormat?
        /// The status of the external connection of a repository. There is one valid value, Available.
        public var status: CodeartifactClientTypes.ExternalConnectionStatus?

        public init (
            externalConnectionName: Swift.String? = nil,
            packageFormat: CodeartifactClientTypes.PackageFormat? = nil,
            status: CodeartifactClientTypes.ExternalConnectionStatus? = nil
        )
        {
            self.externalConnectionName = externalConnectionName
            self.packageFormat = packageFormat
            self.status = status
        }
    }

}

extension CodeartifactClientTypes.RepositorySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorAccount
        case arn
        case description
        case domainName
        case domainOwner
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorAccount = administratorAccount {
            try encodeContainer.encode(administratorAccount, forKey: .administratorAccount)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainOwner = domainOwner {
            try encodeContainer.encode(domainOwner, forKey: .domainOwner)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let administratorAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorAccount)
        administratorAccount = administratorAccountDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainOwner)
        domainOwner = domainOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about a repository, including its Amazon Resource Name (ARN), description, and domain information. The [ListRepositories](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListRepositories.html) operation returns a list of RepositorySummary objects.
    public struct RepositorySummary: Swift.Equatable {
        /// The AWS account ID that manages the repository.
        public var administratorAccount: Swift.String?
        /// The ARN of the repository.
        public var arn: Swift.String?
        /// The description of the repository.
        public var description: Swift.String?
        /// The name of the domain that contains the repository.
        public var domainName: Swift.String?
        /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public var domainOwner: Swift.String?
        /// The name of the repository.
        public var name: Swift.String?

        public init (
            administratorAccount: Swift.String? = nil,
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainOwner: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.administratorAccount = administratorAccount
            self.arn = arn
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.name = name
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation did not succeed because the resource requested is not found in the service.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of AWS resource.
    public var resourceType: CodeartifactClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CodeartifactClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: CodeartifactClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CodeartifactClientTypes.ResourcePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document
        case resourceArn
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
    }
}

extension CodeartifactClientTypes {
    /// An AWS CodeArtifact resource policy that contains a resource ARN, document details, and a revision.
    public struct ResourcePolicy: Swift.Equatable {
        /// The resource policy formatted in JSON.
        public var document: Swift.String?
        /// The ARN of the resource associated with the resource policy
        public var resourceArn: Swift.String?
        /// The current revision of the resource policy.
        public var revision: Swift.String?

        public init (
            document: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.document = document
            self.resourceArn = resourceArn
            self.revision = revision
        }
    }

}

extension CodeartifactClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asset
        case domain
        case package
        case packageVersion
        case repository
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .asset,
                .domain,
                .package,
                .packageVersion,
                .repository,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asset: return "asset"
            case .domain: return "domain"
            case .package: return "package"
            case .packageVersion: return "package-version"
            case .repository: return "repository"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation did not succeed because it would have exceeded a service limit for your account.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of AWS resource.
    public var resourceType: CodeartifactClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CodeartifactClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: CodeartifactClientTypes.ResourceType?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CodeartifactClientTypes.SuccessfulPackageVersionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revision
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeartifactClientTypes {
    /// Contains the revision and status of a package version.
    public struct SuccessfulPackageVersionInfo: Swift.Equatable {
        /// The revision of a package version.
        public var revision: Swift.String?
        /// The status of a package version. Valid statuses are:
        ///
        /// * Published
        ///
        /// * Unfinished
        ///
        /// * Unlisted
        ///
        /// * Archived
        ///
        /// * Disposed
        public var status: CodeartifactClientTypes.PackageVersionStatus?

        public init (
            revision: Swift.String? = nil,
            status: CodeartifactClientTypes.PackageVersionStatus? = nil
        )
        {
            self.revision = revision
            self.status = status
        }
    }

}

extension CodeartifactClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CodeartifactClientTypes {
    /// A tag is a key-value pair that can be used to manage, search for, or filter resources in AWS CodeArtifact.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceArn = resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
        }
        return items
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/tag"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags you want to modify or add to the resource.
    /// This member is required.
    public var tags: [CodeartifactClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [CodeartifactClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [CodeartifactClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeartifactClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeartifactClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation did not succeed because too many requests are sent to the service.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The time period, in seconds, to wait before retrying the request.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceArn = resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/untag"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key for each tag that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdatePackageVersionsStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case targetStatus
        case versionRevisions
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedStatus = expectedStatus {
            try encodeContainer.encode(expectedStatus.rawValue, forKey: .expectedStatus)
        }
        if let targetStatus = targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
        if let versionRevisions = versionRevisions {
            var versionRevisionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .versionRevisions)
            for (dictKey0, packageversionrevisionmap0) in versionRevisions {
                try versionRevisionsContainer.encode(packageversionrevisionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversionlist0 in versions {
                try versionsContainer.encode(packageversionlist0)
            }
        }
    }
}

extension UpdatePackageVersionsStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let package = package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
        }
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension UpdatePackageVersionsStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/versions/update_status"
    }
}

public struct UpdatePackageVersionsStatusInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the package versions with a status to be updated.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The package versions expected status before it is updated. If expectedStatus is provided, the package version's status is updated only if its status at the time UpdatePackageVersionsStatus is called matches expectedStatus.
    public var expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
    /// A format that specifies the type of the package with the statuses to update. The valid values are:
    ///
    /// * npm
    ///
    /// * pypi
    ///
    /// * maven
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * A Python package does not contain a corresponding component, so Python packages do not have a namespace.
    public var namespace: Swift.String?
    /// The name of the package with the version statuses to update.
    /// This member is required.
    public var package: Swift.String?
    /// The repository that contains the package versions with the status you want to update.
    /// This member is required.
    public var repository: Swift.String?
    /// The status you want to change the package version status to.
    /// This member is required.
    public var targetStatus: CodeartifactClientTypes.PackageVersionStatus?
    /// A map of package versions and package version revisions. The map key is the package version (for example, 3.5.2), and the map value is the package version revision.
    public var versionRevisions: [Swift.String:Swift.String]?
    /// An array of strings that specify the versions of the package with the statuses to update.
    /// This member is required.
    public var versions: [Swift.String]?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        expectedStatus: CodeartifactClientTypes.PackageVersionStatus? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        targetStatus: CodeartifactClientTypes.PackageVersionStatus? = nil,
        versionRevisions: [Swift.String:Swift.String]? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.expectedStatus = expectedStatus
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.targetStatus = targetStatus
        self.versionRevisions = versionRevisions
        self.versions = versions
    }
}

struct UpdatePackageVersionsStatusInputBody: Swift.Equatable {
    let versions: [Swift.String]?
    let versionRevisions: [Swift.String:Swift.String]?
    let expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
    let targetStatus: CodeartifactClientTypes.PackageVersionStatus?
}

extension UpdatePackageVersionsStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case targetStatus
        case versionRevisions
        case versions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let versionRevisionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .versionRevisions)
        var versionRevisionsDecoded0: [Swift.String:Swift.String]? = nil
        if let versionRevisionsContainer = versionRevisionsContainer {
            versionRevisionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, packageversionrevision0) in versionRevisionsContainer {
                if let packageversionrevision0 = packageversionrevision0 {
                    versionRevisionsDecoded0?[key0] = packageversionrevision0
                }
            }
        }
        versionRevisions = versionRevisionsDecoded0
        let expectedStatusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .expectedStatus)
        expectedStatus = expectedStatusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension UpdatePackageVersionsStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePackageVersionsStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePackageVersionsStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePackageVersionsStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePackageVersionsStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct UpdatePackageVersionsStatusOutputResponse: Swift.Equatable {
    /// A list of SuccessfulPackageVersionInfo objects, one for each package version with a status that successfully updated.
    public var failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
    /// A list of PackageVersionError objects, one for each package version with a status that failed to update.
    public var successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?

    public init (
        failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil,
        successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct UpdatePackageVersionsStatusOutputResponseBody: Swift.Equatable {
    let successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?
    let failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
}

extension UpdatePackageVersionsStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

extension UpdateRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case upstreams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let upstreams = upstreams {
            var upstreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .upstreams)
            for upstreamrepositorylist0 in upstreams {
                try upstreamsContainer.encode(upstreamrepositorylist0)
            }
        }
    }
}

extension UpdateRepositoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domain = domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        if let domainOwner = domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            items.append(domainOwnerQueryItem)
        }
        if let repository = repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
        }
        return items
    }
}

extension UpdateRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository"
    }
}

public struct UpdateRepositoryInput: Swift.Equatable {
    /// An updated repository description.
    public var description: Swift.String?
    /// The name of the domain associated with the repository to update.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The name of the repository to update.
    /// This member is required.
    public var repository: Swift.String?
    /// A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more information, see [Working with upstream repositories](https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html).
    public var upstreams: [CodeartifactClientTypes.UpstreamRepository]?

    public init (
        description: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil,
        upstreams: [CodeartifactClientTypes.UpstreamRepository]? = nil
    )
    {
        self.description = description
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
        self.upstreams = upstreams
    }
}

struct UpdateRepositoryInputBody: Swift.Equatable {
    let description: Swift.String?
    let upstreams: [CodeartifactClientTypes.UpstreamRepository]?
}

extension UpdateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case upstreams
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let upstreamsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.UpstreamRepository?].self, forKey: .upstreams)
        var upstreamsDecoded0:[CodeartifactClientTypes.UpstreamRepository]? = nil
        if let upstreamsContainer = upstreamsContainer {
            upstreamsDecoded0 = [CodeartifactClientTypes.UpstreamRepository]()
            for structure0 in upstreamsContainer {
                if let structure0 = structure0 {
                    upstreamsDecoded0?.append(structure0)
                }
            }
        }
        upstreams = upstreamsDecoded0
    }
}

extension UpdateRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct UpdateRepositoryOutputResponse: Swift.Equatable {
    /// The updated repository.
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init (
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct UpdateRepositoryOutputResponseBody: Swift.Equatable {
    let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension UpdateRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension CodeartifactClientTypes.UpstreamRepository: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension CodeartifactClientTypes {
    /// Information about an upstream repository. A list of UpstreamRepository objects is an input parameter to [CreateRepository](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_CreateRepository.html) and [UpdateRepository](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_UpdateRepository.html).
    public struct UpstreamRepository: Swift.Equatable {
        /// The name of an upstream repository.
        /// This member is required.
        public var repositoryName: Swift.String?

        public init (
            repositoryName: Swift.String? = nil
        )
        {
            self.repositoryName = repositoryName
        }
    }

}

extension CodeartifactClientTypes.UpstreamRepositoryInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension CodeartifactClientTypes {
    /// Information about an upstream repository.
    public struct UpstreamRepositoryInfo: Swift.Equatable {
        /// The name of an upstream repository.
        public var repositoryName: Swift.String?

        public init (
            repositoryName: Swift.String? = nil
        )
        {
            self.repositoryName = repositoryName
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation did not succeed because a parameter in the request was sent with an invalid value.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    public var reason: CodeartifactClientTypes.ValidationExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: CodeartifactClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: CodeartifactClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CodeartifactClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case encryptionKeyError
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .encryptionKeyError,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .encryptionKeyError: return "ENCRYPTION_KEY_ERROR"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
