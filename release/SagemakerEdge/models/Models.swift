// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension EdgeMetric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimension = "Dimension"
        case metricName = "MetricName"
        case timestamp = "Timestamp"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimension = dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let valueDecoded = try containerValues.decode(Double.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension EdgeMetric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EdgeMetric(dimension: \(String(describing: dimension)), metricName: \(String(describing: metricName)), timestamp: \(String(describing: timestamp)), value: \(String(describing: value)))"}
}

/// <p>Information required for edge device metrics.</p>
public struct EdgeMetric: Equatable {
    /// <p>The dimension of metrics published.</p>
    public let dimension: String?
    /// <p>Returns the name of the metric.</p>
    public let metricName: String?
    /// <p>Timestamp of when the metric was requested.</p>
    public let timestamp: Date?
    /// <p>Returns the value of the metric.</p>
    public let value: Double

    public init (
        dimension: String? = nil,
        metricName: String? = nil,
        timestamp: Date? = nil,
        value: Double = 0.0
    )
    {
        self.dimension = dimension
        self.metricName = metricName
        self.timestamp = timestamp
        self.value = value
    }
}

public struct GetDeviceRegistrationInputBodyMiddleware: Middleware {
    public let id: String = "GetDeviceRegistrationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceRegistrationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceRegistrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceRegistrationInput>
    public typealias MOutput = OperationOutput<GetDeviceRegistrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceRegistrationOutputError>
}

extension GetDeviceRegistrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceRegistrationInput(deviceFleetName: \(String(describing: deviceFleetName)), deviceName: \(String(describing: deviceName)))"}
}

extension GetDeviceRegistrationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceFleetName = "DeviceFleetName"
        case deviceName = "DeviceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceFleetName = deviceFleetName {
            try encodeContainer.encode(deviceFleetName, forKey: .deviceFleetName)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
    }
}

public struct GetDeviceRegistrationInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeviceRegistrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceRegistrationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceRegistrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceRegistrationInput>
    public typealias MOutput = OperationOutput<GetDeviceRegistrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceRegistrationOutputError>
}

public struct GetDeviceRegistrationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeviceRegistrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceRegistrationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceRegistrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceRegistrationInput>
    public typealias MOutput = OperationOutput<GetDeviceRegistrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceRegistrationOutputError>
}

public struct GetDeviceRegistrationInput: Equatable {
    /// <p>The name of the fleet that the device belongs to.</p>
    public let deviceFleetName: String?
    /// <p>The unique name of the device you want to get the registration status from.</p>
    public let deviceName: String?

    public init (
        deviceFleetName: String? = nil,
        deviceName: String? = nil
    )
    {
        self.deviceFleetName = deviceFleetName
        self.deviceName = deviceName
    }
}

struct GetDeviceRegistrationInputBody: Equatable {
    public let deviceName: String?
    public let deviceFleetName: String?
}

extension GetDeviceRegistrationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceFleetName = "DeviceFleetName"
        case deviceName = "DeviceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let deviceFleetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceFleetName)
        deviceFleetName = deviceFleetNameDecoded
    }
}

extension GetDeviceRegistrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceRegistrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceRegistrationOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceRegistrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceRegistrationOutputResponse(cacheTTL: \(String(describing: cacheTTL)), deviceRegistration: \(String(describing: deviceRegistration)))"}
}

extension GetDeviceRegistrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeviceRegistrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cacheTTL = output.cacheTTL
            self.deviceRegistration = output.deviceRegistration
        } else {
            self.cacheTTL = nil
            self.deviceRegistration = nil
        }
    }
}

public struct GetDeviceRegistrationOutputResponse: Equatable {
    /// <p>The amount of time, in seconds, that the registration status is stored on the device’s cache before it is refreshed.</p>
    public let cacheTTL: String?
    /// <p>Describes if the device is currently registered with SageMaker Edge Manager.</p>
    public let deviceRegistration: String?

    public init (
        cacheTTL: String? = nil,
        deviceRegistration: String? = nil
    )
    {
        self.cacheTTL = cacheTTL
        self.deviceRegistration = deviceRegistration
    }
}

struct GetDeviceRegistrationOutputResponseBody: Equatable {
    public let deviceRegistration: String?
    public let cacheTTL: String?
}

extension GetDeviceRegistrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cacheTTL = "CacheTTL"
        case deviceRegistration = "DeviceRegistration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceRegistration)
        deviceRegistration = deviceRegistrationDecoded
        let cacheTTLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheTTL)
        cacheTTL = cacheTTLDecoded
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal failure occurred. Try your request again. If the problem
///       persists, contact AWS customer support.</p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Model: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case latestInference = "LatestInference"
        case latestSampleTime = "LatestSampleTime"
        case modelMetrics = "ModelMetrics"
        case modelName = "ModelName"
        case modelVersion = "ModelVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestInference = latestInference {
            try encodeContainer.encode(latestInference.timeIntervalSince1970, forKey: .latestInference)
        }
        if let latestSampleTime = latestSampleTime {
            try encodeContainer.encode(latestSampleTime.timeIntervalSince1970, forKey: .latestSampleTime)
        }
        if let modelMetrics = modelMetrics {
            var modelMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modelMetrics)
            for edgemetrics0 in modelMetrics {
                try modelMetricsContainer.encode(edgemetrics0)
            }
        }
        if let modelName = modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let modelVersion = modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let latestSampleTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestSampleTime)
        latestSampleTime = latestSampleTimeDecoded
        let latestInferenceDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestInference)
        latestInference = latestInferenceDecoded
        let modelMetricsContainer = try containerValues.decodeIfPresent([EdgeMetric?].self, forKey: .modelMetrics)
        var modelMetricsDecoded0:[EdgeMetric]? = nil
        if let modelMetricsContainer = modelMetricsContainer {
            modelMetricsDecoded0 = [EdgeMetric]()
            for structure0 in modelMetricsContainer {
                if let structure0 = structure0 {
                    modelMetricsDecoded0?.append(structure0)
                }
            }
        }
        modelMetrics = modelMetricsDecoded0
    }
}

extension Model: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Model(latestInference: \(String(describing: latestInference)), latestSampleTime: \(String(describing: latestSampleTime)), modelMetrics: \(String(describing: modelMetrics)), modelName: \(String(describing: modelName)), modelVersion: \(String(describing: modelVersion)))"}
}

/// <p>Information about a model deployed on an edge device that is registered with SageMaker Edge Manager.</p>
public struct Model: Equatable {
    /// <p>The timestamp of the last inference that was made.</p>
    public let latestInference: Date?
    /// <p>The timestamp of the last data sample taken.</p>
    public let latestSampleTime: Date?
    /// <p>Information required for model metrics.</p>
    public let modelMetrics: [EdgeMetric]?
    /// <p>The name of the model.</p>
    public let modelName: String?
    /// <p>The version of the model.</p>
    public let modelVersion: String?

    public init (
        latestInference: Date? = nil,
        latestSampleTime: Date? = nil,
        modelMetrics: [EdgeMetric]? = nil,
        modelName: String? = nil,
        modelVersion: String? = nil
    )
    {
        self.latestInference = latestInference
        self.latestSampleTime = latestSampleTime
        self.modelMetrics = modelMetrics
        self.modelName = modelName
        self.modelVersion = modelVersion
    }
}

public struct SendHeartbeatInputBodyMiddleware: Middleware {
    public let id: String = "SendHeartbeatInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendHeartbeatInput>,
                  next: H) -> Swift.Result<OperationOutput<SendHeartbeatOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendHeartbeatInput>
    public typealias MOutput = OperationOutput<SendHeartbeatOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendHeartbeatOutputError>
}

extension SendHeartbeatInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendHeartbeatInput(agentMetrics: \(String(describing: agentMetrics)), agentVersion: \(String(describing: agentVersion)), deviceFleetName: \(String(describing: deviceFleetName)), deviceName: \(String(describing: deviceName)), models: \(String(describing: models)))"}
}

extension SendHeartbeatInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentMetrics = "AgentMetrics"
        case agentVersion = "AgentVersion"
        case deviceFleetName = "DeviceFleetName"
        case deviceName = "DeviceName"
        case models = "Models"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentMetrics = agentMetrics {
            var agentMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentMetrics)
            for edgemetrics0 in agentMetrics {
                try agentMetricsContainer.encode(edgemetrics0)
            }
        }
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let deviceFleetName = deviceFleetName {
            try encodeContainer.encode(deviceFleetName, forKey: .deviceFleetName)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let models = models {
            var modelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .models)
            for models0 in models {
                try modelsContainer.encode(models0)
            }
        }
    }
}

public struct SendHeartbeatInputHeadersMiddleware: Middleware {
    public let id: String = "SendHeartbeatInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendHeartbeatInput>,
                  next: H) -> Swift.Result<OperationOutput<SendHeartbeatOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendHeartbeatInput>
    public typealias MOutput = OperationOutput<SendHeartbeatOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendHeartbeatOutputError>
}

public struct SendHeartbeatInputQueryItemMiddleware: Middleware {
    public let id: String = "SendHeartbeatInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendHeartbeatInput>,
                  next: H) -> Swift.Result<OperationOutput<SendHeartbeatOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendHeartbeatInput>
    public typealias MOutput = OperationOutput<SendHeartbeatOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendHeartbeatOutputError>
}

public struct SendHeartbeatInput: Equatable {
    /// <p>For internal use. Returns a list of SageMaker Edge Manager agent operating metrics.</p>
    public let agentMetrics: [EdgeMetric]?
    /// <p>Returns the version of the agent.</p>
    public let agentVersion: String?
    /// <p>The name of the fleet that the device belongs to.</p>
    public let deviceFleetName: String?
    /// <p>The unique name of the device.</p>
    public let deviceName: String?
    /// <p>Returns a list of models deployed on the the device.</p>
    public let models: [Model]?

    public init (
        agentMetrics: [EdgeMetric]? = nil,
        agentVersion: String? = nil,
        deviceFleetName: String? = nil,
        deviceName: String? = nil,
        models: [Model]? = nil
    )
    {
        self.agentMetrics = agentMetrics
        self.agentVersion = agentVersion
        self.deviceFleetName = deviceFleetName
        self.deviceName = deviceName
        self.models = models
    }
}

struct SendHeartbeatInputBody: Equatable {
    public let agentMetrics: [EdgeMetric]?
    public let models: [Model]?
    public let agentVersion: String?
    public let deviceName: String?
    public let deviceFleetName: String?
}

extension SendHeartbeatInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentMetrics = "AgentMetrics"
        case agentVersion = "AgentVersion"
        case deviceFleetName = "DeviceFleetName"
        case deviceName = "DeviceName"
        case models = "Models"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentMetricsContainer = try containerValues.decodeIfPresent([EdgeMetric?].self, forKey: .agentMetrics)
        var agentMetricsDecoded0:[EdgeMetric]? = nil
        if let agentMetricsContainer = agentMetricsContainer {
            agentMetricsDecoded0 = [EdgeMetric]()
            for structure0 in agentMetricsContainer {
                if let structure0 = structure0 {
                    agentMetricsDecoded0?.append(structure0)
                }
            }
        }
        agentMetrics = agentMetricsDecoded0
        let modelsContainer = try containerValues.decodeIfPresent([Model?].self, forKey: .models)
        var modelsDecoded0:[Model]? = nil
        if let modelsContainer = modelsContainer {
            modelsDecoded0 = [Model]()
            for structure0 in modelsContainer {
                if let structure0 = structure0 {
                    modelsDecoded0?.append(structure0)
                }
            }
        }
        models = modelsDecoded0
        let agentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let deviceFleetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceFleetName)
        deviceFleetName = deviceFleetNameDecoded
    }
}

extension SendHeartbeatOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendHeartbeatOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendHeartbeatOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendHeartbeatOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendHeartbeatOutputResponse()"}
}

extension SendHeartbeatOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SendHeartbeatOutputResponse: Equatable {

    public init() {}
}

struct SendHeartbeatOutputResponseBody: Equatable {
}

extension SendHeartbeatOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
