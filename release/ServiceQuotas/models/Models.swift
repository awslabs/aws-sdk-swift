// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AWSServiceAccessNotEnabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AWSServiceAccessNotEnabledException(message: \(String(describing: message)))"}
}

extension AWSServiceAccessNotEnabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AWSServiceAccessNotEnabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The action you attempted is not allowed unless Service Access with Service Quotas is
///       enabled in your organization.</p>
public struct AWSServiceAccessNotEnabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AWSServiceAccessNotEnabledExceptionBody: Equatable {
    public let message: String?
}

extension AWSServiceAccessNotEnabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient permission to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateServiceQuotaTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateServiceQuotaTemplateInput()"}
}

extension AssociateServiceQuotaTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct AssociateServiceQuotaTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateServiceQuotaTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateServiceQuotaTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateServiceQuotaTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateServiceQuotaTemplateInput>
    public typealias MOutput = OperationOutput<AssociateServiceQuotaTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateServiceQuotaTemplateOutputError>
}

public struct AssociateServiceQuotaTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateServiceQuotaTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateServiceQuotaTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateServiceQuotaTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateServiceQuotaTemplateInput>
    public typealias MOutput = OperationOutput<AssociateServiceQuotaTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateServiceQuotaTemplateOutputError>
}

public struct AssociateServiceQuotaTemplateInput: Equatable {

    public init() {}
}

struct AssociateServiceQuotaTemplateInputBody: Equatable {
}

extension AssociateServiceQuotaTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AssociateServiceQuotaTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateServiceQuotaTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesModeException" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateServiceQuotaTemplateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case serviceException(ServiceException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateServiceQuotaTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateServiceQuotaTemplateOutputResponse()"}
}

extension AssociateServiceQuotaTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateServiceQuotaTemplateOutputResponse: Equatable {

    public init() {}
}

struct AssociateServiceQuotaTemplateOutputResponseBody: Equatable {
}

extension AssociateServiceQuotaTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteServiceQuotaIncreaseRequestFromTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceQuotaIncreaseRequestFromTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceQuotaIncreaseRequestFromTemplateInput>
    public typealias MOutput = OperationOutput<DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceQuotaIncreaseRequestFromTemplateOutputError>
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceQuotaIncreaseRequestFromTemplateInput(awsRegion: \(String(describing: awsRegion)), quotaCode: \(String(describing: quotaCode)), serviceCode: \(String(describing: serviceCode)))"}
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteServiceQuotaIncreaseRequestFromTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceQuotaIncreaseRequestFromTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceQuotaIncreaseRequestFromTemplateInput>
    public typealias MOutput = OperationOutput<DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceQuotaIncreaseRequestFromTemplateOutputError>
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteServiceQuotaIncreaseRequestFromTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceQuotaIncreaseRequestFromTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceQuotaIncreaseRequestFromTemplateInput>
    public typealias MOutput = OperationOutput<DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceQuotaIncreaseRequestFromTemplateOutputError>
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateInput: Equatable {
    /// <p>The AWS Region.</p>
    public let awsRegion: String?
    /// <p>The quota identifier.</p>
    public let quotaCode: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?

    public init (
        awsRegion: String? = nil,
        quotaCode: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct DeleteServiceQuotaIncreaseRequestFromTemplateInputBody: Equatable {
    public let serviceCode: String?
    public let quotaCode: String?
    public let awsRegion: String?
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceQuotaIncreaseRequestFromTemplateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse()"}
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponseBody: Equatable {
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DependencyAccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DependencyAccessDeniedException(message: \(String(describing: message)))"}
}

extension DependencyAccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DependencyAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't perform this action because a dependency does not have access.</p>
public struct DependencyAccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DependencyAccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension DependencyAccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DisassociateServiceQuotaTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateServiceQuotaTemplateInput()"}
}

extension DisassociateServiceQuotaTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateServiceQuotaTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateServiceQuotaTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateServiceQuotaTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateServiceQuotaTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateServiceQuotaTemplateInput>
    public typealias MOutput = OperationOutput<DisassociateServiceQuotaTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateServiceQuotaTemplateOutputError>
}

public struct DisassociateServiceQuotaTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateServiceQuotaTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateServiceQuotaTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateServiceQuotaTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateServiceQuotaTemplateInput>
    public typealias MOutput = OperationOutput<DisassociateServiceQuotaTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateServiceQuotaTemplateOutputError>
}

public struct DisassociateServiceQuotaTemplateInput: Equatable {

    public init() {}
}

struct DisassociateServiceQuotaTemplateInputBody: Equatable {
}

extension DisassociateServiceQuotaTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateServiceQuotaTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateServiceQuotaTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaTemplateNotInUseException" : self = .serviceQuotaTemplateNotInUseException(try ServiceQuotaTemplateNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateServiceQuotaTemplateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case serviceException(ServiceException)
    case serviceQuotaTemplateNotInUseException(ServiceQuotaTemplateNotInUseException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateServiceQuotaTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateServiceQuotaTemplateOutputResponse()"}
}

extension DisassociateServiceQuotaTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateServiceQuotaTemplateOutputResponse: Equatable {

    public init() {}
}

struct DisassociateServiceQuotaTemplateOutputResponseBody: Equatable {
}

extension DisassociateServiceQuotaTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ErrorCode {
    case dependencyAccessDeniedError
    case dependencyServiceError
    case dependencyThrottlingError
    case serviceQuotaNotAvailableError
    case sdkUnknown(String)
}

extension ErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ErrorCode] {
        return [
            .dependencyAccessDeniedError,
            .dependencyServiceError,
            .dependencyThrottlingError,
            .serviceQuotaNotAvailableError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dependencyAccessDeniedError: return "DEPENDENCY_ACCESS_DENIED_ERROR"
        case .dependencyServiceError: return "DEPENDENCY_SERVICE_ERROR"
        case .dependencyThrottlingError: return "DEPENDENCY_THROTTLING_ERROR"
        case .serviceQuotaNotAvailableError: return "SERVICE_QUOTA_NOT_AVAILABLE_ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
    }
}

extension ErrorReason: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ErrorReason: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorReason(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>An error that explains why an action did not succeed.</p>
public struct ErrorReason: Equatable {
    /// <p>Service Quotas returns the following error values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DEPENDENCY_ACCESS_DENIED_ERROR</code> - The caller does not have the required
    ///           permissions to complete the action. To resolve the error, you must have permission to
    ///           access the service or quota.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DEPENDENCY_THROTTLING_ERROR</code> - The service is throttling Service
    ///           Quotas.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DEPENDENCY_SERVICE_ERROR</code> - The service is not available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SERVICE_QUOTA_NOT_AVAILABLE_ERROR</code> - There was an error in Service
    ///           Quotas.</p>
    ///             </li>
    ///          </ul>
    public let errorCode: ErrorCode?
    /// <p>The error message.</p>
    public let errorMessage: String?

    public init (
        errorCode: ErrorCode? = nil,
        errorMessage: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

public struct GetAWSDefaultServiceQuotaInputBodyMiddleware: Middleware {
    public let id: String = "GetAWSDefaultServiceQuotaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAWSDefaultServiceQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAWSDefaultServiceQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAWSDefaultServiceQuotaInput>
    public typealias MOutput = OperationOutput<GetAWSDefaultServiceQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAWSDefaultServiceQuotaOutputError>
}

extension GetAWSDefaultServiceQuotaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAWSDefaultServiceQuotaInput(quotaCode: \(String(describing: quotaCode)), serviceCode: \(String(describing: serviceCode)))"}
}

extension GetAWSDefaultServiceQuotaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct GetAWSDefaultServiceQuotaInputHeadersMiddleware: Middleware {
    public let id: String = "GetAWSDefaultServiceQuotaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAWSDefaultServiceQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAWSDefaultServiceQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAWSDefaultServiceQuotaInput>
    public typealias MOutput = OperationOutput<GetAWSDefaultServiceQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAWSDefaultServiceQuotaOutputError>
}

public struct GetAWSDefaultServiceQuotaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAWSDefaultServiceQuotaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAWSDefaultServiceQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAWSDefaultServiceQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAWSDefaultServiceQuotaInput>
    public typealias MOutput = OperationOutput<GetAWSDefaultServiceQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAWSDefaultServiceQuotaOutputError>
}

public struct GetAWSDefaultServiceQuotaInput: Equatable {
    /// <p>The quota identifier.</p>
    public let quotaCode: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?

    public init (
        quotaCode: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct GetAWSDefaultServiceQuotaInputBody: Equatable {
    public let serviceCode: String?
    public let quotaCode: String?
}

extension GetAWSDefaultServiceQuotaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension GetAWSDefaultServiceQuotaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAWSDefaultServiceQuotaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAWSDefaultServiceQuotaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAWSDefaultServiceQuotaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAWSDefaultServiceQuotaOutputResponse(quota: \(String(describing: quota)))"}
}

extension GetAWSDefaultServiceQuotaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAWSDefaultServiceQuotaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.quota = output.quota
        } else {
            self.quota = nil
        }
    }
}

public struct GetAWSDefaultServiceQuotaOutputResponse: Equatable {
    /// <p>Information about the quota.</p>
    public let quota: ServiceQuota?

    public init (
        quota: ServiceQuota? = nil
    )
    {
        self.quota = quota
    }
}

struct GetAWSDefaultServiceQuotaOutputResponseBody: Equatable {
    public let quota: ServiceQuota?
}

extension GetAWSDefaultServiceQuotaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case quota = "Quota"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quotaDecoded = try containerValues.decodeIfPresent(ServiceQuota.self, forKey: .quota)
        quota = quotaDecoded
    }
}

extension GetAssociationForServiceQuotaTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssociationForServiceQuotaTemplateInput()"}
}

extension GetAssociationForServiceQuotaTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAssociationForServiceQuotaTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetAssociationForServiceQuotaTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssociationForServiceQuotaTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssociationForServiceQuotaTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssociationForServiceQuotaTemplateInput>
    public typealias MOutput = OperationOutput<GetAssociationForServiceQuotaTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssociationForServiceQuotaTemplateOutputError>
}

public struct GetAssociationForServiceQuotaTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAssociationForServiceQuotaTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssociationForServiceQuotaTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssociationForServiceQuotaTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssociationForServiceQuotaTemplateInput>
    public typealias MOutput = OperationOutput<GetAssociationForServiceQuotaTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssociationForServiceQuotaTemplateOutputError>
}

public struct GetAssociationForServiceQuotaTemplateInput: Equatable {

    public init() {}
}

struct GetAssociationForServiceQuotaTemplateInputBody: Equatable {
}

extension GetAssociationForServiceQuotaTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAssociationForServiceQuotaTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssociationForServiceQuotaTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaTemplateNotInUseException" : self = .serviceQuotaTemplateNotInUseException(try ServiceQuotaTemplateNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssociationForServiceQuotaTemplateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case serviceException(ServiceException)
    case serviceQuotaTemplateNotInUseException(ServiceQuotaTemplateNotInUseException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssociationForServiceQuotaTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssociationForServiceQuotaTemplateOutputResponse(serviceQuotaTemplateAssociationStatus: \(String(describing: serviceQuotaTemplateAssociationStatus)))"}
}

extension GetAssociationForServiceQuotaTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAssociationForServiceQuotaTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceQuotaTemplateAssociationStatus = output.serviceQuotaTemplateAssociationStatus
        } else {
            self.serviceQuotaTemplateAssociationStatus = nil
        }
    }
}

public struct GetAssociationForServiceQuotaTemplateOutputResponse: Equatable {
    /// <p>The association status. If the status is <code>ASSOCIATED</code>, the quota increase
    ///       requests in the template are automatically applied to new accounts in your
    ///       organization.</p>
    public let serviceQuotaTemplateAssociationStatus: ServiceQuotaTemplateAssociationStatus?

    public init (
        serviceQuotaTemplateAssociationStatus: ServiceQuotaTemplateAssociationStatus? = nil
    )
    {
        self.serviceQuotaTemplateAssociationStatus = serviceQuotaTemplateAssociationStatus
    }
}

struct GetAssociationForServiceQuotaTemplateOutputResponseBody: Equatable {
    public let serviceQuotaTemplateAssociationStatus: ServiceQuotaTemplateAssociationStatus?
}

extension GetAssociationForServiceQuotaTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceQuotaTemplateAssociationStatus = "ServiceQuotaTemplateAssociationStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaTemplateAssociationStatusDecoded = try containerValues.decodeIfPresent(ServiceQuotaTemplateAssociationStatus.self, forKey: .serviceQuotaTemplateAssociationStatus)
        serviceQuotaTemplateAssociationStatus = serviceQuotaTemplateAssociationStatusDecoded
    }
}

public struct GetRequestedServiceQuotaChangeInputBodyMiddleware: Middleware {
    public let id: String = "GetRequestedServiceQuotaChangeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRequestedServiceQuotaChangeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRequestedServiceQuotaChangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRequestedServiceQuotaChangeInput>
    public typealias MOutput = OperationOutput<GetRequestedServiceQuotaChangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRequestedServiceQuotaChangeOutputError>
}

extension GetRequestedServiceQuotaChangeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRequestedServiceQuotaChangeInput(requestId: \(String(describing: requestId)))"}
}

extension GetRequestedServiceQuotaChangeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }
}

public struct GetRequestedServiceQuotaChangeInputHeadersMiddleware: Middleware {
    public let id: String = "GetRequestedServiceQuotaChangeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRequestedServiceQuotaChangeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRequestedServiceQuotaChangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRequestedServiceQuotaChangeInput>
    public typealias MOutput = OperationOutput<GetRequestedServiceQuotaChangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRequestedServiceQuotaChangeOutputError>
}

public struct GetRequestedServiceQuotaChangeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRequestedServiceQuotaChangeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRequestedServiceQuotaChangeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRequestedServiceQuotaChangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRequestedServiceQuotaChangeInput>
    public typealias MOutput = OperationOutput<GetRequestedServiceQuotaChangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRequestedServiceQuotaChangeOutputError>
}

public struct GetRequestedServiceQuotaChangeInput: Equatable {
    /// <p>The ID of the quota increase request.</p>
    public let requestId: String?

    public init (
        requestId: String? = nil
    )
    {
        self.requestId = requestId
    }
}

struct GetRequestedServiceQuotaChangeInputBody: Equatable {
    public let requestId: String?
}

extension GetRequestedServiceQuotaChangeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension GetRequestedServiceQuotaChangeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRequestedServiceQuotaChangeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRequestedServiceQuotaChangeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRequestedServiceQuotaChangeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRequestedServiceQuotaChangeOutputResponse(requestedQuota: \(String(describing: requestedQuota)))"}
}

extension GetRequestedServiceQuotaChangeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRequestedServiceQuotaChangeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestedQuota = output.requestedQuota
        } else {
            self.requestedQuota = nil
        }
    }
}

public struct GetRequestedServiceQuotaChangeOutputResponse: Equatable {
    /// <p>Information about the quota increase request.</p>
    public let requestedQuota: RequestedServiceQuotaChange?

    public init (
        requestedQuota: RequestedServiceQuotaChange? = nil
    )
    {
        self.requestedQuota = requestedQuota
    }
}

struct GetRequestedServiceQuotaChangeOutputResponseBody: Equatable {
    public let requestedQuota: RequestedServiceQuotaChange?
}

extension GetRequestedServiceQuotaChangeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestedQuota = "RequestedQuota"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedQuotaDecoded = try containerValues.decodeIfPresent(RequestedServiceQuotaChange.self, forKey: .requestedQuota)
        requestedQuota = requestedQuotaDecoded
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateInputBodyMiddleware: Middleware {
    public let id: String = "GetServiceQuotaIncreaseRequestFromTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceQuotaIncreaseRequestFromTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceQuotaIncreaseRequestFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceQuotaIncreaseRequestFromTemplateInput>
    public typealias MOutput = OperationOutput<GetServiceQuotaIncreaseRequestFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceQuotaIncreaseRequestFromTemplateOutputError>
}

extension GetServiceQuotaIncreaseRequestFromTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceQuotaIncreaseRequestFromTemplateInput(awsRegion: \(String(describing: awsRegion)), quotaCode: \(String(describing: quotaCode)), serviceCode: \(String(describing: serviceCode)))"}
}

extension GetServiceQuotaIncreaseRequestFromTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetServiceQuotaIncreaseRequestFromTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceQuotaIncreaseRequestFromTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceQuotaIncreaseRequestFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceQuotaIncreaseRequestFromTemplateInput>
    public typealias MOutput = OperationOutput<GetServiceQuotaIncreaseRequestFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceQuotaIncreaseRequestFromTemplateOutputError>
}

public struct GetServiceQuotaIncreaseRequestFromTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServiceQuotaIncreaseRequestFromTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceQuotaIncreaseRequestFromTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceQuotaIncreaseRequestFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceQuotaIncreaseRequestFromTemplateInput>
    public typealias MOutput = OperationOutput<GetServiceQuotaIncreaseRequestFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceQuotaIncreaseRequestFromTemplateOutputError>
}

public struct GetServiceQuotaIncreaseRequestFromTemplateInput: Equatable {
    /// <p>The AWS Region.</p>
    public let awsRegion: String?
    /// <p>The quota identifier.</p>
    public let quotaCode: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?

    public init (
        awsRegion: String? = nil,
        quotaCode: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct GetServiceQuotaIncreaseRequestFromTemplateInputBody: Equatable {
    public let serviceCode: String?
    public let quotaCode: String?
    public let awsRegion: String?
}

extension GetServiceQuotaIncreaseRequestFromTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceQuotaIncreaseRequestFromTemplateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceQuotaIncreaseRequestFromTemplateOutputResponse(serviceQuotaIncreaseRequestInTemplate: \(String(describing: serviceQuotaIncreaseRequestInTemplate)))"}
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServiceQuotaIncreaseRequestFromTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceQuotaIncreaseRequestInTemplate = output.serviceQuotaIncreaseRequestInTemplate
        } else {
            self.serviceQuotaIncreaseRequestInTemplate = nil
        }
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateOutputResponse: Equatable {
    /// <p>Information about the quota increase request.</p>
    public let serviceQuotaIncreaseRequestInTemplate: ServiceQuotaIncreaseRequestInTemplate?

    public init (
        serviceQuotaIncreaseRequestInTemplate: ServiceQuotaIncreaseRequestInTemplate? = nil
    )
    {
        self.serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplate
    }
}

struct GetServiceQuotaIncreaseRequestFromTemplateOutputResponseBody: Equatable {
    public let serviceQuotaIncreaseRequestInTemplate: ServiceQuotaIncreaseRequestInTemplate?
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceQuotaIncreaseRequestInTemplate = "ServiceQuotaIncreaseRequestInTemplate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaIncreaseRequestInTemplateDecoded = try containerValues.decodeIfPresent(ServiceQuotaIncreaseRequestInTemplate.self, forKey: .serviceQuotaIncreaseRequestInTemplate)
        serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplateDecoded
    }
}

public struct GetServiceQuotaInputBodyMiddleware: Middleware {
    public let id: String = "GetServiceQuotaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceQuotaInput>
    public typealias MOutput = OperationOutput<GetServiceQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceQuotaOutputError>
}

extension GetServiceQuotaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceQuotaInput(quotaCode: \(String(describing: quotaCode)), serviceCode: \(String(describing: serviceCode)))"}
}

extension GetServiceQuotaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct GetServiceQuotaInputHeadersMiddleware: Middleware {
    public let id: String = "GetServiceQuotaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceQuotaInput>
    public typealias MOutput = OperationOutput<GetServiceQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceQuotaOutputError>
}

public struct GetServiceQuotaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServiceQuotaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceQuotaInput>
    public typealias MOutput = OperationOutput<GetServiceQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceQuotaOutputError>
}

public struct GetServiceQuotaInput: Equatable {
    /// <p>The quota identifier.</p>
    public let quotaCode: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?

    public init (
        quotaCode: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct GetServiceQuotaInputBody: Equatable {
    public let serviceCode: String?
    public let quotaCode: String?
}

extension GetServiceQuotaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension GetServiceQuotaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceQuotaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceQuotaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceQuotaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceQuotaOutputResponse(quota: \(String(describing: quota)))"}
}

extension GetServiceQuotaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServiceQuotaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.quota = output.quota
        } else {
            self.quota = nil
        }
    }
}

public struct GetServiceQuotaOutputResponse: Equatable {
    /// <p>Information about the quota.</p>
    public let quota: ServiceQuota?

    public init (
        quota: ServiceQuota? = nil
    )
    {
        self.quota = quota
    }
}

struct GetServiceQuotaOutputResponseBody: Equatable {
    public let quota: ServiceQuota?
}

extension GetServiceQuotaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case quota = "Quota"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quotaDecoded = try containerValues.decodeIfPresent(ServiceQuota.self, forKey: .quota)
        quota = quotaDecoded
    }
}

extension IllegalArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IllegalArgumentException(message: \(String(describing: message)))"}
}

extension IllegalArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IllegalArgumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Invalid input was provided.</p>
public struct IllegalArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalArgumentExceptionBody: Equatable {
    public let message: String?
}

extension IllegalArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPaginationTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPaginationTokenException(message: \(String(describing: message)))"}
}

extension InvalidPaginationTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Invalid input was provided.</p>
public struct InvalidPaginationTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPaginationTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourceStateException(message: \(String(describing: message)))"}
}

extension InvalidResourceStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is in an invalid state.</p>
public struct InvalidResourceStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceStateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidResourceStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAWSDefaultServiceQuotasInputBodyMiddleware: Middleware {
    public let id: String = "ListAWSDefaultServiceQuotasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAWSDefaultServiceQuotasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAWSDefaultServiceQuotasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAWSDefaultServiceQuotasInput>
    public typealias MOutput = OperationOutput<ListAWSDefaultServiceQuotasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAWSDefaultServiceQuotasOutputError>
}

extension ListAWSDefaultServiceQuotasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAWSDefaultServiceQuotasInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ListAWSDefaultServiceQuotasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct ListAWSDefaultServiceQuotasInputHeadersMiddleware: Middleware {
    public let id: String = "ListAWSDefaultServiceQuotasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAWSDefaultServiceQuotasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAWSDefaultServiceQuotasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAWSDefaultServiceQuotasInput>
    public typealias MOutput = OperationOutput<ListAWSDefaultServiceQuotasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAWSDefaultServiceQuotasOutputError>
}

public struct ListAWSDefaultServiceQuotasInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAWSDefaultServiceQuotasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAWSDefaultServiceQuotasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAWSDefaultServiceQuotasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAWSDefaultServiceQuotasInput>
    public typealias MOutput = OperationOutput<ListAWSDefaultServiceQuotasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAWSDefaultServiceQuotasOutputError>
}

public struct ListAWSDefaultServiceQuotasInput: Equatable {
    /// <p>The maximum number of results to return with a single call. To retrieve the remaining
    ///       results, if any, make another call with the token returned from this call.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct ListAWSDefaultServiceQuotasInputBody: Equatable {
    public let serviceCode: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAWSDefaultServiceQuotasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAWSDefaultServiceQuotasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAWSDefaultServiceQuotasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAWSDefaultServiceQuotasOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAWSDefaultServiceQuotasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAWSDefaultServiceQuotasOutputResponse(nextToken: \(String(describing: nextToken)), quotas: \(String(describing: quotas)))"}
}

extension ListAWSDefaultServiceQuotasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAWSDefaultServiceQuotasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.quotas = output.quotas
        } else {
            self.nextToken = nil
            self.quotas = nil
        }
    }
}

public struct ListAWSDefaultServiceQuotasOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are
    ///       no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the quotas.</p>
    public let quotas: [ServiceQuota]?

    public init (
        nextToken: String? = nil,
        quotas: [ServiceQuota]? = nil
    )
    {
        self.nextToken = nextToken
        self.quotas = quotas
    }
}

struct ListAWSDefaultServiceQuotasOutputResponseBody: Equatable {
    public let nextToken: String?
    public let quotas: [ServiceQuota]?
}

extension ListAWSDefaultServiceQuotasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case quotas = "Quotas"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let quotasContainer = try containerValues.decodeIfPresent([ServiceQuota?].self, forKey: .quotas)
        var quotasDecoded0:[ServiceQuota]? = nil
        if let quotasContainer = quotasContainer {
            quotasDecoded0 = [ServiceQuota]()
            for structure0 in quotasContainer {
                if let structure0 = structure0 {
                    quotasDecoded0?.append(structure0)
                }
            }
        }
        quotas = quotasDecoded0
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaInputBodyMiddleware: Middleware {
    public let id: String = "ListRequestedServiceQuotaChangeHistoryByQuotaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRequestedServiceQuotaChangeHistoryByQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRequestedServiceQuotaChangeHistoryByQuotaInput>
    public typealias MOutput = OperationOutput<ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRequestedServiceQuotaChangeHistoryByQuotaOutputError>
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRequestedServiceQuotaChangeHistoryByQuotaInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), quotaCode: \(String(describing: quotaCode)), serviceCode: \(String(describing: serviceCode)), status: \(String(describing: status)))"}
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaInputHeadersMiddleware: Middleware {
    public let id: String = "ListRequestedServiceQuotaChangeHistoryByQuotaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRequestedServiceQuotaChangeHistoryByQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRequestedServiceQuotaChangeHistoryByQuotaInput>
    public typealias MOutput = OperationOutput<ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRequestedServiceQuotaChangeHistoryByQuotaOutputError>
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRequestedServiceQuotaChangeHistoryByQuotaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRequestedServiceQuotaChangeHistoryByQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRequestedServiceQuotaChangeHistoryByQuotaInput>
    public typealias MOutput = OperationOutput<ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRequestedServiceQuotaChangeHistoryByQuotaOutputError>
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaInput: Equatable {
    /// <p>The maximum number of results to return with a single call. To retrieve the remaining
    ///       results, if any, make another call with the token returned from this call.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The quota identifier.</p>
    public let quotaCode: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?
    /// <p>The status value of the quota increase request.</p>
    public let status: RequestStatus?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        quotaCode: String? = nil,
        serviceCode: String? = nil,
        status: RequestStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
        self.status = status
    }
}

struct ListRequestedServiceQuotaChangeHistoryByQuotaInputBody: Equatable {
    public let serviceCode: String?
    public let quotaCode: String?
    public let status: RequestStatus?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RequestStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRequestedServiceQuotaChangeHistoryByQuotaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse(nextToken: \(String(describing: nextToken)), requestedQuotas: \(String(describing: requestedQuotas)))"}
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.requestedQuotas = output.requestedQuotas
        } else {
            self.nextToken = nil
            self.requestedQuotas = nil
        }
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are
    ///       no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the quota increase requests.</p>
    public let requestedQuotas: [RequestedServiceQuotaChange]?

    public init (
        nextToken: String? = nil,
        requestedQuotas: [RequestedServiceQuotaChange]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestedQuotas = requestedQuotas
    }
}

struct ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponseBody: Equatable {
    public let nextToken: String?
    public let requestedQuotas: [RequestedServiceQuotaChange]?
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case requestedQuotas = "RequestedQuotas"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestedQuotasContainer = try containerValues.decodeIfPresent([RequestedServiceQuotaChange?].self, forKey: .requestedQuotas)
        var requestedQuotasDecoded0:[RequestedServiceQuotaChange]? = nil
        if let requestedQuotasContainer = requestedQuotasContainer {
            requestedQuotasDecoded0 = [RequestedServiceQuotaChange]()
            for structure0 in requestedQuotasContainer {
                if let structure0 = structure0 {
                    requestedQuotasDecoded0?.append(structure0)
                }
            }
        }
        requestedQuotas = requestedQuotasDecoded0
    }
}

public struct ListRequestedServiceQuotaChangeHistoryInputBodyMiddleware: Middleware {
    public let id: String = "ListRequestedServiceQuotaChangeHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRequestedServiceQuotaChangeHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRequestedServiceQuotaChangeHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRequestedServiceQuotaChangeHistoryInput>
    public typealias MOutput = OperationOutput<ListRequestedServiceQuotaChangeHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRequestedServiceQuotaChangeHistoryOutputError>
}

extension ListRequestedServiceQuotaChangeHistoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRequestedServiceQuotaChangeHistoryInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serviceCode: \(String(describing: serviceCode)), status: \(String(describing: status)))"}
}

extension ListRequestedServiceQuotaChangeHistoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListRequestedServiceQuotaChangeHistoryInputHeadersMiddleware: Middleware {
    public let id: String = "ListRequestedServiceQuotaChangeHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRequestedServiceQuotaChangeHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRequestedServiceQuotaChangeHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRequestedServiceQuotaChangeHistoryInput>
    public typealias MOutput = OperationOutput<ListRequestedServiceQuotaChangeHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRequestedServiceQuotaChangeHistoryOutputError>
}

public struct ListRequestedServiceQuotaChangeHistoryInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRequestedServiceQuotaChangeHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRequestedServiceQuotaChangeHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRequestedServiceQuotaChangeHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRequestedServiceQuotaChangeHistoryInput>
    public typealias MOutput = OperationOutput<ListRequestedServiceQuotaChangeHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRequestedServiceQuotaChangeHistoryOutputError>
}

public struct ListRequestedServiceQuotaChangeHistoryInput: Equatable {
    /// <p>The maximum number of results to return with a single call. To retrieve the remaining
    ///       results, if any, make another call with the token returned from this call.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?
    /// <p>The status of the quota increase request.</p>
    public let status: RequestStatus?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serviceCode: String? = nil,
        status: RequestStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
        self.status = status
    }
}

struct ListRequestedServiceQuotaChangeHistoryInputBody: Equatable {
    public let serviceCode: String?
    public let status: RequestStatus?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListRequestedServiceQuotaChangeHistoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RequestStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRequestedServiceQuotaChangeHistoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRequestedServiceQuotaChangeHistoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRequestedServiceQuotaChangeHistoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRequestedServiceQuotaChangeHistoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRequestedServiceQuotaChangeHistoryOutputResponse(nextToken: \(String(describing: nextToken)), requestedQuotas: \(String(describing: requestedQuotas)))"}
}

extension ListRequestedServiceQuotaChangeHistoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRequestedServiceQuotaChangeHistoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.requestedQuotas = output.requestedQuotas
        } else {
            self.nextToken = nil
            self.requestedQuotas = nil
        }
    }
}

public struct ListRequestedServiceQuotaChangeHistoryOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are
    ///       no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the quota increase requests.</p>
    public let requestedQuotas: [RequestedServiceQuotaChange]?

    public init (
        nextToken: String? = nil,
        requestedQuotas: [RequestedServiceQuotaChange]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestedQuotas = requestedQuotas
    }
}

struct ListRequestedServiceQuotaChangeHistoryOutputResponseBody: Equatable {
    public let nextToken: String?
    public let requestedQuotas: [RequestedServiceQuotaChange]?
}

extension ListRequestedServiceQuotaChangeHistoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case requestedQuotas = "RequestedQuotas"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestedQuotasContainer = try containerValues.decodeIfPresent([RequestedServiceQuotaChange?].self, forKey: .requestedQuotas)
        var requestedQuotasDecoded0:[RequestedServiceQuotaChange]? = nil
        if let requestedQuotasContainer = requestedQuotasContainer {
            requestedQuotasDecoded0 = [RequestedServiceQuotaChange]()
            for structure0 in requestedQuotasContainer {
                if let structure0 = structure0 {
                    requestedQuotasDecoded0?.append(structure0)
                }
            }
        }
        requestedQuotas = requestedQuotasDecoded0
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateInputBodyMiddleware: Middleware {
    public let id: String = "ListServiceQuotaIncreaseRequestsInTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceQuotaIncreaseRequestsInTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceQuotaIncreaseRequestsInTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceQuotaIncreaseRequestsInTemplateInput>
    public typealias MOutput = OperationOutput<ListServiceQuotaIncreaseRequestsInTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceQuotaIncreaseRequestsInTemplateOutputError>
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServiceQuotaIncreaseRequestsInTemplateInput(awsRegion: \(String(describing: awsRegion)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsRegion = "AwsRegion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "ListServiceQuotaIncreaseRequestsInTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceQuotaIncreaseRequestsInTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceQuotaIncreaseRequestsInTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceQuotaIncreaseRequestsInTemplateInput>
    public typealias MOutput = OperationOutput<ListServiceQuotaIncreaseRequestsInTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceQuotaIncreaseRequestsInTemplateOutputError>
}

public struct ListServiceQuotaIncreaseRequestsInTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServiceQuotaIncreaseRequestsInTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceQuotaIncreaseRequestsInTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceQuotaIncreaseRequestsInTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceQuotaIncreaseRequestsInTemplateInput>
    public typealias MOutput = OperationOutput<ListServiceQuotaIncreaseRequestsInTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceQuotaIncreaseRequestsInTemplateOutputError>
}

public struct ListServiceQuotaIncreaseRequestsInTemplateInput: Equatable {
    /// <p>The AWS Region.</p>
    public let awsRegion: String?
    /// <p>The maximum number of results to return with a single call. To retrieve the remaining
    ///       results, if any, make another call with the token returned from this call.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?

    public init (
        awsRegion: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct ListServiceQuotaIncreaseRequestsInTemplateInputBody: Equatable {
    public let serviceCode: String?
    public let awsRegion: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListServiceQuotaIncreaseRequestsInTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsRegion = "AwsRegion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceQuotaIncreaseRequestsInTemplateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case serviceException(ServiceException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServiceQuotaIncreaseRequestsInTemplateOutputResponse(nextToken: \(String(describing: nextToken)), serviceQuotaIncreaseRequestInTemplateList: \(String(describing: serviceQuotaIncreaseRequestInTemplateList)))"}
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServiceQuotaIncreaseRequestsInTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.serviceQuotaIncreaseRequestInTemplateList = output.serviceQuotaIncreaseRequestInTemplateList
        } else {
            self.nextToken = nil
            self.serviceQuotaIncreaseRequestInTemplateList = nil
        }
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are
    ///       no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the quota increase requests.</p>
    public let serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotaIncreaseRequestInTemplate]?

    public init (
        nextToken: String? = nil,
        serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotaIncreaseRequestInTemplate]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceQuotaIncreaseRequestInTemplateList = serviceQuotaIncreaseRequestInTemplateList
    }
}

struct ListServiceQuotaIncreaseRequestsInTemplateOutputResponseBody: Equatable {
    public let serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotaIncreaseRequestInTemplate]?
    public let nextToken: String?
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case serviceQuotaIncreaseRequestInTemplateList = "ServiceQuotaIncreaseRequestInTemplateList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaIncreaseRequestInTemplateListContainer = try containerValues.decodeIfPresent([ServiceQuotaIncreaseRequestInTemplate?].self, forKey: .serviceQuotaIncreaseRequestInTemplateList)
        var serviceQuotaIncreaseRequestInTemplateListDecoded0:[ServiceQuotaIncreaseRequestInTemplate]? = nil
        if let serviceQuotaIncreaseRequestInTemplateListContainer = serviceQuotaIncreaseRequestInTemplateListContainer {
            serviceQuotaIncreaseRequestInTemplateListDecoded0 = [ServiceQuotaIncreaseRequestInTemplate]()
            for structure0 in serviceQuotaIncreaseRequestInTemplateListContainer {
                if let structure0 = structure0 {
                    serviceQuotaIncreaseRequestInTemplateListDecoded0?.append(structure0)
                }
            }
        }
        serviceQuotaIncreaseRequestInTemplateList = serviceQuotaIncreaseRequestInTemplateListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListServiceQuotasInputBodyMiddleware: Middleware {
    public let id: String = "ListServiceQuotasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceQuotasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceQuotasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceQuotasInput>
    public typealias MOutput = OperationOutput<ListServiceQuotasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceQuotasOutputError>
}

extension ListServiceQuotasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServiceQuotasInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ListServiceQuotasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct ListServiceQuotasInputHeadersMiddleware: Middleware {
    public let id: String = "ListServiceQuotasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceQuotasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceQuotasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceQuotasInput>
    public typealias MOutput = OperationOutput<ListServiceQuotasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceQuotasOutputError>
}

public struct ListServiceQuotasInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServiceQuotasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceQuotasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceQuotasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceQuotasInput>
    public typealias MOutput = OperationOutput<ListServiceQuotasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceQuotasOutputError>
}

public struct ListServiceQuotasInput: Equatable {
    /// <p>The maximum number of results to return with a single call. To retrieve the remaining
    ///       results, if any, make another call with the token returned from this call.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct ListServiceQuotasInputBody: Equatable {
    public let serviceCode: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListServiceQuotasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServiceQuotasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceQuotasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceQuotasOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceQuotasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServiceQuotasOutputResponse(nextToken: \(String(describing: nextToken)), quotas: \(String(describing: quotas)))"}
}

extension ListServiceQuotasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServiceQuotasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.quotas = output.quotas
        } else {
            self.nextToken = nil
            self.quotas = nil
        }
    }
}

public struct ListServiceQuotasOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are
    ///       no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the quotas.</p>
    public let quotas: [ServiceQuota]?

    public init (
        nextToken: String? = nil,
        quotas: [ServiceQuota]? = nil
    )
    {
        self.nextToken = nextToken
        self.quotas = quotas
    }
}

struct ListServiceQuotasOutputResponseBody: Equatable {
    public let nextToken: String?
    public let quotas: [ServiceQuota]?
}

extension ListServiceQuotasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case quotas = "Quotas"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let quotasContainer = try containerValues.decodeIfPresent([ServiceQuota?].self, forKey: .quotas)
        var quotasDecoded0:[ServiceQuota]? = nil
        if let quotasContainer = quotasContainer {
            quotasDecoded0 = [ServiceQuota]()
            for structure0 in quotasContainer {
                if let structure0 = structure0 {
                    quotasDecoded0?.append(structure0)
                }
            }
        }
        quotas = quotasDecoded0
    }
}

public struct ListServicesInputBodyMiddleware: Middleware {
    public let id: String = "ListServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServicesInput>
    public typealias MOutput = OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServicesOutputError>
}

extension ListServicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServicesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListServicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListServicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServicesInput>
    public typealias MOutput = OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServicesOutputError>
}

public struct ListServicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServicesInput>
    public typealias MOutput = OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServicesOutputError>
}

public struct ListServicesInput: Equatable {
    /// <p>The maximum number of results to return with a single call. To retrieve the remaining
    ///       results, if any, make another call with the token returned from this call.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListServicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServicesOutputResponse(nextToken: \(String(describing: nextToken)), services: \(String(describing: services)))"}
}

extension ListServicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct ListServicesOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are
    ///       no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the services.</p>
    public let services: [ServiceInfo]?

    public init (
        nextToken: String? = nil,
        services: [ServiceInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

struct ListServicesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let services: [ServiceInfo]?
}

extension ListServicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let servicesContainer = try containerValues.decodeIfPresent([ServiceInfo?].self, forKey: .services)
        var servicesDecoded0:[ServiceInfo]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [ServiceInfo]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the applied quota for which you want to list tags. You
    ///       can get this information by using the Service Quotas console, or by listing the quotas using the
    ///         <a href="https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html">list-service-quotas</a> AWS CLI command or the <a href="https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html">ListServiceQuotas</a> AWS API operation.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A complex data type that contains zero or more tag elements.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MetricInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metricDimensions = "MetricDimensions"
        case metricName = "MetricName"
        case metricNamespace = "MetricNamespace"
        case metricStatisticRecommendation = "MetricStatisticRecommendation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDimensions = metricDimensions {
            var metricDimensionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metricDimensions)
            for (dictKey0, metricdimensionsmapdefinition0) in metricDimensions {
                try metricDimensionsContainer.encode(metricdimensionsmapdefinition0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricNamespace = metricNamespace {
            try encodeContainer.encode(metricNamespace, forKey: .metricNamespace)
        }
        if let metricStatisticRecommendation = metricStatisticRecommendation {
            try encodeContainer.encode(metricStatisticRecommendation, forKey: .metricStatisticRecommendation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricNamespace)
        metricNamespace = metricNamespaceDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricDimensionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .metricDimensions)
        var metricDimensionsDecoded0: [String:String]? = nil
        if let metricDimensionsContainer = metricDimensionsContainer {
            metricDimensionsDecoded0 = [String:String]()
            for (key0, metricdimensionvalue0) in metricDimensionsContainer {
                if let metricdimensionvalue0 = metricdimensionvalue0 {
                    metricDimensionsDecoded0?[key0] = metricdimensionvalue0
                }
            }
        }
        metricDimensions = metricDimensionsDecoded0
        let metricStatisticRecommendationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricStatisticRecommendation)
        metricStatisticRecommendation = metricStatisticRecommendationDecoded
    }
}

extension MetricInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricInfo(metricDimensions: \(String(describing: metricDimensions)), metricName: \(String(describing: metricName)), metricNamespace: \(String(describing: metricNamespace)), metricStatisticRecommendation: \(String(describing: metricStatisticRecommendation)))"}
}

/// <p>Information about the CloudWatch metric that reflects quota usage.</p>
public struct MetricInfo: Equatable {
    /// <p>The metric dimension. This is a name/value pair that is part of the identity of a
    ///       metric.</p>
    public let metricDimensions: [String:String]?
    /// <p>The name of the metric.</p>
    public let metricName: String?
    /// <p>The namespace of the metric.</p>
    public let metricNamespace: String?
    /// <p>The metric statistic that we recommend you use when determining quota usage.</p>
    public let metricStatisticRecommendation: String?

    public init (
        metricDimensions: [String:String]? = nil,
        metricName: String? = nil,
        metricNamespace: String? = nil,
        metricStatisticRecommendation: String? = nil
    )
    {
        self.metricDimensions = metricDimensions
        self.metricName = metricName
        self.metricNamespace = metricNamespace
        self.metricStatisticRecommendation = metricStatisticRecommendation
    }
}

extension NoAvailableOrganizationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoAvailableOrganizationException(message: \(String(describing: message)))"}
}

extension NoAvailableOrganizationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoAvailableOrganizationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The account making this call is not a member of an organization.</p>
public struct NoAvailableOrganizationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoAvailableOrganizationExceptionBody: Equatable {
    public let message: String?
}

extension NoAvailableOrganizationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchResourceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchResourceException(message: \(String(describing: message)))"}
}

extension NoSuchResourceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchResourceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource does not exist.</p>
public struct NoSuchResourceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchResourceExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchResourceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNotInAllFeaturesModeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationNotInAllFeaturesModeException(message: \(String(describing: message)))"}
}

extension OrganizationNotInAllFeaturesModeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OrganizationNotInAllFeaturesModeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The organization that your account belongs to is not in All Features mode.</p>
public struct OrganizationNotInAllFeaturesModeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationNotInAllFeaturesModeExceptionBody: Equatable {
    public let message: String?
}

extension OrganizationNotInAllFeaturesModeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum PeriodUnit {
    case day
    case hour
    case microsecond
    case millisecond
    case minute
    case second
    case week
    case sdkUnknown(String)
}

extension PeriodUnit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PeriodUnit] {
        return [
            .day,
            .hour,
            .microsecond,
            .millisecond,
            .minute,
            .second,
            .week,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .day: return "DAY"
        case .hour: return "HOUR"
        case .microsecond: return "MICROSECOND"
        case .millisecond: return "MILLISECOND"
        case .minute: return "MINUTE"
        case .second: return "SECOND"
        case .week: return "WEEK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PeriodUnit(rawValue: rawValue) ?? PeriodUnit.sdkUnknown(rawValue)
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateInputBodyMiddleware: Middleware {
    public let id: String = "PutServiceQuotaIncreaseRequestIntoTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutServiceQuotaIncreaseRequestIntoTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutServiceQuotaIncreaseRequestIntoTemplateInput>
    public typealias MOutput = OperationOutput<PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutServiceQuotaIncreaseRequestIntoTemplateOutputError>
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutServiceQuotaIncreaseRequestIntoTemplateInput(awsRegion: \(String(describing: awsRegion)), desiredValue: \(String(describing: desiredValue)), quotaCode: \(String(describing: quotaCode)), serviceCode: \(String(describing: serviceCode)))"}
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsRegion = "AwsRegion"
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let desiredValue = desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "PutServiceQuotaIncreaseRequestIntoTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutServiceQuotaIncreaseRequestIntoTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutServiceQuotaIncreaseRequestIntoTemplateInput>
    public typealias MOutput = OperationOutput<PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutServiceQuotaIncreaseRequestIntoTemplateOutputError>
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "PutServiceQuotaIncreaseRequestIntoTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutServiceQuotaIncreaseRequestIntoTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutServiceQuotaIncreaseRequestIntoTemplateInput>
    public typealias MOutput = OperationOutput<PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutServiceQuotaIncreaseRequestIntoTemplateOutputError>
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateInput: Equatable {
    /// <p>The AWS Region.</p>
    public let awsRegion: String?
    /// <p>The new, increased value for the quota.</p>
    public let desiredValue: Double?
    /// <p>The quota identifier.</p>
    public let quotaCode: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?

    public init (
        awsRegion: String? = nil,
        desiredValue: Double? = nil,
        quotaCode: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.desiredValue = desiredValue
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct PutServiceQuotaIncreaseRequestIntoTemplateInputBody: Equatable {
    public let quotaCode: String?
    public let serviceCode: String?
    public let awsRegion: String?
    public let desiredValue: Double?
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsRegion = "AwsRegion"
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuotaExceededException" : self = .quotaExceededException(try QuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutServiceQuotaIncreaseRequestIntoTemplateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case noSuchResourceException(NoSuchResourceException)
    case quotaExceededException(QuotaExceededException)
    case serviceException(ServiceException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse(serviceQuotaIncreaseRequestInTemplate: \(String(describing: serviceQuotaIncreaseRequestInTemplate)))"}
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutServiceQuotaIncreaseRequestIntoTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceQuotaIncreaseRequestInTemplate = output.serviceQuotaIncreaseRequestInTemplate
        } else {
            self.serviceQuotaIncreaseRequestInTemplate = nil
        }
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse: Equatable {
    /// <p>Information about the quota increase request.</p>
    public let serviceQuotaIncreaseRequestInTemplate: ServiceQuotaIncreaseRequestInTemplate?

    public init (
        serviceQuotaIncreaseRequestInTemplate: ServiceQuotaIncreaseRequestInTemplate? = nil
    )
    {
        self.serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplate
    }
}

struct PutServiceQuotaIncreaseRequestIntoTemplateOutputResponseBody: Equatable {
    public let serviceQuotaIncreaseRequestInTemplate: ServiceQuotaIncreaseRequestInTemplate?
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceQuotaIncreaseRequestInTemplate = "ServiceQuotaIncreaseRequestInTemplate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaIncreaseRequestInTemplateDecoded = try containerValues.decodeIfPresent(ServiceQuotaIncreaseRequestInTemplate.self, forKey: .serviceQuotaIncreaseRequestInTemplate)
        serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplateDecoded
    }
}

extension QuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuotaExceededException(message: \(String(describing: message)))"}
}

extension QuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: QuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded your service quota. To perform the requested action, remove some of the
///       relevant resources, or use Service Quotas to request a service quota increase.</p>
public struct QuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct QuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension QuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QuotaPeriod: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case periodUnit = "PeriodUnit"
        case periodValue = "PeriodValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let periodUnit = periodUnit {
            try encodeContainer.encode(periodUnit.rawValue, forKey: .periodUnit)
        }
        if let periodValue = periodValue {
            try encodeContainer.encode(periodValue, forKey: .periodValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let periodValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .periodValue)
        periodValue = periodValueDecoded
        let periodUnitDecoded = try containerValues.decodeIfPresent(PeriodUnit.self, forKey: .periodUnit)
        periodUnit = periodUnitDecoded
    }
}

extension QuotaPeriod: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuotaPeriod(periodUnit: \(String(describing: periodUnit)), periodValue: \(String(describing: periodValue)))"}
}

/// <p>Information about the quota period.</p>
public struct QuotaPeriod: Equatable {
    /// <p>The time unit.</p>
    public let periodUnit: PeriodUnit?
    /// <p>The value.</p>
    public let periodValue: Int?

    public init (
        periodUnit: PeriodUnit? = nil,
        periodValue: Int? = nil
    )
    {
        self.periodUnit = periodUnit
        self.periodValue = periodValue
    }
}

public struct RequestServiceQuotaIncreaseInputBodyMiddleware: Middleware {
    public let id: String = "RequestServiceQuotaIncreaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RequestServiceQuotaIncreaseInput>,
                  next: H) -> Swift.Result<OperationOutput<RequestServiceQuotaIncreaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RequestServiceQuotaIncreaseInput>
    public typealias MOutput = OperationOutput<RequestServiceQuotaIncreaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RequestServiceQuotaIncreaseOutputError>
}

extension RequestServiceQuotaIncreaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestServiceQuotaIncreaseInput(desiredValue: \(String(describing: desiredValue)), quotaCode: \(String(describing: quotaCode)), serviceCode: \(String(describing: serviceCode)))"}
}

extension RequestServiceQuotaIncreaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredValue = desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct RequestServiceQuotaIncreaseInputHeadersMiddleware: Middleware {
    public let id: String = "RequestServiceQuotaIncreaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RequestServiceQuotaIncreaseInput>,
                  next: H) -> Swift.Result<OperationOutput<RequestServiceQuotaIncreaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RequestServiceQuotaIncreaseInput>
    public typealias MOutput = OperationOutput<RequestServiceQuotaIncreaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RequestServiceQuotaIncreaseOutputError>
}

public struct RequestServiceQuotaIncreaseInputQueryItemMiddleware: Middleware {
    public let id: String = "RequestServiceQuotaIncreaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RequestServiceQuotaIncreaseInput>,
                  next: H) -> Swift.Result<OperationOutput<RequestServiceQuotaIncreaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RequestServiceQuotaIncreaseInput>
    public typealias MOutput = OperationOutput<RequestServiceQuotaIncreaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RequestServiceQuotaIncreaseOutputError>
}

public struct RequestServiceQuotaIncreaseInput: Equatable {
    /// <p>The new, increased value for the quota.</p>
    public let desiredValue: Double?
    /// <p>The quota identifier.</p>
    public let quotaCode: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?

    public init (
        desiredValue: Double? = nil,
        quotaCode: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.desiredValue = desiredValue
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct RequestServiceQuotaIncreaseInputBody: Equatable {
    public let serviceCode: String?
    public let quotaCode: String?
    public let desiredValue: Double?
}

extension RequestServiceQuotaIncreaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
    }
}

extension RequestServiceQuotaIncreaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RequestServiceQuotaIncreaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuotaExceededException" : self = .quotaExceededException(try QuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RequestServiceQuotaIncreaseOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case invalidResourceStateException(InvalidResourceStateException)
    case noSuchResourceException(NoSuchResourceException)
    case quotaExceededException(QuotaExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RequestServiceQuotaIncreaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestServiceQuotaIncreaseOutputResponse(requestedQuota: \(String(describing: requestedQuota)))"}
}

extension RequestServiceQuotaIncreaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestServiceQuotaIncreaseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestedQuota = output.requestedQuota
        } else {
            self.requestedQuota = nil
        }
    }
}

public struct RequestServiceQuotaIncreaseOutputResponse: Equatable {
    /// <p>Information about the quota increase request.</p>
    public let requestedQuota: RequestedServiceQuotaChange?

    public init (
        requestedQuota: RequestedServiceQuotaChange? = nil
    )
    {
        self.requestedQuota = requestedQuota
    }
}

struct RequestServiceQuotaIncreaseOutputResponseBody: Equatable {
    public let requestedQuota: RequestedServiceQuotaChange?
}

extension RequestServiceQuotaIncreaseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestedQuota = "RequestedQuota"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedQuotaDecoded = try containerValues.decodeIfPresent(RequestedServiceQuotaChange.self, forKey: .requestedQuota)
        requestedQuota = requestedQuotaDecoded
    }
}

public enum RequestStatus {
    case approved
    case caseClosed
    case caseOpened
    case denied
    case pending
    case sdkUnknown(String)
}

extension RequestStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RequestStatus] {
        return [
            .approved,
            .caseClosed,
            .caseOpened,
            .denied,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approved: return "APPROVED"
        case .caseClosed: return "CASE_CLOSED"
        case .caseOpened: return "CASE_OPENED"
        case .denied: return "DENIED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RequestStatus(rawValue: rawValue) ?? RequestStatus.sdkUnknown(rawValue)
    }
}

extension RequestedServiceQuotaChange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case caseId = "CaseId"
        case created = "Created"
        case desiredValue = "DesiredValue"
        case globalQuota = "GlobalQuota"
        case id = "Id"
        case lastUpdated = "LastUpdated"
        case quotaArn = "QuotaArn"
        case quotaCode = "QuotaCode"
        case quotaName = "QuotaName"
        case requester = "Requester"
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
        case status = "Status"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let desiredValue = desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if globalQuota != false {
            try encodeContainer.encode(globalQuota, forKey: .globalQuota)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let quotaArn = quotaArn {
            try encodeContainer.encode(quotaArn, forKey: .quotaArn)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaName = quotaName {
            try encodeContainer.encode(quotaName, forKey: .quotaName)
        }
        if let requester = requester {
            try encodeContainer.encode(requester, forKey: .requester)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let caseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RequestStatus.self, forKey: .status)
        status = statusDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let requesterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requester)
        requester = requesterDecoded
        let quotaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaArn)
        quotaArn = quotaArnDecoded
        let globalQuotaDecoded = try containerValues.decode(Bool.self, forKey: .globalQuota)
        globalQuota = globalQuotaDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension RequestedServiceQuotaChange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestedServiceQuotaChange(caseId: \(String(describing: caseId)), created: \(String(describing: created)), desiredValue: \(String(describing: desiredValue)), globalQuota: \(String(describing: globalQuota)), id: \(String(describing: id)), lastUpdated: \(String(describing: lastUpdated)), quotaArn: \(String(describing: quotaArn)), quotaCode: \(String(describing: quotaCode)), quotaName: \(String(describing: quotaName)), requester: \(String(describing: requester)), serviceCode: \(String(describing: serviceCode)), serviceName: \(String(describing: serviceName)), status: \(String(describing: status)), unit: \(String(describing: unit)))"}
}

/// <p>Information about a quota increase request.</p>
public struct RequestedServiceQuotaChange: Equatable {
    /// <p>The case ID.</p>
    public let caseId: String?
    /// <p>The date and time when the quota increase request was received and the case ID was
    ///       created.</p>
    public let created: Date?
    /// <p>The new, increased value for the quota.</p>
    public let desiredValue: Double?
    /// <p>Indicates whether the quota is global.</p>
    public let globalQuota: Bool
    /// <p>The unique identifier.</p>
    public let id: String?
    /// <p>The date and time of the most recent change.</p>
    public let lastUpdated: Date?
    /// <p>The Amazon Resource Name (ARN) of the quota.</p>
    public let quotaArn: String?
    /// <p>The quota identifier.</p>
    public let quotaCode: String?
    /// <p>The quota name.</p>
    public let quotaName: String?
    /// <p>The IAM identity of the requester.</p>
    public let requester: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?
    /// <p>The service name.</p>
    public let serviceName: String?
    /// <p>The state of the quota increase request.</p>
    public let status: RequestStatus?
    /// <p>The unit of measurement.</p>
    public let unit: String?

    public init (
        caseId: String? = nil,
        created: Date? = nil,
        desiredValue: Double? = nil,
        globalQuota: Bool = false,
        id: String? = nil,
        lastUpdated: Date? = nil,
        quotaArn: String? = nil,
        quotaCode: String? = nil,
        quotaName: String? = nil,
        requester: String? = nil,
        serviceCode: String? = nil,
        serviceName: String? = nil,
        status: RequestStatus? = nil,
        unit: String? = nil
    )
    {
        self.caseId = caseId
        self.created = created
        self.desiredValue = desiredValue
        self.globalQuota = globalQuota
        self.id = id
        self.lastUpdated = lastUpdated
        self.quotaArn = quotaArn
        self.quotaCode = quotaCode
        self.quotaName = quotaName
        self.requester = requester
        self.serviceCode = serviceCode
        self.serviceName = serviceName
        self.status = status
        self.unit = unit
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceException(message: \(String(describing: message)))"}
}

extension ServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Something went wrong.</p>
public struct ServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceExceptionBody: Equatable {
    public let message: String?
}

extension ServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension ServiceInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceInfo(serviceCode: \(String(describing: serviceCode)), serviceName: \(String(describing: serviceName)))"}
}

/// <p>Information about a service.</p>
public struct ServiceInfo: Equatable {
    /// <p>The service identifier.</p>
    public let serviceCode: String?
    /// <p>The service name.</p>
    public let serviceName: String?

    public init (
        serviceCode: String? = nil,
        serviceName: String? = nil
    )
    {
        self.serviceCode = serviceCode
        self.serviceName = serviceName
    }
}

extension ServiceQuota: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adjustable = "Adjustable"
        case errorReason = "ErrorReason"
        case globalQuota = "GlobalQuota"
        case period = "Period"
        case quotaArn = "QuotaArn"
        case quotaCode = "QuotaCode"
        case quotaName = "QuotaName"
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
        case unit = "Unit"
        case usageMetric = "UsageMetric"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if adjustable != false {
            try encodeContainer.encode(adjustable, forKey: .adjustable)
        }
        if let errorReason = errorReason {
            try encodeContainer.encode(errorReason, forKey: .errorReason)
        }
        if globalQuota != false {
            try encodeContainer.encode(globalQuota, forKey: .globalQuota)
        }
        if let period = period {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let quotaArn = quotaArn {
            try encodeContainer.encode(quotaArn, forKey: .quotaArn)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaName = quotaName {
            try encodeContainer.encode(quotaName, forKey: .quotaName)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let usageMetric = usageMetric {
            try encodeContainer.encode(usageMetric, forKey: .usageMetric)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let quotaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaArn)
        quotaArn = quotaArnDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
        let adjustableDecoded = try containerValues.decode(Bool.self, forKey: .adjustable)
        adjustable = adjustableDecoded
        let globalQuotaDecoded = try containerValues.decode(Bool.self, forKey: .globalQuota)
        globalQuota = globalQuotaDecoded
        let usageMetricDecoded = try containerValues.decodeIfPresent(MetricInfo.self, forKey: .usageMetric)
        usageMetric = usageMetricDecoded
        let periodDecoded = try containerValues.decodeIfPresent(QuotaPeriod.self, forKey: .period)
        period = periodDecoded
        let errorReasonDecoded = try containerValues.decodeIfPresent(ErrorReason.self, forKey: .errorReason)
        errorReason = errorReasonDecoded
    }
}

extension ServiceQuota: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuota(adjustable: \(String(describing: adjustable)), errorReason: \(String(describing: errorReason)), globalQuota: \(String(describing: globalQuota)), period: \(String(describing: period)), quotaArn: \(String(describing: quotaArn)), quotaCode: \(String(describing: quotaCode)), quotaName: \(String(describing: quotaName)), serviceCode: \(String(describing: serviceCode)), serviceName: \(String(describing: serviceName)), unit: \(String(describing: unit)), usageMetric: \(String(describing: usageMetric)), value: \(String(describing: value)))"}
}

/// <p>Information about a quota.</p>
public struct ServiceQuota: Equatable {
    /// <p>Indicates whether the quota value can be increased.</p>
    public let adjustable: Bool
    /// <p>The error code and error reason.</p>
    public let errorReason: ErrorReason?
    /// <p>Indicates whether the quota is global.</p>
    public let globalQuota: Bool
    /// <p>The period of time.</p>
    public let period: QuotaPeriod?
    /// <p>The Amazon Resource Name (ARN) of the quota.</p>
    public let quotaArn: String?
    /// <p>The quota identifier.</p>
    public let quotaCode: String?
    /// <p>The quota name.</p>
    public let quotaName: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?
    /// <p>The service name.</p>
    public let serviceName: String?
    /// <p>The unit of measurement.</p>
    public let unit: String?
    /// <p>Information about the measurement.</p>
    public let usageMetric: MetricInfo?
    /// <p>The quota value.</p>
    public let value: Double?

    public init (
        adjustable: Bool = false,
        errorReason: ErrorReason? = nil,
        globalQuota: Bool = false,
        period: QuotaPeriod? = nil,
        quotaArn: String? = nil,
        quotaCode: String? = nil,
        quotaName: String? = nil,
        serviceCode: String? = nil,
        serviceName: String? = nil,
        unit: String? = nil,
        usageMetric: MetricInfo? = nil,
        value: Double? = nil
    )
    {
        self.adjustable = adjustable
        self.errorReason = errorReason
        self.globalQuota = globalQuota
        self.period = period
        self.quotaArn = quotaArn
        self.quotaCode = quotaCode
        self.quotaName = quotaName
        self.serviceCode = serviceCode
        self.serviceName = serviceName
        self.unit = unit
        self.usageMetric = usageMetric
        self.value = value
    }
}

extension ServiceQuotaIncreaseRequestInTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsRegion = "AwsRegion"
        case desiredValue = "DesiredValue"
        case globalQuota = "GlobalQuota"
        case quotaCode = "QuotaCode"
        case quotaName = "QuotaName"
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let desiredValue = desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if globalQuota != false {
            try encodeContainer.encode(globalQuota, forKey: .globalQuota)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaName = quotaName {
            try encodeContainer.encode(quotaName, forKey: .quotaName)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
        let globalQuotaDecoded = try containerValues.decode(Bool.self, forKey: .globalQuota)
        globalQuota = globalQuotaDecoded
    }
}

extension ServiceQuotaIncreaseRequestInTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaIncreaseRequestInTemplate(awsRegion: \(String(describing: awsRegion)), desiredValue: \(String(describing: desiredValue)), globalQuota: \(String(describing: globalQuota)), quotaCode: \(String(describing: quotaCode)), quotaName: \(String(describing: quotaName)), serviceCode: \(String(describing: serviceCode)), serviceName: \(String(describing: serviceName)), unit: \(String(describing: unit)))"}
}

/// <p>Information about a quota increase request.</p>
public struct ServiceQuotaIncreaseRequestInTemplate: Equatable {
    /// <p>The AWS Region.</p>
    public let awsRegion: String?
    /// <p>The new, increased value of the quota.</p>
    public let desiredValue: Double?
    /// <p>Indicates whether the quota is global.</p>
    public let globalQuota: Bool
    /// <p>The quota identifier.</p>
    public let quotaCode: String?
    /// <p>The quota name.</p>
    public let quotaName: String?
    /// <p>The service identifier.</p>
    public let serviceCode: String?
    /// <p>The service name.</p>
    public let serviceName: String?
    /// <p>The unit of measurement.</p>
    public let unit: String?

    public init (
        awsRegion: String? = nil,
        desiredValue: Double? = nil,
        globalQuota: Bool = false,
        quotaCode: String? = nil,
        quotaName: String? = nil,
        serviceCode: String? = nil,
        serviceName: String? = nil,
        unit: String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.desiredValue = desiredValue
        self.globalQuota = globalQuota
        self.quotaCode = quotaCode
        self.quotaName = quotaName
        self.serviceCode = serviceCode
        self.serviceName = serviceName
        self.unit = unit
    }
}

public enum ServiceQuotaTemplateAssociationStatus {
    case associated
    case disassociated
    case sdkUnknown(String)
}

extension ServiceQuotaTemplateAssociationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceQuotaTemplateAssociationStatus] {
        return [
            .associated,
            .disassociated,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .associated: return "ASSOCIATED"
        case .disassociated: return "DISASSOCIATED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceQuotaTemplateAssociationStatus(rawValue: rawValue) ?? ServiceQuotaTemplateAssociationStatus.sdkUnknown(rawValue)
    }
}

extension ServiceQuotaTemplateNotInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaTemplateNotInUseException(message: \(String(describing: message)))"}
}

extension ServiceQuotaTemplateNotInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaTemplateNotInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota request template is not associated with your organization.</p>
public struct ServiceQuotaTemplateNotInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaTemplateNotInUseExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaTemplateNotInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A complex data type that contains a tag key and tag value.</p>
public struct Tag: Equatable {
    /// <p>A string that contains a tag key. The string length should be between 1 and 128
    ///       characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . :
    ///       / = + @.</p>
    public let key: String?
    /// <p>A string that contains an optional tag value. The string length should be between 0 and
    ///       256 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ -
    ///       . : / = + @.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagPolicyViolationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagPolicyViolationException(message: \(String(describing: message)))"}
}

extension TagPolicyViolationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagPolicyViolationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified tag is a reserved word and cannot be used.</p>
public struct TagPolicyViolationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagPolicyViolationExceptionBody: Equatable {
    public let message: String?
}

extension TagPolicyViolationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for inputtags0 in tags {
                try tagsContainer.encode(inputtags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the applied quota. You can get this information by
    ///       using the Service Quotas console, or by listing the quotas using the <a href="https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html">list-service-quotas</a> AWS CLI command or the <a href="https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html">ListServiceQuotas</a> AWS API operation.</p>
    public let resourceARN: String?
    /// <p>The tags that you want to add to the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyViolationException" : self = .tagPolicyViolationException(try TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tagPolicyViolationException(TagPolicyViolationException)
    case tooManyRequestsException(TooManyRequestsException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TemplatesNotAvailableInRegionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplatesNotAvailableInRegionException(message: \(String(describing: message)))"}
}

extension TemplatesNotAvailableInRegionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TemplatesNotAvailableInRegionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Service Quotas template is not available in this AWS Region.</p>
public struct TemplatesNotAvailableInRegionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TemplatesNotAvailableInRegionExceptionBody: Equatable {
    public let message: String?
}

extension TemplatesNotAvailableInRegionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request
///       an increase for this quota.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've exceeded the number of tags allowed for a resource. For more information, see
///         <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/sq-tagging.html#sq-tagging-restrictions">Tag
///         restrictions</a> in the <i>Service Quotas User Guide</i>.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for inputtagkeys0 in tagKeys {
                try tagKeysContainer.encode(inputtagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the applied quota that you want to untag. You can get
    ///       this information by using the Service Quotas console, or by listing the quotas using the <a href="https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html">list-service-quotas</a> AWS CLI command or the <a href="https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html">ListServiceQuotas</a> AWS API operation.</p>
    public let resourceARN: String?
    /// <p>The keys of the tags that you want to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
