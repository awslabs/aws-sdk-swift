// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessPoliciesStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let options = options {
            try container.encode(options, forKey: Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AccessPoliciesStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessPoliciesStatus(options: \(String(describing: options)), status: \(String(describing: status)))"}
}

/// <p>The configured access rules for the domain's document and search endpoints, and the current status of those rules.</p>
public struct AccessPoliciesStatus: Equatable {
    /// <p>Access rules for a domain's document or search service endpoints. For more information, see <a href="http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-access.html" target="_blank">Configuring Access for a Search Domain</a> in the <i>Amazon CloudSearch Developer Guide</i>. The maximum size of a policy document is 100 KB.</p>
    public let options: String?
    /// <p>The status of domain configuration option.</p>
    public let status: OptionStatus?

    public init (
        options: String? = nil,
        status: OptionStatus? = nil
    )
    {
        self.options = options
        self.status = status
    }
}

public enum AlgorithmicStemming {
    case full
    case light
    case minimal
    case `none`
    case sdkUnknown(String)
}

extension AlgorithmicStemming : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AlgorithmicStemming] {
        return [
            .full,
            .light,
            .minimal,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .full: return "full"
        case .light: return "light"
        case .minimal: return "minimal"
        case .none: return "none"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AlgorithmicStemming(rawValue: rawValue) ?? AlgorithmicStemming.sdkUnknown(rawValue)
    }
}

extension AnalysisOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case algorithmicStemming = "AlgorithmicStemming"
        case japaneseTokenizationDictionary = "JapaneseTokenizationDictionary"
        case stemmingDictionary = "StemmingDictionary"
        case stopwords = "Stopwords"
        case synonyms = "Synonyms"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let algorithmicStemming = algorithmicStemming {
            try container.encode(algorithmicStemming, forKey: Key("AlgorithmicStemming"))
        }
        if let japaneseTokenizationDictionary = japaneseTokenizationDictionary {
            try container.encode(japaneseTokenizationDictionary, forKey: Key("JapaneseTokenizationDictionary"))
        }
        if let stemmingDictionary = stemmingDictionary {
            try container.encode(stemmingDictionary, forKey: Key("StemmingDictionary"))
        }
        if let stopwords = stopwords {
            try container.encode(stopwords, forKey: Key("Stopwords"))
        }
        if let synonyms = synonyms {
            try container.encode(synonyms, forKey: Key("Synonyms"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let synonymsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .synonyms)
        synonyms = synonymsDecoded
        let stopwordsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stopwords)
        stopwords = stopwordsDecoded
        let stemmingDictionaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stemmingDictionary)
        stemmingDictionary = stemmingDictionaryDecoded
        let japaneseTokenizationDictionaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .japaneseTokenizationDictionary)
        japaneseTokenizationDictionary = japaneseTokenizationDictionaryDecoded
        let algorithmicStemmingDecoded = try containerValues.decodeIfPresent(AlgorithmicStemming.self, forKey: .algorithmicStemming)
        algorithmicStemming = algorithmicStemmingDecoded
    }
}

extension AnalysisOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalysisOptions(algorithmicStemming: \(String(describing: algorithmicStemming)), japaneseTokenizationDictionary: \(String(describing: japaneseTokenizationDictionary)), stemmingDictionary: \(String(describing: stemmingDictionary)), stopwords: \(String(describing: stopwords)), synonyms: \(String(describing: synonyms)))"}
}

/// <p>Synonyms, stopwords, and stemming options for an analysis scheme. Includes tokenization dictionary for Japanese.</p>
public struct AnalysisOptions: Equatable {
    /// <p>The level of algorithmic stemming to perform: <code>none</code>, <code>minimal</code>, <code>light</code>, or <code>full</code>. The available levels vary depending on the language. For more information, see <a href="http://docs.aws.amazon.com/cloudsearch/latest/developerguide/text-processing.html#text-processing-settings" target="_blank">Language Specific Text Processing Settings</a> in the <i>Amazon CloudSearch Developer Guide</i> </p>
    public let algorithmicStemming: AlgorithmicStemming?
    /// <p>A JSON array that contains a collection of terms, tokens, readings and part of speech for Japanese Tokenizaiton. The Japanese tokenization dictionary enables you to override the default tokenization for selected terms. This is only valid for Japanese language fields.</p>
    public let japaneseTokenizationDictionary: String?
    /// <p>A JSON object that contains a collection of string:value pairs that each map a term to its stem. For example, <code>{"term1": "stem1", "term2": "stem2", "term3": "stem3"}</code>. The stemming dictionary is applied in addition to any algorithmic stemming. This enables you to override the results of the algorithmic stemming to correct specific cases of overstemming or understemming. The maximum size of a stemming dictionary is 500 KB.</p>
    public let stemmingDictionary: String?
    /// <p>A  JSON array of terms to ignore during indexing and searching. For example, <code>["a", "an", "the", "of"]</code>. The stopwords dictionary must explicitly list each word you want to ignore. Wildcards and regular expressions are not supported. </p>
    public let stopwords: String?
    /// <p>A JSON object that defines synonym groups and aliases. A synonym group is an array of arrays, where each sub-array is a group of terms where each term in the group is considered a synonym of every other term in the group. The aliases value is an object that contains a collection of string:value pairs where the string specifies a term and the array of values specifies each of the aliases for that term. An alias is considered a synonym of the specified term, but the term is not considered a synonym of the alias. For more information about specifying synonyms, see <a href="http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-analysis-schemes.html#synonyms">Synonyms</a> in the <i>Amazon CloudSearch Developer Guide</i>.</p>
    public let synonyms: String?

    public init (
        algorithmicStemming: AlgorithmicStemming? = nil,
        japaneseTokenizationDictionary: String? = nil,
        stemmingDictionary: String? = nil,
        stopwords: String? = nil,
        synonyms: String? = nil
    )
    {
        self.algorithmicStemming = algorithmicStemming
        self.japaneseTokenizationDictionary = japaneseTokenizationDictionary
        self.stemmingDictionary = stemmingDictionary
        self.stopwords = stopwords
        self.synonyms = synonyms
    }
}

extension AnalysisScheme: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analysisOptions = "AnalysisOptions"
        case analysisSchemeLanguage = "AnalysisSchemeLanguage"
        case analysisSchemeName = "AnalysisSchemeName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let analysisOptions = analysisOptions {
            try container.encode(analysisOptions, forKey: Key("AnalysisOptions"))
        }
        if let analysisSchemeLanguage = analysisSchemeLanguage {
            try container.encode(analysisSchemeLanguage, forKey: Key("AnalysisSchemeLanguage"))
        }
        if let analysisSchemeName = analysisSchemeName {
            try container.encode(analysisSchemeName, forKey: Key("AnalysisSchemeName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisSchemeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisSchemeName)
        analysisSchemeName = analysisSchemeNameDecoded
        let analysisSchemeLanguageDecoded = try containerValues.decodeIfPresent(AnalysisSchemeLanguage.self, forKey: .analysisSchemeLanguage)
        analysisSchemeLanguage = analysisSchemeLanguageDecoded
        let analysisOptionsDecoded = try containerValues.decodeIfPresent(AnalysisOptions.self, forKey: .analysisOptions)
        analysisOptions = analysisOptionsDecoded
    }
}

extension AnalysisScheme: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalysisScheme(analysisOptions: \(String(describing: analysisOptions)), analysisSchemeLanguage: \(String(describing: analysisSchemeLanguage)), analysisSchemeName: \(String(describing: analysisSchemeName)))"}
}

/// <p>Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: <code>Synonyms</code>, <code>Stopwords</code>, <code>StemmingDictionary</code>, <code>JapaneseTokenizationDictionary</code> and <code>AlgorithmicStemming</code>.</p>
public struct AnalysisScheme: Equatable {
    /// <p>Synonyms, stopwords, and stemming options for an analysis scheme. Includes tokenization dictionary for Japanese.</p>
    public let analysisOptions: AnalysisOptions?
    /// <p>An <a href="http://tools.ietf.org/html/rfc4646" target="_blank">IETF RFC 4646</a> language code or <code>mul</code>  for multiple languages.</p>
    public let analysisSchemeLanguage: AnalysisSchemeLanguage?
    /// <p>Names must begin with a letter and can contain the following characters:
    ///       a-z (lowercase), 0-9, and _ (underscore).</p>
    public let analysisSchemeName: String?

    public init (
        analysisOptions: AnalysisOptions? = nil,
        analysisSchemeLanguage: AnalysisSchemeLanguage? = nil,
        analysisSchemeName: String? = nil
    )
    {
        self.analysisOptions = analysisOptions
        self.analysisSchemeLanguage = analysisSchemeLanguage
        self.analysisSchemeName = analysisSchemeName
    }
}

/// <p>An <a href="http://tools.ietf.org/html/rfc4646" target="_blank">IETF RFC 4646</a> language code or <code>mul</code>  for multiple languages.</p>
public enum AnalysisSchemeLanguage {
    case ar
    case bg
    case ca
    case cs
    case da
    case de
    case el
    case en
    case es
    case eu
    case fa
    case fi
    case fr
    case ga
    case gl
    case he
    case hi
    case hu
    case hy
    case id
    case it
    case ja
    case ko
    case lv
    case mul
    case nl
    case no
    case pt
    case ro
    case ru
    case sv
    case th
    case tr
    case zhHans
    case zhHant
    case sdkUnknown(String)
}

extension AnalysisSchemeLanguage : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnalysisSchemeLanguage] {
        return [
            .ar,
            .bg,
            .ca,
            .cs,
            .da,
            .de,
            .el,
            .en,
            .es,
            .eu,
            .fa,
            .fi,
            .fr,
            .ga,
            .gl,
            .he,
            .hi,
            .hu,
            .hy,
            .id,
            .it,
            .ja,
            .ko,
            .lv,
            .mul,
            .nl,
            .no,
            .pt,
            .ro,
            .ru,
            .sv,
            .th,
            .tr,
            .zhHans,
            .zhHant,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ar: return "ar"
        case .bg: return "bg"
        case .ca: return "ca"
        case .cs: return "cs"
        case .da: return "da"
        case .de: return "de"
        case .el: return "el"
        case .en: return "en"
        case .es: return "es"
        case .eu: return "eu"
        case .fa: return "fa"
        case .fi: return "fi"
        case .fr: return "fr"
        case .ga: return "ga"
        case .gl: return "gl"
        case .he: return "he"
        case .hi: return "hi"
        case .hu: return "hu"
        case .hy: return "hy"
        case .id: return "id"
        case .it: return "it"
        case .ja: return "ja"
        case .ko: return "ko"
        case .lv: return "lv"
        case .mul: return "mul"
        case .nl: return "nl"
        case .no: return "no"
        case .pt: return "pt"
        case .ro: return "ro"
        case .ru: return "ru"
        case .sv: return "sv"
        case .th: return "th"
        case .tr: return "tr"
        case .zhHans: return "zh-Hans"
        case .zhHant: return "zh-Hant"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnalysisSchemeLanguage(rawValue: rawValue) ?? AnalysisSchemeLanguage.sdkUnknown(rawValue)
    }
}

extension AnalysisSchemeStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let options = options {
            try container.encode(options, forKey: Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(AnalysisScheme.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AnalysisSchemeStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalysisSchemeStatus(options: \(String(describing: options)), status: \(String(describing: status)))"}
}

/// <p>The status and configuration of an  <code>AnalysisScheme</code>.</p>
public struct AnalysisSchemeStatus: Equatable {
    /// <p>Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: <code>Synonyms</code>, <code>Stopwords</code>, <code>StemmingDictionary</code>, <code>JapaneseTokenizationDictionary</code> and <code>AlgorithmicStemming</code>.</p>
    public let options: AnalysisScheme?
    /// <p>The status of domain configuration option.</p>
    public let status: OptionStatus?

    public init (
        options: AnalysisScheme? = nil,
        status: OptionStatus? = nil
    )
    {
        self.options = options
        self.status = status
    }
}

extension AvailabilityOptionsStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if options != false {
            try container.encode(options, forKey: Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decode(Bool.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AvailabilityOptionsStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailabilityOptionsStatus(options: \(String(describing: options)), status: \(String(describing: status)))"}
}

/// <p>The status and configuration of the domain's availability options.</p>
public struct AvailabilityOptionsStatus: Equatable {
    /// <p>The availability options configured for the domain.</p>
    public let options: Bool
    /// <p>The status of domain configuration option.</p>
    public let status: OptionStatus?

    public init (
        options: Bool = false,
        status: OptionStatus? = nil
    )
    {
        self.options = options
        self.status = status
    }
}

extension BaseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BaseException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension BaseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<BaseExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occurred while processing the request.</p>
public struct BaseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A machine-parsable string error or warning code.</p>
    public var code: String?
    /// <p>A human-readable string error or warning message.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BaseExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension BaseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct BuildSuggestersInputBodyMiddleware: Middleware {
    public let id: String = "BuildSuggestersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BuildSuggestersInput>,
                  next: H) -> Swift.Result<OperationOutput<BuildSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BuildSuggestersInput>
    public typealias MOutput = OperationOutput<BuildSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BuildSuggestersOutputError>
}

extension BuildSuggestersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildSuggestersInput(domainName: \(String(describing: domainName)))"}
}

extension BuildSuggestersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("BuildSuggesters", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct BuildSuggestersInputHeadersMiddleware: Middleware {
    public let id: String = "BuildSuggestersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BuildSuggestersInput>,
                  next: H) -> Swift.Result<OperationOutput<BuildSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BuildSuggestersInput>
    public typealias MOutput = OperationOutput<BuildSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BuildSuggestersOutputError>
}

public struct BuildSuggestersInputQueryItemMiddleware: Middleware {
    public let id: String = "BuildSuggestersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BuildSuggestersInput>,
                  next: H) -> Swift.Result<OperationOutput<BuildSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BuildSuggestersInput>
    public typealias MOutput = OperationOutput<BuildSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BuildSuggestersOutputError>
}

/// <p>Container for the parameters to the <code><a>BuildSuggester</a></code> operation. Specifies the name of the domain you want to update.</p>
public struct BuildSuggestersInput: Equatable {
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension BuildSuggestersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension BuildSuggestersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BuildSuggestersOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BuildSuggestersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildSuggestersOutputResponse(fieldNames: \(String(describing: fieldNames)))"}
}

extension BuildSuggestersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BuildSuggestersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fieldNames = output.fieldNames
        } else {
            self.fieldNames = nil
        }
    }
}

/// <p>The result of a <code>BuildSuggester</code> request. Contains a list of the fields used for suggestions.</p>
public struct BuildSuggestersOutputResponse: Equatable {
    /// <p>A list of field names.</p>
    public let fieldNames: [String]?

    public init (
        fieldNames: [String]? = nil
    )
    {
        self.fieldNames = fieldNames
    }
}

struct BuildSuggestersOutputResponseBody: Equatable {
    public let fieldNames: [String]?
}

extension BuildSuggestersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldNames = "FieldNames"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("BuildSuggestersResult"))
        if containerValues.contains(.fieldNames) {
            struct KeyVal0{struct member{}}
            let fieldNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .fieldNames)
            if let fieldNamesWrappedContainer = fieldNamesWrappedContainer {
                let fieldNamesContainer = try fieldNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var fieldNamesBuffer:[String]? = nil
                if let fieldNamesContainer = fieldNamesContainer {
                    fieldNamesBuffer = [String]()
                    for stringContainer0 in fieldNamesContainer {
                        fieldNamesBuffer?.append(stringContainer0)
                    }
                }
                fieldNames = fieldNamesBuffer
            } else {
                fieldNames = []
            }
        } else {
            fieldNames = nil
        }
    }
}

public struct CreateDomainInputBodyMiddleware: Middleware {
    public let id: String = "CreateDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainInput>
    public typealias MOutput = OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainOutputError>
}

extension CreateDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainInput(domainName: \(String(describing: domainName)))"}
}

extension CreateDomainInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("CreateDomain", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct CreateDomainInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainInput>
    public typealias MOutput = OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainOutputError>
}

public struct CreateDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainInput>
    public typealias MOutput = OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainOutputError>
}

/// <p>Container for the parameters to the <code><a>CreateDomain</a></code> operation. Specifies a name for the new search domain.</p>
public struct CreateDomainInput: Equatable {
    /// <p>A name for the domain you are creating. Allowed characters are a-z (lower-case letters), 0-9, and hyphen (-). Domain names must start with a letter or number and be at least 3 and no more than 28 characters long.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension CreateDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainOutputResponse(domainStatus: \(String(describing: domainStatus)))"}
}

extension CreateDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainStatus = output.domainStatus
        } else {
            self.domainStatus = nil
        }
    }
}

/// <p>The result of a <code>CreateDomainRequest</code>. Contains the status of a newly created domain.</p>
public struct CreateDomainOutputResponse: Equatable {
    /// <p>The current status of the search domain.</p>
    public let domainStatus: DomainStatus?

    public init (
        domainStatus: DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

struct CreateDomainOutputResponseBody: Equatable {
    public let domainStatus: DomainStatus?
}

extension CreateDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainStatus = "DomainStatus"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDomainResult"))
        let domainStatusDecoded = try containerValues.decodeIfPresent(DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

extension DateArrayOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: Key("SourceFields"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
    }
}

extension DateArrayOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DateArrayOptions(defaultValue: \(String(describing: defaultValue)), facetEnabled: \(String(describing: facetEnabled)), returnEnabled: \(String(describing: returnEnabled)), searchEnabled: \(String(describing: searchEnabled)), sourceFields: \(String(describing: sourceFields)))"}
}

/// <p>Options for a field that contains an array of dates.  Present if <code>IndexFieldType</code> specifies the field is of type <code>date-array</code>. All options are enabled by default.</p>
public struct DateArrayOptions: Equatable {
    /// A value to use for the field if the field isn't specified for a document.
    public let defaultValue: String?
    /// <p>Whether facet information can be returned for the field.</p>
    public let facetEnabled: Bool?
    /// <p>Whether the contents of the field can be returned in the search results.</p>
    public let returnEnabled: Bool?
    /// <p>Whether the contents of the field are searchable.</p>
    public let searchEnabled: Bool?
    /// <p>A list of source fields to map to the field. </p>
    public let sourceFields: String?

    public init (
        defaultValue: String? = nil,
        facetEnabled: Bool? = nil,
        returnEnabled: Bool? = nil,
        searchEnabled: Bool? = nil,
        sourceFields: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.facetEnabled = facetEnabled
        self.returnEnabled = returnEnabled
        self.searchEnabled = searchEnabled
        self.sourceFields = sourceFields
    }
}

extension DateOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: Key("SourceField"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension DateOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DateOptions(defaultValue: \(String(describing: defaultValue)), facetEnabled: \(String(describing: facetEnabled)), returnEnabled: \(String(describing: returnEnabled)), searchEnabled: \(String(describing: searchEnabled)), sortEnabled: \(String(describing: sortEnabled)), sourceField: \(String(describing: sourceField)))"}
}

/// <p>Options for a date field. Dates and times are specified in UTC (Coordinated Universal Time) according to IETF RFC3339: yyyy-mm-ddT00:00:00Z.  Present if <code>IndexFieldType</code> specifies the field is of type <code>date</code>. All options are enabled by default.</p>
public struct DateOptions: Equatable {
    /// A value to use for the field if the field isn't specified for a document.
    public let defaultValue: String?
    /// <p>Whether facet information can be returned for the field.</p>
    public let facetEnabled: Bool?
    /// <p>Whether the contents of the field can be returned in the search results.</p>
    public let returnEnabled: Bool?
    /// <p>Whether the contents of the field are searchable.</p>
    public let searchEnabled: Bool?
    /// <p>Whether the field can be used to sort the search results.</p>
    public let sortEnabled: Bool?
    /// <p>A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields.
    ///       A dynamic field's name defines a pattern that begins or ends with a wildcard.
    ///       Any document fields that don't map to a regular index field but do match a	
    ///       dynamic field's pattern are configured with the dynamic field's indexing options.
    ///     </p>
    ///     <p>Regular field names begin with a letter and can contain the following characters:
    ///       a-z (lowercase), 0-9, and _ (underscore).
    ///       Dynamic field names must begin or end with a wildcard (*).
    ///       The wildcard can also be the only character in a dynamic field name.
    ///       Multiple wildcards, and wildcards embedded within a string are not supported.
    ///     </p>
    ///     <p>The name <code>score</code> is reserved and cannot be used as a field name.
    ///       To reference a document's ID, you can use the name <code>_id</code>.
    ///     </p>
    public let sourceField: String?

    public init (
        defaultValue: String? = nil,
        facetEnabled: Bool? = nil,
        returnEnabled: Bool? = nil,
        searchEnabled: Bool? = nil,
        sortEnabled: Bool? = nil,
        sourceField: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.facetEnabled = facetEnabled
        self.returnEnabled = returnEnabled
        self.searchEnabled = searchEnabled
        self.sortEnabled = sortEnabled
        self.sourceField = sourceField
    }
}

public struct DefineAnalysisSchemeInputBodyMiddleware: Middleware {
    public let id: String = "DefineAnalysisSchemeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DefineAnalysisSchemeInput>,
                  next: H) -> Swift.Result<OperationOutput<DefineAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DefineAnalysisSchemeInput>
    public typealias MOutput = OperationOutput<DefineAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DefineAnalysisSchemeOutputError>
}

extension DefineAnalysisSchemeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefineAnalysisSchemeInput(analysisScheme: \(String(describing: analysisScheme)), domainName: \(String(describing: domainName)))"}
}

extension DefineAnalysisSchemeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let analysisScheme = analysisScheme {
            try container.encode(analysisScheme, forKey: Key("AnalysisScheme"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("DefineAnalysisScheme", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DefineAnalysisSchemeInputHeadersMiddleware: Middleware {
    public let id: String = "DefineAnalysisSchemeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DefineAnalysisSchemeInput>,
                  next: H) -> Swift.Result<OperationOutput<DefineAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DefineAnalysisSchemeInput>
    public typealias MOutput = OperationOutput<DefineAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DefineAnalysisSchemeOutputError>
}

public struct DefineAnalysisSchemeInputQueryItemMiddleware: Middleware {
    public let id: String = "DefineAnalysisSchemeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DefineAnalysisSchemeInput>,
                  next: H) -> Swift.Result<OperationOutput<DefineAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DefineAnalysisSchemeInput>
    public typealias MOutput = OperationOutput<DefineAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DefineAnalysisSchemeOutputError>
}

/// <p>Container for the parameters to the <code><a>DefineAnalysisScheme</a></code> operation. Specifies the name of the domain you want to update and the analysis scheme configuration.</p>
public struct DefineAnalysisSchemeInput: Equatable {
    /// <p>Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: <code>Synonyms</code>, <code>Stopwords</code>, <code>StemmingDictionary</code>, <code>JapaneseTokenizationDictionary</code> and <code>AlgorithmicStemming</code>.</p>
    public let analysisScheme: AnalysisScheme?
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?

    public init (
        analysisScheme: AnalysisScheme? = nil,
        domainName: String? = nil
    )
    {
        self.analysisScheme = analysisScheme
        self.domainName = domainName
    }
}

extension DefineAnalysisSchemeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DefineAnalysisSchemeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DefineAnalysisSchemeOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DefineAnalysisSchemeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefineAnalysisSchemeOutputResponse(analysisScheme: \(String(describing: analysisScheme)))"}
}

extension DefineAnalysisSchemeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DefineAnalysisSchemeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisScheme = output.analysisScheme
        } else {
            self.analysisScheme = nil
        }
    }
}

/// <p>The result of a <code><a>DefineAnalysisScheme</a></code> request. Contains the status of the newly-configured analysis scheme.</p>
public struct DefineAnalysisSchemeOutputResponse: Equatable {
    /// <p>The status and configuration of an  <code>AnalysisScheme</code>.</p>
    public let analysisScheme: AnalysisSchemeStatus?

    public init (
        analysisScheme: AnalysisSchemeStatus? = nil
    )
    {
        self.analysisScheme = analysisScheme
    }
}

struct DefineAnalysisSchemeOutputResponseBody: Equatable {
    public let analysisScheme: AnalysisSchemeStatus?
}

extension DefineAnalysisSchemeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisScheme = "AnalysisScheme"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DefineAnalysisSchemeResult"))
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(AnalysisSchemeStatus.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

public struct DefineExpressionInputBodyMiddleware: Middleware {
    public let id: String = "DefineExpressionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DefineExpressionInput>,
                  next: H) -> Swift.Result<OperationOutput<DefineExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DefineExpressionInput>
    public typealias MOutput = OperationOutput<DefineExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DefineExpressionOutputError>
}

extension DefineExpressionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefineExpressionInput(domainName: \(String(describing: domainName)), expression: \(String(describing: expression)))"}
}

extension DefineExpressionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        if let expression = expression {
            try container.encode(expression, forKey: Key("Expression"))
        }
        try container.encode("DefineExpression", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DefineExpressionInputHeadersMiddleware: Middleware {
    public let id: String = "DefineExpressionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DefineExpressionInput>,
                  next: H) -> Swift.Result<OperationOutput<DefineExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DefineExpressionInput>
    public typealias MOutput = OperationOutput<DefineExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DefineExpressionOutputError>
}

public struct DefineExpressionInputQueryItemMiddleware: Middleware {
    public let id: String = "DefineExpressionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DefineExpressionInput>,
                  next: H) -> Swift.Result<OperationOutput<DefineExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DefineExpressionInput>
    public typealias MOutput = OperationOutput<DefineExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DefineExpressionOutputError>
}

/// <p>Container for the parameters to the <code><a>DefineExpression</a></code> operation. Specifies the name of the domain you want to update and the expression you want to configure.</p>
public struct DefineExpressionInput: Equatable {
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?
    /// <p>A named expression that can be evaluated at search time. Can be used to sort the search results, define other expressions, or return computed information in the search results.  </p>
    public let expression: Expression?

    public init (
        domainName: String? = nil,
        expression: Expression? = nil
    )
    {
        self.domainName = domainName
        self.expression = expression
    }
}

extension DefineExpressionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DefineExpressionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DefineExpressionOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DefineExpressionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefineExpressionOutputResponse(expression: \(String(describing: expression)))"}
}

extension DefineExpressionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DefineExpressionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.expression = output.expression
        } else {
            self.expression = nil
        }
    }
}

/// <p>The result of a <code>DefineExpression</code> request. Contains the status of the newly-configured expression.</p>
public struct DefineExpressionOutputResponse: Equatable {
    /// <p>The value of an <code>Expression</code> and its current status.</p>
    public let expression: ExpressionStatus?

    public init (
        expression: ExpressionStatus? = nil
    )
    {
        self.expression = expression
    }
}

struct DefineExpressionOutputResponseBody: Equatable {
    public let expression: ExpressionStatus?
}

extension DefineExpressionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expression = "Expression"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DefineExpressionResult"))
        let expressionDecoded = try containerValues.decodeIfPresent(ExpressionStatus.self, forKey: .expression)
        expression = expressionDecoded
    }
}

public struct DefineIndexFieldInputBodyMiddleware: Middleware {
    public let id: String = "DefineIndexFieldInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DefineIndexFieldInput>,
                  next: H) -> Swift.Result<OperationOutput<DefineIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DefineIndexFieldInput>
    public typealias MOutput = OperationOutput<DefineIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DefineIndexFieldOutputError>
}

extension DefineIndexFieldInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefineIndexFieldInput(domainName: \(String(describing: domainName)), indexField: \(String(describing: indexField)))"}
}

extension DefineIndexFieldInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        if let indexField = indexField {
            try container.encode(indexField, forKey: Key("IndexField"))
        }
        try container.encode("DefineIndexField", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DefineIndexFieldInputHeadersMiddleware: Middleware {
    public let id: String = "DefineIndexFieldInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DefineIndexFieldInput>,
                  next: H) -> Swift.Result<OperationOutput<DefineIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DefineIndexFieldInput>
    public typealias MOutput = OperationOutput<DefineIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DefineIndexFieldOutputError>
}

public struct DefineIndexFieldInputQueryItemMiddleware: Middleware {
    public let id: String = "DefineIndexFieldInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DefineIndexFieldInput>,
                  next: H) -> Swift.Result<OperationOutput<DefineIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DefineIndexFieldInput>
    public typealias MOutput = OperationOutput<DefineIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DefineIndexFieldOutputError>
}

/// <p>Container for the parameters to the <code><a>DefineIndexField</a></code> operation. Specifies the name of the domain you want to update and the index field configuration.</p>
public struct DefineIndexFieldInput: Equatable {
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?
    /// <p>The index field and field options you want to configure. </p>
    public let indexField: IndexField?

    public init (
        domainName: String? = nil,
        indexField: IndexField? = nil
    )
    {
        self.domainName = domainName
        self.indexField = indexField
    }
}

extension DefineIndexFieldOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DefineIndexFieldOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DefineIndexFieldOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DefineIndexFieldOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefineIndexFieldOutputResponse(indexField: \(String(describing: indexField)))"}
}

extension DefineIndexFieldOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DefineIndexFieldOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.indexField = output.indexField
        } else {
            self.indexField = nil
        }
    }
}

/// <p>The result of a <code><a>DefineIndexField</a></code> request. Contains the status of the newly-configured index field.</p>
public struct DefineIndexFieldOutputResponse: Equatable {
    /// <p>The value of an <code>IndexField</code> and its current status.</p>
    public let indexField: IndexFieldStatus?

    public init (
        indexField: IndexFieldStatus? = nil
    )
    {
        self.indexField = indexField
    }
}

struct DefineIndexFieldOutputResponseBody: Equatable {
    public let indexField: IndexFieldStatus?
}

extension DefineIndexFieldOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexField = "IndexField"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DefineIndexFieldResult"))
        let indexFieldDecoded = try containerValues.decodeIfPresent(IndexFieldStatus.self, forKey: .indexField)
        indexField = indexFieldDecoded
    }
}

public struct DefineSuggesterInputBodyMiddleware: Middleware {
    public let id: String = "DefineSuggesterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DefineSuggesterInput>,
                  next: H) -> Swift.Result<OperationOutput<DefineSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DefineSuggesterInput>
    public typealias MOutput = OperationOutput<DefineSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DefineSuggesterOutputError>
}

extension DefineSuggesterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefineSuggesterInput(domainName: \(String(describing: domainName)), suggester: \(String(describing: suggester)))"}
}

extension DefineSuggesterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        if let suggester = suggester {
            try container.encode(suggester, forKey: Key("Suggester"))
        }
        try container.encode("DefineSuggester", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DefineSuggesterInputHeadersMiddleware: Middleware {
    public let id: String = "DefineSuggesterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DefineSuggesterInput>,
                  next: H) -> Swift.Result<OperationOutput<DefineSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DefineSuggesterInput>
    public typealias MOutput = OperationOutput<DefineSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DefineSuggesterOutputError>
}

public struct DefineSuggesterInputQueryItemMiddleware: Middleware {
    public let id: String = "DefineSuggesterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DefineSuggesterInput>,
                  next: H) -> Swift.Result<OperationOutput<DefineSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DefineSuggesterInput>
    public typealias MOutput = OperationOutput<DefineSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DefineSuggesterOutputError>
}

/// <p>Container for the parameters to the <code><a>DefineSuggester</a></code> operation. Specifies the name of the domain you want to update and the suggester configuration.</p>
public struct DefineSuggesterInput: Equatable {
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?
    /// <p>Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: <code>FuzzyMatching</code>, <code>SortExpression</code>. </p>
    public let suggester: Suggester?

    public init (
        domainName: String? = nil,
        suggester: Suggester? = nil
    )
    {
        self.domainName = domainName
        self.suggester = suggester
    }
}

extension DefineSuggesterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DefineSuggesterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DefineSuggesterOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DefineSuggesterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefineSuggesterOutputResponse(suggester: \(String(describing: suggester)))"}
}

extension DefineSuggesterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DefineSuggesterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.suggester = output.suggester
        } else {
            self.suggester = nil
        }
    }
}

/// <p>The result of a <code>DefineSuggester</code> request. Contains the status of the newly-configured suggester.</p>
public struct DefineSuggesterOutputResponse: Equatable {
    /// <p>The value of a <code>Suggester</code> and its current status.</p>
    public let suggester: SuggesterStatus?

    public init (
        suggester: SuggesterStatus? = nil
    )
    {
        self.suggester = suggester
    }
}

struct DefineSuggesterOutputResponseBody: Equatable {
    public let suggester: SuggesterStatus?
}

extension DefineSuggesterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case suggester = "Suggester"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DefineSuggesterResult"))
        let suggesterDecoded = try containerValues.decodeIfPresent(SuggesterStatus.self, forKey: .suggester)
        suggester = suggesterDecoded
    }
}

public struct DeleteAnalysisSchemeInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAnalysisSchemeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnalysisSchemeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnalysisSchemeInput>
    public typealias MOutput = OperationOutput<DeleteAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnalysisSchemeOutputError>
}

extension DeleteAnalysisSchemeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAnalysisSchemeInput(analysisSchemeName: \(String(describing: analysisSchemeName)), domainName: \(String(describing: domainName)))"}
}

extension DeleteAnalysisSchemeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let analysisSchemeName = analysisSchemeName {
            try container.encode(analysisSchemeName, forKey: Key("AnalysisSchemeName"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("DeleteAnalysisScheme", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DeleteAnalysisSchemeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAnalysisSchemeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnalysisSchemeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnalysisSchemeInput>
    public typealias MOutput = OperationOutput<DeleteAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnalysisSchemeOutputError>
}

public struct DeleteAnalysisSchemeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAnalysisSchemeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnalysisSchemeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnalysisSchemeInput>
    public typealias MOutput = OperationOutput<DeleteAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnalysisSchemeOutputError>
}

/// <p>Container for the parameters to the <code><a>DeleteAnalysisScheme</a></code> operation. Specifies the name of the domain you want to update and the analysis scheme you want to delete. </p>
public struct DeleteAnalysisSchemeInput: Equatable {
    /// <p>The name of the analysis scheme you want to delete.</p>
    public let analysisSchemeName: String?
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?

    public init (
        analysisSchemeName: String? = nil,
        domainName: String? = nil
    )
    {
        self.analysisSchemeName = analysisSchemeName
        self.domainName = domainName
    }
}

extension DeleteAnalysisSchemeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAnalysisSchemeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAnalysisSchemeOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnalysisSchemeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAnalysisSchemeOutputResponse(analysisScheme: \(String(describing: analysisScheme)))"}
}

extension DeleteAnalysisSchemeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteAnalysisSchemeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisScheme = output.analysisScheme
        } else {
            self.analysisScheme = nil
        }
    }
}

/// <p>The result of a <code>DeleteAnalysisScheme</code> request. Contains the status of the deleted analysis scheme.</p>
public struct DeleteAnalysisSchemeOutputResponse: Equatable {
    /// <p>The status of the analysis scheme being deleted.</p>
    public let analysisScheme: AnalysisSchemeStatus?

    public init (
        analysisScheme: AnalysisSchemeStatus? = nil
    )
    {
        self.analysisScheme = analysisScheme
    }
}

struct DeleteAnalysisSchemeOutputResponseBody: Equatable {
    public let analysisScheme: AnalysisSchemeStatus?
}

extension DeleteAnalysisSchemeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisScheme = "AnalysisScheme"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteAnalysisSchemeResult"))
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(AnalysisSchemeStatus.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

public struct DeleteDomainInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainOutputError>
}

extension DeleteDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainInput(domainName: \(String(describing: domainName)))"}
}

extension DeleteDomainInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("DeleteDomain", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DeleteDomainInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainOutputError>
}

/// <p>Container for the parameters to the <code><a>DeleteDomain</a></code> operation. Specifies the name of the domain you want to delete.</p>
public struct DeleteDomainInput: Equatable {
    /// <p>The name of the domain you want to permanently delete.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension DeleteDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainOutputResponse(domainStatus: \(String(describing: domainStatus)))"}
}

extension DeleteDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainStatus = output.domainStatus
        } else {
            self.domainStatus = nil
        }
    }
}

/// <p>The result of a <code>DeleteDomain</code> request. Contains the status of a newly deleted domain, or no status if the domain has already been completely deleted.</p>
public struct DeleteDomainOutputResponse: Equatable {
    /// <p>The current status of the search domain.</p>
    public let domainStatus: DomainStatus?

    public init (
        domainStatus: DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

struct DeleteDomainOutputResponseBody: Equatable {
    public let domainStatus: DomainStatus?
}

extension DeleteDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainStatus = "DomainStatus"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDomainResult"))
        let domainStatusDecoded = try containerValues.decodeIfPresent(DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

public struct DeleteExpressionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteExpressionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteExpressionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteExpressionInput>
    public typealias MOutput = OperationOutput<DeleteExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteExpressionOutputError>
}

extension DeleteExpressionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteExpressionInput(domainName: \(String(describing: domainName)), expressionName: \(String(describing: expressionName)))"}
}

extension DeleteExpressionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        if let expressionName = expressionName {
            try container.encode(expressionName, forKey: Key("ExpressionName"))
        }
        try container.encode("DeleteExpression", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DeleteExpressionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteExpressionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteExpressionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteExpressionInput>
    public typealias MOutput = OperationOutput<DeleteExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteExpressionOutputError>
}

public struct DeleteExpressionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteExpressionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteExpressionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteExpressionInput>
    public typealias MOutput = OperationOutput<DeleteExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteExpressionOutputError>
}

/// <p>Container for the parameters to the <code><a>DeleteExpression</a></code> operation. Specifies the name of the domain you want to update and the name of the expression you want to delete.</p>
public struct DeleteExpressionInput: Equatable {
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?
    /// <p>The name of the <code><a>Expression</a></code> to delete.</p>
    public let expressionName: String?

    public init (
        domainName: String? = nil,
        expressionName: String? = nil
    )
    {
        self.domainName = domainName
        self.expressionName = expressionName
    }
}

extension DeleteExpressionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteExpressionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteExpressionOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExpressionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteExpressionOutputResponse(expression: \(String(describing: expression)))"}
}

extension DeleteExpressionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteExpressionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.expression = output.expression
        } else {
            self.expression = nil
        }
    }
}

/// <p>The result of a <code><a>DeleteExpression</a></code> request. Specifies the expression being deleted.</p>
public struct DeleteExpressionOutputResponse: Equatable {
    /// <p>The status of the expression being deleted.</p>
    public let expression: ExpressionStatus?

    public init (
        expression: ExpressionStatus? = nil
    )
    {
        self.expression = expression
    }
}

struct DeleteExpressionOutputResponseBody: Equatable {
    public let expression: ExpressionStatus?
}

extension DeleteExpressionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expression = "Expression"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteExpressionResult"))
        let expressionDecoded = try containerValues.decodeIfPresent(ExpressionStatus.self, forKey: .expression)
        expression = expressionDecoded
    }
}

public struct DeleteIndexFieldInputBodyMiddleware: Middleware {
    public let id: String = "DeleteIndexFieldInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIndexFieldInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIndexFieldInput>
    public typealias MOutput = OperationOutput<DeleteIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIndexFieldOutputError>
}

extension DeleteIndexFieldInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIndexFieldInput(domainName: \(String(describing: domainName)), indexFieldName: \(String(describing: indexFieldName)))"}
}

extension DeleteIndexFieldInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        if let indexFieldName = indexFieldName {
            try container.encode(indexFieldName, forKey: Key("IndexFieldName"))
        }
        try container.encode("DeleteIndexField", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DeleteIndexFieldInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIndexFieldInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIndexFieldInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIndexFieldInput>
    public typealias MOutput = OperationOutput<DeleteIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIndexFieldOutputError>
}

public struct DeleteIndexFieldInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIndexFieldInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIndexFieldInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIndexFieldInput>
    public typealias MOutput = OperationOutput<DeleteIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIndexFieldOutputError>
}

/// <p>Container for the parameters to the <code><a>DeleteIndexField</a></code> operation. Specifies the name of the domain you want to update and the name of the index field you want to delete.</p>
public struct DeleteIndexFieldInput: Equatable {
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?
    /// <p>The name of the index field your want to remove from the domain's indexing options.</p>
    public let indexFieldName: String?

    public init (
        domainName: String? = nil,
        indexFieldName: String? = nil
    )
    {
        self.domainName = domainName
        self.indexFieldName = indexFieldName
    }
}

extension DeleteIndexFieldOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteIndexFieldOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIndexFieldOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIndexFieldOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIndexFieldOutputResponse(indexField: \(String(describing: indexField)))"}
}

extension DeleteIndexFieldOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteIndexFieldOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.indexField = output.indexField
        } else {
            self.indexField = nil
        }
    }
}

/// <p>The result of a <code><a>DeleteIndexField</a></code> request.</p>
public struct DeleteIndexFieldOutputResponse: Equatable {
    /// <p>The status of the index field being deleted.</p>
    public let indexField: IndexFieldStatus?

    public init (
        indexField: IndexFieldStatus? = nil
    )
    {
        self.indexField = indexField
    }
}

struct DeleteIndexFieldOutputResponseBody: Equatable {
    public let indexField: IndexFieldStatus?
}

extension DeleteIndexFieldOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexField = "IndexField"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteIndexFieldResult"))
        let indexFieldDecoded = try containerValues.decodeIfPresent(IndexFieldStatus.self, forKey: .indexField)
        indexField = indexFieldDecoded
    }
}

public struct DeleteSuggesterInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSuggesterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSuggesterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSuggesterInput>
    public typealias MOutput = OperationOutput<DeleteSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSuggesterOutputError>
}

extension DeleteSuggesterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSuggesterInput(domainName: \(String(describing: domainName)), suggesterName: \(String(describing: suggesterName)))"}
}

extension DeleteSuggesterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        if let suggesterName = suggesterName {
            try container.encode(suggesterName, forKey: Key("SuggesterName"))
        }
        try container.encode("DeleteSuggester", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DeleteSuggesterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSuggesterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSuggesterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSuggesterInput>
    public typealias MOutput = OperationOutput<DeleteSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSuggesterOutputError>
}

public struct DeleteSuggesterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSuggesterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSuggesterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSuggesterInput>
    public typealias MOutput = OperationOutput<DeleteSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSuggesterOutputError>
}

/// <p>Container for the parameters to the <code><a>DeleteSuggester</a></code> operation. Specifies the name of the domain you want to update and name of the suggester you want to delete.</p>
public struct DeleteSuggesterInput: Equatable {
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?
    /// <p>Specifies the name of the suggester you want to delete.</p>
    public let suggesterName: String?

    public init (
        domainName: String? = nil,
        suggesterName: String? = nil
    )
    {
        self.domainName = domainName
        self.suggesterName = suggesterName
    }
}

extension DeleteSuggesterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSuggesterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSuggesterOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSuggesterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSuggesterOutputResponse(suggester: \(String(describing: suggester)))"}
}

extension DeleteSuggesterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSuggesterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.suggester = output.suggester
        } else {
            self.suggester = nil
        }
    }
}

/// <p>The result of a <code>DeleteSuggester</code> request. Contains the status of the deleted suggester.</p>
public struct DeleteSuggesterOutputResponse: Equatable {
    /// <p>The status of the suggester being deleted.</p>
    public let suggester: SuggesterStatus?

    public init (
        suggester: SuggesterStatus? = nil
    )
    {
        self.suggester = suggester
    }
}

struct DeleteSuggesterOutputResponseBody: Equatable {
    public let suggester: SuggesterStatus?
}

extension DeleteSuggesterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case suggester = "Suggester"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteSuggesterResult"))
        let suggesterDecoded = try containerValues.decodeIfPresent(SuggesterStatus.self, forKey: .suggester)
        suggester = suggesterDecoded
    }
}

public struct DescribeAnalysisSchemesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAnalysisSchemesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnalysisSchemesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnalysisSchemesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnalysisSchemesInput>
    public typealias MOutput = OperationOutput<DescribeAnalysisSchemesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnalysisSchemesOutputError>
}

extension DescribeAnalysisSchemesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAnalysisSchemesInput(analysisSchemeNames: \(String(describing: analysisSchemeNames)), deployed: \(String(describing: deployed)), domainName: \(String(describing: domainName)))"}
}

extension DescribeAnalysisSchemesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let analysisSchemeNames = analysisSchemeNames {
            var analysisSchemeNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AnalysisSchemeNames"))
            for (index0, standardname0) in analysisSchemeNames.enumerated() {
                try analysisSchemeNamesContainer.encode(standardname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let deployed = deployed {
            try container.encode(deployed, forKey: Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("DescribeAnalysisSchemes", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DescribeAnalysisSchemesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAnalysisSchemesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnalysisSchemesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnalysisSchemesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnalysisSchemesInput>
    public typealias MOutput = OperationOutput<DescribeAnalysisSchemesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnalysisSchemesOutputError>
}

public struct DescribeAnalysisSchemesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAnalysisSchemesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnalysisSchemesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnalysisSchemesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnalysisSchemesInput>
    public typealias MOutput = OperationOutput<DescribeAnalysisSchemesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnalysisSchemesOutputError>
}

/// <p>Container for the parameters to the <code><a>DescribeAnalysisSchemes</a></code> operation. Specifies the name of the domain you want to describe. To limit the response to particular analysis schemes, specify the names of the analysis schemes you want to describe. To show the active configuration and exclude any pending changes, set the <code>Deployed</code> option to <code>true</code>. </p>
public struct DescribeAnalysisSchemesInput: Equatable {
    /// <p>The analysis schemes you want to describe.</p>
    public let analysisSchemeNames: [String]?
    /// <p>Whether to display the deployed configuration (<code>true</code>) or include any pending changes (<code>false</code>). Defaults to <code>false</code>.</p>
    public let deployed: Bool?
    /// <p>The name of the domain you want to describe.</p>
    public let domainName: String?

    public init (
        analysisSchemeNames: [String]? = nil,
        deployed: Bool? = nil,
        domainName: String? = nil
    )
    {
        self.analysisSchemeNames = analysisSchemeNames
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension DescribeAnalysisSchemesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAnalysisSchemesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAnalysisSchemesOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnalysisSchemesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAnalysisSchemesOutputResponse(analysisSchemes: \(String(describing: analysisSchemes)))"}
}

extension DescribeAnalysisSchemesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAnalysisSchemesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisSchemes = output.analysisSchemes
        } else {
            self.analysisSchemes = nil
        }
    }
}

/// <p>The result of a <code>DescribeAnalysisSchemes</code> request. Contains the analysis schemes configured for the domain specified in the request.</p>
public struct DescribeAnalysisSchemesOutputResponse: Equatable {
    /// <p>The analysis scheme descriptions.</p>
    public let analysisSchemes: [AnalysisSchemeStatus]?

    public init (
        analysisSchemes: [AnalysisSchemeStatus]? = nil
    )
    {
        self.analysisSchemes = analysisSchemes
    }
}

struct DescribeAnalysisSchemesOutputResponseBody: Equatable {
    public let analysisSchemes: [AnalysisSchemeStatus]?
}

extension DescribeAnalysisSchemesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisSchemes = "AnalysisSchemes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeAnalysisSchemesResult"))
        if containerValues.contains(.analysisSchemes) {
            struct KeyVal0{struct member{}}
            let analysisSchemesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .analysisSchemes)
            if let analysisSchemesWrappedContainer = analysisSchemesWrappedContainer {
                let analysisSchemesContainer = try analysisSchemesWrappedContainer.decodeIfPresent([AnalysisSchemeStatus].self, forKey: .member)
                var analysisSchemesBuffer:[AnalysisSchemeStatus]? = nil
                if let analysisSchemesContainer = analysisSchemesContainer {
                    analysisSchemesBuffer = [AnalysisSchemeStatus]()
                    for structureContainer0 in analysisSchemesContainer {
                        analysisSchemesBuffer?.append(structureContainer0)
                    }
                }
                analysisSchemes = analysisSchemesBuffer
            } else {
                analysisSchemes = []
            }
        } else {
            analysisSchemes = nil
        }
    }
}

public struct DescribeAvailabilityOptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAvailabilityOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAvailabilityOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAvailabilityOptionsInput>
    public typealias MOutput = OperationOutput<DescribeAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAvailabilityOptionsOutputError>
}

extension DescribeAvailabilityOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAvailabilityOptionsInput(deployed: \(String(describing: deployed)), domainName: \(String(describing: domainName)))"}
}

extension DescribeAvailabilityOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("DescribeAvailabilityOptions", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DescribeAvailabilityOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAvailabilityOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAvailabilityOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAvailabilityOptionsInput>
    public typealias MOutput = OperationOutput<DescribeAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAvailabilityOptionsOutputError>
}

public struct DescribeAvailabilityOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAvailabilityOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAvailabilityOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAvailabilityOptionsInput>
    public typealias MOutput = OperationOutput<DescribeAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAvailabilityOptionsOutputError>
}

/// <p>Container for the parameters to the <code><a>DescribeAvailabilityOptions</a></code> operation. Specifies the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to <code>true</code>.</p>
public struct DescribeAvailabilityOptionsInput: Equatable {
    /// <p>Whether to display the deployed configuration (<code>true</code>) or include any pending changes (<code>false</code>). Defaults to <code>false</code>.</p>
    public let deployed: Bool?
    /// <p>The name of the domain you want to describe.</p>
    public let domainName: String?

    public init (
        deployed: Bool? = nil,
        domainName: String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension DescribeAvailabilityOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAvailabilityOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAvailabilityOptionsOutputError: Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAvailabilityOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAvailabilityOptionsOutputResponse(availabilityOptions: \(String(describing: availabilityOptions)))"}
}

extension DescribeAvailabilityOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAvailabilityOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.availabilityOptions = output.availabilityOptions
        } else {
            self.availabilityOptions = nil
        }
    }
}

/// <p>The result of a <code>DescribeAvailabilityOptions</code> request. Indicates whether or not the Multi-AZ option is enabled for the domain specified in the request. </p>
public struct DescribeAvailabilityOptionsOutputResponse: Equatable {
    /// <p>The availability options configured for the domain. Indicates whether Multi-AZ is enabled for the domain. </p>
    public let availabilityOptions: AvailabilityOptionsStatus?

    public init (
        availabilityOptions: AvailabilityOptionsStatus? = nil
    )
    {
        self.availabilityOptions = availabilityOptions
    }
}

struct DescribeAvailabilityOptionsOutputResponseBody: Equatable {
    public let availabilityOptions: AvailabilityOptionsStatus?
}

extension DescribeAvailabilityOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityOptions = "AvailabilityOptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeAvailabilityOptionsResult"))
        let availabilityOptionsDecoded = try containerValues.decodeIfPresent(AvailabilityOptionsStatus.self, forKey: .availabilityOptions)
        availabilityOptions = availabilityOptionsDecoded
    }
}

public struct DescribeDomainEndpointOptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDomainEndpointOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainEndpointOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainEndpointOptionsInput>
    public typealias MOutput = OperationOutput<DescribeDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainEndpointOptionsOutputError>
}

extension DescribeDomainEndpointOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDomainEndpointOptionsInput(deployed: \(String(describing: deployed)), domainName: \(String(describing: domainName)))"}
}

extension DescribeDomainEndpointOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("DescribeDomainEndpointOptions", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DescribeDomainEndpointOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDomainEndpointOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainEndpointOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainEndpointOptionsInput>
    public typealias MOutput = OperationOutput<DescribeDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainEndpointOptionsOutputError>
}

public struct DescribeDomainEndpointOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDomainEndpointOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainEndpointOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainEndpointOptionsInput>
    public typealias MOutput = OperationOutput<DescribeDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainEndpointOptionsOutputError>
}

/// <p>Container for the parameters to the <code><a>DescribeDomainEndpointOptions</a></code> operation. Specify the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to <code>true</code>.</p>
public struct DescribeDomainEndpointOptionsInput: Equatable {
    /// <p>Whether to retrieve the latest configuration (which might be in a Processing state) or the current, active configuration. Defaults to <code>false</code>.</p>
    public let deployed: Bool?
    /// <p>A string that represents the name of a domain.</p>
    public let domainName: String?

    public init (
        deployed: Bool? = nil,
        domainName: String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension DescribeDomainEndpointOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDomainEndpointOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainEndpointOptionsOutputError: Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainEndpointOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDomainEndpointOptionsOutputResponse(domainEndpointOptions: \(String(describing: domainEndpointOptions)))"}
}

extension DescribeDomainEndpointOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDomainEndpointOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainEndpointOptions = output.domainEndpointOptions
        } else {
            self.domainEndpointOptions = nil
        }
    }
}

/// <p>The result of a <code>DescribeDomainEndpointOptions</code> request. Contains the status and configuration of a search domain's endpoint options. </p>
public struct DescribeDomainEndpointOptionsOutputResponse: Equatable {
    /// <p>The status and configuration of a search domain's endpoint options.</p>
    public let domainEndpointOptions: DomainEndpointOptionsStatus?

    public init (
        domainEndpointOptions: DomainEndpointOptionsStatus? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
    }
}

struct DescribeDomainEndpointOptionsOutputResponseBody: Equatable {
    public let domainEndpointOptions: DomainEndpointOptionsStatus?
}

extension DescribeDomainEndpointOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainEndpointOptions = "DomainEndpointOptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDomainEndpointOptionsResult"))
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(DomainEndpointOptionsStatus.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
    }
}

public struct DescribeDomainsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainsInput>
    public typealias MOutput = OperationOutput<DescribeDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainsOutputError>
}

extension DescribeDomainsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDomainsInput(domainNames: \(String(describing: domainNames)))"}
}

extension DescribeDomainsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainNames = domainNames {
            var domainNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DomainNames"))
            for (index0, domainname0) in domainNames.enumerated() {
                try domainNamesContainer.encode(domainname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeDomains", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DescribeDomainsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainsInput>
    public typealias MOutput = OperationOutput<DescribeDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainsOutputError>
}

public struct DescribeDomainsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainsInput>
    public typealias MOutput = OperationOutput<DescribeDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainsOutputError>
}

/// <p>Container for the parameters to the <code><a>DescribeDomains</a></code> operation. By default shows the status of all domains. To restrict the response to particular domains, specify the names of the domains you want to describe.</p>
public struct DescribeDomainsInput: Equatable {
    /// <p>The names of the domains you want to include in the response.</p>
    public let domainNames: [String]?

    public init (
        domainNames: [String]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

extension DescribeDomainsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDomainsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainsOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDomainsOutputResponse(domainStatusList: \(String(describing: domainStatusList)))"}
}

extension DescribeDomainsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDomainsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainStatusList = output.domainStatusList
        } else {
            self.domainStatusList = nil
        }
    }
}

/// <p>The result of a <code>DescribeDomains</code> request. Contains the status of the domains specified in the request or all domains owned by the account.</p>
public struct DescribeDomainsOutputResponse: Equatable {
    /// <p>A list that contains the status of each requested domain.</p>
    public let domainStatusList: [DomainStatus]?

    public init (
        domainStatusList: [DomainStatus]? = nil
    )
    {
        self.domainStatusList = domainStatusList
    }
}

struct DescribeDomainsOutputResponseBody: Equatable {
    public let domainStatusList: [DomainStatus]?
}

extension DescribeDomainsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainStatusList = "DomainStatusList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDomainsResult"))
        if containerValues.contains(.domainStatusList) {
            struct KeyVal0{struct member{}}
            let domainStatusListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .domainStatusList)
            if let domainStatusListWrappedContainer = domainStatusListWrappedContainer {
                let domainStatusListContainer = try domainStatusListWrappedContainer.decodeIfPresent([DomainStatus].self, forKey: .member)
                var domainStatusListBuffer:[DomainStatus]? = nil
                if let domainStatusListContainer = domainStatusListContainer {
                    domainStatusListBuffer = [DomainStatus]()
                    for structureContainer0 in domainStatusListContainer {
                        domainStatusListBuffer?.append(structureContainer0)
                    }
                }
                domainStatusList = domainStatusListBuffer
            } else {
                domainStatusList = []
            }
        } else {
            domainStatusList = nil
        }
    }
}

public struct DescribeExpressionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeExpressionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExpressionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExpressionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExpressionsInput>
    public typealias MOutput = OperationOutput<DescribeExpressionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExpressionsOutputError>
}

extension DescribeExpressionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExpressionsInput(deployed: \(String(describing: deployed)), domainName: \(String(describing: domainName)), expressionNames: \(String(describing: expressionNames)))"}
}

extension DescribeExpressionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        if let expressionNames = expressionNames {
            var expressionNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExpressionNames"))
            for (index0, standardname0) in expressionNames.enumerated() {
                try expressionNamesContainer.encode(standardname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeExpressions", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DescribeExpressionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeExpressionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExpressionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExpressionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExpressionsInput>
    public typealias MOutput = OperationOutput<DescribeExpressionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExpressionsOutputError>
}

public struct DescribeExpressionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeExpressionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExpressionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExpressionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExpressionsInput>
    public typealias MOutput = OperationOutput<DescribeExpressionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExpressionsOutputError>
}

/// <p>Container for the parameters to the <code><a>DescribeDomains</a></code> operation.
///       Specifies the name of the domain you want to describe. To restrict the response to particular expressions, specify the names of the expressions you want to describe. To show the active configuration and exclude any pending changes, set the <code>Deployed</code> option to <code>true</code>.</p>
public struct DescribeExpressionsInput: Equatable {
    /// <p>Whether to display the deployed configuration (<code>true</code>) or include any pending changes (<code>false</code>). Defaults to <code>false</code>.</p>
    public let deployed: Bool?
    /// <p>The name of the domain you want to describe.</p>
    public let domainName: String?
    /// <p>Limits the <code><a>DescribeExpressions</a></code> response to the specified expressions. If not specified, all expressions are shown.</p>
    public let expressionNames: [String]?

    public init (
        deployed: Bool? = nil,
        domainName: String? = nil,
        expressionNames: [String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.expressionNames = expressionNames
    }
}

extension DescribeExpressionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeExpressionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExpressionsOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExpressionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExpressionsOutputResponse(expressions: \(String(describing: expressions)))"}
}

extension DescribeExpressionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeExpressionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.expressions = output.expressions
        } else {
            self.expressions = nil
        }
    }
}

/// <p>The result of a <code>DescribeExpressions</code> request. Contains the expressions configured for the domain specified in the request.</p>
public struct DescribeExpressionsOutputResponse: Equatable {
    /// <p>The expressions configured for the domain.</p>
    public let expressions: [ExpressionStatus]?

    public init (
        expressions: [ExpressionStatus]? = nil
    )
    {
        self.expressions = expressions
    }
}

struct DescribeExpressionsOutputResponseBody: Equatable {
    public let expressions: [ExpressionStatus]?
}

extension DescribeExpressionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expressions = "Expressions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeExpressionsResult"))
        if containerValues.contains(.expressions) {
            struct KeyVal0{struct member{}}
            let expressionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .expressions)
            if let expressionsWrappedContainer = expressionsWrappedContainer {
                let expressionsContainer = try expressionsWrappedContainer.decodeIfPresent([ExpressionStatus].self, forKey: .member)
                var expressionsBuffer:[ExpressionStatus]? = nil
                if let expressionsContainer = expressionsContainer {
                    expressionsBuffer = [ExpressionStatus]()
                    for structureContainer0 in expressionsContainer {
                        expressionsBuffer?.append(structureContainer0)
                    }
                }
                expressions = expressionsBuffer
            } else {
                expressions = []
            }
        } else {
            expressions = nil
        }
    }
}

public struct DescribeIndexFieldsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeIndexFieldsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIndexFieldsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIndexFieldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIndexFieldsInput>
    public typealias MOutput = OperationOutput<DescribeIndexFieldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIndexFieldsOutputError>
}

extension DescribeIndexFieldsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIndexFieldsInput(deployed: \(String(describing: deployed)), domainName: \(String(describing: domainName)), fieldNames: \(String(describing: fieldNames)))"}
}

extension DescribeIndexFieldsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        if let fieldNames = fieldNames {
            var fieldNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("FieldNames"))
            for (index0, dynamicfieldname0) in fieldNames.enumerated() {
                try fieldNamesContainer.encode(dynamicfieldname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeIndexFields", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DescribeIndexFieldsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIndexFieldsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIndexFieldsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIndexFieldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIndexFieldsInput>
    public typealias MOutput = OperationOutput<DescribeIndexFieldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIndexFieldsOutputError>
}

public struct DescribeIndexFieldsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIndexFieldsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIndexFieldsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIndexFieldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIndexFieldsInput>
    public typealias MOutput = OperationOutput<DescribeIndexFieldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIndexFieldsOutputError>
}

/// <p>Container for the parameters to the <code><a>DescribeIndexFields</a></code> operation. Specifies the name of the domain you want to describe. To restrict the response to particular index fields, specify the names of the index fields you want to describe. To show  the active configuration and exclude any pending changes, set the <code>Deployed</code> option to <code>true</code>.</p>
public struct DescribeIndexFieldsInput: Equatable {
    /// <p>Whether to display the deployed configuration (<code>true</code>) or include any pending changes (<code>false</code>). Defaults to <code>false</code>.</p>
    public let deployed: Bool?
    /// <p>The name of the domain you want to describe.</p>
    public let domainName: String?
    /// <p>A list of the index fields you want to describe. If not specified, information is returned for all configured index fields.</p>
    public let fieldNames: [String]?

    public init (
        deployed: Bool? = nil,
        domainName: String? = nil,
        fieldNames: [String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.fieldNames = fieldNames
    }
}

extension DescribeIndexFieldsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeIndexFieldsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIndexFieldsOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIndexFieldsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIndexFieldsOutputResponse(indexFields: \(String(describing: indexFields)))"}
}

extension DescribeIndexFieldsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIndexFieldsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.indexFields = output.indexFields
        } else {
            self.indexFields = nil
        }
    }
}

/// <p>The result of a <code>DescribeIndexFields</code> request. Contains the index fields configured for the domain specified in the request.</p>
public struct DescribeIndexFieldsOutputResponse: Equatable {
    /// <p>The index fields configured for the domain.</p>
    public let indexFields: [IndexFieldStatus]?

    public init (
        indexFields: [IndexFieldStatus]? = nil
    )
    {
        self.indexFields = indexFields
    }
}

struct DescribeIndexFieldsOutputResponseBody: Equatable {
    public let indexFields: [IndexFieldStatus]?
}

extension DescribeIndexFieldsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexFields = "IndexFields"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeIndexFieldsResult"))
        if containerValues.contains(.indexFields) {
            struct KeyVal0{struct member{}}
            let indexFieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .indexFields)
            if let indexFieldsWrappedContainer = indexFieldsWrappedContainer {
                let indexFieldsContainer = try indexFieldsWrappedContainer.decodeIfPresent([IndexFieldStatus].self, forKey: .member)
                var indexFieldsBuffer:[IndexFieldStatus]? = nil
                if let indexFieldsContainer = indexFieldsContainer {
                    indexFieldsBuffer = [IndexFieldStatus]()
                    for structureContainer0 in indexFieldsContainer {
                        indexFieldsBuffer?.append(structureContainer0)
                    }
                }
                indexFields = indexFieldsBuffer
            } else {
                indexFields = []
            }
        } else {
            indexFields = nil
        }
    }
}

public struct DescribeScalingParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeScalingParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScalingParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScalingParametersInput>
    public typealias MOutput = OperationOutput<DescribeScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScalingParametersOutputError>
}

extension DescribeScalingParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeScalingParametersInput(domainName: \(String(describing: domainName)))"}
}

extension DescribeScalingParametersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("DescribeScalingParameters", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DescribeScalingParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeScalingParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScalingParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScalingParametersInput>
    public typealias MOutput = OperationOutput<DescribeScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScalingParametersOutputError>
}

public struct DescribeScalingParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeScalingParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScalingParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScalingParametersInput>
    public typealias MOutput = OperationOutput<DescribeScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScalingParametersOutputError>
}

/// <p>Container for the parameters to the <code><a>DescribeScalingParameters</a></code> operation. Specifies the name of the domain you want to describe. </p>
public struct DescribeScalingParametersInput: Equatable {
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension DescribeScalingParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeScalingParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeScalingParametersOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeScalingParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeScalingParametersOutputResponse(scalingParameters: \(String(describing: scalingParameters)))"}
}

extension DescribeScalingParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeScalingParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.scalingParameters = output.scalingParameters
        } else {
            self.scalingParameters = nil
        }
    }
}

/// <p>The result of a <code>DescribeScalingParameters</code> request. Contains the scaling parameters configured for the domain specified in the request.</p>
public struct DescribeScalingParametersOutputResponse: Equatable {
    /// <p>The status and configuration of a search domain's scaling parameters. </p>
    public let scalingParameters: ScalingParametersStatus?

    public init (
        scalingParameters: ScalingParametersStatus? = nil
    )
    {
        self.scalingParameters = scalingParameters
    }
}

struct DescribeScalingParametersOutputResponseBody: Equatable {
    public let scalingParameters: ScalingParametersStatus?
}

extension DescribeScalingParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case scalingParameters = "ScalingParameters"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeScalingParametersResult"))
        let scalingParametersDecoded = try containerValues.decodeIfPresent(ScalingParametersStatus.self, forKey: .scalingParameters)
        scalingParameters = scalingParametersDecoded
    }
}

public struct DescribeServiceAccessPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeServiceAccessPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceAccessPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceAccessPoliciesInput>
    public typealias MOutput = OperationOutput<DescribeServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceAccessPoliciesOutputError>
}

extension DescribeServiceAccessPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServiceAccessPoliciesInput(deployed: \(String(describing: deployed)), domainName: \(String(describing: domainName)))"}
}

extension DescribeServiceAccessPoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("DescribeServiceAccessPolicies", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DescribeServiceAccessPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeServiceAccessPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceAccessPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceAccessPoliciesInput>
    public typealias MOutput = OperationOutput<DescribeServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceAccessPoliciesOutputError>
}

public struct DescribeServiceAccessPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeServiceAccessPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceAccessPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceAccessPoliciesInput>
    public typealias MOutput = OperationOutput<DescribeServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceAccessPoliciesOutputError>
}

/// <p>Container for the parameters to the <code><a>DescribeServiceAccessPolicies</a></code> operation. Specifies the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the <code>Deployed</code> option to <code>true</code>.</p>
public struct DescribeServiceAccessPoliciesInput: Equatable {
    /// <p>Whether to display the deployed configuration (<code>true</code>) or include any pending changes (<code>false</code>). Defaults to <code>false</code>.</p>
    public let deployed: Bool?
    /// <p>The name of the domain you want to describe.</p>
    public let domainName: String?

    public init (
        deployed: Bool? = nil,
        domainName: String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension DescribeServiceAccessPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeServiceAccessPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceAccessPoliciesOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceAccessPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServiceAccessPoliciesOutputResponse(accessPolicies: \(String(describing: accessPolicies)))"}
}

extension DescribeServiceAccessPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeServiceAccessPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessPolicies = output.accessPolicies
        } else {
            self.accessPolicies = nil
        }
    }
}

/// <p>The result of a <code>DescribeServiceAccessPolicies</code> request.</p>
public struct DescribeServiceAccessPoliciesOutputResponse: Equatable {
    /// <p>The access rules configured for the domain specified in the request.</p>
    public let accessPolicies: AccessPoliciesStatus?

    public init (
        accessPolicies: AccessPoliciesStatus? = nil
    )
    {
        self.accessPolicies = accessPolicies
    }
}

struct DescribeServiceAccessPoliciesOutputResponseBody: Equatable {
    public let accessPolicies: AccessPoliciesStatus?
}

extension DescribeServiceAccessPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPolicies = "AccessPolicies"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeServiceAccessPoliciesResult"))
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(AccessPoliciesStatus.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
    }
}

public struct DescribeSuggestersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSuggestersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSuggestersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSuggestersInput>
    public typealias MOutput = OperationOutput<DescribeSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSuggestersOutputError>
}

extension DescribeSuggestersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSuggestersInput(deployed: \(String(describing: deployed)), domainName: \(String(describing: domainName)), suggesterNames: \(String(describing: suggesterNames)))"}
}

extension DescribeSuggestersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        if let suggesterNames = suggesterNames {
            var suggesterNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SuggesterNames"))
            for (index0, standardname0) in suggesterNames.enumerated() {
                try suggesterNamesContainer.encode(standardname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeSuggesters", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct DescribeSuggestersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSuggestersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSuggestersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSuggestersInput>
    public typealias MOutput = OperationOutput<DescribeSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSuggestersOutputError>
}

public struct DescribeSuggestersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSuggestersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSuggestersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSuggestersInput>
    public typealias MOutput = OperationOutput<DescribeSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSuggestersOutputError>
}

/// <p>Container for the parameters to the <code><a>DescribeSuggester</a></code> operation. Specifies the name of the domain you want to describe. To restrict the response to particular suggesters, specify the names of the suggesters you want to describe. To show the active configuration and exclude any pending changes, set the <code>Deployed</code> option to <code>true</code>.</p>
public struct DescribeSuggestersInput: Equatable {
    /// <p>Whether to display the deployed configuration (<code>true</code>) or include any pending changes (<code>false</code>). Defaults to <code>false</code>.</p>
    public let deployed: Bool?
    /// <p>The name of the domain you want to describe.</p>
    public let domainName: String?
    /// <p>The suggesters you want to describe.</p>
    public let suggesterNames: [String]?

    public init (
        deployed: Bool? = nil,
        domainName: String? = nil,
        suggesterNames: [String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.suggesterNames = suggesterNames
    }
}

extension DescribeSuggestersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeSuggestersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSuggestersOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSuggestersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSuggestersOutputResponse(suggesters: \(String(describing: suggesters)))"}
}

extension DescribeSuggestersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSuggestersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.suggesters = output.suggesters
        } else {
            self.suggesters = nil
        }
    }
}

/// <p>The result of a <code>DescribeSuggesters</code> request.</p>
public struct DescribeSuggestersOutputResponse: Equatable {
    /// <p>The suggesters configured for the domain specified in the request.</p>
    public let suggesters: [SuggesterStatus]?

    public init (
        suggesters: [SuggesterStatus]? = nil
    )
    {
        self.suggesters = suggesters
    }
}

struct DescribeSuggestersOutputResponseBody: Equatable {
    public let suggesters: [SuggesterStatus]?
}

extension DescribeSuggestersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case suggesters = "Suggesters"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeSuggestersResult"))
        if containerValues.contains(.suggesters) {
            struct KeyVal0{struct member{}}
            let suggestersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .suggesters)
            if let suggestersWrappedContainer = suggestersWrappedContainer {
                let suggestersContainer = try suggestersWrappedContainer.decodeIfPresent([SuggesterStatus].self, forKey: .member)
                var suggestersBuffer:[SuggesterStatus]? = nil
                if let suggestersContainer = suggestersContainer {
                    suggestersBuffer = [SuggesterStatus]()
                    for structureContainer0 in suggestersContainer {
                        suggestersBuffer?.append(structureContainer0)
                    }
                }
                suggesters = suggestersBuffer
            } else {
                suggesters = []
            }
        } else {
            suggesters = nil
        }
    }
}

extension DisabledOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisabledOperationException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension DisabledOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DisabledOperationExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it attempted an operation which is not enabled.</p>
public struct DisabledOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A machine-parsable string error or warning code.</p>
    public var code: String?
    /// <p>A human-readable string error or warning message.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct DisabledOperationExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension DisabledOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DocumentSuggesterOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fuzzyMatching = "FuzzyMatching"
        case sortExpression = "SortExpression"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let fuzzyMatching = fuzzyMatching {
            try container.encode(fuzzyMatching, forKey: Key("FuzzyMatching"))
        }
        if let sortExpression = sortExpression {
            try container.encode(sortExpression, forKey: Key("SortExpression"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: Key("SourceField"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let fuzzyMatchingDecoded = try containerValues.decodeIfPresent(SuggesterFuzzyMatching.self, forKey: .fuzzyMatching)
        fuzzyMatching = fuzzyMatchingDecoded
        let sortExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sortExpression)
        sortExpression = sortExpressionDecoded
    }
}

extension DocumentSuggesterOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentSuggesterOptions(fuzzyMatching: \(String(describing: fuzzyMatching)), sortExpression: \(String(describing: sortExpression)), sourceField: \(String(describing: sourceField)))"}
}

/// <p>Options for a search suggester.</p>
public struct DocumentSuggesterOptions: Equatable {
    /// <p>The level of fuzziness allowed when suggesting matches for a string: <code>none</code>, <code>low</code>, or <code>high</code>. With none, the specified string is treated as an exact prefix. With low, suggestions must differ from the specified string by no more than one character. With high, suggestions can differ by up to two characters. The default is none. </p>
    public let fuzzyMatching: SuggesterFuzzyMatching?
    /// <p>An expression that computes a score for each suggestion to control how they are sorted. The scores are rounded to the nearest
    ///         integer, with a floor of 0 and a ceiling of 2^31-1. A document's relevance score is not computed
    ///         for suggestions, so sort expressions cannot reference the <code>_score</code> value.
    ///         To sort suggestions using a numeric field or existing expression, simply specify
    ///         the name of the field or expression. If no expression is configured for the suggester, the
    ///         suggestions are sorted with the closest matches listed first.</p>
    public let sortExpression: String?
    /// <p>The name of the index field you want to use for suggestions.
    ///       </p>
    public let sourceField: String?

    public init (
        fuzzyMatching: SuggesterFuzzyMatching? = nil,
        sortExpression: String? = nil,
        sourceField: String? = nil
    )
    {
        self.fuzzyMatching = fuzzyMatching
        self.sortExpression = sortExpression
        self.sourceField = sourceField
    }
}

extension DomainEndpointOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enforceHTTPS = "EnforceHTTPS"
        case tLSSecurityPolicy = "TLSSecurityPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let enforceHTTPS = enforceHTTPS {
            try container.encode(enforceHTTPS, forKey: Key("EnforceHTTPS"))
        }
        if let tLSSecurityPolicy = tLSSecurityPolicy {
            try container.encode(tLSSecurityPolicy, forKey: Key("TLSSecurityPolicy"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceHTTPSDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enforceHTTPS)
        enforceHTTPS = enforceHTTPSDecoded
        let tLSSecurityPolicyDecoded = try containerValues.decodeIfPresent(TLSSecurityPolicy.self, forKey: .tLSSecurityPolicy)
        tLSSecurityPolicy = tLSSecurityPolicyDecoded
    }
}

extension DomainEndpointOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainEndpointOptions(enforceHTTPS: \(String(describing: enforceHTTPS)), tLSSecurityPolicy: \(String(describing: tLSSecurityPolicy)))"}
}

/// <p>The domain's endpoint options.</p>
public struct DomainEndpointOptions: Equatable {
    /// <p>Whether the domain is HTTPS only enabled.</p>
    public let enforceHTTPS: Bool?
    /// <p>The minimum required TLS version</p>
    public let tLSSecurityPolicy: TLSSecurityPolicy?

    public init (
        enforceHTTPS: Bool? = nil,
        tLSSecurityPolicy: TLSSecurityPolicy? = nil
    )
    {
        self.enforceHTTPS = enforceHTTPS
        self.tLSSecurityPolicy = tLSSecurityPolicy
    }
}

extension DomainEndpointOptionsStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let options = options {
            try container.encode(options, forKey: Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(DomainEndpointOptions.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DomainEndpointOptionsStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainEndpointOptionsStatus(options: \(String(describing: options)), status: \(String(describing: status)))"}
}

/// <p>The configuration and status of the domain's endpoint options.</p>
public struct DomainEndpointOptionsStatus: Equatable {
    /// <p>The domain endpoint options configured for the domain.</p>
    public let options: DomainEndpointOptions?
    /// <p>The status of the configured domain endpoint options.</p>
    public let status: OptionStatus?

    public init (
        options: DomainEndpointOptions? = nil,
        status: OptionStatus? = nil
    )
    {
        self.options = options
        self.status = status
    }
}

extension DomainStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case created = "Created"
        case deleted = "Deleted"
        case docService = "DocService"
        case domainId = "DomainId"
        case domainName = "DomainName"
        case limits = "Limits"
        case processing = "Processing"
        case requiresIndexDocuments = "RequiresIndexDocuments"
        case searchInstanceCount = "SearchInstanceCount"
        case searchInstanceType = "SearchInstanceType"
        case searchPartitionCount = "SearchPartitionCount"
        case searchService = "SearchService"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let aRN = aRN {
            try container.encode(aRN, forKey: Key("ARN"))
        }
        if let created = created {
            try container.encode(created, forKey: Key("Created"))
        }
        if let deleted = deleted {
            try container.encode(deleted, forKey: Key("Deleted"))
        }
        if let docService = docService {
            try container.encode(docService, forKey: Key("DocService"))
        }
        if let domainId = domainId {
            try container.encode(domainId, forKey: Key("DomainId"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        if let limits = limits {
            try container.encode(limits, forKey: Key("Limits"))
        }
        if let processing = processing {
            try container.encode(processing, forKey: Key("Processing"))
        }
        if let requiresIndexDocuments = requiresIndexDocuments {
            try container.encode(requiresIndexDocuments, forKey: Key("RequiresIndexDocuments"))
        }
        if searchInstanceCount != 0 {
            try container.encode(searchInstanceCount, forKey: Key("SearchInstanceCount"))
        }
        if let searchInstanceType = searchInstanceType {
            try container.encode(searchInstanceType, forKey: Key("SearchInstanceType"))
        }
        if searchPartitionCount != 0 {
            try container.encode(searchPartitionCount, forKey: Key("SearchPartitionCount"))
        }
        if let searchService = searchService {
            try container.encode(searchService, forKey: Key("SearchService"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .created)
        created = createdDecoded
        let deletedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deleted)
        deleted = deletedDecoded
        let docServiceDecoded = try containerValues.decodeIfPresent(ServiceEndpoint.self, forKey: .docService)
        docService = docServiceDecoded
        let searchServiceDecoded = try containerValues.decodeIfPresent(ServiceEndpoint.self, forKey: .searchService)
        searchService = searchServiceDecoded
        let requiresIndexDocumentsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .requiresIndexDocuments)
        requiresIndexDocuments = requiresIndexDocumentsDecoded
        let processingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .processing)
        processing = processingDecoded
        let searchInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .searchInstanceType)
        searchInstanceType = searchInstanceTypeDecoded
        let searchPartitionCountDecoded = try containerValues.decode(Int.self, forKey: .searchPartitionCount)
        searchPartitionCount = searchPartitionCountDecoded
        let searchInstanceCountDecoded = try containerValues.decode(Int.self, forKey: .searchInstanceCount)
        searchInstanceCount = searchInstanceCountDecoded
        let limitsDecoded = try containerValues.decodeIfPresent(Limits.self, forKey: .limits)
        limits = limitsDecoded
    }
}

extension DomainStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainStatus(aRN: \(String(describing: aRN)), created: \(String(describing: created)), deleted: \(String(describing: deleted)), docService: \(String(describing: docService)), domainId: \(String(describing: domainId)), domainName: \(String(describing: domainName)), limits: \(String(describing: limits)), processing: \(String(describing: processing)), requiresIndexDocuments: \(String(describing: requiresIndexDocuments)), searchInstanceCount: \(String(describing: searchInstanceCount)), searchInstanceType: \(String(describing: searchInstanceType)), searchPartitionCount: \(String(describing: searchPartitionCount)), searchService: \(String(describing: searchService)))"}
}

/// <p>The current status of the search domain.</p>
public struct DomainStatus: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the search domain.  See <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i> for more information.</p>
    public let aRN: String?
    /// <p>True if the search domain is created. It can take several minutes to initialize a domain when <a>CreateDomain</a> is called. Newly created search domains are returned from <a>DescribeDomains</a> with a false value for Created until domain creation is complete.</p>
    public let created: Bool?
    /// <p>True if the search domain has been deleted.  The system must clean up resources dedicated to the search domain when <a>DeleteDomain</a> is called.  Newly deleted search domains are returned from <a>DescribeDomains</a> with a true value for IsDeleted for several minutes until resource cleanup is complete.</p>
    public let deleted: Bool?
    /// <p>The service endpoint for updating documents in a search domain.</p>
    public let docService: ServiceEndpoint?
    /// <p>An internally generated unique identifier for a domain.</p>
    public let domainId: String?
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?
    public let limits: Limits?
    /// <p>True if processing is being done to activate the current domain configuration.</p>
    public let processing: Bool?
    /// <p>True if <a>IndexDocuments</a> needs to be called to activate the current domain configuration.</p>
    public let requiresIndexDocuments: Bool?
    /// <p>The number of search instances that are available to process search requests.</p>
    public let searchInstanceCount: Int
    /// <p>The instance type that is being used to process search requests.</p>
    public let searchInstanceType: String?
    /// <p>The number of partitions across which the search index is spread.</p>
    public let searchPartitionCount: Int
    /// <p>The service endpoint for requesting search results from a search domain.</p>
    public let searchService: ServiceEndpoint?

    public init (
        aRN: String? = nil,
        created: Bool? = nil,
        deleted: Bool? = nil,
        docService: ServiceEndpoint? = nil,
        domainId: String? = nil,
        domainName: String? = nil,
        limits: Limits? = nil,
        processing: Bool? = nil,
        requiresIndexDocuments: Bool? = nil,
        searchInstanceCount: Int = 0,
        searchInstanceType: String? = nil,
        searchPartitionCount: Int = 0,
        searchService: ServiceEndpoint? = nil
    )
    {
        self.aRN = aRN
        self.created = created
        self.deleted = deleted
        self.docService = docService
        self.domainId = domainId
        self.domainName = domainName
        self.limits = limits
        self.processing = processing
        self.requiresIndexDocuments = requiresIndexDocuments
        self.searchInstanceCount = searchInstanceCount
        self.searchInstanceType = searchInstanceType
        self.searchPartitionCount = searchPartitionCount
        self.searchService = searchService
    }
}

extension DoubleArrayOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: Key("SourceFields"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
    }
}

extension DoubleArrayOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DoubleArrayOptions(defaultValue: \(String(describing: defaultValue)), facetEnabled: \(String(describing: facetEnabled)), returnEnabled: \(String(describing: returnEnabled)), searchEnabled: \(String(describing: searchEnabled)), sourceFields: \(String(describing: sourceFields)))"}
}

/// <p>Options for a field that contains an array of double-precision 64-bit floating point values.  Present if <code>IndexFieldType</code> specifies the field is of type <code>double-array</code>.  All options are enabled by default.</p>
public struct DoubleArrayOptions: Equatable {
    /// A value to use for the field if the field isn't specified for a document.
    public let defaultValue: Double?
    /// <p>Whether facet information can be returned for the field.</p>
    public let facetEnabled: Bool?
    /// <p>Whether the contents of the field can be returned in the search results.</p>
    public let returnEnabled: Bool?
    /// <p>Whether the contents of the field are searchable.</p>
    public let searchEnabled: Bool?
    /// <p>A list of source fields to map to the field. </p>
    public let sourceFields: String?

    public init (
        defaultValue: Double? = nil,
        facetEnabled: Bool? = nil,
        returnEnabled: Bool? = nil,
        searchEnabled: Bool? = nil,
        sourceFields: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.facetEnabled = facetEnabled
        self.returnEnabled = returnEnabled
        self.searchEnabled = searchEnabled
        self.sourceFields = sourceFields
    }
}

extension DoubleOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: Key("SourceField"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension DoubleOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DoubleOptions(defaultValue: \(String(describing: defaultValue)), facetEnabled: \(String(describing: facetEnabled)), returnEnabled: \(String(describing: returnEnabled)), searchEnabled: \(String(describing: searchEnabled)), sortEnabled: \(String(describing: sortEnabled)), sourceField: \(String(describing: sourceField)))"}
}

/// <p>Options for a double-precision 64-bit floating point field.  Present if <code>IndexFieldType</code> specifies the field is of type <code>double</code>. All options are enabled by default.</p>
public struct DoubleOptions: Equatable {
    /// <p>A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.</p>
    public let defaultValue: Double?
    /// <p>Whether facet information can be returned for the field.</p>
    public let facetEnabled: Bool?
    /// <p>Whether the contents of the field can be returned in the search results.</p>
    public let returnEnabled: Bool?
    /// <p>Whether the contents of the field are searchable.</p>
    public let searchEnabled: Bool?
    /// <p>Whether the field can be used to sort the search results.</p>
    public let sortEnabled: Bool?
    /// <p>The name of the source field to map to the field. </p>
    public let sourceField: String?

    public init (
        defaultValue: Double? = nil,
        facetEnabled: Bool? = nil,
        returnEnabled: Bool? = nil,
        searchEnabled: Bool? = nil,
        sortEnabled: Bool? = nil,
        sourceField: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.facetEnabled = facetEnabled
        self.returnEnabled = returnEnabled
        self.searchEnabled = searchEnabled
        self.sortEnabled = sortEnabled
        self.sourceField = sourceField
    }
}

extension Expression: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expressionName = "ExpressionName"
        case expressionValue = "ExpressionValue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let expressionName = expressionName {
            try container.encode(expressionName, forKey: Key("ExpressionName"))
        }
        if let expressionValue = expressionValue {
            try container.encode(expressionValue, forKey: Key("ExpressionValue"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expressionName)
        expressionName = expressionNameDecoded
        let expressionValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expressionValue)
        expressionValue = expressionValueDecoded
    }
}

extension Expression: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Expression(expressionName: \(String(describing: expressionName)), expressionValue: \(String(describing: expressionValue)))"}
}

/// <p>A named expression that can be evaluated at search time. Can be used to sort the search results, define other expressions, or return computed information in the search results.  </p>
public struct Expression: Equatable {
    /// <p>Names must begin with a letter and can contain the following characters:
    ///       a-z (lowercase), 0-9, and _ (underscore).</p>
    public let expressionName: String?
    /// <p>The expression to evaluate for sorting while processing a search request.  The <code>Expression</code> syntax is based on JavaScript expressions. For more information, see <a href="http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-expressions.html" target="_blank">Configuring Expressions</a> in the <i>Amazon CloudSearch Developer Guide</i>.</p>
    public let expressionValue: String?

    public init (
        expressionName: String? = nil,
        expressionValue: String? = nil
    )
    {
        self.expressionName = expressionName
        self.expressionValue = expressionValue
    }
}

extension ExpressionStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let options = options {
            try container.encode(options, forKey: Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ExpressionStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpressionStatus(options: \(String(describing: options)), status: \(String(describing: status)))"}
}

/// <p>The value of an <code>Expression</code> and its current status.</p>
public struct ExpressionStatus: Equatable {
    /// <p>The expression that is evaluated for sorting while processing a search request.</p>
    public let options: Expression?
    /// <p>The status of domain configuration option.</p>
    public let status: OptionStatus?

    public init (
        options: Expression? = nil,
        status: OptionStatus? = nil
    )
    {
        self.options = options
        self.status = status
    }
}

public struct IndexDocumentsInputBodyMiddleware: Middleware {
    public let id: String = "IndexDocumentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<IndexDocumentsInput>,
                  next: H) -> Swift.Result<OperationOutput<IndexDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<IndexDocumentsInput>
    public typealias MOutput = OperationOutput<IndexDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<IndexDocumentsOutputError>
}

extension IndexDocumentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IndexDocumentsInput(domainName: \(String(describing: domainName)))"}
}

extension IndexDocumentsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("IndexDocuments", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct IndexDocumentsInputHeadersMiddleware: Middleware {
    public let id: String = "IndexDocumentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<IndexDocumentsInput>,
                  next: H) -> Swift.Result<OperationOutput<IndexDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<IndexDocumentsInput>
    public typealias MOutput = OperationOutput<IndexDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<IndexDocumentsOutputError>
}

public struct IndexDocumentsInputQueryItemMiddleware: Middleware {
    public let id: String = "IndexDocumentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<IndexDocumentsInput>,
                  next: H) -> Swift.Result<OperationOutput<IndexDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<IndexDocumentsInput>
    public typealias MOutput = OperationOutput<IndexDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<IndexDocumentsOutputError>
}

/// <p>Container for the parameters to the <code><a>IndexDocuments</a></code> operation. Specifies the name of the domain you want to re-index.</p>
public struct IndexDocumentsInput: Equatable {
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension IndexDocumentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension IndexDocumentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum IndexDocumentsOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension IndexDocumentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IndexDocumentsOutputResponse(fieldNames: \(String(describing: fieldNames)))"}
}

extension IndexDocumentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IndexDocumentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fieldNames = output.fieldNames
        } else {
            self.fieldNames = nil
        }
    }
}

/// <p>The result of an <code>IndexDocuments</code> request. Contains the status of the indexing operation, including the fields being indexed.</p>
public struct IndexDocumentsOutputResponse: Equatable {
    /// <p>The names of the fields that are currently being indexed.</p>
    public let fieldNames: [String]?

    public init (
        fieldNames: [String]? = nil
    )
    {
        self.fieldNames = fieldNames
    }
}

struct IndexDocumentsOutputResponseBody: Equatable {
    public let fieldNames: [String]?
}

extension IndexDocumentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldNames = "FieldNames"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("IndexDocumentsResult"))
        if containerValues.contains(.fieldNames) {
            struct KeyVal0{struct member{}}
            let fieldNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .fieldNames)
            if let fieldNamesWrappedContainer = fieldNamesWrappedContainer {
                let fieldNamesContainer = try fieldNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var fieldNamesBuffer:[String]? = nil
                if let fieldNamesContainer = fieldNamesContainer {
                    fieldNamesBuffer = [String]()
                    for stringContainer0 in fieldNamesContainer {
                        fieldNamesBuffer?.append(stringContainer0)
                    }
                }
                fieldNames = fieldNamesBuffer
            } else {
                fieldNames = []
            }
        } else {
            fieldNames = nil
        }
    }
}

extension IndexField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dateArrayOptions = "DateArrayOptions"
        case dateOptions = "DateOptions"
        case doubleArrayOptions = "DoubleArrayOptions"
        case doubleOptions = "DoubleOptions"
        case indexFieldName = "IndexFieldName"
        case indexFieldType = "IndexFieldType"
        case intArrayOptions = "IntArrayOptions"
        case intOptions = "IntOptions"
        case latLonOptions = "LatLonOptions"
        case literalArrayOptions = "LiteralArrayOptions"
        case literalOptions = "LiteralOptions"
        case textArrayOptions = "TextArrayOptions"
        case textOptions = "TextOptions"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dateArrayOptions = dateArrayOptions {
            try container.encode(dateArrayOptions, forKey: Key("DateArrayOptions"))
        }
        if let dateOptions = dateOptions {
            try container.encode(dateOptions, forKey: Key("DateOptions"))
        }
        if let doubleArrayOptions = doubleArrayOptions {
            try container.encode(doubleArrayOptions, forKey: Key("DoubleArrayOptions"))
        }
        if let doubleOptions = doubleOptions {
            try container.encode(doubleOptions, forKey: Key("DoubleOptions"))
        }
        if let indexFieldName = indexFieldName {
            try container.encode(indexFieldName, forKey: Key("IndexFieldName"))
        }
        if let indexFieldType = indexFieldType {
            try container.encode(indexFieldType, forKey: Key("IndexFieldType"))
        }
        if let intArrayOptions = intArrayOptions {
            try container.encode(intArrayOptions, forKey: Key("IntArrayOptions"))
        }
        if let intOptions = intOptions {
            try container.encode(intOptions, forKey: Key("IntOptions"))
        }
        if let latLonOptions = latLonOptions {
            try container.encode(latLonOptions, forKey: Key("LatLonOptions"))
        }
        if let literalArrayOptions = literalArrayOptions {
            try container.encode(literalArrayOptions, forKey: Key("LiteralArrayOptions"))
        }
        if let literalOptions = literalOptions {
            try container.encode(literalOptions, forKey: Key("LiteralOptions"))
        }
        if let textArrayOptions = textArrayOptions {
            try container.encode(textArrayOptions, forKey: Key("TextArrayOptions"))
        }
        if let textOptions = textOptions {
            try container.encode(textOptions, forKey: Key("TextOptions"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
        let indexFieldTypeDecoded = try containerValues.decodeIfPresent(IndexFieldType.self, forKey: .indexFieldType)
        indexFieldType = indexFieldTypeDecoded
        let intOptionsDecoded = try containerValues.decodeIfPresent(IntOptions.self, forKey: .intOptions)
        intOptions = intOptionsDecoded
        let doubleOptionsDecoded = try containerValues.decodeIfPresent(DoubleOptions.self, forKey: .doubleOptions)
        doubleOptions = doubleOptionsDecoded
        let literalOptionsDecoded = try containerValues.decodeIfPresent(LiteralOptions.self, forKey: .literalOptions)
        literalOptions = literalOptionsDecoded
        let textOptionsDecoded = try containerValues.decodeIfPresent(TextOptions.self, forKey: .textOptions)
        textOptions = textOptionsDecoded
        let dateOptionsDecoded = try containerValues.decodeIfPresent(DateOptions.self, forKey: .dateOptions)
        dateOptions = dateOptionsDecoded
        let latLonOptionsDecoded = try containerValues.decodeIfPresent(LatLonOptions.self, forKey: .latLonOptions)
        latLonOptions = latLonOptionsDecoded
        let intArrayOptionsDecoded = try containerValues.decodeIfPresent(IntArrayOptions.self, forKey: .intArrayOptions)
        intArrayOptions = intArrayOptionsDecoded
        let doubleArrayOptionsDecoded = try containerValues.decodeIfPresent(DoubleArrayOptions.self, forKey: .doubleArrayOptions)
        doubleArrayOptions = doubleArrayOptionsDecoded
        let literalArrayOptionsDecoded = try containerValues.decodeIfPresent(LiteralArrayOptions.self, forKey: .literalArrayOptions)
        literalArrayOptions = literalArrayOptionsDecoded
        let textArrayOptionsDecoded = try containerValues.decodeIfPresent(TextArrayOptions.self, forKey: .textArrayOptions)
        textArrayOptions = textArrayOptionsDecoded
        let dateArrayOptionsDecoded = try containerValues.decodeIfPresent(DateArrayOptions.self, forKey: .dateArrayOptions)
        dateArrayOptions = dateArrayOptionsDecoded
    }
}

extension IndexField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IndexField(dateArrayOptions: \(String(describing: dateArrayOptions)), dateOptions: \(String(describing: dateOptions)), doubleArrayOptions: \(String(describing: doubleArrayOptions)), doubleOptions: \(String(describing: doubleOptions)), indexFieldName: \(String(describing: indexFieldName)), indexFieldType: \(String(describing: indexFieldType)), intArrayOptions: \(String(describing: intArrayOptions)), intOptions: \(String(describing: intOptions)), latLonOptions: \(String(describing: latLonOptions)), literalArrayOptions: \(String(describing: literalArrayOptions)), literalOptions: \(String(describing: literalOptions)), textArrayOptions: \(String(describing: textArrayOptions)), textOptions: \(String(describing: textOptions)))"}
}

/// <p>Configuration information for a field in the index, including its name, type, and options. The supported options depend on the <code><a>IndexFieldType</a></code>.</p>
public struct IndexField: Equatable {
    /// <p>Options for a field that contains an array of dates.  Present if <code>IndexFieldType</code> specifies the field is of type <code>date-array</code>. All options are enabled by default.</p>
    public let dateArrayOptions: DateArrayOptions?
    /// <p>Options for a date field. Dates and times are specified in UTC (Coordinated Universal Time) according to IETF RFC3339: yyyy-mm-ddT00:00:00Z.  Present if <code>IndexFieldType</code> specifies the field is of type <code>date</code>. All options are enabled by default.</p>
    public let dateOptions: DateOptions?
    /// <p>Options for a field that contains an array of double-precision 64-bit floating point values.  Present if <code>IndexFieldType</code> specifies the field is of type <code>double-array</code>.  All options are enabled by default.</p>
    public let doubleArrayOptions: DoubleArrayOptions?
    /// <p>Options for a double-precision 64-bit floating point field.  Present if <code>IndexFieldType</code> specifies the field is of type <code>double</code>. All options are enabled by default.</p>
    public let doubleOptions: DoubleOptions?
    /// <p>A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields.
    ///       A dynamic field's name defines a pattern that begins or ends with a wildcard.
    ///       Any document fields that don't map to a regular index field but do match a	
    ///       dynamic field's pattern are configured with the dynamic field's indexing options.
    ///     </p>
    ///     <p>Regular field names begin with a letter and can contain the following characters:
    ///       a-z (lowercase), 0-9, and _ (underscore).
    ///       Dynamic field names must begin or end with a wildcard (*).
    ///       The wildcard can also be the only character in a dynamic field name.
    ///       Multiple wildcards, and wildcards embedded within a string are not supported.
    ///     </p>
    ///     <p>The name <code>score</code> is reserved and cannot be used as a field name.
    ///       To reference a document's ID, you can use the name <code>_id</code>.
    ///     </p>
    public let indexFieldName: String?
    /// <p>The type of field. The valid options for a field depend on the field type. For more information about the supported field types, see <a href="http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-index-fields.html" target="_blank">Configuring Index Fields</a> in the <i>Amazon CloudSearch Developer Guide</i>.</p>
    public let indexFieldType: IndexFieldType?
    /// <p>Options for a field that contains an array of 64-bit signed integers.  Present if <code>IndexFieldType</code> specifies the field is of type <code>int-array</code>. All options are enabled by default.</p>
    public let intArrayOptions: IntArrayOptions?
    /// <p>Options for a 64-bit signed integer field.  Present if <code>IndexFieldType</code> specifies the field is of type <code>int</code>. All options are enabled by default.</p>
    public let intOptions: IntOptions?
    /// <p>Options for a latlon field. A latlon field contains a location stored as a latitude and longitude value pair. Present if <code>IndexFieldType</code> specifies the field is of type <code>latlon</code>. All options are enabled by default.</p>
    public let latLonOptions: LatLonOptions?
    /// <p>Options for a field that contains an array of literal strings.  Present if <code>IndexFieldType</code> specifies the field is of type <code>literal-array</code>. All options are enabled by default.</p>
    public let literalArrayOptions: LiteralArrayOptions?
    /// <p>Options for literal field.  Present if <code>IndexFieldType</code> specifies the field is of type <code>literal</code>. All options are enabled by default.</p>
    public let literalOptions: LiteralOptions?
    /// <p>Options for a field that contains an array of text strings.  Present if <code>IndexFieldType</code> specifies the field is of type <code>text-array</code>. A <code>text-array</code> field is always searchable. All options are enabled by default.</p>
    public let textArrayOptions: TextArrayOptions?
    /// <p>Options for text field.  Present if <code>IndexFieldType</code> specifies the field is of type <code>text</code>. A <code>text</code> field is always searchable. All options are enabled by default.</p>
    public let textOptions: TextOptions?

    public init (
        dateArrayOptions: DateArrayOptions? = nil,
        dateOptions: DateOptions? = nil,
        doubleArrayOptions: DoubleArrayOptions? = nil,
        doubleOptions: DoubleOptions? = nil,
        indexFieldName: String? = nil,
        indexFieldType: IndexFieldType? = nil,
        intArrayOptions: IntArrayOptions? = nil,
        intOptions: IntOptions? = nil,
        latLonOptions: LatLonOptions? = nil,
        literalArrayOptions: LiteralArrayOptions? = nil,
        literalOptions: LiteralOptions? = nil,
        textArrayOptions: TextArrayOptions? = nil,
        textOptions: TextOptions? = nil
    )
    {
        self.dateArrayOptions = dateArrayOptions
        self.dateOptions = dateOptions
        self.doubleArrayOptions = doubleArrayOptions
        self.doubleOptions = doubleOptions
        self.indexFieldName = indexFieldName
        self.indexFieldType = indexFieldType
        self.intArrayOptions = intArrayOptions
        self.intOptions = intOptions
        self.latLonOptions = latLonOptions
        self.literalArrayOptions = literalArrayOptions
        self.literalOptions = literalOptions
        self.textArrayOptions = textArrayOptions
        self.textOptions = textOptions
    }
}

extension IndexFieldStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let options = options {
            try container.encode(options, forKey: Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(IndexField.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IndexFieldStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IndexFieldStatus(options: \(String(describing: options)), status: \(String(describing: status)))"}
}

/// <p>The value of an <code>IndexField</code> and its current status.</p>
public struct IndexFieldStatus: Equatable {
    /// <p>Configuration information for a field in the index, including its name, type, and options. The supported options depend on the <code><a>IndexFieldType</a></code>.</p>
    public let options: IndexField?
    /// <p>The status of domain configuration option.</p>
    public let status: OptionStatus?

    public init (
        options: IndexField? = nil,
        status: OptionStatus? = nil
    )
    {
        self.options = options
        self.status = status
    }
}

/// <p>The type of field. The valid options for a field depend on the field type. For more information about the supported field types, see <a href="http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-index-fields.html" target="_blank">Configuring Index Fields</a> in the <i>Amazon CloudSearch Developer Guide</i>.</p>
public enum IndexFieldType {
    case date
    case dateArray
    case double
    case doubleArray
    case int
    case intArray
    case latlon
    case literal
    case literalArray
    case text
    case textArray
    case sdkUnknown(String)
}

extension IndexFieldType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IndexFieldType] {
        return [
            .date,
            .dateArray,
            .double,
            .doubleArray,
            .int,
            .intArray,
            .latlon,
            .literal,
            .literalArray,
            .text,
            .textArray,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .date: return "date"
        case .dateArray: return "date-array"
        case .double: return "double"
        case .doubleArray: return "double-array"
        case .int: return "int"
        case .intArray: return "int-array"
        case .latlon: return "latlon"
        case .literal: return "literal"
        case .literalArray: return "literal-array"
        case .text: return "text"
        case .textArray: return "text-array"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IndexFieldType(rawValue: rawValue) ?? IndexFieldType.sdkUnknown(rawValue)
    }
}

extension IntArrayOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: Key("SourceFields"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
    }
}

extension IntArrayOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntArrayOptions(defaultValue: \(String(describing: defaultValue)), facetEnabled: \(String(describing: facetEnabled)), returnEnabled: \(String(describing: returnEnabled)), searchEnabled: \(String(describing: searchEnabled)), sourceFields: \(String(describing: sourceFields)))"}
}

/// <p>Options for a field that contains an array of 64-bit signed integers.  Present if <code>IndexFieldType</code> specifies the field is of type <code>int-array</code>. All options are enabled by default.</p>
public struct IntArrayOptions: Equatable {
    /// A value to use for the field if the field isn't specified for a document.
    public let defaultValue: Int?
    /// <p>Whether facet information can be returned for the field.</p>
    public let facetEnabled: Bool?
    /// <p>Whether the contents of the field can be returned in the search results.</p>
    public let returnEnabled: Bool?
    /// <p>Whether the contents of the field are searchable.</p>
    public let searchEnabled: Bool?
    /// <p>A list of source fields to map to the field. </p>
    public let sourceFields: String?

    public init (
        defaultValue: Int? = nil,
        facetEnabled: Bool? = nil,
        returnEnabled: Bool? = nil,
        searchEnabled: Bool? = nil,
        sourceFields: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.facetEnabled = facetEnabled
        self.returnEnabled = returnEnabled
        self.searchEnabled = searchEnabled
        self.sourceFields = sourceFields
    }
}

extension IntOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: Key("SourceField"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension IntOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntOptions(defaultValue: \(String(describing: defaultValue)), facetEnabled: \(String(describing: facetEnabled)), returnEnabled: \(String(describing: returnEnabled)), searchEnabled: \(String(describing: searchEnabled)), sortEnabled: \(String(describing: sortEnabled)), sourceField: \(String(describing: sourceField)))"}
}

/// <p>Options for a 64-bit signed integer field.  Present if <code>IndexFieldType</code> specifies the field is of type <code>int</code>. All options are enabled by default.</p>
public struct IntOptions: Equatable {
    /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
    public let defaultValue: Int?
    /// <p>Whether facet information can be returned for the field.</p>
    public let facetEnabled: Bool?
    /// <p>Whether the contents of the field can be returned in the search results.</p>
    public let returnEnabled: Bool?
    /// <p>Whether the contents of the field are searchable.</p>
    public let searchEnabled: Bool?
    /// <p>Whether the field can be used to sort the search results.</p>
    public let sortEnabled: Bool?
    /// <p>The name of the source field to map to the field. </p>
    public let sourceField: String?

    public init (
        defaultValue: Int? = nil,
        facetEnabled: Bool? = nil,
        returnEnabled: Bool? = nil,
        searchEnabled: Bool? = nil,
        sortEnabled: Bool? = nil,
        sourceField: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.facetEnabled = facetEnabled
        self.returnEnabled = returnEnabled
        self.searchEnabled = searchEnabled
        self.sortEnabled = sortEnabled
        self.sourceField = sourceField
    }
}

extension InternalException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InternalException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InternalExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal error occurred while processing the request. If this problem persists,
///       report an issue from the <a href="http://status.aws.amazon.com/" target="_blank">Service Health Dashboard</a>.</p>
public struct InternalException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>A machine-parsable string error or warning code.</p>
    public var code: String?
    /// <p>A human-readable string error or warning message.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension InternalExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTypeException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InvalidTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidTypeExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it specified an invalid type definition.</p>
public struct InvalidTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A machine-parsable string error or warning code.</p>
    public var code: String?
    /// <p>A human-readable string error or warning message.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidTypeExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension InvalidTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LatLonOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: Key("SourceField"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension LatLonOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LatLonOptions(defaultValue: \(String(describing: defaultValue)), facetEnabled: \(String(describing: facetEnabled)), returnEnabled: \(String(describing: returnEnabled)), searchEnabled: \(String(describing: searchEnabled)), sortEnabled: \(String(describing: sortEnabled)), sourceField: \(String(describing: sourceField)))"}
}

/// <p>Options for a latlon field. A latlon field contains a location stored as a latitude and longitude value pair. Present if <code>IndexFieldType</code> specifies the field is of type <code>latlon</code>. All options are enabled by default.</p>
public struct LatLonOptions: Equatable {
    /// A value to use for the field if the field isn't specified for a document.
    public let defaultValue: String?
    /// <p>Whether facet information can be returned for the field.</p>
    public let facetEnabled: Bool?
    /// <p>Whether the contents of the field can be returned in the search results.</p>
    public let returnEnabled: Bool?
    /// <p>Whether the contents of the field are searchable.</p>
    public let searchEnabled: Bool?
    /// <p>Whether the field can be used to sort the search results.</p>
    public let sortEnabled: Bool?
    /// <p>A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields.
    ///       A dynamic field's name defines a pattern that begins or ends with a wildcard.
    ///       Any document fields that don't map to a regular index field but do match a	
    ///       dynamic field's pattern are configured with the dynamic field's indexing options.
    ///     </p>
    ///     <p>Regular field names begin with a letter and can contain the following characters:
    ///       a-z (lowercase), 0-9, and _ (underscore).
    ///       Dynamic field names must begin or end with a wildcard (*).
    ///       The wildcard can also be the only character in a dynamic field name.
    ///       Multiple wildcards, and wildcards embedded within a string are not supported.
    ///     </p>
    ///     <p>The name <code>score</code> is reserved and cannot be used as a field name.
    ///       To reference a document's ID, you can use the name <code>_id</code>.
    ///     </p>
    public let sourceField: String?

    public init (
        defaultValue: String? = nil,
        facetEnabled: Bool? = nil,
        returnEnabled: Bool? = nil,
        searchEnabled: Bool? = nil,
        sortEnabled: Bool? = nil,
        sourceField: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.facetEnabled = facetEnabled
        self.returnEnabled = returnEnabled
        self.searchEnabled = searchEnabled
        self.sortEnabled = sortEnabled
        self.sourceField = sourceField
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<LimitExceededExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because a resource limit has already been met.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A machine-parsable string error or warning code.</p>
    public var code: String?
    /// <p>A human-readable string error or warning message.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Limits: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maximumPartitionCount = "MaximumPartitionCount"
        case maximumReplicationCount = "MaximumReplicationCount"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if maximumPartitionCount != 0 {
            try container.encode(maximumPartitionCount, forKey: Key("MaximumPartitionCount"))
        }
        if maximumReplicationCount != 0 {
            try container.encode(maximumReplicationCount, forKey: Key("MaximumReplicationCount"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumReplicationCountDecoded = try containerValues.decode(Int.self, forKey: .maximumReplicationCount)
        maximumReplicationCount = maximumReplicationCountDecoded
        let maximumPartitionCountDecoded = try containerValues.decode(Int.self, forKey: .maximumPartitionCount)
        maximumPartitionCount = maximumPartitionCountDecoded
    }
}

extension Limits: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Limits(maximumPartitionCount: \(String(describing: maximumPartitionCount)), maximumReplicationCount: \(String(describing: maximumReplicationCount)))"}
}

public struct Limits: Equatable {
    public let maximumPartitionCount: Int
    public let maximumReplicationCount: Int

    public init (
        maximumPartitionCount: Int = 0,
        maximumReplicationCount: Int = 0
    )
    {
        self.maximumPartitionCount = maximumPartitionCount
        self.maximumReplicationCount = maximumReplicationCount
    }
}

public struct ListDomainNamesInputBodyMiddleware: Middleware {
    public let id: String = "ListDomainNamesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainNamesInput>
    public typealias MOutput = OperationOutput<ListDomainNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainNamesOutputError>
}

extension ListDomainNamesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainNamesInput()"}
}

extension ListDomainNamesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("ListDomainNames", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct ListDomainNamesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDomainNamesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainNamesInput>
    public typealias MOutput = OperationOutput<ListDomainNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainNamesOutputError>
}

public struct ListDomainNamesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDomainNamesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainNamesInput>
    public typealias MOutput = OperationOutput<ListDomainNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainNamesOutputError>
}

public struct ListDomainNamesInput: Equatable {

    public init() {}
}

extension ListDomainNamesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDomainNamesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainNamesOutputError: Equatable {
    case baseException(BaseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainNamesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainNamesOutputResponse(domainNames: \(String(describing: domainNames)))"}
}

extension ListDomainNamesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDomainNamesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainNames = output.domainNames
        } else {
            self.domainNames = nil
        }
    }
}

/// <p>The result of a <code>ListDomainNames</code> request. Contains a list of the domains owned by an account.</p>
public struct ListDomainNamesOutputResponse: Equatable {
    /// <p>The names of the search domains owned by an account.</p>
    public let domainNames: [String:String]?

    public init (
        domainNames: [String:String]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

struct ListDomainNamesOutputResponseBody: Equatable {
    public let domainNames: [String:String]?
}

extension ListDomainNamesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainNames = "DomainNames"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListDomainNamesResult"))
        if containerValues.contains(.domainNames) {
            struct KeyVal0{struct key{}; struct value{}}
            let domainNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .domainNames)
            if let domainNamesWrappedContainer = domainNamesWrappedContainer {
                let domainNamesContainer = try domainNamesWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var domainNamesBuffer: [String:String]? = nil
                if let domainNamesContainer = domainNamesContainer {
                    domainNamesBuffer = [String:String]()
                    for stringContainer0 in domainNamesContainer {
                        domainNamesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                domainNames = domainNamesBuffer
            } else {
                domainNames = [:]
            }
        } else {
            domainNames = nil
        }
    }
}

extension LiteralArrayOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: Key("SourceFields"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
    }
}

extension LiteralArrayOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LiteralArrayOptions(defaultValue: \(String(describing: defaultValue)), facetEnabled: \(String(describing: facetEnabled)), returnEnabled: \(String(describing: returnEnabled)), searchEnabled: \(String(describing: searchEnabled)), sourceFields: \(String(describing: sourceFields)))"}
}

/// <p>Options for a field that contains an array of literal strings.  Present if <code>IndexFieldType</code> specifies the field is of type <code>literal-array</code>. All options are enabled by default.</p>
public struct LiteralArrayOptions: Equatable {
    /// A value to use for the field if the field isn't specified for a document.
    public let defaultValue: String?
    /// <p>Whether facet information can be returned for the field.</p>
    public let facetEnabled: Bool?
    /// <p>Whether the contents of the field can be returned in the search results.</p>
    public let returnEnabled: Bool?
    /// <p>Whether the contents of the field are searchable.</p>
    public let searchEnabled: Bool?
    /// <p>A list of source fields to map to the field. </p>
    public let sourceFields: String?

    public init (
        defaultValue: String? = nil,
        facetEnabled: Bool? = nil,
        returnEnabled: Bool? = nil,
        searchEnabled: Bool? = nil,
        sourceFields: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.facetEnabled = facetEnabled
        self.returnEnabled = returnEnabled
        self.searchEnabled = searchEnabled
        self.sourceFields = sourceFields
    }
}

extension LiteralOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: Key("SourceField"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension LiteralOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LiteralOptions(defaultValue: \(String(describing: defaultValue)), facetEnabled: \(String(describing: facetEnabled)), returnEnabled: \(String(describing: returnEnabled)), searchEnabled: \(String(describing: searchEnabled)), sortEnabled: \(String(describing: sortEnabled)), sourceField: \(String(describing: sourceField)))"}
}

/// <p>Options for literal field.  Present if <code>IndexFieldType</code> specifies the field is of type <code>literal</code>. All options are enabled by default.</p>
public struct LiteralOptions: Equatable {
    /// A value to use for the field if the field isn't specified for a document.
    public let defaultValue: String?
    /// <p>Whether facet information can be returned for the field.</p>
    public let facetEnabled: Bool?
    /// <p>Whether the contents of the field can be returned in the search results.</p>
    public let returnEnabled: Bool?
    /// <p>Whether the contents of the field are searchable.</p>
    public let searchEnabled: Bool?
    /// <p>Whether the field can be used to sort the search results.</p>
    public let sortEnabled: Bool?
    /// <p>A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields.
    ///       A dynamic field's name defines a pattern that begins or ends with a wildcard.
    ///       Any document fields that don't map to a regular index field but do match a	
    ///       dynamic field's pattern are configured with the dynamic field's indexing options.
    ///     </p>
    ///     <p>Regular field names begin with a letter and can contain the following characters:
    ///       a-z (lowercase), 0-9, and _ (underscore).
    ///       Dynamic field names must begin or end with a wildcard (*).
    ///       The wildcard can also be the only character in a dynamic field name.
    ///       Multiple wildcards, and wildcards embedded within a string are not supported.
    ///     </p>
    ///     <p>The name <code>score</code> is reserved and cannot be used as a field name.
    ///       To reference a document's ID, you can use the name <code>_id</code>.
    ///     </p>
    public let sourceField: String?

    public init (
        defaultValue: String? = nil,
        facetEnabled: Bool? = nil,
        returnEnabled: Bool? = nil,
        searchEnabled: Bool? = nil,
        sortEnabled: Bool? = nil,
        sourceField: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.facetEnabled = facetEnabled
        self.returnEnabled = returnEnabled
        self.searchEnabled = searchEnabled
        self.sortEnabled = sortEnabled
        self.sourceField = sourceField
    }
}

/// <p>The state of processing a change to an option. One of:</p>
///     <ul>
///       <li>RequiresIndexDocuments: The option's latest value will not be deployed until  <a>IndexDocuments</a> has been called and indexing is complete.</li>
///       <li>Processing: The option's latest value is in the process of being activated.</li>
///       <li>Active: The option's latest value is fully deployed. </li>
///       <li>FailedToValidate: The option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.</li>
///     </ul>
public enum OptionState {
    case active
    case failedtovalidate
    case processing
    case requiresindexdocuments
    case sdkUnknown(String)
}

extension OptionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OptionState] {
        return [
            .active,
            .failedtovalidate,
            .processing,
            .requiresindexdocuments,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .failedtovalidate: return "FailedToValidate"
        case .processing: return "Processing"
        case .requiresindexdocuments: return "RequiresIndexDocuments"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OptionState(rawValue: rawValue) ?? OptionState.sdkUnknown(rawValue)
    }
}

extension OptionStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case pendingDeletion = "PendingDeletion"
        case state = "State"
        case updateDate = "UpdateDate"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let creationDate = creationDate {
            try container.encode(TimestampWrapper(creationDate, format: .dateTime), forKey: Key("creationDate"))
        }
        if let pendingDeletion = pendingDeletion {
            try container.encode(pendingDeletion, forKey: Key("PendingDeletion"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
        if let updateDate = updateDate {
            try container.encode(TimestampWrapper(updateDate, format: .dateTime), forKey: Key("updateDate"))
        }
        if updateVersion != 0 {
            try container.encode(updateVersion, forKey: Key("UpdateVersion"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        var creationDateBuffer:Date? = nil
        if let creationDateDecoded = creationDateDecoded {
            creationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationDateDecoded, format: .dateTime)
        }
        creationDate = creationDateBuffer
        let updateDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateDate)
        var updateDateBuffer:Date? = nil
        if let updateDateDecoded = updateDateDecoded {
            updateDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(updateDateDecoded, format: .dateTime)
        }
        updateDate = updateDateBuffer
        let updateVersionDecoded = try containerValues.decode(Int.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(OptionState.self, forKey: .state)
        state = stateDecoded
        let pendingDeletionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .pendingDeletion)
        pendingDeletion = pendingDeletionDecoded
    }
}

extension OptionStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionStatus(creationDate: \(String(describing: creationDate)), pendingDeletion: \(String(describing: pendingDeletion)), state: \(String(describing: state)), updateDate: \(String(describing: updateDate)), updateVersion: \(String(describing: updateVersion)))"}
}

/// <p>The status of domain configuration option.</p>
public struct OptionStatus: Equatable {
    /// <p>A timestamp for when this option was created.</p>
    public let creationDate: Date?
    /// <p>Indicates that the option will be deleted once processing is complete.</p>
    public let pendingDeletion: Bool?
    /// <p>The state of processing a change to an option.  Possible values:</p><ul>
    ///     <li><code>RequiresIndexDocuments</code>: the option's latest value will not be deployed until  <a>IndexDocuments</a> has been called and indexing is complete.</li>
    ///     <li><code>Processing</code>: the option's latest value is in the process of being activated.  </li>
    ///     <li><code>Active</code>: the option's latest value is completely deployed.</li>
    ///     <li><code>FailedToValidate</code>: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.</li>
    ///   </ul>
    public let state: OptionState?
    /// <p>A timestamp for when this option was last updated.</p>
    public let updateDate: Date?
    /// <p>A unique integer that indicates when this option was last updated.</p>
    public let updateVersion: Int

    public init (
        creationDate: Date? = nil,
        pendingDeletion: Bool? = nil,
        state: OptionState? = nil,
        updateDate: Date? = nil,
        updateVersion: Int = 0
    )
    {
        self.creationDate = creationDate
        self.pendingDeletion = pendingDeletion
        self.state = state
        self.updateDate = updateDate
        self.updateVersion = updateVersion
    }
}

/// <p>The instance type (such as <code>search.m1.small</code>) on which an index partition is hosted.</p>
public enum PartitionInstanceType {
    case search2xlarge
    case searchLarge
    case searchM1Large
    case searchM1Small
    case searchM22xlarge
    case searchM2Xlarge
    case searchM32xlarge
    case searchM3Large
    case searchM3Medium
    case searchM3Xlarge
    case searchMedium
    case searchSmall
    case searchXlarge
    case sdkUnknown(String)
}

extension PartitionInstanceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PartitionInstanceType] {
        return [
            .search2xlarge,
            .searchLarge,
            .searchM1Large,
            .searchM1Small,
            .searchM22xlarge,
            .searchM2Xlarge,
            .searchM32xlarge,
            .searchM3Large,
            .searchM3Medium,
            .searchM3Xlarge,
            .searchMedium,
            .searchSmall,
            .searchXlarge,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .search2xlarge: return "search.2xlarge"
        case .searchLarge: return "search.large"
        case .searchM1Large: return "search.m1.large"
        case .searchM1Small: return "search.m1.small"
        case .searchM22xlarge: return "search.m2.2xlarge"
        case .searchM2Xlarge: return "search.m2.xlarge"
        case .searchM32xlarge: return "search.m3.2xlarge"
        case .searchM3Large: return "search.m3.large"
        case .searchM3Medium: return "search.m3.medium"
        case .searchM3Xlarge: return "search.m3.xlarge"
        case .searchMedium: return "search.medium"
        case .searchSmall: return "search.small"
        case .searchXlarge: return "search.xlarge"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PartitionInstanceType(rawValue: rawValue) ?? PartitionInstanceType.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ResourceNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it attempted to reference a resource that does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A machine-parsable string error or warning code.</p>
    public var code: String?
    /// <p>A human-readable string error or warning message.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ScalingParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case desiredInstanceType = "DesiredInstanceType"
        case desiredPartitionCount = "DesiredPartitionCount"
        case desiredReplicationCount = "DesiredReplicationCount"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let desiredInstanceType = desiredInstanceType {
            try container.encode(desiredInstanceType, forKey: Key("DesiredInstanceType"))
        }
        if desiredPartitionCount != 0 {
            try container.encode(desiredPartitionCount, forKey: Key("DesiredPartitionCount"))
        }
        if desiredReplicationCount != 0 {
            try container.encode(desiredReplicationCount, forKey: Key("DesiredReplicationCount"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredInstanceTypeDecoded = try containerValues.decodeIfPresent(PartitionInstanceType.self, forKey: .desiredInstanceType)
        desiredInstanceType = desiredInstanceTypeDecoded
        let desiredReplicationCountDecoded = try containerValues.decode(Int.self, forKey: .desiredReplicationCount)
        desiredReplicationCount = desiredReplicationCountDecoded
        let desiredPartitionCountDecoded = try containerValues.decode(Int.self, forKey: .desiredPartitionCount)
        desiredPartitionCount = desiredPartitionCountDecoded
    }
}

extension ScalingParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScalingParameters(desiredInstanceType: \(String(describing: desiredInstanceType)), desiredPartitionCount: \(String(describing: desiredPartitionCount)), desiredReplicationCount: \(String(describing: desiredReplicationCount)))"}
}

/// <p>The desired instance type and desired number of replicas of each index partition.</p>
public struct ScalingParameters: Equatable {
    /// <p>The instance type that you want to preconfigure for your domain. For example, <code>search.m1.small</code>.</p>
    public let desiredInstanceType: PartitionInstanceType?
    /// <p>The number of partitions you want to preconfigure for your domain. Only valid when
    ///     you select <code>m2.2xlarge</code> as the desired instance type.</p>
    public let desiredPartitionCount: Int
    /// <p>The number of replicas you want to preconfigure for each index partition.</p>
    public let desiredReplicationCount: Int

    public init (
        desiredInstanceType: PartitionInstanceType? = nil,
        desiredPartitionCount: Int = 0,
        desiredReplicationCount: Int = 0
    )
    {
        self.desiredInstanceType = desiredInstanceType
        self.desiredPartitionCount = desiredPartitionCount
        self.desiredReplicationCount = desiredReplicationCount
    }
}

extension ScalingParametersStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let options = options {
            try container.encode(options, forKey: Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(ScalingParameters.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ScalingParametersStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScalingParametersStatus(options: \(String(describing: options)), status: \(String(describing: status)))"}
}

/// <p>The status and configuration of a search domain's scaling parameters. </p>
public struct ScalingParametersStatus: Equatable {
    /// <p>The desired instance type and desired number of replicas of each index partition.</p>
    public let options: ScalingParameters?
    /// <p>The status of domain configuration option.</p>
    public let status: OptionStatus?

    public init (
        options: ScalingParameters? = nil,
        status: OptionStatus? = nil
    )
    {
        self.options = options
        self.status = status
    }
}

extension ServiceEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpoint = "Endpoint"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension ServiceEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceEndpoint(endpoint: \(String(describing: endpoint)))"}
}

/// <p>The endpoint to which service requests can be submitted.</p>
public struct ServiceEndpoint: Equatable {
    /// <p>The endpoint to which service requests can be submitted. For example, <code>search-imdb-movies-oopcnjfn6ugofer3zx5iadxxca.eu-west-1.cloudsearch.amazonaws.com</code> or <code>doc-imdb-movies-oopcnjfn6ugofer3zx5iadxxca.eu-west-1.cloudsearch.amazonaws.com</code>.</p>
    public let endpoint: String?

    public init (
        endpoint: String? = nil
    )
    {
        self.endpoint = endpoint
    }
}

extension Suggester: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentSuggesterOptions = "DocumentSuggesterOptions"
        case suggesterName = "SuggesterName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let documentSuggesterOptions = documentSuggesterOptions {
            try container.encode(documentSuggesterOptions, forKey: Key("DocumentSuggesterOptions"))
        }
        if let suggesterName = suggesterName {
            try container.encode(suggesterName, forKey: Key("SuggesterName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suggesterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suggesterName)
        suggesterName = suggesterNameDecoded
        let documentSuggesterOptionsDecoded = try containerValues.decodeIfPresent(DocumentSuggesterOptions.self, forKey: .documentSuggesterOptions)
        documentSuggesterOptions = documentSuggesterOptionsDecoded
    }
}

extension Suggester: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Suggester(documentSuggesterOptions: \(String(describing: documentSuggesterOptions)), suggesterName: \(String(describing: suggesterName)))"}
}

/// <p>Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: <code>FuzzyMatching</code>, <code>SortExpression</code>. </p>
public struct Suggester: Equatable {
    /// <p>Options for a search suggester.</p>
    public let documentSuggesterOptions: DocumentSuggesterOptions?
    /// <p>Names must begin with a letter and can contain the following characters:
    ///       a-z (lowercase), 0-9, and _ (underscore).</p>
    public let suggesterName: String?

    public init (
        documentSuggesterOptions: DocumentSuggesterOptions? = nil,
        suggesterName: String? = nil
    )
    {
        self.documentSuggesterOptions = documentSuggesterOptions
        self.suggesterName = suggesterName
    }
}

public enum SuggesterFuzzyMatching {
    case high
    case low
    case `none`
    case sdkUnknown(String)
}

extension SuggesterFuzzyMatching : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SuggesterFuzzyMatching] {
        return [
            .high,
            .low,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "high"
        case .low: return "low"
        case .none: return "none"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SuggesterFuzzyMatching(rawValue: rawValue) ?? SuggesterFuzzyMatching.sdkUnknown(rawValue)
    }
}

extension SuggesterStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let options = options {
            try container.encode(options, forKey: Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(Suggester.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SuggesterStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuggesterStatus(options: \(String(describing: options)), status: \(String(describing: status)))"}
}

/// <p>The value of a <code>Suggester</code> and its current status.</p>
public struct SuggesterStatus: Equatable {
    /// <p>Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: <code>FuzzyMatching</code>, <code>SortExpression</code>. </p>
    public let options: Suggester?
    /// <p>The status of domain configuration option.</p>
    public let status: OptionStatus?

    public init (
        options: Suggester? = nil,
        status: OptionStatus? = nil
    )
    {
        self.options = options
        self.status = status
    }
}

/// <p>The minimum required TLS version.</p>
public enum TLSSecurityPolicy {
    case policyMinTls10201907
    case policyMinTls12201907
    case sdkUnknown(String)
}

extension TLSSecurityPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TLSSecurityPolicy] {
        return [
            .policyMinTls10201907,
            .policyMinTls12201907,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .policyMinTls10201907: return "Policy-Min-TLS-1-0-2019-07"
        case .policyMinTls12201907: return "Policy-Min-TLS-1-2-2019-07"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TLSSecurityPolicy(rawValue: rawValue) ?? TLSSecurityPolicy.sdkUnknown(rawValue)
    }
}

extension TextArrayOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analysisScheme = "AnalysisScheme"
        case defaultValue = "DefaultValue"
        case highlightEnabled = "HighlightEnabled"
        case returnEnabled = "ReturnEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let analysisScheme = analysisScheme {
            try container.encode(analysisScheme, forKey: Key("AnalysisScheme"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let highlightEnabled = highlightEnabled {
            try container.encode(highlightEnabled, forKey: Key("HighlightEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: Key("ReturnEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: Key("SourceFields"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let highlightEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .highlightEnabled)
        highlightEnabled = highlightEnabledDecoded
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

extension TextArrayOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextArrayOptions(analysisScheme: \(String(describing: analysisScheme)), defaultValue: \(String(describing: defaultValue)), highlightEnabled: \(String(describing: highlightEnabled)), returnEnabled: \(String(describing: returnEnabled)), sourceFields: \(String(describing: sourceFields)))"}
}

/// <p>Options for a field that contains an array of text strings.  Present if <code>IndexFieldType</code> specifies the field is of type <code>text-array</code>. A <code>text-array</code> field is always searchable. All options are enabled by default.</p>
public struct TextArrayOptions: Equatable {
    /// <p>The name of an analysis scheme for a  <code>text-array</code> field.</p>
    public let analysisScheme: String?
    /// A value to use for the field if the field isn't specified for a document.
    public let defaultValue: String?
    /// <p>Whether highlights can be returned for the field.</p>
    public let highlightEnabled: Bool?
    /// <p>Whether the contents of the field can be returned in the search results.</p>
    public let returnEnabled: Bool?
    /// <p>A list of source fields to map to the field. </p>
    public let sourceFields: String?

    public init (
        analysisScheme: String? = nil,
        defaultValue: String? = nil,
        highlightEnabled: Bool? = nil,
        returnEnabled: Bool? = nil,
        sourceFields: String? = nil
    )
    {
        self.analysisScheme = analysisScheme
        self.defaultValue = defaultValue
        self.highlightEnabled = highlightEnabled
        self.returnEnabled = returnEnabled
        self.sourceFields = sourceFields
    }
}

extension TextOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analysisScheme = "AnalysisScheme"
        case defaultValue = "DefaultValue"
        case highlightEnabled = "HighlightEnabled"
        case returnEnabled = "ReturnEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let analysisScheme = analysisScheme {
            try container.encode(analysisScheme, forKey: Key("AnalysisScheme"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let highlightEnabled = highlightEnabled {
            try container.encode(highlightEnabled, forKey: Key("HighlightEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: Key("ReturnEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: Key("SourceField"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
        let highlightEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .highlightEnabled)
        highlightEnabled = highlightEnabledDecoded
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

extension TextOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextOptions(analysisScheme: \(String(describing: analysisScheme)), defaultValue: \(String(describing: defaultValue)), highlightEnabled: \(String(describing: highlightEnabled)), returnEnabled: \(String(describing: returnEnabled)), sortEnabled: \(String(describing: sortEnabled)), sourceField: \(String(describing: sourceField)))"}
}

/// <p>Options for text field.  Present if <code>IndexFieldType</code> specifies the field is of type <code>text</code>. A <code>text</code> field is always searchable. All options are enabled by default.</p>
public struct TextOptions: Equatable {
    /// <p>The name of an analysis scheme for a  <code>text</code> field.</p>
    public let analysisScheme: String?
    /// A value to use for the field if the field isn't specified for a document.
    public let defaultValue: String?
    /// <p>Whether highlights can be returned for the field.</p>
    public let highlightEnabled: Bool?
    /// <p>Whether the contents of the field can be returned in the search results.</p>
    public let returnEnabled: Bool?
    /// <p>Whether the field can be used to sort the search results.</p>
    public let sortEnabled: Bool?
    /// <p>A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields.
    ///       A dynamic field's name defines a pattern that begins or ends with a wildcard.
    ///       Any document fields that don't map to a regular index field but do match a	
    ///       dynamic field's pattern are configured with the dynamic field's indexing options.
    ///     </p>
    ///     <p>Regular field names begin with a letter and can contain the following characters:
    ///       a-z (lowercase), 0-9, and _ (underscore).
    ///       Dynamic field names must begin or end with a wildcard (*).
    ///       The wildcard can also be the only character in a dynamic field name.
    ///       Multiple wildcards, and wildcards embedded within a string are not supported.
    ///     </p>
    ///     <p>The name <code>score</code> is reserved and cannot be used as a field name.
    ///       To reference a document's ID, you can use the name <code>_id</code>.
    ///     </p>
    public let sourceField: String?

    public init (
        analysisScheme: String? = nil,
        defaultValue: String? = nil,
        highlightEnabled: Bool? = nil,
        returnEnabled: Bool? = nil,
        sortEnabled: Bool? = nil,
        sourceField: String? = nil
    )
    {
        self.analysisScheme = analysisScheme
        self.defaultValue = defaultValue
        self.highlightEnabled = highlightEnabled
        self.returnEnabled = returnEnabled
        self.sortEnabled = sortEnabled
        self.sourceField = sourceField
    }
}

public struct UpdateAvailabilityOptionsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAvailabilityOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAvailabilityOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAvailabilityOptionsInput>
    public typealias MOutput = OperationOutput<UpdateAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAvailabilityOptionsOutputError>
}

extension UpdateAvailabilityOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAvailabilityOptionsInput(domainName: \(String(describing: domainName)), multiAZ: \(String(describing: multiAZ)))"}
}

extension UpdateAvailabilityOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        try container.encode("UpdateAvailabilityOptions", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct UpdateAvailabilityOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAvailabilityOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAvailabilityOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAvailabilityOptionsInput>
    public typealias MOutput = OperationOutput<UpdateAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAvailabilityOptionsOutputError>
}

public struct UpdateAvailabilityOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAvailabilityOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAvailabilityOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAvailabilityOptionsInput>
    public typealias MOutput = OperationOutput<UpdateAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAvailabilityOptionsOutputError>
}

/// <p>Container for the parameters to the <code><a>UpdateAvailabilityOptions</a></code> operation. Specifies the name of the domain you want to update and the Multi-AZ availability option.</p>
public struct UpdateAvailabilityOptionsInput: Equatable {
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?
    /// <p>You expand an existing search domain to a second Availability Zone by setting the Multi-AZ option to true. Similarly, you can turn off the Multi-AZ option to downgrade the domain to a single Availability Zone by setting the Multi-AZ option to <code>false</code>. </p>
    public let multiAZ: Bool?

    public init (
        domainName: String? = nil,
        multiAZ: Bool? = nil
    )
    {
        self.domainName = domainName
        self.multiAZ = multiAZ
    }
}

extension UpdateAvailabilityOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateAvailabilityOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAvailabilityOptionsOutputError: Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAvailabilityOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAvailabilityOptionsOutputResponse(availabilityOptions: \(String(describing: availabilityOptions)))"}
}

extension UpdateAvailabilityOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAvailabilityOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.availabilityOptions = output.availabilityOptions
        } else {
            self.availabilityOptions = nil
        }
    }
}

/// <p>The result of a <code>UpdateAvailabilityOptions</code> request. Contains the status of the domain's availability options. </p>
public struct UpdateAvailabilityOptionsOutputResponse: Equatable {
    /// <p>The newly-configured availability options. Indicates whether Multi-AZ is enabled for the domain. </p>
    public let availabilityOptions: AvailabilityOptionsStatus?

    public init (
        availabilityOptions: AvailabilityOptionsStatus? = nil
    )
    {
        self.availabilityOptions = availabilityOptions
    }
}

struct UpdateAvailabilityOptionsOutputResponseBody: Equatable {
    public let availabilityOptions: AvailabilityOptionsStatus?
}

extension UpdateAvailabilityOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityOptions = "AvailabilityOptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateAvailabilityOptionsResult"))
        let availabilityOptionsDecoded = try containerValues.decodeIfPresent(AvailabilityOptionsStatus.self, forKey: .availabilityOptions)
        availabilityOptions = availabilityOptionsDecoded
    }
}

public struct UpdateDomainEndpointOptionsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDomainEndpointOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainEndpointOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainEndpointOptionsInput>
    public typealias MOutput = OperationOutput<UpdateDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainEndpointOptionsOutputError>
}

extension UpdateDomainEndpointOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainEndpointOptionsInput(domainEndpointOptions: \(String(describing: domainEndpointOptions)), domainName: \(String(describing: domainName)))"}
}

extension UpdateDomainEndpointOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainEndpointOptions = domainEndpointOptions {
            try container.encode(domainEndpointOptions, forKey: Key("DomainEndpointOptions"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("UpdateDomainEndpointOptions", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct UpdateDomainEndpointOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDomainEndpointOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainEndpointOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainEndpointOptionsInput>
    public typealias MOutput = OperationOutput<UpdateDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainEndpointOptionsOutputError>
}

public struct UpdateDomainEndpointOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDomainEndpointOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainEndpointOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainEndpointOptionsInput>
    public typealias MOutput = OperationOutput<UpdateDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainEndpointOptionsOutputError>
}

/// <p>Container for the parameters to the <code><a>UpdateDomainEndpointOptions</a></code> operation. Specifies the name of the domain you want to update and the domain endpoint options.</p>
public struct UpdateDomainEndpointOptionsInput: Equatable {
    /// <p>Whether to require that all requests to the domain arrive over HTTPS. We recommend Policy-Min-TLS-1-2-2019-07 for TLSSecurityPolicy. For compatibility with older clients, the default is Policy-Min-TLS-1-0-2019-07. </p>
    public let domainEndpointOptions: DomainEndpointOptions?
    /// <p>A string that represents the name of a domain.</p>
    public let domainName: String?

    public init (
        domainEndpointOptions: DomainEndpointOptions? = nil,
        domainName: String? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
        self.domainName = domainName
    }
}

extension UpdateDomainEndpointOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateDomainEndpointOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainEndpointOptionsOutputError: Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainEndpointOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainEndpointOptionsOutputResponse(domainEndpointOptions: \(String(describing: domainEndpointOptions)))"}
}

extension UpdateDomainEndpointOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDomainEndpointOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainEndpointOptions = output.domainEndpointOptions
        } else {
            self.domainEndpointOptions = nil
        }
    }
}

/// <p>The result of a <code>UpdateDomainEndpointOptions</code> request. Contains the configuration and status of the domain's endpoint options. </p>
public struct UpdateDomainEndpointOptionsOutputResponse: Equatable {
    /// <p>The newly-configured domain endpoint options.</p>
    public let domainEndpointOptions: DomainEndpointOptionsStatus?

    public init (
        domainEndpointOptions: DomainEndpointOptionsStatus? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
    }
}

struct UpdateDomainEndpointOptionsOutputResponseBody: Equatable {
    public let domainEndpointOptions: DomainEndpointOptionsStatus?
}

extension UpdateDomainEndpointOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainEndpointOptions = "DomainEndpointOptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateDomainEndpointOptionsResult"))
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(DomainEndpointOptionsStatus.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
    }
}

public struct UpdateScalingParametersInputBodyMiddleware: Middleware {
    public let id: String = "UpdateScalingParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateScalingParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateScalingParametersInput>
    public typealias MOutput = OperationOutput<UpdateScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateScalingParametersOutputError>
}

extension UpdateScalingParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateScalingParametersInput(domainName: \(String(describing: domainName)), scalingParameters: \(String(describing: scalingParameters)))"}
}

extension UpdateScalingParametersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        if let scalingParameters = scalingParameters {
            try container.encode(scalingParameters, forKey: Key("ScalingParameters"))
        }
        try container.encode("UpdateScalingParameters", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct UpdateScalingParametersInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateScalingParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateScalingParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateScalingParametersInput>
    public typealias MOutput = OperationOutput<UpdateScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateScalingParametersOutputError>
}

public struct UpdateScalingParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateScalingParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateScalingParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateScalingParametersInput>
    public typealias MOutput = OperationOutput<UpdateScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateScalingParametersOutputError>
}

/// <p>Container for the parameters to the <code><a>UpdateScalingParameters</a></code> operation. Specifies the name of the domain you want to update and the scaling parameters you want to configure.</p>
public struct UpdateScalingParametersInput: Equatable {
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?
    /// <p>The desired instance type and desired number of replicas of each index partition.</p>
    public let scalingParameters: ScalingParameters?

    public init (
        domainName: String? = nil,
        scalingParameters: ScalingParameters? = nil
    )
    {
        self.domainName = domainName
        self.scalingParameters = scalingParameters
    }
}

extension UpdateScalingParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateScalingParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateScalingParametersOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateScalingParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateScalingParametersOutputResponse(scalingParameters: \(String(describing: scalingParameters)))"}
}

extension UpdateScalingParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateScalingParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.scalingParameters = output.scalingParameters
        } else {
            self.scalingParameters = nil
        }
    }
}

/// <p>The result of a <code>UpdateScalingParameters</code> request. Contains the status of the newly-configured scaling parameters.</p>
public struct UpdateScalingParametersOutputResponse: Equatable {
    /// <p>The status and configuration of a search domain's scaling parameters. </p>
    public let scalingParameters: ScalingParametersStatus?

    public init (
        scalingParameters: ScalingParametersStatus? = nil
    )
    {
        self.scalingParameters = scalingParameters
    }
}

struct UpdateScalingParametersOutputResponseBody: Equatable {
    public let scalingParameters: ScalingParametersStatus?
}

extension UpdateScalingParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case scalingParameters = "ScalingParameters"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateScalingParametersResult"))
        let scalingParametersDecoded = try containerValues.decodeIfPresent(ScalingParametersStatus.self, forKey: .scalingParameters)
        scalingParameters = scalingParametersDecoded
    }
}

public struct UpdateServiceAccessPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateServiceAccessPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceAccessPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceAccessPoliciesInput>
    public typealias MOutput = OperationOutput<UpdateServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceAccessPoliciesOutputError>
}

extension UpdateServiceAccessPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceAccessPoliciesInput(accessPolicies: \(String(describing: accessPolicies)), domainName: \(String(describing: domainName)))"}
}

extension UpdateServiceAccessPoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accessPolicies = accessPolicies {
            try container.encode(accessPolicies, forKey: Key("AccessPolicies"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("DomainName"))
        }
        try container.encode("UpdateServiceAccessPolicies", forKey:Key("Action"))
        try container.encode("2013-01-01", forKey:Key("Version"))
    }
}

public struct UpdateServiceAccessPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateServiceAccessPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceAccessPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceAccessPoliciesInput>
    public typealias MOutput = OperationOutput<UpdateServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceAccessPoliciesOutputError>
}

public struct UpdateServiceAccessPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateServiceAccessPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceAccessPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceAccessPoliciesInput>
    public typealias MOutput = OperationOutput<UpdateServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceAccessPoliciesOutputError>
}

/// <p>Container for the parameters to the <code><a>UpdateServiceAccessPolicies</a></code> operation. Specifies the name of the domain you want to update and the access rules you want to configure.</p>
public struct UpdateServiceAccessPoliciesInput: Equatable {
    /// <p>The access rules you want to configure. These rules replace any existing rules. </p>
    public let accessPolicies: String?
    /// <p>A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).</p>
    public let domainName: String?

    public init (
        accessPolicies: String? = nil,
        domainName: String? = nil
    )
    {
        self.accessPolicies = accessPolicies
        self.domainName = domainName
    }
}

extension UpdateServiceAccessPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateServiceAccessPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceAccessPoliciesOutputError: Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceAccessPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceAccessPoliciesOutputResponse(accessPolicies: \(String(describing: accessPolicies)))"}
}

extension UpdateServiceAccessPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateServiceAccessPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessPolicies = output.accessPolicies
        } else {
            self.accessPolicies = nil
        }
    }
}

/// <p>The result of an <code>UpdateServiceAccessPolicies</code> request. Contains the new access policies.</p>
public struct UpdateServiceAccessPoliciesOutputResponse: Equatable {
    /// <p>The access rules configured for the domain.</p>
    public let accessPolicies: AccessPoliciesStatus?

    public init (
        accessPolicies: AccessPoliciesStatus? = nil
    )
    {
        self.accessPolicies = accessPolicies
    }
}

struct UpdateServiceAccessPoliciesOutputResponseBody: Equatable {
    public let accessPolicies: AccessPoliciesStatus?
}

extension UpdateServiceAccessPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPolicies = "AccessPolicies"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateServiceAccessPoliciesResult"))
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(AccessPoliciesStatus.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ValidationExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it has invalid parameters.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A machine-parsable string error or warning code.</p>
    public var code: String?
    /// <p>A human-readable string error or warning message.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
