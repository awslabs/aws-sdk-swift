// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ComplianceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceStatus = "ComplianceStatus"
        case keysWithNoncompliantValues = "KeysWithNoncompliantValues"
        case noncompliantKeys = "NoncompliantKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus, forKey: .complianceStatus)
        }
        if let keysWithNoncompliantValues = keysWithNoncompliantValues {
            var keysWithNoncompliantValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keysWithNoncompliantValues)
            for tagkeylist0 in keysWithNoncompliantValues {
                try keysWithNoncompliantValuesContainer.encode(tagkeylist0)
            }
        }
        if let noncompliantKeys = noncompliantKeys {
            var noncompliantKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .noncompliantKeys)
            for tagkeylist0 in noncompliantKeys {
                try noncompliantKeysContainer.encode(tagkeylist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncompliantKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .noncompliantKeys)
        var noncompliantKeysDecoded0:[String]? = nil
        if let noncompliantKeysContainer = noncompliantKeysContainer {
            noncompliantKeysDecoded0 = [String]()
            for string0 in noncompliantKeysContainer {
                if let string0 = string0 {
                    noncompliantKeysDecoded0?.append(string0)
                }
            }
        }
        noncompliantKeys = noncompliantKeysDecoded0
        let keysWithNoncompliantValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .keysWithNoncompliantValues)
        var keysWithNoncompliantValuesDecoded0:[String]? = nil
        if let keysWithNoncompliantValuesContainer = keysWithNoncompliantValuesContainer {
            keysWithNoncompliantValuesDecoded0 = [String]()
            for string0 in keysWithNoncompliantValuesContainer {
                if let string0 = string0 {
                    keysWithNoncompliantValuesDecoded0?.append(string0)
                }
            }
        }
        keysWithNoncompliantValues = keysWithNoncompliantValuesDecoded0
        let complianceStatusDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
    }
}

extension ComplianceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceDetails(complianceStatus: \(String(describing: complianceStatus)), keysWithNoncompliantValues: \(String(describing: keysWithNoncompliantValues)), noncompliantKeys: \(String(describing: noncompliantKeys)))"}
}

/// <p>Information that shows whether a resource is compliant with the effective tag policy,
///             including details on any noncompliant tag keys.</p>
public struct ComplianceDetails: Equatable {
    /// <p>Whether a resource is compliant with the effective tag policy.</p>
    public let complianceStatus: Bool?
    /// <p>These are keys defined in the effective policy that are on the resource with either
    ///             incorrect case treatment or noncompliant values. </p>
    public let keysWithNoncompliantValues: [String]?
    /// <p>These tag keys on the resource are noncompliant with the effective tag policy.</p>
    public let noncompliantKeys: [String]?

    public init (
        complianceStatus: Bool? = nil,
        keysWithNoncompliantValues: [String]? = nil,
        noncompliantKeys: [String]? = nil
    )
    {
        self.complianceStatus = complianceStatus
        self.keysWithNoncompliantValues = keysWithNoncompliantValues
        self.noncompliantKeys = noncompliantKeys
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The target of the operation is currently being modified by a different request. Try
///             again later.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConstraintViolationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConstraintViolationException(message: \(String(describing: message)))"}
}

extension ConstraintViolationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConstraintViolationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied because performing this operation violates a constraint. </p>
///         <p>Some of the reasons in the following list might not apply to this specific
///             operation.</p>
///         <ul>
///             <li>
///                 <p>You must meet the prerequisites for using tag policies. For information, see
///                         <a href="http://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_tag-policies-prereqs.html">Prerequisites and Permissions for Using Tag Policies</a> in the
///                         <i>AWS Organizations User Guide.</i>
///                </p>
///             </li>
///             <li>
///                 <p>You must enable the tag policies service principal
///                         (<code>tagpolicies.tag.amazonaws.com</code>) to integrate with AWS Organizations For
///                     information, see <a href="http://docs.aws.amazon.com/organizations/latest/APIReference/API_EnableAWSServiceAccess.html">EnableAWSServiceAccess</a>.</p>
///             </li>
///             <li>
///                 <p>You must have a tag policy attached to the organization root, an OU, or an
///                     account.</p>
///             </li>
///          </ul>
public struct ConstraintViolationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConstraintViolationExceptionBody: Equatable {
    public let message: String?
}

extension ConstraintViolationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeReportCreationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReportCreationInput()"}
}

extension DescribeReportCreationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeReportCreationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReportCreationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReportCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReportCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReportCreationInput>
    public typealias MOutput = OperationOutput<DescribeReportCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReportCreationOutputError>
}

public struct DescribeReportCreationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReportCreationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReportCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReportCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReportCreationInput>
    public typealias MOutput = OperationOutput<DescribeReportCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReportCreationOutputError>
}

public struct DescribeReportCreationInput: Equatable {

    public init() {}
}

struct DescribeReportCreationInputBody: Equatable {
}

extension DescribeReportCreationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeReportCreationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReportCreationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConstraintViolationException" : self = .constraintViolationException(try ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReportCreationOutputError: Equatable {
    case constraintViolationException(ConstraintViolationException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReportCreationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReportCreationOutputResponse(errorMessage: \(String(describing: errorMessage)), s3Location: \(String(describing: s3Location)), startDate: \(String(describing: startDate)), status: \(String(describing: status)))"}
}

extension DescribeReportCreationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReportCreationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorMessage = output.errorMessage
            self.s3Location = output.s3Location
            self.startDate = output.startDate
            self.status = output.status
        } else {
            self.errorMessage = nil
            self.s3Location = nil
            self.startDate = nil
            self.status = nil
        }
    }
}

public struct DescribeReportCreationOutputResponse: Equatable {
    /// <p>Details of the common errors that all operations return.</p>
    public let errorMessage: String?
    /// <p>The path to the Amazon S3 bucket where the report was stored on creation.</p>
    public let s3Location: String?
    /// <p>The date and time that the report was started. </p>
    public let startDate: String?
    /// <p>Reports the status of the operation.</p>
    ///         <p>The operation status can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>RUNNING</code> - Report creation is in progress.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SUCCEEDED</code> - Report creation is complete. You can open the report
    ///                     from the Amazon S3 bucket that you specified when you ran
    ///                         <code>StartReportCreation</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FAILED</code> - Report creation timed out or the Amazon S3 bucket is not
    ///                     accessible. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NO REPORT</code> - No report was generated in the last 90 days.</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        errorMessage: String? = nil,
        s3Location: String? = nil,
        startDate: String? = nil,
        status: String? = nil
    )
    {
        self.errorMessage = errorMessage
        self.s3Location = s3Location
        self.startDate = startDate
        self.status = status
    }
}

struct DescribeReportCreationOutputResponseBody: Equatable {
    public let status: String?
    public let s3Location: String?
    public let startDate: String?
    public let errorMessage: String?
}

extension DescribeReportCreationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorMessage = "ErrorMessage"
        case s3Location = "S3Location"
        case startDate = "StartDate"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

public enum ErrorCode {
    case internalServiceException
    case invalidParameterException
    case sdkUnknown(String)
}

extension ErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ErrorCode] {
        return [
            .internalServiceException,
            .invalidParameterException,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalServiceException: return "InternalServiceException"
        case .invalidParameterException: return "InvalidParameterException"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
    }
}

extension FailureInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if statusCode != 0 {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decode(Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension FailureInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailureInfo(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>Information about the errors that are returned for each failed resource. This
///             information can include <code>InternalServiceException</code> and
///                 <code>InvalidParameterException</code> errors. It can also include any valid error
///             code returned by the AWS service that hosts the resource that the ARN key
///             represents.</p>
///         <p>The following are common error codes that you might receive from other AWS
///             services:</p>
///         <ul>
///             <li>
///                 <p>
///                   <b>InternalServiceException</b> – This can
///                     mean that the Resource Groups Tagging API didn't receive a response from another
///                     AWS service. It can also mean the the resource type in the request is not
///                     supported by the Resource Groups Tagging API. In these cases, it's safe to retry
///                     the request and then call <a href="http://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html">GetResources</a> to verify the changes.</p>
///             </li>
///             <li>
///                 <p>
///                   <b>AccessDeniedException</b> – This can mean
///                     that you need permission to calling tagging operations in the AWS service that
///                     contains the resource. For example, to use the Resource Groups Tagging API to
///                     tag a CloudWatch alarm resource, you need permission to call <a href="http://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_TagResources.html">
///                      <code>TagResources</code>
///                   </a>
///                     <i>and</i>
///                     <a href="http://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html">
///                      <code>TagResource</code>
///                   </a> in the CloudWatch API. </p>
///             </li>
///          </ul>
///         <p>For more information on errors that are generated from other AWS services, see the
///             documentation for that service. </p>
public struct FailureInfo: Equatable {
    /// <p>The code of the common error. Valid values include
    ///                 <code>InternalServiceException</code>, <code>InvalidParameterException</code>, and
    ///             any valid error code returned by the AWS service that hosts the resource that you want
    ///             to tag.</p>
    public let errorCode: ErrorCode?
    /// <p>The message of the common error.</p>
    public let errorMessage: String?
    /// <p>The HTTP status code of the common error.</p>
    public let statusCode: Int

    public init (
        errorCode: ErrorCode? = nil,
        errorMessage: String? = nil,
        statusCode: Int = 0
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.statusCode = statusCode
    }
}

public struct GetComplianceSummaryInputBodyMiddleware: Middleware {
    public let id: String = "GetComplianceSummaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceSummaryInput>
    public typealias MOutput = OperationOutput<GetComplianceSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceSummaryOutputError>
}

extension GetComplianceSummaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComplianceSummaryInput(groupBy: \(String(describing: groupBy)), maxResults: \(String(describing: maxResults)), paginationToken: \(String(describing: paginationToken)), regionFilters: \(String(describing: regionFilters)), resourceTypeFilters: \(String(describing: resourceTypeFilters)), tagKeyFilters: \(String(describing: tagKeyFilters)), targetIdFilters: \(String(describing: targetIdFilters)))"}
}

extension GetComplianceSummaryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case paginationToken = "PaginationToken"
        case regionFilters = "RegionFilters"
        case resourceTypeFilters = "ResourceTypeFilters"
        case tagKeyFilters = "TagKeyFilters"
        case targetIdFilters = "TargetIdFilters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupby0 in groupBy {
                try groupByContainer.encode(groupby0.rawValue)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let paginationToken = paginationToken {
            try encodeContainer.encode(paginationToken, forKey: .paginationToken)
        }
        if let regionFilters = regionFilters {
            var regionFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regionFilters)
            for regionfilterlist0 in regionFilters {
                try regionFiltersContainer.encode(regionfilterlist0)
            }
        }
        if let resourceTypeFilters = resourceTypeFilters {
            var resourceTypeFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypeFilters)
            for resourcetypefilterlist0 in resourceTypeFilters {
                try resourceTypeFiltersContainer.encode(resourcetypefilterlist0)
            }
        }
        if let tagKeyFilters = tagKeyFilters {
            var tagKeyFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyFilters)
            for tagkeyfilterlist0 in tagKeyFilters {
                try tagKeyFiltersContainer.encode(tagkeyfilterlist0)
            }
        }
        if let targetIdFilters = targetIdFilters {
            var targetIdFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIdFilters)
            for targetidfilterlist0 in targetIdFilters {
                try targetIdFiltersContainer.encode(targetidfilterlist0)
            }
        }
    }
}

public struct GetComplianceSummaryInputHeadersMiddleware: Middleware {
    public let id: String = "GetComplianceSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceSummaryInput>
    public typealias MOutput = OperationOutput<GetComplianceSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceSummaryOutputError>
}

public struct GetComplianceSummaryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetComplianceSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceSummaryInput>
    public typealias MOutput = OperationOutput<GetComplianceSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceSummaryOutputError>
}

public struct GetComplianceSummaryInput: Equatable {
    /// <p>Specifies a list of attributes to group the counts of noncompliant resources by. If
    ///             supplied, the counts are sorted by those attributes.</p>
    public let groupBy: [GroupByAttribute]?
    /// <p>Specifies the maximum number of results to be returned in each page. A
    ///     query can return fewer than this maximum, even if there are more results still to return. You
    ///     should always check the <code>PaginationToken</code> response value to see if there are more
    ///     results. You can specify a minimum of 1 and a maximum value of 100.</p>
    public let maxResults: Int?
    /// <p>Specifies a <code>PaginationToken</code> response value from a
    ///     previous request to indicate that you want the next page of results. Leave this parameter empty
    ///     in your initial request.</p>
    public let paginationToken: String?
    /// <p>Specifies a list of AWS Regions to limit the output by. If you use this parameter,
    ///             the count of returned noncompliant resources includes only resources in the specified
    ///             Regions.</p>
    public let regionFilters: [String]?
    /// <p>Specifies that you want the response to include information for only resources of the
    ///             specified types. The format of each resource type is
    ///             <code>service[:resourceType]</code>. For example, specifying a resource type of
    ///                 <code>ec2</code> returns all Amazon EC2 resources (which includes EC2 instances).
    ///             Specifying a resource type of <code>ec2:instance</code> returns only EC2 instances. </p>
    ///         <p>The string for each service name and resource type is the same as that embedded in a
    ///             resource's Amazon Resource Name (ARN). Consult the <i>AWS General
    ///                 Reference</i> for the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For a list of service name strings, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces">AWS Service Namespaces</a>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For resource type strings, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arns-syntax">Example
    ///                         ARNs</a>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names
    ///                         (ARNs) and AWS Service Namespaces</a>.</p>
    ///             </li>
    ///          </ul>
    ///         <p>You can specify multiple resource types by using a comma separated array. The array
    ///             can include up to 100 items. Note that the length constraint requirement applies to each
    ///             resource type filter. </p>
    public let resourceTypeFilters: [String]?
    /// <p>Specifies that you want the response to include information for only resources that
    ///             have tags with the specified tag keys. If you use this parameter, the count of returned
    ///             noncompliant resources includes only resources that have the specified tag keys.</p>
    public let tagKeyFilters: [String]?
    /// <p>Specifies target identifiers (usually, specific account IDs) to limit the output by.
    ///             If you use this parameter, the count of returned noncompliant resources includes only
    ///             resources with the specified target IDs.</p>
    public let targetIdFilters: [String]?

    public init (
        groupBy: [GroupByAttribute]? = nil,
        maxResults: Int? = nil,
        paginationToken: String? = nil,
        regionFilters: [String]? = nil,
        resourceTypeFilters: [String]? = nil,
        tagKeyFilters: [String]? = nil,
        targetIdFilters: [String]? = nil
    )
    {
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.paginationToken = paginationToken
        self.regionFilters = regionFilters
        self.resourceTypeFilters = resourceTypeFilters
        self.tagKeyFilters = tagKeyFilters
        self.targetIdFilters = targetIdFilters
    }
}

struct GetComplianceSummaryInputBody: Equatable {
    public let targetIdFilters: [String]?
    public let regionFilters: [String]?
    public let resourceTypeFilters: [String]?
    public let tagKeyFilters: [String]?
    public let groupBy: [GroupByAttribute]?
    public let maxResults: Int?
    public let paginationToken: String?
}

extension GetComplianceSummaryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case paginationToken = "PaginationToken"
        case regionFilters = "RegionFilters"
        case resourceTypeFilters = "ResourceTypeFilters"
        case tagKeyFilters = "TagKeyFilters"
        case targetIdFilters = "TargetIdFilters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetIdFiltersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetIdFilters)
        var targetIdFiltersDecoded0:[String]? = nil
        if let targetIdFiltersContainer = targetIdFiltersContainer {
            targetIdFiltersDecoded0 = [String]()
            for string0 in targetIdFiltersContainer {
                if let string0 = string0 {
                    targetIdFiltersDecoded0?.append(string0)
                }
            }
        }
        targetIdFilters = targetIdFiltersDecoded0
        let regionFiltersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .regionFilters)
        var regionFiltersDecoded0:[String]? = nil
        if let regionFiltersContainer = regionFiltersContainer {
            regionFiltersDecoded0 = [String]()
            for string0 in regionFiltersContainer {
                if let string0 = string0 {
                    regionFiltersDecoded0?.append(string0)
                }
            }
        }
        regionFilters = regionFiltersDecoded0
        let resourceTypeFiltersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceTypeFilters)
        var resourceTypeFiltersDecoded0:[String]? = nil
        if let resourceTypeFiltersContainer = resourceTypeFiltersContainer {
            resourceTypeFiltersDecoded0 = [String]()
            for string0 in resourceTypeFiltersContainer {
                if let string0 = string0 {
                    resourceTypeFiltersDecoded0?.append(string0)
                }
            }
        }
        resourceTypeFilters = resourceTypeFiltersDecoded0
        let tagKeyFiltersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeyFilters)
        var tagKeyFiltersDecoded0:[String]? = nil
        if let tagKeyFiltersContainer = tagKeyFiltersContainer {
            tagKeyFiltersDecoded0 = [String]()
            for string0 in tagKeyFiltersContainer {
                if let string0 = string0 {
                    tagKeyFiltersDecoded0?.append(string0)
                }
            }
        }
        tagKeyFilters = tagKeyFiltersDecoded0
        let groupByContainer = try containerValues.decodeIfPresent([GroupByAttribute?].self, forKey: .groupBy)
        var groupByDecoded0:[GroupByAttribute]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [GroupByAttribute]()
            for string0 in groupByContainer {
                if let string0 = string0 {
                    groupByDecoded0?.append(string0)
                }
            }
        }
        groupBy = groupByDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
    }
}

extension GetComplianceSummaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComplianceSummaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConstraintViolationException" : self = .constraintViolationException(try ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComplianceSummaryOutputError: Equatable {
    case constraintViolationException(ConstraintViolationException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComplianceSummaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComplianceSummaryOutputResponse(paginationToken: \(String(describing: paginationToken)), summaryList: \(String(describing: summaryList)))"}
}

extension GetComplianceSummaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetComplianceSummaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.paginationToken = output.paginationToken
            self.summaryList = output.summaryList
        } else {
            self.paginationToken = nil
            self.summaryList = nil
        }
    }
}

public struct GetComplianceSummaryOutputResponse: Equatable {
    /// <p>A string that indicates that there is more data available than this
    ///     response contains. To receive the next part of the response, specify this response value
    ///     as the <code>PaginationToken</code> value in the request for the next page.</p>
    public let paginationToken: String?
    /// <p>A table that shows counts of noncompliant resources.</p>
    public let summaryList: [Summary]?

    public init (
        paginationToken: String? = nil,
        summaryList: [Summary]? = nil
    )
    {
        self.paginationToken = paginationToken
        self.summaryList = summaryList
    }
}

struct GetComplianceSummaryOutputResponseBody: Equatable {
    public let summaryList: [Summary]?
    public let paginationToken: String?
}

extension GetComplianceSummaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case paginationToken = "PaginationToken"
        case summaryList = "SummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryListContainer = try containerValues.decodeIfPresent([Summary?].self, forKey: .summaryList)
        var summaryListDecoded0:[Summary]? = nil
        if let summaryListContainer = summaryListContainer {
            summaryListDecoded0 = [Summary]()
            for structure0 in summaryListContainer {
                if let structure0 = structure0 {
                    summaryListDecoded0?.append(structure0)
                }
            }
        }
        summaryList = summaryListDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
    }
}

public struct GetResourcesInputBodyMiddleware: Middleware {
    public let id: String = "GetResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcesInput>
    public typealias MOutput = OperationOutput<GetResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcesOutputError>
}

extension GetResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcesInput(excludeCompliantResources: \(String(describing: excludeCompliantResources)), includeComplianceDetails: \(String(describing: includeComplianceDetails)), paginationToken: \(String(describing: paginationToken)), resourceARNList: \(String(describing: resourceARNList)), resourceTypeFilters: \(String(describing: resourceTypeFilters)), resourcesPerPage: \(String(describing: resourcesPerPage)), tagFilters: \(String(describing: tagFilters)), tagsPerPage: \(String(describing: tagsPerPage)))"}
}

extension GetResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludeCompliantResources = "ExcludeCompliantResources"
        case includeComplianceDetails = "IncludeComplianceDetails"
        case paginationToken = "PaginationToken"
        case resourceARNList = "ResourceARNList"
        case resourceTypeFilters = "ResourceTypeFilters"
        case resourcesPerPage = "ResourcesPerPage"
        case tagFilters = "TagFilters"
        case tagsPerPage = "TagsPerPage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeCompliantResources = excludeCompliantResources {
            try encodeContainer.encode(excludeCompliantResources, forKey: .excludeCompliantResources)
        }
        if let includeComplianceDetails = includeComplianceDetails {
            try encodeContainer.encode(includeComplianceDetails, forKey: .includeComplianceDetails)
        }
        if let paginationToken = paginationToken {
            try encodeContainer.encode(paginationToken, forKey: .paginationToken)
        }
        if let resourceARNList = resourceARNList {
            var resourceARNListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceARNList)
            for resourcearnlistforget0 in resourceARNList {
                try resourceARNListContainer.encode(resourcearnlistforget0)
            }
        }
        if let resourceTypeFilters = resourceTypeFilters {
            var resourceTypeFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypeFilters)
            for resourcetypefilterlist0 in resourceTypeFilters {
                try resourceTypeFiltersContainer.encode(resourcetypefilterlist0)
            }
        }
        if let resourcesPerPage = resourcesPerPage {
            try encodeContainer.encode(resourcesPerPage, forKey: .resourcesPerPage)
        }
        if let tagFilters = tagFilters {
            var tagFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagFilters)
            for tagfilterlist0 in tagFilters {
                try tagFiltersContainer.encode(tagfilterlist0)
            }
        }
        if let tagsPerPage = tagsPerPage {
            try encodeContainer.encode(tagsPerPage, forKey: .tagsPerPage)
        }
    }
}

public struct GetResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcesInput>
    public typealias MOutput = OperationOutput<GetResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcesOutputError>
}

public struct GetResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcesInput>
    public typealias MOutput = OperationOutput<GetResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcesOutputError>
}

public struct GetResourcesInput: Equatable {
    /// <p>Specifies whether to exclude resources that are compliant with the tag policy. Set
    ///             this to <code>true</code> if you are interested in retrieving information on
    ///             noncompliant resources only.</p>
    ///         <p>You can use this parameter only if the <code>IncludeComplianceDetails</code> parameter
    ///             is also set to <code>true</code>.</p>
    public let excludeCompliantResources: Bool?
    /// <p>Specifies whether to include details regarding the compliance with the effective tag
    ///             policy. Set this to <code>true</code> to determine whether resources are compliant with
    ///             the tag policy and to get details.</p>
    public let includeComplianceDetails: Bool?
    /// <p>Specifies a <code>PaginationToken</code> response value from a
    ///     previous request to indicate that you want the next page of results. Leave this parameter empty
    ///     in your initial request.</p>
    public let paginationToken: String?
    /// <p>Specifies a list of ARNs of resources for which you want to retrieve tag data. You
    ///             can't specify both this parameter and any of the pagination parameters
    ///                 (<code>ResourcesPerPage</code>, <code>TagsPerPage</code>,
    ///                 <code>PaginationToken</code>) in the same request. If you specify both, you get an
    ///                 <code>Invalid Parameter</code> exception.</p>
    ///         <p>If a resource specified by this parameter doesn't exist, it doesn't generate an error;
    ///             it simply isn't included in the response.</p>
    ///         <p>An ARN (Amazon Resource Name) uniquely identifies a resource. For more information,
    ///             see <a href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
    ///                 Resource Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS
    ///                 General Reference</i>.</p>
    public let resourceARNList: [String]?
    /// <p>Specifies the resource types that you want included in the response. The format of
    ///             each resource type is <code>service[:resourceType]</code>. For example, specifying a
    ///             resource type of <code>ec2</code> returns all Amazon EC2 resources (which includes EC2
    ///             instances). Specifying a resource type of <code>ec2:instance</code> returns only EC2
    ///             instances. </p>
    ///         <p>The string for each service name and resource type is the same as that embedded in a
    ///             resource's Amazon Resource Name (ARN). Consult the <i>AWS General
    ///                 Reference</i> for the following:</p>
    ///         <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and
    ///                 AWS Service Namespaces</a>.</p>
    ///         <p>You can specify multiple resource types by using an array. The array can include up to
    ///             100 items. Note that the length constraint requirement applies to each resource type
    ///             filter. </p>
    public let resourceTypeFilters: [String]?
    /// <p>Specifies the maximum number of results to be returned in each page. A
    ///     query can return fewer than this maximum, even if there are more results still to return. You
    ///     should always check the <code>PaginationToken</code> response value to see if there are more
    ///     results. You can specify a minimum of 1 and a maximum value of 100.</p>
    public let resourcesPerPage: Int?
    /// <p>Specifies a list of TagFilters (keys and values) to restrict the output to only those
    ///             resources that have the specified tag and, if included, the specified value. Each
    ///                 <code>TagFilter</code> must contain a key with values optional. A request can
    ///             include up to 50 keys, and each key can include up to 20 values. </p>
    ///         <p>Note the following when deciding how to use TagFilters:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If you <i>don't</i> specify a <code>TagFilter</code>, the
    ///                     response includes all resources that are currently tagged or ever had a tag.
    ///                     Resources that currently don't have tags are shown with an empty tag set, like
    ///                     this: <code>"Tags": []</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If you specify more than one filter in a single request, the response returns
    ///                     only those resources that satisfy all filters.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If you specify a filter that contains more than one value for a key, the
    ///                     response returns resources that match any of the specified values for that
    ///                     key.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If you don't specify any values for a key, the response returns resources that
    ///                     are tagged with that key and any or no value.</p>
    ///                 <p>For example, for the following filters: <code>filter1= {keyA,{value1}}</code>,
    ///                         <code>filter2={keyB,{value2,value3,value4}}</code>, <code>filter3=
    ///                         {keyC}</code>:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>
    ///                         <code>GetResources({filter1})</code> returns resources tagged with
    ///                                 <code>key1=value1</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <code>GetResources({filter2})</code> returns resources tagged with
    ///                                 <code>key2=value2</code> or <code>key2=value3</code> or
    ///                                 <code>key2=value4</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <code>GetResources({filter3})</code> returns resources tagged with any
    ///                             tag with the key <code>key3</code>, and with any or no value</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <code>GetResources({filter1,filter2,filter3})</code> returns resources
    ///                             tagged with <code>(key1=value1) and (key2=value2 or key2=value3 or
    ///                                 key2=value4) and (key3, any or no value)</code>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let tagFilters: [TagFilter]?
    /// <p>AWS recommends using <code>ResourcesPerPage</code> instead of this parameter.</p>
    ///         <p>A limit that restricts the number of tags (key and value pairs) returned by
    ///                 <code>GetResources</code> in paginated output. A resource with no tags is counted as
    ///             having one tag (one key and value pair).</p>
    ///         <p>
    ///             <code>GetResources</code> does not split a resource and its associated tags across
    ///             pages. If the specified <code>TagsPerPage</code> would cause such a break, a
    ///                 <code>PaginationToken</code> is returned in place of the affected resource and its
    ///             tags. Use that token in another request to get the remaining data. For example, if you
    ///             specify a <code>TagsPerPage</code> of <code>100</code> and the account has 22 resources
    ///             with 10 tags each (meaning that each resource has 10 key and value pairs), the output
    ///             will consist of three pages. The first page displays the first 10 resources, each with
    ///             its 10 tags. The second page displays the next 10 resources, each with its 10 tags. The
    ///             third page displays the remaining 2 resources, each with its 10 tags.</p>
    ///         <p>You can set <code>TagsPerPage</code> to a minimum of 100 items up to a maximum of 500
    ///             items.</p>
    public let tagsPerPage: Int?

    public init (
        excludeCompliantResources: Bool? = nil,
        includeComplianceDetails: Bool? = nil,
        paginationToken: String? = nil,
        resourceARNList: [String]? = nil,
        resourceTypeFilters: [String]? = nil,
        resourcesPerPage: Int? = nil,
        tagFilters: [TagFilter]? = nil,
        tagsPerPage: Int? = nil
    )
    {
        self.excludeCompliantResources = excludeCompliantResources
        self.includeComplianceDetails = includeComplianceDetails
        self.paginationToken = paginationToken
        self.resourceARNList = resourceARNList
        self.resourceTypeFilters = resourceTypeFilters
        self.resourcesPerPage = resourcesPerPage
        self.tagFilters = tagFilters
        self.tagsPerPage = tagsPerPage
    }
}

struct GetResourcesInputBody: Equatable {
    public let paginationToken: String?
    public let tagFilters: [TagFilter]?
    public let resourcesPerPage: Int?
    public let tagsPerPage: Int?
    public let resourceTypeFilters: [String]?
    public let includeComplianceDetails: Bool?
    public let excludeCompliantResources: Bool?
    public let resourceARNList: [String]?
}

extension GetResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case excludeCompliantResources = "ExcludeCompliantResources"
        case includeComplianceDetails = "IncludeComplianceDetails"
        case paginationToken = "PaginationToken"
        case resourceARNList = "ResourceARNList"
        case resourceTypeFilters = "ResourceTypeFilters"
        case resourcesPerPage = "ResourcesPerPage"
        case tagFilters = "TagFilters"
        case tagsPerPage = "TagsPerPage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let tagFiltersContainer = try containerValues.decodeIfPresent([TagFilter?].self, forKey: .tagFilters)
        var tagFiltersDecoded0:[TagFilter]? = nil
        if let tagFiltersContainer = tagFiltersContainer {
            tagFiltersDecoded0 = [TagFilter]()
            for structure0 in tagFiltersContainer {
                if let structure0 = structure0 {
                    tagFiltersDecoded0?.append(structure0)
                }
            }
        }
        tagFilters = tagFiltersDecoded0
        let resourcesPerPageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .resourcesPerPage)
        resourcesPerPage = resourcesPerPageDecoded
        let tagsPerPageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tagsPerPage)
        tagsPerPage = tagsPerPageDecoded
        let resourceTypeFiltersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceTypeFilters)
        var resourceTypeFiltersDecoded0:[String]? = nil
        if let resourceTypeFiltersContainer = resourceTypeFiltersContainer {
            resourceTypeFiltersDecoded0 = [String]()
            for string0 in resourceTypeFiltersContainer {
                if let string0 = string0 {
                    resourceTypeFiltersDecoded0?.append(string0)
                }
            }
        }
        resourceTypeFilters = resourceTypeFiltersDecoded0
        let includeComplianceDetailsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeComplianceDetails)
        includeComplianceDetails = includeComplianceDetailsDecoded
        let excludeCompliantResourcesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .excludeCompliantResources)
        excludeCompliantResources = excludeCompliantResourcesDecoded
        let resourceARNListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceARNList)
        var resourceARNListDecoded0:[String]? = nil
        if let resourceARNListContainer = resourceARNListContainer {
            resourceARNListDecoded0 = [String]()
            for string0 in resourceARNListContainer {
                if let string0 = string0 {
                    resourceARNListDecoded0?.append(string0)
                }
            }
        }
        resourceARNList = resourceARNListDecoded0
    }
}

extension GetResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PaginationTokenExpiredException" : self = .paginationTokenExpiredException(try PaginationTokenExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case paginationTokenExpiredException(PaginationTokenExpiredException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcesOutputResponse(paginationToken: \(String(describing: paginationToken)), resourceTagMappingList: \(String(describing: resourceTagMappingList)))"}
}

extension GetResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.paginationToken = output.paginationToken
            self.resourceTagMappingList = output.resourceTagMappingList
        } else {
            self.paginationToken = nil
            self.resourceTagMappingList = nil
        }
    }
}

public struct GetResourcesOutputResponse: Equatable {
    /// <p>A string that indicates that there is more data available than this
    ///     response contains. To receive the next part of the response, specify this response value
    ///     as the <code>PaginationToken</code> value in the request for the next page.</p>
    public let paginationToken: String?
    /// <p>A list of resource ARNs and the tags (keys and values) associated with
    ///     those ARNs.</p>
    public let resourceTagMappingList: [ResourceTagMapping]?

    public init (
        paginationToken: String? = nil,
        resourceTagMappingList: [ResourceTagMapping]? = nil
    )
    {
        self.paginationToken = paginationToken
        self.resourceTagMappingList = resourceTagMappingList
    }
}

struct GetResourcesOutputResponseBody: Equatable {
    public let paginationToken: String?
    public let resourceTagMappingList: [ResourceTagMapping]?
}

extension GetResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case paginationToken = "PaginationToken"
        case resourceTagMappingList = "ResourceTagMappingList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let resourceTagMappingListContainer = try containerValues.decodeIfPresent([ResourceTagMapping?].self, forKey: .resourceTagMappingList)
        var resourceTagMappingListDecoded0:[ResourceTagMapping]? = nil
        if let resourceTagMappingListContainer = resourceTagMappingListContainer {
            resourceTagMappingListDecoded0 = [ResourceTagMapping]()
            for structure0 in resourceTagMappingListContainer {
                if let structure0 = structure0 {
                    resourceTagMappingListDecoded0?.append(structure0)
                }
            }
        }
        resourceTagMappingList = resourceTagMappingListDecoded0
    }
}

public struct GetTagKeysInputBodyMiddleware: Middleware {
    public let id: String = "GetTagKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagKeysInput>
    public typealias MOutput = OperationOutput<GetTagKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagKeysOutputError>
}

extension GetTagKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagKeysInput(paginationToken: \(String(describing: paginationToken)))"}
}

extension GetTagKeysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case paginationToken = "PaginationToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let paginationToken = paginationToken {
            try encodeContainer.encode(paginationToken, forKey: .paginationToken)
        }
    }
}

public struct GetTagKeysInputHeadersMiddleware: Middleware {
    public let id: String = "GetTagKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagKeysInput>
    public typealias MOutput = OperationOutput<GetTagKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagKeysOutputError>
}

public struct GetTagKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTagKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagKeysInput>
    public typealias MOutput = OperationOutput<GetTagKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagKeysOutputError>
}

public struct GetTagKeysInput: Equatable {
    /// <p>Specifies a <code>PaginationToken</code> response value from a
    ///     previous request to indicate that you want the next page of results. Leave this parameter empty
    ///     in your initial request.</p>
    public let paginationToken: String?

    public init (
        paginationToken: String? = nil
    )
    {
        self.paginationToken = paginationToken
    }
}

struct GetTagKeysInputBody: Equatable {
    public let paginationToken: String?
}

extension GetTagKeysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
    }
}

extension GetTagKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTagKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PaginationTokenExpiredException" : self = .paginationTokenExpiredException(try PaginationTokenExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTagKeysOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case paginationTokenExpiredException(PaginationTokenExpiredException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTagKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagKeysOutputResponse(paginationToken: \(String(describing: paginationToken)), tagKeys: \(String(describing: tagKeys)))"}
}

extension GetTagKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTagKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.paginationToken = output.paginationToken
            self.tagKeys = output.tagKeys
        } else {
            self.paginationToken = nil
            self.tagKeys = nil
        }
    }
}

public struct GetTagKeysOutputResponse: Equatable {
    /// <p>A string that indicates that there is more data available than this
    ///     response contains. To receive the next part of the response, specify this response value
    ///     as the <code>PaginationToken</code> value in the request for the next page.</p>
    public let paginationToken: String?
    /// <p>A list of all tag keys in the AWS account.</p>
    public let tagKeys: [String]?

    public init (
        paginationToken: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.paginationToken = paginationToken
        self.tagKeys = tagKeys
    }
}

struct GetTagKeysOutputResponseBody: Equatable {
    public let paginationToken: String?
    public let tagKeys: [String]?
}

extension GetTagKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case paginationToken = "PaginationToken"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

public struct GetTagValuesInputBodyMiddleware: Middleware {
    public let id: String = "GetTagValuesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagValuesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagValuesInput>
    public typealias MOutput = OperationOutput<GetTagValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagValuesOutputError>
}

extension GetTagValuesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagValuesInput(key: \(String(describing: key)), paginationToken: \(String(describing: paginationToken)))"}
}

extension GetTagValuesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case paginationToken = "PaginationToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let paginationToken = paginationToken {
            try encodeContainer.encode(paginationToken, forKey: .paginationToken)
        }
    }
}

public struct GetTagValuesInputHeadersMiddleware: Middleware {
    public let id: String = "GetTagValuesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagValuesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagValuesInput>
    public typealias MOutput = OperationOutput<GetTagValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagValuesOutputError>
}

public struct GetTagValuesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTagValuesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagValuesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagValuesInput>
    public typealias MOutput = OperationOutput<GetTagValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagValuesOutputError>
}

public struct GetTagValuesInput: Equatable {
    /// <p>Specifies the tag key for which you want to list all existing values that are
    ///             currently used in the specified AWS Region for the calling AWS account.</p>
    public let key: String?
    /// <p>Specifies a <code>PaginationToken</code> response value from a
    ///     previous request to indicate that you want the next page of results. Leave this parameter empty
    ///     in your initial request.</p>
    public let paginationToken: String?

    public init (
        key: String? = nil,
        paginationToken: String? = nil
    )
    {
        self.key = key
        self.paginationToken = paginationToken
    }
}

struct GetTagValuesInputBody: Equatable {
    public let paginationToken: String?
    public let key: String?
}

extension GetTagValuesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension GetTagValuesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTagValuesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PaginationTokenExpiredException" : self = .paginationTokenExpiredException(try PaginationTokenExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTagValuesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case paginationTokenExpiredException(PaginationTokenExpiredException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTagValuesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagValuesOutputResponse(paginationToken: \(String(describing: paginationToken)), tagValues: \(String(describing: tagValues)))"}
}

extension GetTagValuesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTagValuesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.paginationToken = output.paginationToken
            self.tagValues = output.tagValues
        } else {
            self.paginationToken = nil
            self.tagValues = nil
        }
    }
}

public struct GetTagValuesOutputResponse: Equatable {
    /// <p>A string that indicates that there is more data available than this
    ///     response contains. To receive the next part of the response, specify this response value
    ///     as the <code>PaginationToken</code> value in the request for the next page.</p>
    public let paginationToken: String?
    /// <p>A list of all tag values for the specified key currently used in the specified AWS
    ///             Region for the calling AWS account.</p>
    public let tagValues: [String]?

    public init (
        paginationToken: String? = nil,
        tagValues: [String]? = nil
    )
    {
        self.paginationToken = paginationToken
        self.tagValues = tagValues
    }
}

struct GetTagValuesOutputResponseBody: Equatable {
    public let paginationToken: String?
    public let tagValues: [String]?
}

extension GetTagValuesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case paginationToken = "PaginationToken"
        case tagValues = "TagValues"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

public enum GroupByAttribute {
    case region
    case resourceType
    case targetId
    case sdkUnknown(String)
}

extension GroupByAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GroupByAttribute] {
        return [
            .region,
            .resourceType,
            .targetId,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .region: return "REGION"
        case .resourceType: return "RESOURCE_TYPE"
        case .targetId: return "TARGET_ID"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GroupByAttribute(rawValue: rawValue) ?? GroupByAttribute.sdkUnknown(rawValue)
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request processing failed because of an unknown error, exception, or failure. You
///             can retry the request.</p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This error indicates one of the following:</p>
///         <ul>
///             <li>
///                 <p>A parameter is missing.</p>
///             </li>
///             <li>
///                 <p>A malformed string was supplied for the request parameter.</p>
///             </li>
///             <li>
///                 <p>An out-of-range value was supplied for the request parameter.</p>
///             </li>
///             <li>
///                 <p>The target ID is invalid, unsupported, or doesn't exist.</p>
///             </li>
///             <li>
///                 <p>You can't access the Amazon S3 bucket for report storage. For more information, see
///                         <a href="http://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_tag-policies-prereqs.html#bucket-policies-org-report">Additional Requirements for Organization-wide Tag Compliance
///                         Reports</a> in the <i>AWS Organizations User Guide.</i>
///                </p>
///             </li>
///          </ul>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PaginationTokenExpiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PaginationTokenExpiredException(message: \(String(describing: message)))"}
}

extension PaginationTokenExpiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PaginationTokenExpiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A <code>PaginationToken</code> is valid for a maximum of 15 minutes. Your request was
///             denied because the specified <code>PaginationToken</code> has expired.</p>
public struct PaginationTokenExpiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PaginationTokenExpiredExceptionBody: Equatable {
    public let message: String?
}

extension PaginationTokenExpiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceTagMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceDetails = "ComplianceDetails"
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceDetails = complianceDetails {
            try encodeContainer.encode(complianceDetails, forKey: .complianceDetails)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let complianceDetailsDecoded = try containerValues.decodeIfPresent(ComplianceDetails.self, forKey: .complianceDetails)
        complianceDetails = complianceDetailsDecoded
    }
}

extension ResourceTagMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceTagMapping(complianceDetails: \(String(describing: complianceDetails)), resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

/// <p>A list of resource ARNs and the tags (keys and values) that are associated with
///             each.</p>
public struct ResourceTagMapping: Equatable {
    /// <p>Information that shows whether a resource is compliant with the effective tag policy,
    ///             including details on any noncompliant tag keys.</p>
    public let complianceDetails: ComplianceDetails?
    /// <p>The ARN of the resource.</p>
    public let resourceARN: String?
    /// <p>The tags that have been applied to one or more AWS resources.</p>
    public let tags: [Tag]?

    public init (
        complianceDetails: ComplianceDetails? = nil,
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.complianceDetails = complianceDetails
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct StartReportCreationInputBodyMiddleware: Middleware {
    public let id: String = "StartReportCreationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReportCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReportCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReportCreationInput>
    public typealias MOutput = OperationOutput<StartReportCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReportCreationOutputError>
}

extension StartReportCreationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartReportCreationInput(s3Bucket: \(String(describing: s3Bucket)))"}
}

extension StartReportCreationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
    }
}

public struct StartReportCreationInputHeadersMiddleware: Middleware {
    public let id: String = "StartReportCreationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReportCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReportCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReportCreationInput>
    public typealias MOutput = OperationOutput<StartReportCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReportCreationOutputError>
}

public struct StartReportCreationInputQueryItemMiddleware: Middleware {
    public let id: String = "StartReportCreationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReportCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReportCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReportCreationInput>
    public typealias MOutput = OperationOutput<StartReportCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReportCreationOutputError>
}

public struct StartReportCreationInput: Equatable {
    /// <p>The name of the Amazon S3 bucket where the report will be stored; for example:</p>
    ///         <p>
    ///             <code>awsexamplebucket</code>
    ///          </p>
    ///         <p>For more information on S3 bucket requirements, including an example bucket policy,
    ///             see the example S3 bucket policy on this page.</p>
    public let s3Bucket: String?

    public init (
        s3Bucket: String? = nil
    )
    {
        self.s3Bucket = s3Bucket
    }
}

struct StartReportCreationInputBody: Equatable {
    public let s3Bucket: String?
}

extension StartReportCreationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
    }
}

extension StartReportCreationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReportCreationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConstraintViolationException" : self = .constraintViolationException(try ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartReportCreationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case constraintViolationException(ConstraintViolationException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReportCreationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartReportCreationOutputResponse()"}
}

extension StartReportCreationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartReportCreationOutputResponse: Equatable {

    public init() {}
}

struct StartReportCreationOutputResponseBody: Equatable {
}

extension StartReportCreationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Summary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastUpdated = "LastUpdated"
        case nonCompliantResources = "NonCompliantResources"
        case region = "Region"
        case resourceType = "ResourceType"
        case targetId = "TargetId"
        case targetIdType = "TargetIdType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated, forKey: .lastUpdated)
        }
        if nonCompliantResources != 0 {
            try encodeContainer.encode(nonCompliantResources, forKey: .nonCompliantResources)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetIdType = targetIdType {
            try encodeContainer.encode(targetIdType.rawValue, forKey: .targetIdType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetIdTypeDecoded = try containerValues.decodeIfPresent(TargetIdType.self, forKey: .targetIdType)
        targetIdType = targetIdTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let nonCompliantResourcesDecoded = try containerValues.decode(Int.self, forKey: .nonCompliantResources)
        nonCompliantResources = nonCompliantResourcesDecoded
    }
}

extension Summary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Summary(lastUpdated: \(String(describing: lastUpdated)), nonCompliantResources: \(String(describing: nonCompliantResources)), region: \(String(describing: region)), resourceType: \(String(describing: resourceType)), targetId: \(String(describing: targetId)), targetIdType: \(String(describing: targetIdType)))"}
}

/// <p>A count of noncompliant resources.</p>
public struct Summary: Equatable {
    /// <p>The timestamp that shows when this summary was generated in this Region. </p>
    public let lastUpdated: String?
    /// <p>The count of noncompliant resources.</p>
    public let nonCompliantResources: Int
    /// <p>The AWS Region that the summary applies to.</p>
    public let region: String?
    /// <p>The AWS resource type.</p>
    public let resourceType: String?
    /// <p>The account identifier or the root identifier of the organization. If you don't know
    ///             the root ID, you can call the AWS Organizations <a href="http://docs.aws.amazon.com/organizations/latest/APIReference/API_ListRoots.html">ListRoots</a> API.</p>
    public let targetId: String?
    /// <p>Whether the target is an account, an OU, or the organization root.</p>
    public let targetIdType: TargetIdType?

    public init (
        lastUpdated: String? = nil,
        nonCompliantResources: Int = 0,
        region: String? = nil,
        resourceType: String? = nil,
        targetId: String? = nil,
        targetIdType: TargetIdType? = nil
    )
    {
        self.lastUpdated = lastUpdated
        self.nonCompliantResources = nonCompliantResources
        self.region = region
        self.resourceType = resourceType
        self.targetId = targetId
        self.targetIdType = targetIdType
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The metadata that you apply to AWS resources to help you categorize and organize
///             them. Each tag consists of a key and a value, both of which you define. For more
///             information, see <a href="http://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
///                 Resources</a> in the <i>AWS General Reference</i>.</p>
public struct Tag: Equatable {
    /// <p>One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.</p>
    public let key: String?
    /// <p>One part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key). The value can be empty or null.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for tagvaluelist0 in values {
                try valuesContainer.encode(tagvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension TagFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagFilter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>A list of tags (keys and values) that are used to specify the associated
///             resources.</p>
public struct TagFilter: Equatable {
    /// <p>One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.</p>
    public let key: String?
    /// <p>One part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key). The value can be empty or null.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

public struct TagResourcesInputBodyMiddleware: Middleware {
    public let id: String = "TagResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourcesInput>
    public typealias MOutput = OperationOutput<TagResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourcesOutputError>
}

extension TagResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourcesInput(resourceARNList: \(String(describing: resourceARNList)), tags: \(String(describing: tags)))"}
}

extension TagResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNList = "ResourceARNList"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNList = resourceARNList {
            var resourceARNListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceARNList)
            for resourcearnlistfortaguntag0 in resourceARNList {
                try resourceARNListContainer.encode(resourcearnlistfortaguntag0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourcesInput>
    public typealias MOutput = OperationOutput<TagResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourcesOutputError>
}

public struct TagResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourcesInput>
    public typealias MOutput = OperationOutput<TagResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourcesOutputError>
}

public struct TagResourcesInput: Equatable {
    /// <p>Specifies the list of ARNs of the resources that you want to apply tags to.</p>
    ///         <p>An ARN (Amazon Resource Name) uniquely identifies a resource. For more information,
    ///             see <a href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
    ///                 Resource Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS
    ///                 General Reference</i>.</p>
    public let resourceARNList: [String]?
    /// <p>Specifies a list of tags that you want to add to the specified resources. A tag
    ///             consists of a key and a value that you define.</p>
    public let tags: [String:String]?

    public init (
        resourceARNList: [String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceARNList = resourceARNList
        self.tags = tags
    }
}

struct TagResourcesInputBody: Equatable {
    public let resourceARNList: [String]?
    public let tags: [String:String]?
}

extension TagResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARNList = "ResourceARNList"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceARNList)
        var resourceARNListDecoded0:[String]? = nil
        if let resourceARNListContainer = resourceARNListContainer {
            resourceARNListDecoded0 = [String]()
            for string0 in resourceARNListContainer {
                if let string0 = string0 {
                    resourceARNListDecoded0?.append(string0)
                }
            }
        }
        resourceARNList = resourceARNListDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourcesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourcesOutputResponse(failedResourcesMap: \(String(describing: failedResourcesMap)))"}
}

extension TagResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedResourcesMap = output.failedResourcesMap
        } else {
            self.failedResourcesMap = nil
        }
    }
}

public struct TagResourcesOutputResponse: Equatable {
    /// <p>A map containing a key-value pair for each failed item that couldn't be tagged. The
    ///             key is the ARN of the failed resource. The value is a <code>FailureInfo</code> object
    ///             that contains an error code, a status code, and an error message. If there are no
    ///             errors, the <code>FailedResourcesMap</code> is empty.</p>
    public let failedResourcesMap: [String:FailureInfo]?

    public init (
        failedResourcesMap: [String:FailureInfo]? = nil
    )
    {
        self.failedResourcesMap = failedResourcesMap
    }
}

struct TagResourcesOutputResponseBody: Equatable {
    public let failedResourcesMap: [String:FailureInfo]?
}

extension TagResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedResourcesMap = "FailedResourcesMap"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedResourcesMapContainer = try containerValues.decodeIfPresent([String: FailureInfo?].self, forKey: .failedResourcesMap)
        var failedResourcesMapDecoded0: [String:FailureInfo]? = nil
        if let failedResourcesMapContainer = failedResourcesMapContainer {
            failedResourcesMapDecoded0 = [String:FailureInfo]()
            for (key0, failureinfo0) in failedResourcesMapContainer {
                if let failureinfo0 = failureinfo0 {
                    failedResourcesMapDecoded0?[key0] = failureinfo0
                }
            }
        }
        failedResourcesMap = failedResourcesMapDecoded0
    }
}

public enum TargetIdType {
    case account
    case ou
    case root
    case sdkUnknown(String)
}

extension TargetIdType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetIdType] {
        return [
            .account,
            .ou,
            .root,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .account: return "ACCOUNT"
        case .ou: return "OU"
        case .root: return "ROOT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetIdType(rawValue: rawValue) ?? TargetIdType.sdkUnknown(rawValue)
    }
}

extension ThrottledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottledException(message: \(String(describing: message)))"}
}

extension ThrottledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied to limit the frequency of submitted requests.</p>
public struct ThrottledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottledExceptionBody: Equatable {
    public let message: String?
}

extension ThrottledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourcesInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourcesInput>
    public typealias MOutput = OperationOutput<UntagResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourcesOutputError>
}

extension UntagResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourcesInput(resourceARNList: \(String(describing: resourceARNList)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNList = "ResourceARNList"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNList = resourceARNList {
            var resourceARNListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceARNList)
            for resourcearnlistfortaguntag0 in resourceARNList {
                try resourceARNListContainer.encode(resourcearnlistfortaguntag0)
            }
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylistforuntag0 in tagKeys {
                try tagKeysContainer.encode(tagkeylistforuntag0)
            }
        }
    }
}

public struct UntagResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourcesInput>
    public typealias MOutput = OperationOutput<UntagResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourcesOutputError>
}

public struct UntagResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourcesInput>
    public typealias MOutput = OperationOutput<UntagResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourcesOutputError>
}

public struct UntagResourcesInput: Equatable {
    /// <p>Specifies a list of ARNs of the resources that you want to remove tags from.</p>
    ///         <p>An ARN (Amazon Resource Name) uniquely identifies a resource. For more information,
    ///             see <a href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
    ///                 Resource Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS
    ///                 General Reference</i>.</p>
    public let resourceARNList: [String]?
    /// <p>Specifies a list of tag keys that you want to remove from the specified
    ///             resources.</p>
    public let tagKeys: [String]?

    public init (
        resourceARNList: [String]? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARNList = resourceARNList
        self.tagKeys = tagKeys
    }
}

struct UntagResourcesInputBody: Equatable {
    public let resourceARNList: [String]?
    public let tagKeys: [String]?
}

extension UntagResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARNList = "ResourceARNList"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceARNList)
        var resourceARNListDecoded0:[String]? = nil
        if let resourceARNListContainer = resourceARNListContainer {
            resourceARNListDecoded0 = [String]()
            for string0 in resourceARNListContainer {
                if let string0 = string0 {
                    resourceARNListDecoded0?.append(string0)
                }
            }
        }
        resourceARNList = resourceARNListDecoded0
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourcesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourcesOutputResponse(failedResourcesMap: \(String(describing: failedResourcesMap)))"}
}

extension UntagResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UntagResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedResourcesMap = output.failedResourcesMap
        } else {
            self.failedResourcesMap = nil
        }
    }
}

public struct UntagResourcesOutputResponse: Equatable {
    /// <p>A map containing a key-value pair for each failed item that couldn't be untagged. The
    ///             key is the ARN of the failed resource. The value is a <code>FailureInfo</code> object
    ///             that contains an error code, a status code, and an error message. If there are no
    ///             errors, the <code>FailedResourcesMap</code> is empty.</p>
    public let failedResourcesMap: [String:FailureInfo]?

    public init (
        failedResourcesMap: [String:FailureInfo]? = nil
    )
    {
        self.failedResourcesMap = failedResourcesMap
    }
}

struct UntagResourcesOutputResponseBody: Equatable {
    public let failedResourcesMap: [String:FailureInfo]?
}

extension UntagResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedResourcesMap = "FailedResourcesMap"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedResourcesMapContainer = try containerValues.decodeIfPresent([String: FailureInfo?].self, forKey: .failedResourcesMap)
        var failedResourcesMapDecoded0: [String:FailureInfo]? = nil
        if let failedResourcesMapContainer = failedResourcesMapContainer {
            failedResourcesMapDecoded0 = [String:FailureInfo]()
            for (key0, failureinfo0) in failedResourcesMapContainer {
                if let failureinfo0 = failureinfo0 {
                    failedResourcesMapDecoded0?[key0] = failureinfo0
                }
            }
        }
        failedResourcesMap = failedResourcesMapDecoded0
    }
}
