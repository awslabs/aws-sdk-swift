// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS CodeStar Notifications can't create the notification rule because you do not have sufficient
///       permissions.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS CodeStar Notifications can't complete the request because the resource is being modified by
///       another process. Wait a few minutes and try again.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationException(message: \(String(describing: message)))"}
}

extension ConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Some or all of the configuration is incomplete, missing, or not valid.</p>
public struct ConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension ConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateNotificationRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreateNotificationRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNotificationRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNotificationRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNotificationRuleInput>
    public typealias MOutput = OperationOutput<CreateNotificationRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNotificationRuleOutputError>
}

extension CreateNotificationRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNotificationRuleInput(clientRequestToken: \(String(describing: clientRequestToken)), detailType: \(String(describing: detailType)), eventTypeIds: \(String(describing: eventTypeIds)), name: \(String(describing: name)), resource: \(String(describing: resource)), status: \(String(describing: status)), tags: \(String(describing: tags)), targets: \(String(describing: targets)))"}
}

extension CreateNotificationRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case detailType = "DetailType"
        case eventTypeIds = "EventTypeIds"
        case name = "Name"
        case resource = "Resource"
        case status = "Status"
        case tags = "Tags"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let detailType = detailType {
            try encodeContainer.encode(detailType.rawValue, forKey: .detailType)
        }
        if let eventTypeIds = eventTypeIds {
            var eventTypeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeIds)
            for eventtypeids0 in eventTypeIds {
                try eventTypeIdsContainer.encode(eventtypeids0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

public struct CreateNotificationRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateNotificationRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNotificationRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNotificationRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNotificationRuleInput>
    public typealias MOutput = OperationOutput<CreateNotificationRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNotificationRuleOutputError>
}

public struct CreateNotificationRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateNotificationRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNotificationRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNotificationRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNotificationRuleInput>
    public typealias MOutput = OperationOutput<CreateNotificationRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNotificationRuleOutputError>
}

public struct CreateNotificationRuleInput: Equatable {
    /// <p>A unique, client-generated idempotency token that, when provided in a request, ensures
    ///             the request cannot be repeated with a changed parameter. If a request with the same
    ///             parameters is received and a token is included, the request returns information about
    ///             the initial request that used that token.</p>
    ///         <note>
    ///             <p>The AWS SDKs prepopulate client request tokens. If you are using an AWS SDK, an
    ///                 idempotency token is created for you.</p>
    ///         </note>
    public var clientRequestToken: String?
    /// <p>The level of detail to include in the notifications for this resource. BASIC will include only the
    ///         contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information
    ///         provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created.</p>
    public let detailType: DetailType?
    /// <p>A list of event types associated with this notification rule. For a list of allowed
    ///             events, see <a>EventTypeSummary</a>.</p>
    public let eventTypeIds: [String]?
    /// <p>The name for the notification rule. Notifictaion rule names must be unique in your AWS
    ///             account.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the resource to associate with the notification rule. Supported resources include pipelines in AWS CodePipeline,
    ///       repositories in AWS CodeCommit, and build projects in AWS CodeBuild.</p>
    public let resource: String?
    /// <p>The status of the notification rule. The default value is ENABLED. If the status is
    ///             set to DISABLED, notifications aren't sent for the notification rule.</p>
    public let status: NotificationRuleStatus?
    /// <p>A list of tags to apply to this notification rule. Key names cannot start with "aws". </p>
    public let tags: [String:String]?
    /// <p>A list of Amazon Resource Names (ARNs) of SNS topics to associate with the
    ///       notification rule.</p>
    public let targets: [Target]?

    public init (
        clientRequestToken: String? = nil,
        detailType: DetailType? = nil,
        eventTypeIds: [String]? = nil,
        name: String? = nil,
        resource: String? = nil,
        status: NotificationRuleStatus? = nil,
        tags: [String:String]? = nil,
        targets: [Target]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.detailType = detailType
        self.eventTypeIds = eventTypeIds
        self.name = name
        self.resource = resource
        self.status = status
        self.tags = tags
        self.targets = targets
    }
}

struct CreateNotificationRuleInputBody: Equatable {
    public let name: String?
    public let eventTypeIds: [String]?
    public let resource: String?
    public let targets: [Target]?
    public let detailType: DetailType?
    public let clientRequestToken: String?
    public let tags: [String:String]?
    public let status: NotificationRuleStatus?
}

extension CreateNotificationRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case detailType = "DetailType"
        case eventTypeIds = "EventTypeIds"
        case name = "Name"
        case resource = "Resource"
        case status = "Status"
        case tags = "Tags"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let eventTypeIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventTypeIds)
        var eventTypeIdsDecoded0:[String]? = nil
        if let eventTypeIdsContainer = eventTypeIdsContainer {
            eventTypeIdsDecoded0 = [String]()
            for string0 in eventTypeIdsContainer {
                if let string0 = string0 {
                    eventTypeIdsDecoded0?.append(string0)
                }
            }
        }
        eventTypeIds = eventTypeIdsDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let detailTypeDecoded = try containerValues.decodeIfPresent(DetailType.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(NotificationRuleStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateNotificationRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNotificationRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConfigurationException" : self = .configurationException(try ConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNotificationRuleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentModificationException(ConcurrentModificationException)
    case configurationException(ConfigurationException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNotificationRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNotificationRuleOutputResponse(arn: \(String(describing: arn)))"}
}

extension CreateNotificationRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateNotificationRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateNotificationRuleOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notification rule.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateNotificationRuleOutputResponseBody: Equatable {
    public let arn: String?
}

extension CreateNotificationRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct DeleteNotificationRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteNotificationRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNotificationRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNotificationRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNotificationRuleInput>
    public typealias MOutput = OperationOutput<DeleteNotificationRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNotificationRuleOutputError>
}

extension DeleteNotificationRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNotificationRuleInput(arn: \(String(describing: arn)))"}
}

extension DeleteNotificationRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteNotificationRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteNotificationRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNotificationRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNotificationRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNotificationRuleInput>
    public typealias MOutput = OperationOutput<DeleteNotificationRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNotificationRuleOutputError>
}

public struct DeleteNotificationRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteNotificationRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNotificationRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNotificationRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNotificationRuleInput>
    public typealias MOutput = OperationOutput<DeleteNotificationRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNotificationRuleOutputError>
}

public struct DeleteNotificationRuleInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notification rule you want to delete.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteNotificationRuleInputBody: Equatable {
    public let arn: String?
}

extension DeleteNotificationRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteNotificationRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNotificationRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNotificationRuleOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNotificationRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNotificationRuleOutputResponse(arn: \(String(describing: arn)))"}
}

extension DeleteNotificationRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteNotificationRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeleteNotificationRuleOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the deleted notification rule.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteNotificationRuleOutputResponseBody: Equatable {
    public let arn: String?
}

extension DeleteNotificationRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct DeleteTargetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTargetInput>
    public typealias MOutput = OperationOutput<DeleteTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTargetOutputError>
}

extension DeleteTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTargetInput(forceUnsubscribeAll: \(String(describing: forceUnsubscribeAll)), targetAddress: \(String(describing: targetAddress)))"}
}

extension DeleteTargetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forceUnsubscribeAll = "ForceUnsubscribeAll"
        case targetAddress = "TargetAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if forceUnsubscribeAll != false {
            try encodeContainer.encode(forceUnsubscribeAll, forKey: .forceUnsubscribeAll)
        }
        if let targetAddress = targetAddress {
            try encodeContainer.encode(targetAddress, forKey: .targetAddress)
        }
    }
}

public struct DeleteTargetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTargetInput>
    public typealias MOutput = OperationOutput<DeleteTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTargetOutputError>
}

public struct DeleteTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTargetInput>
    public typealias MOutput = OperationOutput<DeleteTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTargetOutputError>
}

public struct DeleteTargetInput: Equatable {
    /// <p>A Boolean value that can be used to delete all associations with this SNS topic. The
    ///             default value is FALSE. If set to TRUE, all associations between that target and every
    ///             notification rule in your AWS account are deleted.</p>
    public let forceUnsubscribeAll: Bool
    /// <p>The Amazon Resource Name (ARN) of the SNS topic to delete.</p>
    public let targetAddress: String?

    public init (
        forceUnsubscribeAll: Bool = false,
        targetAddress: String? = nil
    )
    {
        self.forceUnsubscribeAll = forceUnsubscribeAll
        self.targetAddress = targetAddress
    }
}

struct DeleteTargetInputBody: Equatable {
    public let targetAddress: String?
    public let forceUnsubscribeAll: Bool
}

extension DeleteTargetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forceUnsubscribeAll = "ForceUnsubscribeAll"
        case targetAddress = "TargetAddress"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetAddress)
        targetAddress = targetAddressDecoded
        let forceUnsubscribeAllDecoded = try containerValues.decode(Bool.self, forKey: .forceUnsubscribeAll)
        forceUnsubscribeAll = forceUnsubscribeAllDecoded
    }
}

extension DeleteTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTargetOutputError: Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTargetOutputResponse()"}
}

extension DeleteTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTargetOutputResponse: Equatable {

    public init() {}
}

struct DeleteTargetOutputResponseBody: Equatable {
}

extension DeleteTargetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeNotificationRuleInputBodyMiddleware: Middleware {
    public let id: String = "DescribeNotificationRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNotificationRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNotificationRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNotificationRuleInput>
    public typealias MOutput = OperationOutput<DescribeNotificationRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNotificationRuleOutputError>
}

extension DescribeNotificationRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNotificationRuleInput(arn: \(String(describing: arn)))"}
}

extension DescribeNotificationRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DescribeNotificationRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeNotificationRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNotificationRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNotificationRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNotificationRuleInput>
    public typealias MOutput = OperationOutput<DescribeNotificationRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNotificationRuleOutputError>
}

public struct DescribeNotificationRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeNotificationRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNotificationRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNotificationRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNotificationRuleInput>
    public typealias MOutput = OperationOutput<DescribeNotificationRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNotificationRuleOutputError>
}

public struct DescribeNotificationRuleInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notification rule.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DescribeNotificationRuleInputBody: Equatable {
    public let arn: String?
}

extension DescribeNotificationRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DescribeNotificationRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNotificationRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNotificationRuleOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNotificationRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNotificationRuleOutputResponse(arn: \(String(describing: arn)), createdBy: \(String(describing: createdBy)), createdTimestamp: \(String(describing: createdTimestamp)), detailType: \(String(describing: detailType)), eventTypes: \(String(describing: eventTypes)), lastModifiedTimestamp: \(String(describing: lastModifiedTimestamp)), name: \(String(describing: name)), resource: \(String(describing: resource)), status: \(String(describing: status)), tags: \(String(describing: tags)), targets: \(String(describing: targets)))"}
}

extension DescribeNotificationRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeNotificationRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.createdTimestamp = output.createdTimestamp
            self.detailType = output.detailType
            self.eventTypes = output.eventTypes
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.name = output.name
            self.resource = output.resource
            self.status = output.status
            self.tags = output.tags
            self.targets = output.targets
        } else {
            self.arn = nil
            self.createdBy = nil
            self.createdTimestamp = nil
            self.detailType = nil
            self.eventTypes = nil
            self.lastModifiedTimestamp = nil
            self.name = nil
            self.resource = nil
            self.status = nil
            self.tags = nil
            self.targets = nil
        }
    }
}

public struct DescribeNotificationRuleOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notification rule.</p>
    public let arn: String?
    /// <p>The name or email alias of the person who created the notification rule.</p>
    public let createdBy: String?
    /// <p>The date and time the notification rule was created, in timestamp format.</p>
    public let createdTimestamp: Date?
    /// <p>The level of detail included in the notifications for this resource. BASIC will include only the
    ///             contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information
    ///             provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created.</p>
    public let detailType: DetailType?
    /// <p>A list of the event types associated with the notification rule.</p>
    public let eventTypes: [EventTypeSummary]?
    /// <p>The date and time the notification rule was most recently updated, in timestamp
    ///             format.</p>
    public let lastModifiedTimestamp: Date?
    /// <p>The name of the notification rule.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the resource associated with the notification
    ///       rule.</p>
    public let resource: String?
    /// <p>The status of the notification rule. Valid statuses are on (sending notifications) or off
    ///       (not sending notifications).</p>
    public let status: NotificationRuleStatus?
    /// <p>The tags associated with the notification rule.</p>
    public let tags: [String:String]?
    /// <p>A list of the SNS topics associated with the notification rule.</p>
    public let targets: [TargetSummary]?

    public init (
        arn: String? = nil,
        createdBy: String? = nil,
        createdTimestamp: Date? = nil,
        detailType: DetailType? = nil,
        eventTypes: [EventTypeSummary]? = nil,
        lastModifiedTimestamp: Date? = nil,
        name: String? = nil,
        resource: String? = nil,
        status: NotificationRuleStatus? = nil,
        tags: [String:String]? = nil,
        targets: [TargetSummary]? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.createdTimestamp = createdTimestamp
        self.detailType = detailType
        self.eventTypes = eventTypes
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.name = name
        self.resource = resource
        self.status = status
        self.tags = tags
        self.targets = targets
    }
}

struct DescribeNotificationRuleOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let eventTypes: [EventTypeSummary]?
    public let resource: String?
    public let targets: [TargetSummary]?
    public let detailType: DetailType?
    public let createdBy: String?
    public let status: NotificationRuleStatus?
    public let createdTimestamp: Date?
    public let lastModifiedTimestamp: Date?
    public let tags: [String:String]?
}

extension DescribeNotificationRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case detailType = "DetailType"
        case eventTypes = "EventTypes"
        case lastModifiedTimestamp = "LastModifiedTimestamp"
        case name = "Name"
        case resource = "Resource"
        case status = "Status"
        case tags = "Tags"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let eventTypesContainer = try containerValues.decodeIfPresent([EventTypeSummary?].self, forKey: .eventTypes)
        var eventTypesDecoded0:[EventTypeSummary]? = nil
        if let eventTypesContainer = eventTypesContainer {
            eventTypesDecoded0 = [EventTypeSummary]()
            for structure0 in eventTypesContainer {
                if let structure0 = structure0 {
                    eventTypesDecoded0?.append(structure0)
                }
            }
        }
        eventTypes = eventTypesDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let targetsContainer = try containerValues.decodeIfPresent([TargetSummary?].self, forKey: .targets)
        var targetsDecoded0:[TargetSummary]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [TargetSummary]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let detailTypeDecoded = try containerValues.decodeIfPresent(DetailType.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NotificationRuleStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum DetailType {
    case basic
    case full
    case sdkUnknown(String)
}

extension DetailType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DetailType] {
        return [
            .basic,
            .full,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .basic: return "BASIC"
        case .full: return "FULL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DetailType(rawValue: rawValue) ?? DetailType.sdkUnknown(rawValue)
    }
}

extension EventTypeSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventTypeId = "EventTypeId"
        case eventTypeName = "EventTypeName"
        case resourceType = "ResourceType"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTypeId = eventTypeId {
            try encodeContainer.encode(eventTypeId, forKey: .eventTypeId)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeId)
        eventTypeId = eventTypeIdDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension EventTypeSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventTypeSummary(eventTypeId: \(String(describing: eventTypeId)), eventTypeName: \(String(describing: eventTypeName)), resourceType: \(String(describing: resourceType)), serviceName: \(String(describing: serviceName)))"}
}

/// <p>Returns information about an event that has triggered a notification rule.</p>
public struct EventTypeSummary: Equatable {
    /// <p>The system-generated ID of the event.</p>
    public let eventTypeId: String?
    /// <p>The name of the event.</p>
    public let eventTypeName: String?
    /// <p>The resource type of the event.</p>
    public let resourceType: String?
    /// <p>The name of the service for which the event applies.</p>
    public let serviceName: String?

    public init (
        eventTypeId: String? = nil,
        eventTypeName: String? = nil,
        resourceType: String? = nil,
        serviceName: String? = nil
    )
    {
        self.eventTypeId = eventTypeId
        self.eventTypeName = eventTypeName
        self.resourceType = resourceType
        self.serviceName = serviceName
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value for the enumeration token used in the request to return the next batch of the results is not valid. </p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One of the AWS CodeStar Notifications limits has been exceeded. Limits apply to
///             accounts, notification rules, notifications, resources, and targets. For more
///             information, see Limits.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListEventTypesFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ListEventTypesFilterName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ListEventTypesFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventTypesFilter(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Information about a filter to apply to the list of returned event types. You can filter
///       by resource type or service name.</p>
public struct ListEventTypesFilter: Equatable {
    /// <p>The system-generated name of the filter type you want to filter by.</p>
    public let name: ListEventTypesFilterName?
    /// <p>The name of the resource type (for example, pipeline) or service name (for example,
    ///       CodePipeline) that you want to filter by.</p>
    public let value: String?

    public init (
        name: ListEventTypesFilterName? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum ListEventTypesFilterName {
    case resourceType
    case serviceName
    case sdkUnknown(String)
}

extension ListEventTypesFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ListEventTypesFilterName] {
        return [
            .resourceType,
            .serviceName,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .resourceType: return "RESOURCE_TYPE"
        case .serviceName: return "SERVICE_NAME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ListEventTypesFilterName(rawValue: rawValue) ?? ListEventTypesFilterName.sdkUnknown(rawValue)
    }
}

public struct ListEventTypesInputBodyMiddleware: Middleware {
    public let id: String = "ListEventTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventTypesInput>
    public typealias MOutput = OperationOutput<ListEventTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventTypesOutputError>
}

extension ListEventTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventTypesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventTypesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listeventtypesfilters0 in filters {
                try filtersContainer.encode(listeventtypesfilters0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEventTypesInputHeadersMiddleware: Middleware {
    public let id: String = "ListEventTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventTypesInput>
    public typealias MOutput = OperationOutput<ListEventTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventTypesOutputError>
}

public struct ListEventTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEventTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventTypesInput>
    public typealias MOutput = OperationOutput<ListEventTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventTypesOutputError>
}

public struct ListEventTypesInput: Equatable {
    /// <p>The filters to use to return information by service or resource type.</p>
    public let filters: [ListEventTypesFilter]?
    /// <p>A non-negative integer used to limit the number of returned results. The default number is 50. The maximum number of
    ///       results that can be returned is 100.</p>
    public let maxResults: Int
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?

    public init (
        filters: [ListEventTypesFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventTypesInputBody: Equatable {
    public let filters: [ListEventTypesFilter]?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListEventTypesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ListEventTypesFilter?].self, forKey: .filters)
        var filtersDecoded0:[ListEventTypesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ListEventTypesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventTypesOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventTypesOutputResponse(eventTypes: \(String(describing: eventTypes)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEventTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventTypes = output.eventTypes
            self.nextToken = output.nextToken
        } else {
            self.eventTypes = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventTypesOutputResponse: Equatable {
    /// <p>Information about each event, including service name, resource type, event ID, and event
    ///       name.</p>
    public let eventTypes: [EventTypeSummary]?
    /// <p>An enumeration token that can be used in a request to return the next batch of the results.</p>
    public let nextToken: String?

    public init (
        eventTypes: [EventTypeSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.eventTypes = eventTypes
        self.nextToken = nextToken
    }
}

struct ListEventTypesOutputResponseBody: Equatable {
    public let eventTypes: [EventTypeSummary]?
    public let nextToken: String?
}

extension ListEventTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventTypes = "EventTypes"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypesContainer = try containerValues.decodeIfPresent([EventTypeSummary?].self, forKey: .eventTypes)
        var eventTypesDecoded0:[EventTypeSummary]? = nil
        if let eventTypesContainer = eventTypesContainer {
            eventTypesDecoded0 = [EventTypeSummary]()
            for structure0 in eventTypesContainer {
                if let structure0 = structure0 {
                    eventTypesDecoded0?.append(structure0)
                }
            }
        }
        eventTypes = eventTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNotificationRulesFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ListNotificationRulesFilterName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ListNotificationRulesFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNotificationRulesFilter(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Information about a filter to apply to the list of returned notification rules. You can
///       filter by event type, owner, resource, or target.</p>
public struct ListNotificationRulesFilter: Equatable {
    /// <p>The name of the attribute you want to use to filter the returned notification rules.</p>
    public let name: ListNotificationRulesFilterName?
    /// <p>The value of the attribute you want to use to filter the returned notification rules. For example, if you specify filtering by <i>RESOURCE</i>
    ///           in Name, you might specify the ARN of a pipeline in AWS CodePipeline for the value.</p>
    public let value: String?

    public init (
        name: ListNotificationRulesFilterName? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum ListNotificationRulesFilterName {
    case createdBy
    case eventTypeId
    case resource
    case targetAddress
    case sdkUnknown(String)
}

extension ListNotificationRulesFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ListNotificationRulesFilterName] {
        return [
            .createdBy,
            .eventTypeId,
            .resource,
            .targetAddress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createdBy: return "CREATED_BY"
        case .eventTypeId: return "EVENT_TYPE_ID"
        case .resource: return "RESOURCE"
        case .targetAddress: return "TARGET_ADDRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ListNotificationRulesFilterName(rawValue: rawValue) ?? ListNotificationRulesFilterName.sdkUnknown(rawValue)
    }
}

public struct ListNotificationRulesInputBodyMiddleware: Middleware {
    public let id: String = "ListNotificationRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNotificationRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNotificationRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNotificationRulesInput>
    public typealias MOutput = OperationOutput<ListNotificationRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNotificationRulesOutputError>
}

extension ListNotificationRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNotificationRulesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListNotificationRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listnotificationrulesfilters0 in filters {
                try filtersContainer.encode(listnotificationrulesfilters0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListNotificationRulesInputHeadersMiddleware: Middleware {
    public let id: String = "ListNotificationRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNotificationRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNotificationRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNotificationRulesInput>
    public typealias MOutput = OperationOutput<ListNotificationRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNotificationRulesOutputError>
}

public struct ListNotificationRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListNotificationRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNotificationRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNotificationRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNotificationRulesInput>
    public typealias MOutput = OperationOutput<ListNotificationRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNotificationRulesOutputError>
}

public struct ListNotificationRulesInput: Equatable {
    /// <p>The filters to use to return information by service or resource type. For valid values,
    ///             see <a>ListNotificationRulesFilter</a>.</p>
    ///          <note>
    ///             <p>A filter with the same name can appear more than once when used with OR statements. Filters with different names should be applied with AND statements.</p>
    ///          </note>
    public let filters: [ListNotificationRulesFilter]?
    /// <p>A non-negative integer used to limit the number of returned results. The maximum number of
    ///       results that can be returned is 100.</p>
    public let maxResults: Int
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?

    public init (
        filters: [ListNotificationRulesFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNotificationRulesInputBody: Equatable {
    public let filters: [ListNotificationRulesFilter]?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListNotificationRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ListNotificationRulesFilter?].self, forKey: .filters)
        var filtersDecoded0:[ListNotificationRulesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ListNotificationRulesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListNotificationRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNotificationRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNotificationRulesOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNotificationRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNotificationRulesOutputResponse(nextToken: \(String(describing: nextToken)), notificationRules: \(String(describing: notificationRules)))"}
}

extension ListNotificationRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListNotificationRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.notificationRules = output.notificationRules
        } else {
            self.nextToken = nil
            self.notificationRules = nil
        }
    }
}

public struct ListNotificationRulesOutputResponse: Equatable {
    /// <p>An enumeration token that can be used in a request to return the next batch of the results.</p>
    public let nextToken: String?
    /// <p>The list of notification rules for the AWS account, by Amazon Resource Name (ARN) and ID. </p>
    public let notificationRules: [NotificationRuleSummary]?

    public init (
        nextToken: String? = nil,
        notificationRules: [NotificationRuleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationRules = notificationRules
    }
}

struct ListNotificationRulesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let notificationRules: [NotificationRuleSummary]?
}

extension ListNotificationRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case notificationRules = "NotificationRules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let notificationRulesContainer = try containerValues.decodeIfPresent([NotificationRuleSummary?].self, forKey: .notificationRules)
        var notificationRulesDecoded0:[NotificationRuleSummary]? = nil
        if let notificationRulesContainer = notificationRulesContainer {
            notificationRulesDecoded0 = [NotificationRuleSummary]()
            for structure0 in notificationRulesContainer {
                if let structure0 = structure0 {
                    notificationRulesDecoded0?.append(structure0)
                }
            }
        }
        notificationRules = notificationRulesDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(arn: \(String(describing: arn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the notification rule.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let arn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags associated with the notification rule.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTargetsFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ListTargetsFilterName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ListTargetsFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTargetsFilter(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Information about a filter to apply to the list of returned targets. You can filter by
///             target type, address, or status. For example, to filter results to notification rules
///             that have active Amazon SNS topics as targets, you could specify a ListTargetsFilter
///             Name as TargetType and a Value of SNS, and a Name of TARGET_STATUS and a Value of
///             ACTIVE.</p>
public struct ListTargetsFilter: Equatable {
    /// <p>The name of the attribute you want to use to filter the returned targets.</p>
    public let name: ListTargetsFilterName?
    /// <p>The value of the attribute you want to use to filter the returned targets. For example,
    ///             if you specify <i>SNS</i> for the Target type, you could specify an Amazon
    ///             Resource Name (ARN) for a topic as the value.</p>
    public let value: String?

    public init (
        name: ListTargetsFilterName? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum ListTargetsFilterName {
    case targetAddress
    case targetStatus
    case targetType
    case sdkUnknown(String)
}

extension ListTargetsFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ListTargetsFilterName] {
        return [
            .targetAddress,
            .targetStatus,
            .targetType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .targetAddress: return "TARGET_ADDRESS"
        case .targetStatus: return "TARGET_STATUS"
        case .targetType: return "TARGET_TYPE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ListTargetsFilterName(rawValue: rawValue) ?? ListTargetsFilterName.sdkUnknown(rawValue)
    }
}

public struct ListTargetsInputBodyMiddleware: Middleware {
    public let id: String = "ListTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTargetsInput>
    public typealias MOutput = OperationOutput<ListTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTargetsOutputError>
}

extension ListTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTargetsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTargetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listtargetsfilters0 in filters {
                try filtersContainer.encode(listtargetsfilters0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTargetsInput>
    public typealias MOutput = OperationOutput<ListTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTargetsOutputError>
}

public struct ListTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTargetsInput>
    public typealias MOutput = OperationOutput<ListTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTargetsOutputError>
}

public struct ListTargetsInput: Equatable {
    /// <p>The filters to use to return information by service or resource type. Valid filters
    ///             include target type, target address, and target status.</p>
    ///          <note>
    ///             <p>A filter with the same name can appear more than once when used with OR statements. Filters with different names should be applied with AND statements.</p>
    ///          </note>
    public let filters: [ListTargetsFilter]?
    /// <p>A non-negative integer used to limit the number of returned results. The maximum number of
    ///       results that can be returned is 100.</p>
    public let maxResults: Int
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?

    public init (
        filters: [ListTargetsFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTargetsInputBody: Equatable {
    public let filters: [ListTargetsFilter]?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListTargetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ListTargetsFilter?].self, forKey: .filters)
        var filtersDecoded0:[ListTargetsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ListTargetsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTargetsOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTargetsOutputResponse(nextToken: \(String(describing: nextToken)), targets: \(String(describing: targets)))"}
}

extension ListTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTargetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.targets = output.targets
        } else {
            self.nextToken = nil
            self.targets = nil
        }
    }
}

public struct ListTargetsOutputResponse: Equatable {
    /// <p>An enumeration token that can be used in a request to return the next batch of
    ///             results.</p>
    public let nextToken: String?
    /// <p>The list of notification rule targets. </p>
    public let targets: [TargetSummary]?

    public init (
        nextToken: String? = nil,
        targets: [TargetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.targets = targets
    }
}

struct ListTargetsOutputResponseBody: Equatable {
    public let targets: [TargetSummary]?
    public let nextToken: String?
}

extension ListTargetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([TargetSummary?].self, forKey: .targets)
        var targetsDecoded0:[TargetSummary]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [TargetSummary]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum NotificationRuleStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension NotificationRuleStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NotificationRuleStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NotificationRuleStatus(rawValue: rawValue) ?? NotificationRuleStatus.sdkUnknown(rawValue)
    }
}

extension NotificationRuleSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension NotificationRuleSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationRuleSummary(arn: \(String(describing: arn)), id: \(String(describing: id)))"}
}

/// <p>Information about a specified notification rule.</p>
public struct NotificationRuleSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notification rule.</p>
    public let arn: String?
    /// <p>The unique ID of the notification rule.</p>
    public let id: String?

    public init (
        arn: String? = nil,
        id: String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource with the same name or ID already exists. Notification rule names must be
///             unique in your AWS account.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS CodeStar Notifications can't find a resource that matches the provided ARN. </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SubscribeInputBodyMiddleware: Middleware {
    public let id: String = "SubscribeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeInput>
    public typealias MOutput = OperationOutput<SubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeOutputError>
}

extension SubscribeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscribeInput(arn: \(String(describing: arn)), clientRequestToken: \(String(describing: clientRequestToken)), target: \(String(describing: target)))"}
}

extension SubscribeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case clientRequestToken = "ClientRequestToken"
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct SubscribeInputHeadersMiddleware: Middleware {
    public let id: String = "SubscribeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeInput>
    public typealias MOutput = OperationOutput<SubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeOutputError>
}

public struct SubscribeInputQueryItemMiddleware: Middleware {
    public let id: String = "SubscribeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeInput>
    public typealias MOutput = OperationOutput<SubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeOutputError>
}

public struct SubscribeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notification rule for which you want to create the association.</p>
    public let arn: String?
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let clientRequestToken: String?
    /// <p>Information about the SNS topics associated with a  notification rule.</p>
    public let target: Target?

    public init (
        arn: String? = nil,
        clientRequestToken: String? = nil,
        target: Target? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.target = target
    }
}

struct SubscribeInputBody: Equatable {
    public let arn: String?
    public let target: Target?
    public let clientRequestToken: String?
}

extension SubscribeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case clientRequestToken = "ClientRequestToken"
        case target = "Target"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Target.self, forKey: .target)
        target = targetDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension SubscribeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SubscribeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubscribeOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubscribeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscribeOutputResponse(arn: \(String(describing: arn)))"}
}

extension SubscribeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubscribeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct SubscribeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notification rule for which you have created assocations.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct SubscribeOutputResponseBody: Equatable {
    public let arn: String?
}

extension SubscribeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(arn: \(String(describing: arn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notification rule to tag.</p>
    public let arn: String?
    /// <p>The list of tags to associate with the resource. Tag key names cannot start with "aws".</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let arn: String?
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct TagResourceOutputResponse: Equatable {
    /// <p>The list of tags associated with the resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct TagResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Target: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetAddress = "TargetAddress"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetAddress = targetAddress {
            try encodeContainer.encode(targetAddress, forKey: .targetAddress)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let targetAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetAddress)
        targetAddress = targetAddressDecoded
    }
}

extension Target: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Target(targetAddress: \(String(describing: targetAddress)), targetType: \(String(describing: targetType)))"}
}

/// <p>Information about the SNS topics associated with a  notification rule.</p>
public struct Target: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the SNS topic.</p>
    public let targetAddress: String?
    /// <p>The target type. Can be an Amazon SNS topic.</p>
    public let targetType: String?

    public init (
        targetAddress: String? = nil,
        targetType: String? = nil
    )
    {
        self.targetAddress = targetAddress
        self.targetType = targetType
    }
}

public enum TargetStatus {
    case active
    case deactivated
    case inactive
    case pending
    case unreachable
    case sdkUnknown(String)
}

extension TargetStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetStatus] {
        return [
            .active,
            .deactivated,
            .inactive,
            .pending,
            .unreachable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deactivated: return "DEACTIVATED"
        case .inactive: return "INACTIVE"
        case .pending: return "PENDING"
        case .unreachable: return "UNREACHABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetStatus(rawValue: rawValue) ?? TargetStatus.sdkUnknown(rawValue)
    }
}

extension TargetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetAddress = "TargetAddress"
        case targetStatus = "TargetStatus"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetAddress = targetAddress {
            try encodeContainer.encode(targetAddress, forKey: .targetAddress)
        }
        if let targetStatus = targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetAddress)
        targetAddress = targetAddressDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(TargetStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension TargetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetSummary(targetAddress: \(String(describing: targetAddress)), targetStatus: \(String(describing: targetStatus)), targetType: \(String(describing: targetType)))"}
}

/// <p>Information about the targets specified for a notification rule.</p>
public struct TargetSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the SNS topic.</p>
    public let targetAddress: String?
    /// <p>The status of the target.</p>
    public let targetStatus: TargetStatus?
    /// <p>The type of the target (for example, SNS).</p>
    public let targetType: String?

    public init (
        targetAddress: String? = nil,
        targetStatus: TargetStatus? = nil,
        targetType: String? = nil
    )
    {
        self.targetAddress = targetAddress
        self.targetStatus = targetStatus
        self.targetType = targetType
    }
}

public struct UnsubscribeInputBodyMiddleware: Middleware {
    public let id: String = "UnsubscribeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnsubscribeInput>,
                  next: H) -> Swift.Result<OperationOutput<UnsubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnsubscribeInput>
    public typealias MOutput = OperationOutput<UnsubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnsubscribeOutputError>
}

extension UnsubscribeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsubscribeInput(arn: \(String(describing: arn)), targetAddress: \(String(describing: targetAddress)))"}
}

extension UnsubscribeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case targetAddress = "TargetAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let targetAddress = targetAddress {
            try encodeContainer.encode(targetAddress, forKey: .targetAddress)
        }
    }
}

public struct UnsubscribeInputHeadersMiddleware: Middleware {
    public let id: String = "UnsubscribeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnsubscribeInput>,
                  next: H) -> Swift.Result<OperationOutput<UnsubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnsubscribeInput>
    public typealias MOutput = OperationOutput<UnsubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnsubscribeOutputError>
}

public struct UnsubscribeInputQueryItemMiddleware: Middleware {
    public let id: String = "UnsubscribeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnsubscribeInput>,
                  next: H) -> Swift.Result<OperationOutput<UnsubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnsubscribeInput>
    public typealias MOutput = OperationOutput<UnsubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnsubscribeOutputError>
}

public struct UnsubscribeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notification rule.</p>
    public let arn: String?
    /// <p>The ARN of the SNS topic to unsubscribe from the notification rule.</p>
    public let targetAddress: String?

    public init (
        arn: String? = nil,
        targetAddress: String? = nil
    )
    {
        self.arn = arn
        self.targetAddress = targetAddress
    }
}

struct UnsubscribeInputBody: Equatable {
    public let arn: String?
    public let targetAddress: String?
}

extension UnsubscribeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case targetAddress = "TargetAddress"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let targetAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetAddress)
        targetAddress = targetAddressDecoded
    }
}

extension UnsubscribeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnsubscribeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnsubscribeOutputError: Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnsubscribeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsubscribeOutputResponse(arn: \(String(describing: arn)))"}
}

extension UnsubscribeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsubscribeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct UnsubscribeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the the notification rule from which you have removed a subscription.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct UnsubscribeOutputResponseBody: Equatable {
    public let arn: String?
}

extension UnsubscribeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(arn: \(String(describing: arn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notification rule from which to remove the
    ///       tags.</p>
    public let arn: String?
    /// <p>The key names of the tags to remove.</p>
    public let tagKeys: [String]?

    public init (
        arn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let arn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateNotificationRuleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateNotificationRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNotificationRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNotificationRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNotificationRuleInput>
    public typealias MOutput = OperationOutput<UpdateNotificationRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNotificationRuleOutputError>
}

extension UpdateNotificationRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNotificationRuleInput(arn: \(String(describing: arn)), detailType: \(String(describing: detailType)), eventTypeIds: \(String(describing: eventTypeIds)), name: \(String(describing: name)), status: \(String(describing: status)), targets: \(String(describing: targets)))"}
}

extension UpdateNotificationRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case detailType = "DetailType"
        case eventTypeIds = "EventTypeIds"
        case name = "Name"
        case status = "Status"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let detailType = detailType {
            try encodeContainer.encode(detailType.rawValue, forKey: .detailType)
        }
        if let eventTypeIds = eventTypeIds {
            var eventTypeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeIds)
            for eventtypeids0 in eventTypeIds {
                try eventTypeIdsContainer.encode(eventtypeids0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

public struct UpdateNotificationRuleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateNotificationRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNotificationRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNotificationRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNotificationRuleInput>
    public typealias MOutput = OperationOutput<UpdateNotificationRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNotificationRuleOutputError>
}

public struct UpdateNotificationRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateNotificationRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNotificationRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNotificationRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNotificationRuleInput>
    public typealias MOutput = OperationOutput<UpdateNotificationRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNotificationRuleOutputError>
}

public struct UpdateNotificationRuleInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notification rule.</p>
    public let arn: String?
    /// <p>The level of detail to include in the notifications for this resource. BASIC will include only the
    ///             contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information
    ///             provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created.</p>
    public let detailType: DetailType?
    /// <p>A list of event types associated with this notification rule.</p>
    public let eventTypeIds: [String]?
    /// <p>The name of the notification rule.</p>
    public let name: String?
    /// <p>The status of the notification rule. Valid statuses include enabled (sending notifications) or
    ///       disabled (not sending notifications).</p>
    public let status: NotificationRuleStatus?
    /// <p>The address and type of the targets to receive notifications from this notification
    ///       rule.</p>
    public let targets: [Target]?

    public init (
        arn: String? = nil,
        detailType: DetailType? = nil,
        eventTypeIds: [String]? = nil,
        name: String? = nil,
        status: NotificationRuleStatus? = nil,
        targets: [Target]? = nil
    )
    {
        self.arn = arn
        self.detailType = detailType
        self.eventTypeIds = eventTypeIds
        self.name = name
        self.status = status
        self.targets = targets
    }
}

struct UpdateNotificationRuleInputBody: Equatable {
    public let arn: String?
    public let name: String?
    public let status: NotificationRuleStatus?
    public let eventTypeIds: [String]?
    public let targets: [Target]?
    public let detailType: DetailType?
}

extension UpdateNotificationRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case detailType = "DetailType"
        case eventTypeIds = "EventTypeIds"
        case name = "Name"
        case status = "Status"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NotificationRuleStatus.self, forKey: .status)
        status = statusDecoded
        let eventTypeIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventTypeIds)
        var eventTypeIdsDecoded0:[String]? = nil
        if let eventTypeIdsContainer = eventTypeIdsContainer {
            eventTypeIdsDecoded0 = [String]()
            for string0 in eventTypeIdsContainer {
                if let string0 = string0 {
                    eventTypeIdsDecoded0?.append(string0)
                }
            }
        }
        eventTypeIds = eventTypeIdsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let detailTypeDecoded = try containerValues.decodeIfPresent(DetailType.self, forKey: .detailType)
        detailType = detailTypeDecoded
    }
}

extension UpdateNotificationRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNotificationRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNotificationRuleOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNotificationRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNotificationRuleOutputResponse()"}
}

extension UpdateNotificationRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNotificationRuleOutputResponse: Equatable {

    public init() {}
}

struct UpdateNotificationRuleOutputResponseBody: Equatable {
}

extension UpdateNotificationRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameter values are not valid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
