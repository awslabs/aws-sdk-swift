// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AdMarkers {
    case daterange
    case `none`
    case passthrough
    case scte35Enhanced
    case sdkUnknown(String)
}

extension AdMarkers : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AdMarkers] {
        return [
            .daterange,
            .none,
            .passthrough,
            .scte35Enhanced,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .daterange: return "DATERANGE"
        case .none: return "NONE"
        case .passthrough: return "PASSTHROUGH"
        case .scte35Enhanced: return "SCTE35_ENHANCED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AdMarkers(rawValue: rawValue) ?? AdMarkers.sdkUnknown(rawValue)
    }
}

/// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to
/// determine whether a message signals an ad.  Choosing "NONE" means no SCTE-35 messages become
/// ads.  Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that
/// contain delivery restrictions will be treated as ads.  Choosing "UNRESTRICTED" means SCTE-35
/// messages of the types specified in AdTriggers that do not contain delivery restrictions will
/// be treated as ads.  Choosing "BOTH" means all SCTE-35 messages of the types specified in
/// AdTriggers will be treated as ads.  Note that Splice Insert messages do not have these flags
/// and are always treated as ads if specified in AdTriggers.
public enum AdsOnDeliveryRestrictions {
    case both
    case `none`
    case restricted
    case unrestricted
    case sdkUnknown(String)
}

extension AdsOnDeliveryRestrictions : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AdsOnDeliveryRestrictions] {
        return [
            .both,
            .none,
            .restricted,
            .unrestricted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .both: return "BOTH"
        case .none: return "NONE"
        case .restricted: return "RESTRICTED"
        case .unrestricted: return "UNRESTRICTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AdsOnDeliveryRestrictions(rawValue: rawValue) ?? AdsOnDeliveryRestrictions.sdkUnknown(rawValue)
    }
}

extension Authorization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cdnIdentifierSecret = "cdnIdentifierSecret"
        case secretsRoleArn = "secretsRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdnIdentifierSecret = cdnIdentifierSecret {
            try encodeContainer.encode(cdnIdentifierSecret, forKey: .cdnIdentifierSecret)
        }
        if let secretsRoleArn = secretsRoleArn {
            try encodeContainer.encode(secretsRoleArn, forKey: .secretsRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cdnIdentifierSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cdnIdentifierSecret)
        cdnIdentifierSecret = cdnIdentifierSecretDecoded
        let secretsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsRoleArn)
        secretsRoleArn = secretsRoleArnDecoded
    }
}

extension Authorization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Authorization(cdnIdentifierSecret: \(String(describing: cdnIdentifierSecret)), secretsRoleArn: \(String(describing: secretsRoleArn)))"}
}

/// CDN Authorization credentials
public struct Authorization: Equatable {
    /// The Amazon Resource Name (ARN) for the secret in Secrets Manager that your Content Distribution Network (CDN) uses for authorization to access your endpoint.
    public let cdnIdentifierSecret: String?
    /// The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
    public let secretsRoleArn: String?

    public init (
        cdnIdentifierSecret: String? = nil,
        secretsRoleArn: String? = nil
    )
    {
        self.cdnIdentifierSecret = cdnIdentifierSecret
        self.secretsRoleArn = secretsRoleArn
    }
}

extension Channel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let egressAccessLogs = egressAccessLogs {
            try encodeContainer.encode(egressAccessLogs, forKey: .egressAccessLogs)
        }
        if let hlsIngest = hlsIngest {
            try encodeContainer.encode(hlsIngest, forKey: .hlsIngest)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ingressAccessLogs = ingressAccessLogs {
            try encodeContainer.encode(ingressAccessLogs, forKey: .ingressAccessLogs)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Channel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Channel(arn: \(String(describing: arn)), description: \(String(describing: description)), egressAccessLogs: \(String(describing: egressAccessLogs)), hlsIngest: \(String(describing: hlsIngest)), id: \(String(describing: id)), ingressAccessLogs: \(String(describing: ingressAccessLogs)), tags: \(String(describing: tags)))"}
}

/// A Channel resource configuration.
public struct Channel: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public let arn: String?
    /// A short text description of the Channel.
    public let description: String?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public let hlsIngest: HlsIngest?
    /// The ID of the Channel.
    public let id: String?
    /// Configure ingress access logging.
    public let ingressAccessLogs: IngressAccessLogs?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        description: String? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        hlsIngest: HlsIngest? = nil,
        id: String? = nil,
        ingressAccessLogs: IngressAccessLogs? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

extension CmafEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case constantInitializationVector = "constantInitializationVector"
        case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constantInitializationVector = constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if keyRotationIntervalSeconds != 0 {
            try encodeContainer.encode(keyRotationIntervalSeconds, forKey: .keyRotationIntervalSeconds)
        }
        if let spekeKeyProvider = spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let keyRotationIntervalSecondsDecoded = try containerValues.decode(Int.self, forKey: .keyRotationIntervalSeconds)
        keyRotationIntervalSeconds = keyRotationIntervalSecondsDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension CmafEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CmafEncryption(constantInitializationVector: \(String(describing: constantInitializationVector)), keyRotationIntervalSeconds: \(String(describing: keyRotationIntervalSeconds)), spekeKeyProvider: \(String(describing: spekeKeyProvider)))"}
}

/// A Common Media Application Format (CMAF) encryption configuration.
public struct CmafEncryption: Equatable {
    /// An optional 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting blocks. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
    public let constantInitializationVector: String?
    /// Time (in seconds) between each encryption key rotation.
    public let keyRotationIntervalSeconds: Int
    /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
    public let spekeKeyProvider: SpekeKeyProvider?

    public init (
        constantInitializationVector: String? = nil,
        keyRotationIntervalSeconds: Int = 0,
        spekeKeyProvider: SpekeKeyProvider? = nil
    )
    {
        self.constantInitializationVector = constantInitializationVector
        self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
        self.spekeKeyProvider = spekeKeyProvider
    }
}

extension CmafPackage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryption = "encryption"
        case hlsManifests = "hlsManifests"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case segmentPrefix = "segmentPrefix"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for __listofhlsmanifest0 in hlsManifests {
                try hlsManifestsContainer.encode(__listofhlsmanifest0)
            }
        }
        if segmentDurationSeconds != 0 {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentPrefix = segmentPrefix {
            try encodeContainer.encode(segmentPrefix, forKey: .segmentPrefix)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(CmafEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([HlsManifest?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[HlsManifest]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [HlsManifest]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let segmentDurationSecondsDecoded = try containerValues.decode(Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentPrefix)
        segmentPrefix = segmentPrefixDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension CmafPackage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CmafPackage(encryption: \(String(describing: encryption)), hlsManifests: \(String(describing: hlsManifests)), segmentDurationSeconds: \(String(describing: segmentDurationSeconds)), segmentPrefix: \(String(describing: segmentPrefix)), streamSelection: \(String(describing: streamSelection)))"}
}

/// A Common Media Application Format (CMAF) packaging configuration.
public struct CmafPackage: Equatable {
    /// A Common Media Application Format (CMAF) encryption configuration.
    public let encryption: CmafEncryption?
    /// A list of HLS manifest configurations
    public let hlsManifests: [HlsManifest]?
    /// Duration (in seconds) of each segment. Actual segments will be
    /// rounded to the nearest multiple of the source segment duration.
    public let segmentDurationSeconds: Int
    /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
    public let segmentPrefix: String?
    /// A StreamSelection configuration.
    public let streamSelection: StreamSelection?

    public init (
        encryption: CmafEncryption? = nil,
        hlsManifests: [HlsManifest]? = nil,
        segmentDurationSeconds: Int = 0,
        segmentPrefix: String? = nil,
        streamSelection: StreamSelection? = nil
    )
    {
        self.encryption = encryption
        self.hlsManifests = hlsManifests
        self.segmentDurationSeconds = segmentDurationSeconds
        self.segmentPrefix = segmentPrefix
        self.streamSelection = streamSelection
    }
}

extension CmafPackageCreateOrUpdateParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryption = "encryption"
        case hlsManifests = "hlsManifests"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case segmentPrefix = "segmentPrefix"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for __listofhlsmanifestcreateorupdateparameters0 in hlsManifests {
                try hlsManifestsContainer.encode(__listofhlsmanifestcreateorupdateparameters0)
            }
        }
        if segmentDurationSeconds != 0 {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentPrefix = segmentPrefix {
            try encodeContainer.encode(segmentPrefix, forKey: .segmentPrefix)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(CmafEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([HlsManifestCreateOrUpdateParameters?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[HlsManifestCreateOrUpdateParameters]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [HlsManifestCreateOrUpdateParameters]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let segmentDurationSecondsDecoded = try containerValues.decode(Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentPrefix)
        segmentPrefix = segmentPrefixDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension CmafPackageCreateOrUpdateParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CmafPackageCreateOrUpdateParameters(encryption: \(String(describing: encryption)), hlsManifests: \(String(describing: hlsManifests)), segmentDurationSeconds: \(String(describing: segmentDurationSeconds)), segmentPrefix: \(String(describing: segmentPrefix)), streamSelection: \(String(describing: streamSelection)))"}
}

/// A Common Media Application Format (CMAF) packaging configuration.
public struct CmafPackageCreateOrUpdateParameters: Equatable {
    /// A Common Media Application Format (CMAF) encryption configuration.
    public let encryption: CmafEncryption?
    /// A list of HLS manifest configurations
    public let hlsManifests: [HlsManifestCreateOrUpdateParameters]?
    /// Duration (in seconds) of each segment. Actual segments will be
    /// rounded to the nearest multiple of the source segment duration.
    public let segmentDurationSeconds: Int
    /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
    public let segmentPrefix: String?
    /// A StreamSelection configuration.
    public let streamSelection: StreamSelection?

    public init (
        encryption: CmafEncryption? = nil,
        hlsManifests: [HlsManifestCreateOrUpdateParameters]? = nil,
        segmentDurationSeconds: Int = 0,
        segmentPrefix: String? = nil,
        streamSelection: StreamSelection? = nil
    )
    {
        self.encryption = encryption
        self.hlsManifests = hlsManifests
        self.segmentDurationSeconds = segmentDurationSeconds
        self.segmentPrefix = segmentPrefix
        self.streamSelection = streamSelection
    }
}

public struct ConfigureLogsInputBodyMiddleware: Middleware {
    public let id: String = "ConfigureLogsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfigureLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfigureLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfigureLogsInput>
    public typealias MOutput = OperationOutput<ConfigureLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfigureLogsOutputError>
}

extension ConfigureLogsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigureLogsInput(egressAccessLogs: \(String(describing: egressAccessLogs)), id: \(String(describing: id)), ingressAccessLogs: \(String(describing: ingressAccessLogs)))"}
}

extension ConfigureLogsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case egressAccessLogs = "egressAccessLogs"
        case ingressAccessLogs = "ingressAccessLogs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressAccessLogs = egressAccessLogs {
            try encodeContainer.encode(egressAccessLogs, forKey: .egressAccessLogs)
        }
        if let ingressAccessLogs = ingressAccessLogs {
            try encodeContainer.encode(ingressAccessLogs, forKey: .ingressAccessLogs)
        }
    }
}

public struct ConfigureLogsInputHeadersMiddleware: Middleware {
    public let id: String = "ConfigureLogsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfigureLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfigureLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfigureLogsInput>
    public typealias MOutput = OperationOutput<ConfigureLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfigureLogsOutputError>
}

public struct ConfigureLogsInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfigureLogsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfigureLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfigureLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfigureLogsInput>
    public typealias MOutput = OperationOutput<ConfigureLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfigureLogsOutputError>
}

/// the option to configure log subscription.
public struct ConfigureLogsInput: Equatable {
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// The ID of the channel to log subscription.
    public let id: String?
    /// Configure ingress access logging.
    public let ingressAccessLogs: IngressAccessLogs?

    public init (
        egressAccessLogs: EgressAccessLogs? = nil,
        id: String? = nil,
        ingressAccessLogs: IngressAccessLogs? = nil
    )
    {
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
    }
}

struct ConfigureLogsInputBody: Equatable {
    public let egressAccessLogs: EgressAccessLogs?
    public let ingressAccessLogs: IngressAccessLogs?
}

extension ConfigureLogsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case egressAccessLogs = "egressAccessLogs"
        case ingressAccessLogs = "ingressAccessLogs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
    }
}

extension ConfigureLogsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfigureLogsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfigureLogsOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfigureLogsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigureLogsOutputResponse(arn: \(String(describing: arn)), description: \(String(describing: description)), egressAccessLogs: \(String(describing: egressAccessLogs)), hlsIngest: \(String(describing: hlsIngest)), id: \(String(describing: id)), ingressAccessLogs: \(String(describing: ingressAccessLogs)), tags: \(String(describing: tags)))"}
}

extension ConfigureLogsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConfigureLogsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct ConfigureLogsOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public let arn: String?
    /// A short text description of the Channel.
    public let description: String?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public let hlsIngest: HlsIngest?
    /// The ID of the Channel.
    public let id: String?
    /// Configure ingress access logging.
    public let ingressAccessLogs: IngressAccessLogs?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        description: String? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        hlsIngest: HlsIngest? = nil,
        id: String? = nil,
        ingressAccessLogs: IngressAccessLogs? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct ConfigureLogsOutputResponseBody: Equatable {
    public let arn: String?
    public let description: String?
    public let egressAccessLogs: EgressAccessLogs?
    public let hlsIngest: HlsIngest?
    public let id: String?
    public let ingressAccessLogs: IngressAccessLogs?
    public let tags: [String:String]?
}

extension ConfigureLogsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateChannelInputBodyMiddleware: Middleware {
    public let id: String = "CreateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChannelInput>
    public typealias MOutput = OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChannelOutputError>
}

extension CreateChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateChannelInput(description: \(String(describing: description)), id: \(String(describing: id)), tags: \(String(describing: tags)))"}
}

extension CreateChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case id = "id"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateChannelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChannelInput>
    public typealias MOutput = OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChannelInput>
    public typealias MOutput = OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChannelOutputError>
}

/// A new Channel configuration.
public struct CreateChannelInput: Equatable {
    /// A short text description of the Channel.
    public let description: String?
    /// The ID of the Channel. The ID must be unique within the region and it
    /// cannot be changed after a Channel is created.
    public let id: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        id: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.tags = tags
    }
}

struct CreateChannelInputBody: Equatable {
    public let description: String?
    public let id: String?
    public let tags: [String:String]?
}

extension CreateChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case id = "id"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateChannelOutputResponse(arn: \(String(describing: arn)), description: \(String(describing: description)), egressAccessLogs: \(String(describing: egressAccessLogs)), hlsIngest: \(String(describing: hlsIngest)), id: \(String(describing: id)), ingressAccessLogs: \(String(describing: ingressAccessLogs)), tags: \(String(describing: tags)))"}
}

extension CreateChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct CreateChannelOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public let arn: String?
    /// A short text description of the Channel.
    public let description: String?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public let hlsIngest: HlsIngest?
    /// The ID of the Channel.
    public let id: String?
    /// Configure ingress access logging.
    public let ingressAccessLogs: IngressAccessLogs?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        description: String? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        hlsIngest: HlsIngest? = nil,
        id: String? = nil,
        ingressAccessLogs: IngressAccessLogs? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct CreateChannelOutputResponseBody: Equatable {
    public let arn: String?
    public let description: String?
    public let egressAccessLogs: EgressAccessLogs?
    public let hlsIngest: HlsIngest?
    public let id: String?
    public let ingressAccessLogs: IngressAccessLogs?
    public let tags: [String:String]?
}

extension CreateChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateHarvestJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateHarvestJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHarvestJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHarvestJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHarvestJobInput>
    public typealias MOutput = OperationOutput<CreateHarvestJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHarvestJobOutputError>
}

extension CreateHarvestJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHarvestJobInput(endTime: \(String(describing: endTime)), id: \(String(describing: id)), originEndpointId: \(String(describing: originEndpointId)), s3Destination: \(String(describing: s3Destination)), startTime: \(String(describing: startTime)))"}
}

extension CreateHarvestJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let originEndpointId = originEndpointId {
            try encodeContainer.encode(originEndpointId, forKey: .originEndpointId)
        }
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }
}

public struct CreateHarvestJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHarvestJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHarvestJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHarvestJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHarvestJobInput>
    public typealias MOutput = OperationOutput<CreateHarvestJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHarvestJobOutputError>
}

public struct CreateHarvestJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHarvestJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHarvestJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHarvestJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHarvestJobInput>
    public typealias MOutput = OperationOutput<CreateHarvestJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHarvestJobOutputError>
}

/// Configuration parameters used to create a new HarvestJob.
public struct CreateHarvestJobInput: Equatable {
    /// The end of the time-window which will be harvested
    public let endTime: String?
    /// The ID of the HarvestJob. The ID must be unique within the region
    /// and it cannot be changed after the HarvestJob is submitted
    public let id: String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
    /// This cannot be changed after the HarvestJob is submitted.
    public let originEndpointId: String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public let s3Destination: S3Destination?
    /// The start of the time-window which will be harvested
    public let startTime: String?

    public init (
        endTime: String? = nil,
        id: String? = nil,
        originEndpointId: String? = nil,
        s3Destination: S3Destination? = nil,
        startTime: String? = nil
    )
    {
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
    }
}

struct CreateHarvestJobInputBody: Equatable {
    public let endTime: String?
    public let id: String?
    public let originEndpointId: String?
    public let s3Destination: S3Destination?
    public let startTime: String?
}

extension CreateHarvestJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let originEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originEndpointId)
        originEndpointId = originEndpointIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension CreateHarvestJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHarvestJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHarvestJobOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHarvestJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHarvestJobOutputResponse(arn: \(String(describing: arn)), channelId: \(String(describing: channelId)), createdAt: \(String(describing: createdAt)), endTime: \(String(describing: endTime)), id: \(String(describing: id)), originEndpointId: \(String(describing: originEndpointId)), s3Destination: \(String(describing: s3Destination)), startTime: \(String(describing: startTime)), status: \(String(describing: status)))"}
}

extension CreateHarvestJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateHarvestJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.channelId = output.channelId
            self.createdAt = output.createdAt
            self.endTime = output.endTime
            self.id = output.id
            self.originEndpointId = output.originEndpointId
            self.s3Destination = output.s3Destination
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.arn = nil
            self.channelId = nil
            self.createdAt = nil
            self.endTime = nil
            self.id = nil
            self.originEndpointId = nil
            self.s3Destination = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct CreateHarvestJobOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
    public let arn: String?
    /// The ID of the Channel that the HarvestJob will harvest from.
    public let channelId: String?
    /// The time the HarvestJob was submitted
    public let createdAt: String?
    /// The end of the time-window which will be harvested.
    public let endTime: String?
    /// The ID of the HarvestJob. The ID must be unique within the region
    /// and it cannot be changed after the HarvestJob is submitted.
    public let id: String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
    /// This cannot be changed after the HarvestJob is submitted.
    public let originEndpointId: String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public let s3Destination: S3Destination?
    /// The start of the time-window which will be harvested.
    public let startTime: String?
    /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
    /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
    /// include an explanation of why the HarvestJob failed.
    public let status: Status?

    public init (
        arn: String? = nil,
        channelId: String? = nil,
        createdAt: String? = nil,
        endTime: String? = nil,
        id: String? = nil,
        originEndpointId: String? = nil,
        s3Destination: S3Destination? = nil,
        startTime: String? = nil,
        status: Status? = nil
    )
    {
        self.arn = arn
        self.channelId = channelId
        self.createdAt = createdAt
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
        self.status = status
    }
}

struct CreateHarvestJobOutputResponseBody: Equatable {
    public let arn: String?
    public let channelId: String?
    public let createdAt: String?
    public let endTime: String?
    public let id: String?
    public let originEndpointId: String?
    public let s3Destination: S3Destination?
    public let startTime: String?
    public let status: Status?
}

extension CreateHarvestJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case channelId = "channelId"
        case createdAt = "createdAt"
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let originEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originEndpointId)
        originEndpointId = originEndpointIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateOriginEndpointInputBodyMiddleware: Middleware {
    public let id: String = "CreateOriginEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOriginEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOriginEndpointInput>
    public typealias MOutput = OperationOutput<CreateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOriginEndpointOutputError>
}

extension CreateOriginEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOriginEndpointInput(authorization: \(String(describing: authorization)), channelId: \(String(describing: channelId)), cmafPackage: \(String(describing: cmafPackage)), dashPackage: \(String(describing: dashPackage)), description: \(String(describing: description)), hlsPackage: \(String(describing: hlsPackage)), id: \(String(describing: id)), manifestName: \(String(describing: manifestName)), mssPackage: \(String(describing: mssPackage)), origination: \(String(describing: origination)), startoverWindowSeconds: \(String(describing: startoverWindowSeconds)), tags: \(String(describing: tags)), timeDelaySeconds: \(String(describing: timeDelaySeconds)), whitelist: \(String(describing: whitelist)))"}
}

extension CreateOriginEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case whitelist = "whitelist"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorization = authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let channelId = channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let cmafPackage = cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let dashPackage = dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsPackage = hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let mssPackage = mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let origination = origination {
            try encodeContainer.encode(origination.rawValue, forKey: .origination)
        }
        if startoverWindowSeconds != 0 {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if timeDelaySeconds != 0 {
            try encodeContainer.encode(timeDelaySeconds, forKey: .timeDelaySeconds)
        }
        if let whitelist = whitelist {
            var whitelistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whitelist)
            for __listof__string0 in whitelist {
                try whitelistContainer.encode(__listof__string0)
            }
        }
    }
}

public struct CreateOriginEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "CreateOriginEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOriginEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOriginEndpointInput>
    public typealias MOutput = OperationOutput<CreateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOriginEndpointOutputError>
}

public struct CreateOriginEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateOriginEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOriginEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOriginEndpointInput>
    public typealias MOutput = OperationOutput<CreateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOriginEndpointOutputError>
}

/// Configuration parameters used to create a new OriginEndpoint.
public struct CreateOriginEndpointInput: Equatable {
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// The ID of the Channel that the OriginEndpoint will be associated with.
    /// This cannot be changed after the OriginEndpoint is created.
    public let channelId: String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public let cmafPackage: CmafPackageCreateOrUpdateParameters?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public let dashPackage: DashPackage?
    /// A short text description of the OriginEndpoint.
    public let description: String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public let hlsPackage: HlsPackage?
    /// The ID of the OriginEndpoint.  The ID must be unique within the region
    /// and it cannot be changed after the OriginEndpoint is created.
    public let id: String?
    /// A short string that will be used as the filename of the OriginEndpoint URL (defaults to "index").
    public let manifestName: String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public let mssPackage: MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public let origination: Origination?
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    public let startoverWindowSeconds: Int
    /// A collection of tags associated with a resource
    public let tags: [String:String]?
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    public let timeDelaySeconds: Int
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public let whitelist: [String]?

    public init (
        authorization: Authorization? = nil,
        channelId: String? = nil,
        cmafPackage: CmafPackageCreateOrUpdateParameters? = nil,
        dashPackage: DashPackage? = nil,
        description: String? = nil,
        hlsPackage: HlsPackage? = nil,
        id: String? = nil,
        manifestName: String? = nil,
        mssPackage: MssPackage? = nil,
        origination: Origination? = nil,
        startoverWindowSeconds: Int = 0,
        tags: [String:String]? = nil,
        timeDelaySeconds: Int = 0,
        whitelist: [String]? = nil
    )
    {
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.whitelist = whitelist
    }
}

struct CreateOriginEndpointInputBody: Equatable {
    public let authorization: Authorization?
    public let channelId: String?
    public let cmafPackage: CmafPackageCreateOrUpdateParameters?
    public let dashPackage: DashPackage?
    public let description: String?
    public let hlsPackage: HlsPackage?
    public let id: String?
    public let manifestName: String?
    public let mssPackage: MssPackage?
    public let origination: Origination?
    public let startoverWindowSeconds: Int
    public let tags: [String:String]?
    public let timeDelaySeconds: Int
    public let whitelist: [String]?
}

extension CreateOriginEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case whitelist = "whitelist"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(CmafPackageCreateOrUpdateParameters.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decode(Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([String?].self, forKey: .whitelist)
        var whitelistDecoded0:[String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension CreateOriginEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOriginEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOriginEndpointOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOriginEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOriginEndpointOutputResponse(arn: \(String(describing: arn)), authorization: \(String(describing: authorization)), channelId: \(String(describing: channelId)), cmafPackage: \(String(describing: cmafPackage)), dashPackage: \(String(describing: dashPackage)), description: \(String(describing: description)), hlsPackage: \(String(describing: hlsPackage)), id: \(String(describing: id)), manifestName: \(String(describing: manifestName)), mssPackage: \(String(describing: mssPackage)), origination: \(String(describing: origination)), startoverWindowSeconds: \(String(describing: startoverWindowSeconds)), tags: \(String(describing: tags)), timeDelaySeconds: \(String(describing: timeDelaySeconds)), url: \(String(describing: url)), whitelist: \(String(describing: whitelist)))"}
}

extension CreateOriginEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateOriginEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.authorization = output.authorization
            self.channelId = output.channelId
            self.cmafPackage = output.cmafPackage
            self.dashPackage = output.dashPackage
            self.description = output.description
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.manifestName = output.manifestName
            self.mssPackage = output.mssPackage
            self.origination = output.origination
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
            self.timeDelaySeconds = output.timeDelaySeconds
            self.url = output.url
            self.whitelist = output.whitelist
        } else {
            self.arn = nil
            self.authorization = nil
            self.channelId = nil
            self.cmafPackage = nil
            self.dashPackage = nil
            self.description = nil
            self.hlsPackage = nil
            self.id = nil
            self.manifestName = nil
            self.mssPackage = nil
            self.origination = nil
            self.startoverWindowSeconds = 0
            self.tags = nil
            self.timeDelaySeconds = 0
            self.url = nil
            self.whitelist = nil
        }
    }
}

public struct CreateOriginEndpointOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public let arn: String?
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public let channelId: String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public let cmafPackage: CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public let dashPackage: DashPackage?
    /// A short text description of the OriginEndpoint.
    public let description: String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public let hlsPackage: HlsPackage?
    /// The ID of the OriginEndpoint.
    public let id: String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public let manifestName: String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public let mssPackage: MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public let origination: Origination?
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    public let startoverWindowSeconds: Int
    /// A collection of tags associated with a resource
    public let tags: [String:String]?
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    public let timeDelaySeconds: Int
    /// The URL of the packaged OriginEndpoint for consumption.
    public let url: String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public let whitelist: [String]?

    public init (
        arn: String? = nil,
        authorization: Authorization? = nil,
        channelId: String? = nil,
        cmafPackage: CmafPackage? = nil,
        dashPackage: DashPackage? = nil,
        description: String? = nil,
        hlsPackage: HlsPackage? = nil,
        id: String? = nil,
        manifestName: String? = nil,
        mssPackage: MssPackage? = nil,
        origination: Origination? = nil,
        startoverWindowSeconds: Int = 0,
        tags: [String:String]? = nil,
        timeDelaySeconds: Int = 0,
        url: String? = nil,
        whitelist: [String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

struct CreateOriginEndpointOutputResponseBody: Equatable {
    public let arn: String?
    public let authorization: Authorization?
    public let channelId: String?
    public let cmafPackage: CmafPackage?
    public let dashPackage: DashPackage?
    public let description: String?
    public let hlsPackage: HlsPackage?
    public let id: String?
    public let manifestName: String?
    public let mssPackage: MssPackage?
    public let origination: Origination?
    public let startoverWindowSeconds: Int
    public let tags: [String:String]?
    public let timeDelaySeconds: Int
    public let url: String?
    public let whitelist: [String]?
}

extension CreateOriginEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case url = "url"
        case whitelist = "whitelist"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decode(Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([String?].self, forKey: .whitelist)
        var whitelistDecoded0:[String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension DashEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if keyRotationIntervalSeconds != 0 {
            try encodeContainer.encode(keyRotationIntervalSeconds, forKey: .keyRotationIntervalSeconds)
        }
        if let spekeKeyProvider = spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyRotationIntervalSecondsDecoded = try containerValues.decode(Int.self, forKey: .keyRotationIntervalSeconds)
        keyRotationIntervalSeconds = keyRotationIntervalSecondsDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension DashEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashEncryption(keyRotationIntervalSeconds: \(String(describing: keyRotationIntervalSeconds)), spekeKeyProvider: \(String(describing: spekeKeyProvider)))"}
}

/// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
public struct DashEncryption: Equatable {
    /// Time (in seconds) between each encryption key rotation.
    public let keyRotationIntervalSeconds: Int
    /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
    public let spekeKeyProvider: SpekeKeyProvider?

    public init (
        keyRotationIntervalSeconds: Int = 0,
        spekeKeyProvider: SpekeKeyProvider? = nil
    )
    {
        self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
        self.spekeKeyProvider = spekeKeyProvider
    }
}

extension DashPackage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adTriggers = "adTriggers"
        case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
        case encryption = "encryption"
        case manifestLayout = "manifestLayout"
        case manifestWindowSeconds = "manifestWindowSeconds"
        case minBufferTimeSeconds = "minBufferTimeSeconds"
        case minUpdatePeriodSeconds = "minUpdatePeriodSeconds"
        case periodTriggers = "periodTriggers"
        case profile = "profile"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case segmentTemplateFormat = "segmentTemplateFormat"
        case streamSelection = "streamSelection"
        case suggestedPresentationDelaySeconds = "suggestedPresentationDelaySeconds"
        case utcTiming = "utcTiming"
        case utcTimingUri = "utcTimingUri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adTriggers = adTriggers {
            var adTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adTriggers)
            for adtriggers0 in adTriggers {
                try adTriggersContainer.encode(adtriggers0.rawValue)
            }
        }
        if let adsOnDeliveryRestrictions = adsOnDeliveryRestrictions {
            try encodeContainer.encode(adsOnDeliveryRestrictions.rawValue, forKey: .adsOnDeliveryRestrictions)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let manifestLayout = manifestLayout {
            try encodeContainer.encode(manifestLayout.rawValue, forKey: .manifestLayout)
        }
        if manifestWindowSeconds != 0 {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if minBufferTimeSeconds != 0 {
            try encodeContainer.encode(minBufferTimeSeconds, forKey: .minBufferTimeSeconds)
        }
        if minUpdatePeriodSeconds != 0 {
            try encodeContainer.encode(minUpdatePeriodSeconds, forKey: .minUpdatePeriodSeconds)
        }
        if let periodTriggers = periodTriggers {
            var periodTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .periodTriggers)
            for __listof__periodtriggerselement0 in periodTriggers {
                try periodTriggersContainer.encode(__listof__periodtriggerselement0.rawValue)
            }
        }
        if let profile = profile {
            try encodeContainer.encode(profile.rawValue, forKey: .profile)
        }
        if segmentDurationSeconds != 0 {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentTemplateFormat = segmentTemplateFormat {
            try encodeContainer.encode(segmentTemplateFormat.rawValue, forKey: .segmentTemplateFormat)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
        if suggestedPresentationDelaySeconds != 0 {
            try encodeContainer.encode(suggestedPresentationDelaySeconds, forKey: .suggestedPresentationDelaySeconds)
        }
        if let utcTiming = utcTiming {
            try encodeContainer.encode(utcTiming.rawValue, forKey: .utcTiming)
        }
        if let utcTimingUri = utcTimingUri {
            try encodeContainer.encode(utcTimingUri, forKey: .utcTimingUri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adTriggersContainer = try containerValues.decodeIfPresent([__AdTriggersElement?].self, forKey: .adTriggers)
        var adTriggersDecoded0:[__AdTriggersElement]? = nil
        if let adTriggersContainer = adTriggersContainer {
            adTriggersDecoded0 = [__AdTriggersElement]()
            for string0 in adTriggersContainer {
                if let string0 = string0 {
                    adTriggersDecoded0?.append(string0)
                }
            }
        }
        adTriggers = adTriggersDecoded0
        let adsOnDeliveryRestrictionsDecoded = try containerValues.decodeIfPresent(AdsOnDeliveryRestrictions.self, forKey: .adsOnDeliveryRestrictions)
        adsOnDeliveryRestrictions = adsOnDeliveryRestrictionsDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(DashEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let manifestLayoutDecoded = try containerValues.decodeIfPresent(ManifestLayout.self, forKey: .manifestLayout)
        manifestLayout = manifestLayoutDecoded
        let manifestWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let minBufferTimeSecondsDecoded = try containerValues.decode(Int.self, forKey: .minBufferTimeSeconds)
        minBufferTimeSeconds = minBufferTimeSecondsDecoded
        let minUpdatePeriodSecondsDecoded = try containerValues.decode(Int.self, forKey: .minUpdatePeriodSeconds)
        minUpdatePeriodSeconds = minUpdatePeriodSecondsDecoded
        let periodTriggersContainer = try containerValues.decodeIfPresent([__PeriodTriggersElement?].self, forKey: .periodTriggers)
        var periodTriggersDecoded0:[__PeriodTriggersElement]? = nil
        if let periodTriggersContainer = periodTriggersContainer {
            periodTriggersDecoded0 = [__PeriodTriggersElement]()
            for string0 in periodTriggersContainer {
                if let string0 = string0 {
                    periodTriggersDecoded0?.append(string0)
                }
            }
        }
        periodTriggers = periodTriggersDecoded0
        let profileDecoded = try containerValues.decodeIfPresent(Profile.self, forKey: .profile)
        profile = profileDecoded
        let segmentDurationSecondsDecoded = try containerValues.decode(Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentTemplateFormatDecoded = try containerValues.decodeIfPresent(SegmentTemplateFormat.self, forKey: .segmentTemplateFormat)
        segmentTemplateFormat = segmentTemplateFormatDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
        let suggestedPresentationDelaySecondsDecoded = try containerValues.decode(Int.self, forKey: .suggestedPresentationDelaySeconds)
        suggestedPresentationDelaySeconds = suggestedPresentationDelaySecondsDecoded
        let utcTimingDecoded = try containerValues.decodeIfPresent(UtcTiming.self, forKey: .utcTiming)
        utcTiming = utcTimingDecoded
        let utcTimingUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .utcTimingUri)
        utcTimingUri = utcTimingUriDecoded
    }
}

extension DashPackage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashPackage(adTriggers: \(String(describing: adTriggers)), adsOnDeliveryRestrictions: \(String(describing: adsOnDeliveryRestrictions)), encryption: \(String(describing: encryption)), manifestLayout: \(String(describing: manifestLayout)), manifestWindowSeconds: \(String(describing: manifestWindowSeconds)), minBufferTimeSeconds: \(String(describing: minBufferTimeSeconds)), minUpdatePeriodSeconds: \(String(describing: minUpdatePeriodSeconds)), periodTriggers: \(String(describing: periodTriggers)), profile: \(String(describing: profile)), segmentDurationSeconds: \(String(describing: segmentDurationSeconds)), segmentTemplateFormat: \(String(describing: segmentTemplateFormat)), streamSelection: \(String(describing: streamSelection)), suggestedPresentationDelaySeconds: \(String(describing: suggestedPresentationDelaySeconds)), utcTiming: \(String(describing: utcTiming)), utcTimingUri: \(String(describing: utcTimingUri)))"}
}

/// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
public struct DashPackage: Equatable {
    /// A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no
    /// ad markers are output.  Specify multiple items to create ad markers for all of the included
    /// message types.
    public let adTriggers: [__AdTriggersElement]?
    /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to
    /// determine whether a message signals an ad.  Choosing "NONE" means no SCTE-35 messages become
    /// ads.  Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that
    /// contain delivery restrictions will be treated as ads.  Choosing "UNRESTRICTED" means SCTE-35
    /// messages of the types specified in AdTriggers that do not contain delivery restrictions will
    /// be treated as ads.  Choosing "BOTH" means all SCTE-35 messages of the types specified in
    /// AdTriggers will be treated as ads.  Note that Splice Insert messages do not have these flags
    /// and are always treated as ads if specified in AdTriggers.
    public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
    public let encryption: DashEncryption?
    /// Determines the position of some tags in the Media Presentation Description (MPD).  When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation.  When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
    public let manifestLayout: ManifestLayout?
    /// Time window (in seconds) contained in each manifest.
    public let manifestWindowSeconds: Int
    /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
    public let minBufferTimeSeconds: Int
    /// Minimum duration (in seconds) between potential changes to the Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD).
    public let minUpdatePeriodSeconds: Int
    /// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH)
    /// Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not
    /// be partitioned into more than one period. If the list contains "ADS", new periods will be created where
    /// the Channel source contains SCTE-35 ad markers.
    public let periodTriggers: [__PeriodTriggersElement]?
    /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
    public let profile: Profile?
    /// Duration (in seconds) of each segment. Actual segments will be
    /// rounded to the nearest multiple of the source segment duration.
    public let segmentDurationSeconds: Int
    /// Determines the type of SegmentTemplate included in the Media Presentation Description (MPD).  When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs.  When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
    public let segmentTemplateFormat: SegmentTemplateFormat?
    /// A StreamSelection configuration.
    public let streamSelection: StreamSelection?
    /// Duration (in seconds) to delay live content before presentation.
    public let suggestedPresentationDelaySeconds: Int
    /// Determines the type of UTCTiming included in the Media Presentation Description (MPD)
    public let utcTiming: UtcTiming?
    /// Specifies the value attribute of the UTCTiming field when utcTiming is set to HTTP-ISO or HTTP-HEAD
    public let utcTimingUri: String?

    public init (
        adTriggers: [__AdTriggersElement]? = nil,
        adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil,
        encryption: DashEncryption? = nil,
        manifestLayout: ManifestLayout? = nil,
        manifestWindowSeconds: Int = 0,
        minBufferTimeSeconds: Int = 0,
        minUpdatePeriodSeconds: Int = 0,
        periodTriggers: [__PeriodTriggersElement]? = nil,
        profile: Profile? = nil,
        segmentDurationSeconds: Int = 0,
        segmentTemplateFormat: SegmentTemplateFormat? = nil,
        streamSelection: StreamSelection? = nil,
        suggestedPresentationDelaySeconds: Int = 0,
        utcTiming: UtcTiming? = nil,
        utcTimingUri: String? = nil
    )
    {
        self.adTriggers = adTriggers
        self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
        self.encryption = encryption
        self.manifestLayout = manifestLayout
        self.manifestWindowSeconds = manifestWindowSeconds
        self.minBufferTimeSeconds = minBufferTimeSeconds
        self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
        self.periodTriggers = periodTriggers
        self.profile = profile
        self.segmentDurationSeconds = segmentDurationSeconds
        self.segmentTemplateFormat = segmentTemplateFormat
        self.streamSelection = streamSelection
        self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
        self.utcTiming = utcTiming
        self.utcTimingUri = utcTimingUri
    }
}

extension DeleteChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChannelInput(id: \(String(describing: id)))"}
}

extension DeleteChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInput: Equatable {
    /// The ID of the Channel to delete.
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteChannelInputBody: Equatable {
}

extension DeleteChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChannelOutputResponse()"}
}

extension DeleteChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Equatable {

    public init() {}
}

struct DeleteChannelOutputResponseBody: Equatable {
}

extension DeleteChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteOriginEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOriginEndpointInput(id: \(String(describing: id)))"}
}

extension DeleteOriginEndpointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteOriginEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteOriginEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOriginEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOriginEndpointInput>
    public typealias MOutput = OperationOutput<DeleteOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOriginEndpointOutputError>
}

public struct DeleteOriginEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteOriginEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOriginEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOriginEndpointInput>
    public typealias MOutput = OperationOutput<DeleteOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOriginEndpointOutputError>
}

public struct DeleteOriginEndpointInput: Equatable {
    /// The ID of the OriginEndpoint to delete.
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteOriginEndpointInputBody: Equatable {
}

extension DeleteOriginEndpointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteOriginEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOriginEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOriginEndpointOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOriginEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOriginEndpointOutputResponse()"}
}

extension DeleteOriginEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOriginEndpointOutputResponse: Equatable {

    public init() {}
}

struct DeleteOriginEndpointOutputResponseBody: Equatable {
}

extension DeleteOriginEndpointOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeChannelInput(id: \(String(describing: id)))"}
}

extension DescribeChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInput: Equatable {
    /// The ID of a Channel.
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeChannelInputBody: Equatable {
}

extension DescribeChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeChannelOutputResponse(arn: \(String(describing: arn)), description: \(String(describing: description)), egressAccessLogs: \(String(describing: egressAccessLogs)), hlsIngest: \(String(describing: hlsIngest)), id: \(String(describing: id)), ingressAccessLogs: \(String(describing: ingressAccessLogs)), tags: \(String(describing: tags)))"}
}

extension DescribeChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct DescribeChannelOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public let arn: String?
    /// A short text description of the Channel.
    public let description: String?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public let hlsIngest: HlsIngest?
    /// The ID of the Channel.
    public let id: String?
    /// Configure ingress access logging.
    public let ingressAccessLogs: IngressAccessLogs?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        description: String? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        hlsIngest: HlsIngest? = nil,
        id: String? = nil,
        ingressAccessLogs: IngressAccessLogs? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct DescribeChannelOutputResponseBody: Equatable {
    public let arn: String?
    public let description: String?
    public let egressAccessLogs: EgressAccessLogs?
    public let hlsIngest: HlsIngest?
    public let id: String?
    public let ingressAccessLogs: IngressAccessLogs?
    public let tags: [String:String]?
}

extension DescribeChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeHarvestJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHarvestJobInput(id: \(String(describing: id)))"}
}

extension DescribeHarvestJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeHarvestJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeHarvestJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHarvestJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHarvestJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHarvestJobInput>
    public typealias MOutput = OperationOutput<DescribeHarvestJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHarvestJobOutputError>
}

public struct DescribeHarvestJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeHarvestJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHarvestJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHarvestJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHarvestJobInput>
    public typealias MOutput = OperationOutput<DescribeHarvestJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHarvestJobOutputError>
}

public struct DescribeHarvestJobInput: Equatable {
    /// The ID of the HarvestJob.
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeHarvestJobInputBody: Equatable {
}

extension DescribeHarvestJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeHarvestJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHarvestJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHarvestJobOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHarvestJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHarvestJobOutputResponse(arn: \(String(describing: arn)), channelId: \(String(describing: channelId)), createdAt: \(String(describing: createdAt)), endTime: \(String(describing: endTime)), id: \(String(describing: id)), originEndpointId: \(String(describing: originEndpointId)), s3Destination: \(String(describing: s3Destination)), startTime: \(String(describing: startTime)), status: \(String(describing: status)))"}
}

extension DescribeHarvestJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeHarvestJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.channelId = output.channelId
            self.createdAt = output.createdAt
            self.endTime = output.endTime
            self.id = output.id
            self.originEndpointId = output.originEndpointId
            self.s3Destination = output.s3Destination
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.arn = nil
            self.channelId = nil
            self.createdAt = nil
            self.endTime = nil
            self.id = nil
            self.originEndpointId = nil
            self.s3Destination = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct DescribeHarvestJobOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
    public let arn: String?
    /// The ID of the Channel that the HarvestJob will harvest from.
    public let channelId: String?
    /// The time the HarvestJob was submitted
    public let createdAt: String?
    /// The end of the time-window which will be harvested.
    public let endTime: String?
    /// The ID of the HarvestJob. The ID must be unique within the region
    /// and it cannot be changed after the HarvestJob is submitted.
    public let id: String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
    /// This cannot be changed after the HarvestJob is submitted.
    public let originEndpointId: String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public let s3Destination: S3Destination?
    /// The start of the time-window which will be harvested.
    public let startTime: String?
    /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
    /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
    /// include an explanation of why the HarvestJob failed.
    public let status: Status?

    public init (
        arn: String? = nil,
        channelId: String? = nil,
        createdAt: String? = nil,
        endTime: String? = nil,
        id: String? = nil,
        originEndpointId: String? = nil,
        s3Destination: S3Destination? = nil,
        startTime: String? = nil,
        status: Status? = nil
    )
    {
        self.arn = arn
        self.channelId = channelId
        self.createdAt = createdAt
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
        self.status = status
    }
}

struct DescribeHarvestJobOutputResponseBody: Equatable {
    public let arn: String?
    public let channelId: String?
    public let createdAt: String?
    public let endTime: String?
    public let id: String?
    public let originEndpointId: String?
    public let s3Destination: S3Destination?
    public let startTime: String?
    public let status: Status?
}

extension DescribeHarvestJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case channelId = "channelId"
        case createdAt = "createdAt"
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let originEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originEndpointId)
        originEndpointId = originEndpointIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeOriginEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOriginEndpointInput(id: \(String(describing: id)))"}
}

extension DescribeOriginEndpointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeOriginEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOriginEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOriginEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOriginEndpointInput>
    public typealias MOutput = OperationOutput<DescribeOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOriginEndpointOutputError>
}

public struct DescribeOriginEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOriginEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOriginEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOriginEndpointInput>
    public typealias MOutput = OperationOutput<DescribeOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOriginEndpointOutputError>
}

public struct DescribeOriginEndpointInput: Equatable {
    /// The ID of the OriginEndpoint.
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeOriginEndpointInputBody: Equatable {
}

extension DescribeOriginEndpointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeOriginEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOriginEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOriginEndpointOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOriginEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOriginEndpointOutputResponse(arn: \(String(describing: arn)), authorization: \(String(describing: authorization)), channelId: \(String(describing: channelId)), cmafPackage: \(String(describing: cmafPackage)), dashPackage: \(String(describing: dashPackage)), description: \(String(describing: description)), hlsPackage: \(String(describing: hlsPackage)), id: \(String(describing: id)), manifestName: \(String(describing: manifestName)), mssPackage: \(String(describing: mssPackage)), origination: \(String(describing: origination)), startoverWindowSeconds: \(String(describing: startoverWindowSeconds)), tags: \(String(describing: tags)), timeDelaySeconds: \(String(describing: timeDelaySeconds)), url: \(String(describing: url)), whitelist: \(String(describing: whitelist)))"}
}

extension DescribeOriginEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOriginEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.authorization = output.authorization
            self.channelId = output.channelId
            self.cmafPackage = output.cmafPackage
            self.dashPackage = output.dashPackage
            self.description = output.description
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.manifestName = output.manifestName
            self.mssPackage = output.mssPackage
            self.origination = output.origination
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
            self.timeDelaySeconds = output.timeDelaySeconds
            self.url = output.url
            self.whitelist = output.whitelist
        } else {
            self.arn = nil
            self.authorization = nil
            self.channelId = nil
            self.cmafPackage = nil
            self.dashPackage = nil
            self.description = nil
            self.hlsPackage = nil
            self.id = nil
            self.manifestName = nil
            self.mssPackage = nil
            self.origination = nil
            self.startoverWindowSeconds = 0
            self.tags = nil
            self.timeDelaySeconds = 0
            self.url = nil
            self.whitelist = nil
        }
    }
}

public struct DescribeOriginEndpointOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public let arn: String?
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public let channelId: String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public let cmafPackage: CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public let dashPackage: DashPackage?
    /// A short text description of the OriginEndpoint.
    public let description: String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public let hlsPackage: HlsPackage?
    /// The ID of the OriginEndpoint.
    public let id: String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public let manifestName: String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public let mssPackage: MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public let origination: Origination?
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    public let startoverWindowSeconds: Int
    /// A collection of tags associated with a resource
    public let tags: [String:String]?
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    public let timeDelaySeconds: Int
    /// The URL of the packaged OriginEndpoint for consumption.
    public let url: String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public let whitelist: [String]?

    public init (
        arn: String? = nil,
        authorization: Authorization? = nil,
        channelId: String? = nil,
        cmafPackage: CmafPackage? = nil,
        dashPackage: DashPackage? = nil,
        description: String? = nil,
        hlsPackage: HlsPackage? = nil,
        id: String? = nil,
        manifestName: String? = nil,
        mssPackage: MssPackage? = nil,
        origination: Origination? = nil,
        startoverWindowSeconds: Int = 0,
        tags: [String:String]? = nil,
        timeDelaySeconds: Int = 0,
        url: String? = nil,
        whitelist: [String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

struct DescribeOriginEndpointOutputResponseBody: Equatable {
    public let arn: String?
    public let authorization: Authorization?
    public let channelId: String?
    public let cmafPackage: CmafPackage?
    public let dashPackage: DashPackage?
    public let description: String?
    public let hlsPackage: HlsPackage?
    public let id: String?
    public let manifestName: String?
    public let mssPackage: MssPackage?
    public let origination: Origination?
    public let startoverWindowSeconds: Int
    public let tags: [String:String]?
    public let timeDelaySeconds: Int
    public let url: String?
    public let whitelist: [String]?
}

extension DescribeOriginEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case url = "url"
        case whitelist = "whitelist"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decode(Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([String?].self, forKey: .whitelist)
        var whitelistDecoded0:[String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension EgressAccessLogs: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logGroupName = "logGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension EgressAccessLogs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EgressAccessLogs(logGroupName: \(String(describing: logGroupName)))"}
}

/// Configure egress access logging.
public struct EgressAccessLogs: Equatable {
    /// Customize the log group name.
    public let logGroupName: String?

    public init (
        logGroupName: String? = nil
    )
    {
        self.logGroupName = logGroupName
    }
}

extension EncryptionContractConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case presetSpeke20Audio = "presetSpeke20Audio"
        case presetSpeke20Video = "presetSpeke20Video"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let presetSpeke20Audio = presetSpeke20Audio {
            try encodeContainer.encode(presetSpeke20Audio.rawValue, forKey: .presetSpeke20Audio)
        }
        if let presetSpeke20Video = presetSpeke20Video {
            try encodeContainer.encode(presetSpeke20Video.rawValue, forKey: .presetSpeke20Video)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetSpeke20AudioDecoded = try containerValues.decodeIfPresent(PresetSpeke20Audio.self, forKey: .presetSpeke20Audio)
        presetSpeke20Audio = presetSpeke20AudioDecoded
        let presetSpeke20VideoDecoded = try containerValues.decodeIfPresent(PresetSpeke20Video.self, forKey: .presetSpeke20Video)
        presetSpeke20Video = presetSpeke20VideoDecoded
    }
}

extension EncryptionContractConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionContractConfiguration(presetSpeke20Audio: \(String(describing: presetSpeke20Audio)), presetSpeke20Video: \(String(describing: presetSpeke20Video)))"}
}

/// Use encryptionContractConfiguration to configure one or more content encryption keys for your endpoints that use SPEKE 2.0.
/// The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream.
/// To configure the encryption contract, specify which audio and video encryption presets to use.
/// Note the following considerations when using encryptionContractConfiguration:
/// encryptionContractConfiguration can be used for DASH endpoints that use SPEKE 2.0. SPEKE 2.0 relies on the CPIX 2.3 specification.
/// You must disable key rotation for this endpoint by setting keyRotationIntervalSeconds to 0.
public struct EncryptionContractConfiguration: Equatable {
    /// A collection of audio encryption presets.
    public let presetSpeke20Audio: PresetSpeke20Audio?
    /// A collection of video encryption presets.
    public let presetSpeke20Video: PresetSpeke20Video?

    public init (
        presetSpeke20Audio: PresetSpeke20Audio? = nil,
        presetSpeke20Video: PresetSpeke20Video? = nil
    )
    {
        self.presetSpeke20Audio = presetSpeke20Audio
        self.presetSpeke20Video = presetSpeke20Video
    }
}

public enum EncryptionMethod {
    case aes128
    case sampleAes
    case sdkUnknown(String)
}

extension EncryptionMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionMethod] {
        return [
            .aes128,
            .sampleAes,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aes128: return "AES_128"
        case .sampleAes: return "SAMPLE_AES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionMethod(rawValue: rawValue) ?? EncryptionMethod.sdkUnknown(rawValue)
    }
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(message: \(String(describing: message)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not authorized to access the requested resource.
public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let message: String?
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HarvestJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case channelId = "channelId"
        case createdAt = "createdAt"
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelId = channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let originEndpointId = originEndpointId {
            try encodeContainer.encode(originEndpointId, forKey: .originEndpointId)
        }
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let originEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originEndpointId)
        originEndpointId = originEndpointIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension HarvestJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HarvestJob(arn: \(String(describing: arn)), channelId: \(String(describing: channelId)), createdAt: \(String(describing: createdAt)), endTime: \(String(describing: endTime)), id: \(String(describing: id)), originEndpointId: \(String(describing: originEndpointId)), s3Destination: \(String(describing: s3Destination)), startTime: \(String(describing: startTime)), status: \(String(describing: status)))"}
}

/// A HarvestJob resource configuration
public struct HarvestJob: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
    public let arn: String?
    /// The ID of the Channel that the HarvestJob will harvest from.
    public let channelId: String?
    /// The time the HarvestJob was submitted
    public let createdAt: String?
    /// The end of the time-window which will be harvested.
    public let endTime: String?
    /// The ID of the HarvestJob. The ID must be unique within the region
    /// and it cannot be changed after the HarvestJob is submitted.
    public let id: String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
    /// This cannot be changed after the HarvestJob is submitted.
    public let originEndpointId: String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public let s3Destination: S3Destination?
    /// The start of the time-window which will be harvested.
    public let startTime: String?
    /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
    /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
    /// include an explanation of why the HarvestJob failed.
    public let status: Status?

    public init (
        arn: String? = nil,
        channelId: String? = nil,
        createdAt: String? = nil,
        endTime: String? = nil,
        id: String? = nil,
        originEndpointId: String? = nil,
        s3Destination: S3Destination? = nil,
        startTime: String? = nil,
        status: Status? = nil
    )
    {
        self.arn = arn
        self.channelId = channelId
        self.createdAt = createdAt
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
        self.status = status
    }
}

extension HlsEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case constantInitializationVector = "constantInitializationVector"
        case encryptionMethod = "encryptionMethod"
        case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
        case repeatExtXKey = "repeatExtXKey"
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constantInitializationVector = constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let encryptionMethod = encryptionMethod {
            try encodeContainer.encode(encryptionMethod.rawValue, forKey: .encryptionMethod)
        }
        if keyRotationIntervalSeconds != 0 {
            try encodeContainer.encode(keyRotationIntervalSeconds, forKey: .keyRotationIntervalSeconds)
        }
        if repeatExtXKey != false {
            try encodeContainer.encode(repeatExtXKey, forKey: .repeatExtXKey)
        }
        if let spekeKeyProvider = spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let encryptionMethodDecoded = try containerValues.decodeIfPresent(EncryptionMethod.self, forKey: .encryptionMethod)
        encryptionMethod = encryptionMethodDecoded
        let keyRotationIntervalSecondsDecoded = try containerValues.decode(Int.self, forKey: .keyRotationIntervalSeconds)
        keyRotationIntervalSeconds = keyRotationIntervalSecondsDecoded
        let repeatExtXKeyDecoded = try containerValues.decode(Bool.self, forKey: .repeatExtXKey)
        repeatExtXKey = repeatExtXKeyDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension HlsEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HlsEncryption(constantInitializationVector: \(String(describing: constantInitializationVector)), encryptionMethod: \(String(describing: encryptionMethod)), keyRotationIntervalSeconds: \(String(describing: keyRotationIntervalSeconds)), repeatExtXKey: \(String(describing: repeatExtXKey)), spekeKeyProvider: \(String(describing: spekeKeyProvider)))"}
}

/// An HTTP Live Streaming (HLS) encryption configuration.
public struct HlsEncryption: Equatable {
    /// A constant initialization vector for encryption (optional).
    /// When not specified the initialization vector will be periodically rotated.
    public let constantInitializationVector: String?
    /// The encryption method to use.
    public let encryptionMethod: EncryptionMethod?
    /// Interval (in seconds) between each encryption key rotation.
    public let keyRotationIntervalSeconds: Int
    /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
    public let repeatExtXKey: Bool
    /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
    public let spekeKeyProvider: SpekeKeyProvider?

    public init (
        constantInitializationVector: String? = nil,
        encryptionMethod: EncryptionMethod? = nil,
        keyRotationIntervalSeconds: Int = 0,
        repeatExtXKey: Bool = false,
        spekeKeyProvider: SpekeKeyProvider? = nil
    )
    {
        self.constantInitializationVector = constantInitializationVector
        self.encryptionMethod = encryptionMethod
        self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
        self.repeatExtXKey = repeatExtXKey
        self.spekeKeyProvider = spekeKeyProvider
    }
}

extension HlsIngest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ingestEndpoints = "ingestEndpoints"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ingestEndpoints = ingestEndpoints {
            var ingestEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ingestEndpoints)
            for __listofingestendpoint0 in ingestEndpoints {
                try ingestEndpointsContainer.encode(__listofingestendpoint0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestEndpointsContainer = try containerValues.decodeIfPresent([IngestEndpoint?].self, forKey: .ingestEndpoints)
        var ingestEndpointsDecoded0:[IngestEndpoint]? = nil
        if let ingestEndpointsContainer = ingestEndpointsContainer {
            ingestEndpointsDecoded0 = [IngestEndpoint]()
            for structure0 in ingestEndpointsContainer {
                if let structure0 = structure0 {
                    ingestEndpointsDecoded0?.append(structure0)
                }
            }
        }
        ingestEndpoints = ingestEndpointsDecoded0
    }
}

extension HlsIngest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HlsIngest(ingestEndpoints: \(String(describing: ingestEndpoints)))"}
}

/// An HTTP Live Streaming (HLS) ingest resource configuration.
public struct HlsIngest: Equatable {
    /// A list of endpoints to which the source stream should be sent.
    public let ingestEndpoints: [IngestEndpoint]?

    public init (
        ingestEndpoints: [IngestEndpoint]? = nil
    )
    {
        self.ingestEndpoints = ingestEndpoints
    }
}

extension HlsManifest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adMarkers = "adMarkers"
        case id = "id"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case manifestName = "manifestName"
        case playlistType = "playlistType"
        case playlistWindowSeconds = "playlistWindowSeconds"
        case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
        case url = "url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = adMarkers {
            try encodeContainer.encode(adMarkers.rawValue, forKey: .adMarkers)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if includeIframeOnlyStream != false {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let playlistType = playlistType {
            try encodeContainer.encode(playlistType.rawValue, forKey: .playlistType)
        }
        if playlistWindowSeconds != 0 {
            try encodeContainer.encode(playlistWindowSeconds, forKey: .playlistWindowSeconds)
        }
        if programDateTimeIntervalSeconds != 0 {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersDecoded = try containerValues.decodeIfPresent(AdMarkers.self, forKey: .adMarkers)
        adMarkers = adMarkersDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decode(Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let playlistTypeDecoded = try containerValues.decodeIfPresent(PlaylistType.self, forKey: .playlistType)
        playlistType = playlistTypeDecoded
        let playlistWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .playlistWindowSeconds)
        playlistWindowSeconds = playlistWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decode(Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension HlsManifest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HlsManifest(adMarkers: \(String(describing: adMarkers)), id: \(String(describing: id)), includeIframeOnlyStream: \(String(describing: includeIframeOnlyStream)), manifestName: \(String(describing: manifestName)), playlistType: \(String(describing: playlistType)), playlistWindowSeconds: \(String(describing: playlistWindowSeconds)), programDateTimeIntervalSeconds: \(String(describing: programDateTimeIntervalSeconds)), url: \(String(describing: url)))"}
}

/// A HTTP Live Streaming (HLS) manifest configuration.
public struct HlsManifest: Equatable {
    /// This setting controls how ad markers are included in the packaged OriginEndpoint.
    /// "NONE" will omit all SCTE-35 ad markers from the output.
    /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
    /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
    /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
    /// messages in the input source.
    /// "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events
    /// in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value
    /// that is greater than 0.
    public let adMarkers: AdMarkers?
    /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
    public let id: String?
    /// When enabled, an I-Frame only stream will be included in the output.
    public let includeIframeOnlyStream: Bool
    /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
    public let manifestName: String?
    /// The HTTP Live Streaming (HLS) playlist type.
    /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
    /// entry will be included in the media playlist.
    public let playlistType: PlaylistType?
    /// Time window (in seconds) contained in each parent manifest.
    public let playlistWindowSeconds: Int
    /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
    /// inserted into manifests. Additionally, when an interval is specified
    /// ID3Timed Metadata messages will be generated every 5 seconds using the
    /// ingest time of the content.
    /// If the interval is not specified, or set to 0, then
    /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
    /// ID3Timed Metadata messages will be generated. Note that irrespective
    /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
    /// it will be passed through to HLS output.
    public let programDateTimeIntervalSeconds: Int
    /// The URL of the packaged OriginEndpoint for consumption.
    public let url: String?

    public init (
        adMarkers: AdMarkers? = nil,
        id: String? = nil,
        includeIframeOnlyStream: Bool = false,
        manifestName: String? = nil,
        playlistType: PlaylistType? = nil,
        playlistWindowSeconds: Int = 0,
        programDateTimeIntervalSeconds: Int = 0,
        url: String? = nil
    )
    {
        self.adMarkers = adMarkers
        self.id = id
        self.includeIframeOnlyStream = includeIframeOnlyStream
        self.manifestName = manifestName
        self.playlistType = playlistType
        self.playlistWindowSeconds = playlistWindowSeconds
        self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
        self.url = url
    }
}

extension HlsManifestCreateOrUpdateParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adMarkers = "adMarkers"
        case adTriggers = "adTriggers"
        case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
        case id = "id"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case manifestName = "manifestName"
        case playlistType = "playlistType"
        case playlistWindowSeconds = "playlistWindowSeconds"
        case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = adMarkers {
            try encodeContainer.encode(adMarkers.rawValue, forKey: .adMarkers)
        }
        if let adTriggers = adTriggers {
            var adTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adTriggers)
            for adtriggers0 in adTriggers {
                try adTriggersContainer.encode(adtriggers0.rawValue)
            }
        }
        if let adsOnDeliveryRestrictions = adsOnDeliveryRestrictions {
            try encodeContainer.encode(adsOnDeliveryRestrictions.rawValue, forKey: .adsOnDeliveryRestrictions)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if includeIframeOnlyStream != false {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let playlistType = playlistType {
            try encodeContainer.encode(playlistType.rawValue, forKey: .playlistType)
        }
        if playlistWindowSeconds != 0 {
            try encodeContainer.encode(playlistWindowSeconds, forKey: .playlistWindowSeconds)
        }
        if programDateTimeIntervalSeconds != 0 {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersDecoded = try containerValues.decodeIfPresent(AdMarkers.self, forKey: .adMarkers)
        adMarkers = adMarkersDecoded
        let adTriggersContainer = try containerValues.decodeIfPresent([__AdTriggersElement?].self, forKey: .adTriggers)
        var adTriggersDecoded0:[__AdTriggersElement]? = nil
        if let adTriggersContainer = adTriggersContainer {
            adTriggersDecoded0 = [__AdTriggersElement]()
            for string0 in adTriggersContainer {
                if let string0 = string0 {
                    adTriggersDecoded0?.append(string0)
                }
            }
        }
        adTriggers = adTriggersDecoded0
        let adsOnDeliveryRestrictionsDecoded = try containerValues.decodeIfPresent(AdsOnDeliveryRestrictions.self, forKey: .adsOnDeliveryRestrictions)
        adsOnDeliveryRestrictions = adsOnDeliveryRestrictionsDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decode(Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let playlistTypeDecoded = try containerValues.decodeIfPresent(PlaylistType.self, forKey: .playlistType)
        playlistType = playlistTypeDecoded
        let playlistWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .playlistWindowSeconds)
        playlistWindowSeconds = playlistWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decode(Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
    }
}

extension HlsManifestCreateOrUpdateParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HlsManifestCreateOrUpdateParameters(adMarkers: \(String(describing: adMarkers)), adTriggers: \(String(describing: adTriggers)), adsOnDeliveryRestrictions: \(String(describing: adsOnDeliveryRestrictions)), id: \(String(describing: id)), includeIframeOnlyStream: \(String(describing: includeIframeOnlyStream)), manifestName: \(String(describing: manifestName)), playlistType: \(String(describing: playlistType)), playlistWindowSeconds: \(String(describing: playlistWindowSeconds)), programDateTimeIntervalSeconds: \(String(describing: programDateTimeIntervalSeconds)))"}
}

/// A HTTP Live Streaming (HLS) manifest configuration.
public struct HlsManifestCreateOrUpdateParameters: Equatable {
    /// This setting controls how ad markers are included in the packaged OriginEndpoint.
    /// "NONE" will omit all SCTE-35 ad markers from the output.
    /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
    /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
    /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
    /// messages in the input source.
    /// "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events
    /// in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value
    /// that is greater than 0.
    public let adMarkers: AdMarkers?
    /// A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no
    /// ad markers are output.  Specify multiple items to create ad markers for all of the included
    /// message types.
    public let adTriggers: [__AdTriggersElement]?
    /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to
    /// determine whether a message signals an ad.  Choosing "NONE" means no SCTE-35 messages become
    /// ads.  Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that
    /// contain delivery restrictions will be treated as ads.  Choosing "UNRESTRICTED" means SCTE-35
    /// messages of the types specified in AdTriggers that do not contain delivery restrictions will
    /// be treated as ads.  Choosing "BOTH" means all SCTE-35 messages of the types specified in
    /// AdTriggers will be treated as ads.  Note that Splice Insert messages do not have these flags
    /// and are always treated as ads if specified in AdTriggers.
    public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
    /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
    public let id: String?
    /// When enabled, an I-Frame only stream will be included in the output.
    public let includeIframeOnlyStream: Bool
    /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
    public let manifestName: String?
    /// The HTTP Live Streaming (HLS) playlist type.
    /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
    /// entry will be included in the media playlist.
    public let playlistType: PlaylistType?
    /// Time window (in seconds) contained in each parent manifest.
    public let playlistWindowSeconds: Int
    /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
    /// inserted into manifests. Additionally, when an interval is specified
    /// ID3Timed Metadata messages will be generated every 5 seconds using the
    /// ingest time of the content.
    /// If the interval is not specified, or set to 0, then
    /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
    /// ID3Timed Metadata messages will be generated. Note that irrespective
    /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
    /// it will be passed through to HLS output.
    public let programDateTimeIntervalSeconds: Int

    public init (
        adMarkers: AdMarkers? = nil,
        adTriggers: [__AdTriggersElement]? = nil,
        adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil,
        id: String? = nil,
        includeIframeOnlyStream: Bool = false,
        manifestName: String? = nil,
        playlistType: PlaylistType? = nil,
        playlistWindowSeconds: Int = 0,
        programDateTimeIntervalSeconds: Int = 0
    )
    {
        self.adMarkers = adMarkers
        self.adTriggers = adTriggers
        self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
        self.id = id
        self.includeIframeOnlyStream = includeIframeOnlyStream
        self.manifestName = manifestName
        self.playlistType = playlistType
        self.playlistWindowSeconds = playlistWindowSeconds
        self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
    }
}

extension HlsPackage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adMarkers = "adMarkers"
        case adTriggers = "adTriggers"
        case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
        case encryption = "encryption"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case playlistType = "playlistType"
        case playlistWindowSeconds = "playlistWindowSeconds"
        case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case streamSelection = "streamSelection"
        case useAudioRenditionGroup = "useAudioRenditionGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = adMarkers {
            try encodeContainer.encode(adMarkers.rawValue, forKey: .adMarkers)
        }
        if let adTriggers = adTriggers {
            var adTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adTriggers)
            for adtriggers0 in adTriggers {
                try adTriggersContainer.encode(adtriggers0.rawValue)
            }
        }
        if let adsOnDeliveryRestrictions = adsOnDeliveryRestrictions {
            try encodeContainer.encode(adsOnDeliveryRestrictions.rawValue, forKey: .adsOnDeliveryRestrictions)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if includeIframeOnlyStream != false {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let playlistType = playlistType {
            try encodeContainer.encode(playlistType.rawValue, forKey: .playlistType)
        }
        if playlistWindowSeconds != 0 {
            try encodeContainer.encode(playlistWindowSeconds, forKey: .playlistWindowSeconds)
        }
        if programDateTimeIntervalSeconds != 0 {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if segmentDurationSeconds != 0 {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
        if useAudioRenditionGroup != false {
            try encodeContainer.encode(useAudioRenditionGroup, forKey: .useAudioRenditionGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersDecoded = try containerValues.decodeIfPresent(AdMarkers.self, forKey: .adMarkers)
        adMarkers = adMarkersDecoded
        let adTriggersContainer = try containerValues.decodeIfPresent([__AdTriggersElement?].self, forKey: .adTriggers)
        var adTriggersDecoded0:[__AdTriggersElement]? = nil
        if let adTriggersContainer = adTriggersContainer {
            adTriggersDecoded0 = [__AdTriggersElement]()
            for string0 in adTriggersContainer {
                if let string0 = string0 {
                    adTriggersDecoded0?.append(string0)
                }
            }
        }
        adTriggers = adTriggersDecoded0
        let adsOnDeliveryRestrictionsDecoded = try containerValues.decodeIfPresent(AdsOnDeliveryRestrictions.self, forKey: .adsOnDeliveryRestrictions)
        adsOnDeliveryRestrictions = adsOnDeliveryRestrictionsDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(HlsEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decode(Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let playlistTypeDecoded = try containerValues.decodeIfPresent(PlaylistType.self, forKey: .playlistType)
        playlistType = playlistTypeDecoded
        let playlistWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .playlistWindowSeconds)
        playlistWindowSeconds = playlistWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decode(Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
        let segmentDurationSecondsDecoded = try containerValues.decode(Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
        let useAudioRenditionGroupDecoded = try containerValues.decode(Bool.self, forKey: .useAudioRenditionGroup)
        useAudioRenditionGroup = useAudioRenditionGroupDecoded
    }
}

extension HlsPackage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HlsPackage(adMarkers: \(String(describing: adMarkers)), adTriggers: \(String(describing: adTriggers)), adsOnDeliveryRestrictions: \(String(describing: adsOnDeliveryRestrictions)), encryption: \(String(describing: encryption)), includeIframeOnlyStream: \(String(describing: includeIframeOnlyStream)), playlistType: \(String(describing: playlistType)), playlistWindowSeconds: \(String(describing: playlistWindowSeconds)), programDateTimeIntervalSeconds: \(String(describing: programDateTimeIntervalSeconds)), segmentDurationSeconds: \(String(describing: segmentDurationSeconds)), streamSelection: \(String(describing: streamSelection)), useAudioRenditionGroup: \(String(describing: useAudioRenditionGroup)))"}
}

/// An HTTP Live Streaming (HLS) packaging configuration.
public struct HlsPackage: Equatable {
    /// This setting controls how ad markers are included in the packaged OriginEndpoint.
    /// "NONE" will omit all SCTE-35 ad markers from the output.
    /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
    /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
    /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
    /// messages in the input source.
    /// "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events
    /// in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value
    /// that is greater than 0.
    public let adMarkers: AdMarkers?
    /// A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no
    /// ad markers are output.  Specify multiple items to create ad markers for all of the included
    /// message types.
    public let adTriggers: [__AdTriggersElement]?
    /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to
    /// determine whether a message signals an ad.  Choosing "NONE" means no SCTE-35 messages become
    /// ads.  Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that
    /// contain delivery restrictions will be treated as ads.  Choosing "UNRESTRICTED" means SCTE-35
    /// messages of the types specified in AdTriggers that do not contain delivery restrictions will
    /// be treated as ads.  Choosing "BOTH" means all SCTE-35 messages of the types specified in
    /// AdTriggers will be treated as ads.  Note that Splice Insert messages do not have these flags
    /// and are always treated as ads if specified in AdTriggers.
    public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
    /// An HTTP Live Streaming (HLS) encryption configuration.
    public let encryption: HlsEncryption?
    /// When enabled, an I-Frame only stream will be included in the output.
    public let includeIframeOnlyStream: Bool
    /// The HTTP Live Streaming (HLS) playlist type.
    /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
    /// entry will be included in the media playlist.
    public let playlistType: PlaylistType?
    /// Time window (in seconds) contained in each parent manifest.
    public let playlistWindowSeconds: Int
    /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
    /// inserted into manifests. Additionally, when an interval is specified
    /// ID3Timed Metadata messages will be generated every 5 seconds using the
    /// ingest time of the content.
    /// If the interval is not specified, or set to 0, then
    /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
    /// ID3Timed Metadata messages will be generated. Note that irrespective
    /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
    /// it will be passed through to HLS output.
    public let programDateTimeIntervalSeconds: Int
    /// Duration (in seconds) of each fragment. Actual fragments will be
    /// rounded to the nearest multiple of the source fragment duration.
    public let segmentDurationSeconds: Int
    /// A StreamSelection configuration.
    public let streamSelection: StreamSelection?
    /// When enabled, audio streams will be placed in rendition groups in the output.
    public let useAudioRenditionGroup: Bool

    public init (
        adMarkers: AdMarkers? = nil,
        adTriggers: [__AdTriggersElement]? = nil,
        adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil,
        encryption: HlsEncryption? = nil,
        includeIframeOnlyStream: Bool = false,
        playlistType: PlaylistType? = nil,
        playlistWindowSeconds: Int = 0,
        programDateTimeIntervalSeconds: Int = 0,
        segmentDurationSeconds: Int = 0,
        streamSelection: StreamSelection? = nil,
        useAudioRenditionGroup: Bool = false
    )
    {
        self.adMarkers = adMarkers
        self.adTriggers = adTriggers
        self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
        self.encryption = encryption
        self.includeIframeOnlyStream = includeIframeOnlyStream
        self.playlistType = playlistType
        self.playlistWindowSeconds = playlistWindowSeconds
        self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
        self.segmentDurationSeconds = segmentDurationSeconds
        self.streamSelection = streamSelection
        self.useAudioRenditionGroup = useAudioRenditionGroup
    }
}

extension IngestEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "id"
        case password = "password"
        case url = "url"
        case username = "username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension IngestEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IngestEndpoint(id: \(String(describing: id)), password: \(String(describing: password)), url: \(String(describing: url)), username: \(String(describing: username)))"}
}

/// An endpoint for ingesting source content for a Channel.
public struct IngestEndpoint: Equatable {
    /// The system generated unique identifier for the IngestEndpoint
    public let id: String?
    /// The system generated password for ingest authentication.
    public let password: String?
    /// The ingest URL to which the source stream should be sent.
    public let url: String?
    /// The system generated username for ingest authentication.
    public let username: String?

    public init (
        id: String? = nil,
        password: String? = nil,
        url: String? = nil,
        username: String? = nil
    )
    {
        self.id = id
        self.password = password
        self.url = url
        self.username = username
    }
}

extension IngressAccessLogs: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logGroupName = "logGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension IngressAccessLogs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IngressAccessLogs(logGroupName: \(String(describing: logGroupName)))"}
}

/// Configure ingress access logging.
public struct IngressAccessLogs: Equatable {
    /// Customize the log group name.
    public let logGroupName: String?

    public init (
        logGroupName: String? = nil
    )
    {
        self.logGroupName = logGroupName
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred.
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChannelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChannelsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListChannelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListChannelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChannelsInput>
    public typealias MOutput = OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChannelsInput>
    public typealias MOutput = OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChannelsOutputError>
}

public struct ListChannelsInput: Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Equatable {
}

extension ListChannelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListChannelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChannelsOutputResponse(channels: \(String(describing: channels)), nextToken: \(String(describing: nextToken)))"}
}

extension ListChannelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Equatable {
    /// A list of Channel records.
    public let channels: [Channel]?
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: String?

    public init (
        channels: [Channel]? = nil,
        nextToken: String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Equatable {
    public let channels: [Channel]?
    public let nextToken: String?
}

extension ListChannelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channels = "channels"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([Channel?].self, forKey: .channels)
        var channelsDecoded0:[Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [Channel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHarvestJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHarvestJobsInput(includeChannelId: \(String(describing: includeChannelId)), includeStatus: \(String(describing: includeStatus)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListHarvestJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListHarvestJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListHarvestJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHarvestJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHarvestJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHarvestJobsInput>
    public typealias MOutput = OperationOutput<ListHarvestJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHarvestJobsOutputError>
}

public struct ListHarvestJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListHarvestJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHarvestJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHarvestJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let includeChannelId = input.operationInput.includeChannelId {
            let includeChannelIdQueryItem = URLQueryItem(name: "includeChannelId".urlPercentEncoding(), value: String(includeChannelId).urlPercentEncoding())
            input.builder.withQueryItem(includeChannelIdQueryItem)
        }
        if let includeStatus = input.operationInput.includeStatus {
            let includeStatusQueryItem = URLQueryItem(name: "includeStatus".urlPercentEncoding(), value: String(includeStatus).urlPercentEncoding())
            input.builder.withQueryItem(includeStatusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHarvestJobsInput>
    public typealias MOutput = OperationOutput<ListHarvestJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHarvestJobsOutputError>
}

public struct ListHarvestJobsInput: Equatable {
    /// When specified, the request will return only HarvestJobs associated with the given Channel ID.
    public let includeChannelId: String?
    /// When specified, the request will return only HarvestJobs in the given status.
    public let includeStatus: String?
    /// The upper bound on the number of records to return.
    public let maxResults: Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: String?

    public init (
        includeChannelId: String? = nil,
        includeStatus: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.includeChannelId = includeChannelId
        self.includeStatus = includeStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHarvestJobsInputBody: Equatable {
}

extension ListHarvestJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListHarvestJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHarvestJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHarvestJobsOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHarvestJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHarvestJobsOutputResponse(harvestJobs: \(String(describing: harvestJobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListHarvestJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListHarvestJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.harvestJobs = output.harvestJobs
            self.nextToken = output.nextToken
        } else {
            self.harvestJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListHarvestJobsOutputResponse: Equatable {
    /// A list of HarvestJob records.
    public let harvestJobs: [HarvestJob]?
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: String?

    public init (
        harvestJobs: [HarvestJob]? = nil,
        nextToken: String? = nil
    )
    {
        self.harvestJobs = harvestJobs
        self.nextToken = nextToken
    }
}

struct ListHarvestJobsOutputResponseBody: Equatable {
    public let harvestJobs: [HarvestJob]?
    public let nextToken: String?
}

extension ListHarvestJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case harvestJobs = "harvestJobs"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let harvestJobsContainer = try containerValues.decodeIfPresent([HarvestJob?].self, forKey: .harvestJobs)
        var harvestJobsDecoded0:[HarvestJob]? = nil
        if let harvestJobsContainer = harvestJobsContainer {
            harvestJobsDecoded0 = [HarvestJob]()
            for structure0 in harvestJobsContainer {
                if let structure0 = structure0 {
                    harvestJobsDecoded0?.append(structure0)
                }
            }
        }
        harvestJobs = harvestJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOriginEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOriginEndpointsInput(channelId: \(String(describing: channelId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOriginEndpointsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListOriginEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOriginEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOriginEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOriginEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOriginEndpointsInput>
    public typealias MOutput = OperationOutput<ListOriginEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOriginEndpointsOutputError>
}

public struct ListOriginEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOriginEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOriginEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOriginEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let channelId = input.operationInput.channelId {
            let channelIdQueryItem = URLQueryItem(name: "channelId".urlPercentEncoding(), value: String(channelId).urlPercentEncoding())
            input.builder.withQueryItem(channelIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOriginEndpointsInput>
    public typealias MOutput = OperationOutput<ListOriginEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOriginEndpointsOutputError>
}

public struct ListOriginEndpointsInput: Equatable {
    /// When specified, the request will return only OriginEndpoints associated with the given Channel ID.
    public let channelId: String?
    /// The upper bound on the number of records to return.
    public let maxResults: Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: String?

    public init (
        channelId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.channelId = channelId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOriginEndpointsInputBody: Equatable {
}

extension ListOriginEndpointsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListOriginEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOriginEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOriginEndpointsOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOriginEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOriginEndpointsOutputResponse(nextToken: \(String(describing: nextToken)), originEndpoints: \(String(describing: originEndpoints)))"}
}

extension ListOriginEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOriginEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.originEndpoints = output.originEndpoints
        } else {
            self.nextToken = nil
            self.originEndpoints = nil
        }
    }
}

public struct ListOriginEndpointsOutputResponse: Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: String?
    /// A list of OriginEndpoint records.
    public let originEndpoints: [OriginEndpoint]?

    public init (
        nextToken: String? = nil,
        originEndpoints: [OriginEndpoint]? = nil
    )
    {
        self.nextToken = nextToken
        self.originEndpoints = originEndpoints
    }
}

struct ListOriginEndpointsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let originEndpoints: [OriginEndpoint]?
}

extension ListOriginEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case originEndpoints = "originEndpoints"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let originEndpointsContainer = try containerValues.decodeIfPresent([OriginEndpoint?].self, forKey: .originEndpoints)
        var originEndpointsDecoded0:[OriginEndpoint]? = nil
        if let originEndpointsContainer = originEndpointsContainer {
            originEndpointsDecoded0 = [OriginEndpoint]()
            for structure0 in originEndpointsContainer {
                if let structure0 = structure0 {
                    originEndpointsDecoded0?.append(structure0)
                }
            }
        }
        originEndpoints = originEndpointsDecoded0
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum ManifestLayout {
    case compact
    case full
    case sdkUnknown(String)
}

extension ManifestLayout : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ManifestLayout] {
        return [
            .compact,
            .full,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .compact: return "COMPACT"
        case .full: return "FULL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ManifestLayout(rawValue: rawValue) ?? ManifestLayout.sdkUnknown(rawValue)
    }
}

extension MssEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spekeKeyProvider = spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MssEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MssEncryption(spekeKeyProvider: \(String(describing: spekeKeyProvider)))"}
}

/// A Microsoft Smooth Streaming (MSS) encryption configuration.
public struct MssEncryption: Equatable {
    /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
    public let spekeKeyProvider: SpekeKeyProvider?

    public init (
        spekeKeyProvider: SpekeKeyProvider? = nil
    )
    {
        self.spekeKeyProvider = spekeKeyProvider
    }
}

extension MssPackage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryption = "encryption"
        case manifestWindowSeconds = "manifestWindowSeconds"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if manifestWindowSeconds != 0 {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if segmentDurationSeconds != 0 {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(MssEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let manifestWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let segmentDurationSecondsDecoded = try containerValues.decode(Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension MssPackage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MssPackage(encryption: \(String(describing: encryption)), manifestWindowSeconds: \(String(describing: manifestWindowSeconds)), segmentDurationSeconds: \(String(describing: segmentDurationSeconds)), streamSelection: \(String(describing: streamSelection)))"}
}

/// A Microsoft Smooth Streaming (MSS) packaging configuration.
public struct MssPackage: Equatable {
    /// A Microsoft Smooth Streaming (MSS) encryption configuration.
    public let encryption: MssEncryption?
    /// The time window (in seconds) contained in each manifest.
    public let manifestWindowSeconds: Int
    /// The duration (in seconds) of each segment.
    public let segmentDurationSeconds: Int
    /// A StreamSelection configuration.
    public let streamSelection: StreamSelection?

    public init (
        encryption: MssEncryption? = nil,
        manifestWindowSeconds: Int = 0,
        segmentDurationSeconds: Int = 0,
        streamSelection: StreamSelection? = nil
    )
    {
        self.encryption = encryption
        self.manifestWindowSeconds = manifestWindowSeconds
        self.segmentDurationSeconds = segmentDurationSeconds
        self.streamSelection = streamSelection
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource does not exist.
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OriginEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case url = "url"
        case whitelist = "whitelist"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authorization = authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let channelId = channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let cmafPackage = cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let dashPackage = dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsPackage = hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let mssPackage = mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let origination = origination {
            try encodeContainer.encode(origination.rawValue, forKey: .origination)
        }
        if startoverWindowSeconds != 0 {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if timeDelaySeconds != 0 {
            try encodeContainer.encode(timeDelaySeconds, forKey: .timeDelaySeconds)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let whitelist = whitelist {
            var whitelistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whitelist)
            for __listof__string0 in whitelist {
                try whitelistContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decode(Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([String?].self, forKey: .whitelist)
        var whitelistDecoded0:[String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension OriginEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginEndpoint(arn: \(String(describing: arn)), authorization: \(String(describing: authorization)), channelId: \(String(describing: channelId)), cmafPackage: \(String(describing: cmafPackage)), dashPackage: \(String(describing: dashPackage)), description: \(String(describing: description)), hlsPackage: \(String(describing: hlsPackage)), id: \(String(describing: id)), manifestName: \(String(describing: manifestName)), mssPackage: \(String(describing: mssPackage)), origination: \(String(describing: origination)), startoverWindowSeconds: \(String(describing: startoverWindowSeconds)), tags: \(String(describing: tags)), timeDelaySeconds: \(String(describing: timeDelaySeconds)), url: \(String(describing: url)), whitelist: \(String(describing: whitelist)))"}
}

/// An OriginEndpoint resource configuration.
public struct OriginEndpoint: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public let arn: String?
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public let channelId: String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public let cmafPackage: CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public let dashPackage: DashPackage?
    /// A short text description of the OriginEndpoint.
    public let description: String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public let hlsPackage: HlsPackage?
    /// The ID of the OriginEndpoint.
    public let id: String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public let manifestName: String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public let mssPackage: MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public let origination: Origination?
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    public let startoverWindowSeconds: Int
    /// A collection of tags associated with a resource
    public let tags: [String:String]?
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    public let timeDelaySeconds: Int
    /// The URL of the packaged OriginEndpoint for consumption.
    public let url: String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public let whitelist: [String]?

    public init (
        arn: String? = nil,
        authorization: Authorization? = nil,
        channelId: String? = nil,
        cmafPackage: CmafPackage? = nil,
        dashPackage: DashPackage? = nil,
        description: String? = nil,
        hlsPackage: HlsPackage? = nil,
        id: String? = nil,
        manifestName: String? = nil,
        mssPackage: MssPackage? = nil,
        origination: Origination? = nil,
        startoverWindowSeconds: Int = 0,
        tags: [String:String]? = nil,
        timeDelaySeconds: Int = 0,
        url: String? = nil,
        whitelist: [String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

public enum Origination {
    case allow
    case deny
    case sdkUnknown(String)
}

extension Origination : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Origination] {
        return [
            .allow,
            .deny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "ALLOW"
        case .deny: return "DENY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Origination(rawValue: rawValue) ?? Origination.sdkUnknown(rawValue)
    }
}

public enum PlaylistType {
    case event
    case `none`
    case vod
    case sdkUnknown(String)
}

extension PlaylistType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PlaylistType] {
        return [
            .event,
            .none,
            .vod,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .event: return "EVENT"
        case .none: return "NONE"
        case .vod: return "VOD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PlaylistType(rawValue: rawValue) ?? PlaylistType.sdkUnknown(rawValue)
    }
}

public enum PresetSpeke20Audio {
    case presetAudio1
    case sdkUnknown(String)
}

extension PresetSpeke20Audio : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PresetSpeke20Audio] {
        return [
            .presetAudio1,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .presetAudio1: return "PRESET-AUDIO-1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PresetSpeke20Audio(rawValue: rawValue) ?? PresetSpeke20Audio.sdkUnknown(rawValue)
    }
}

public enum PresetSpeke20Video {
    case presetVideo1
    case sdkUnknown(String)
}

extension PresetSpeke20Video : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PresetSpeke20Video] {
        return [
            .presetVideo1,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .presetVideo1: return "PRESET-VIDEO-1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PresetSpeke20Video(rawValue: rawValue) ?? PresetSpeke20Video.sdkUnknown(rawValue)
    }
}

public enum Profile {
    case hbbtv15
    case `none`
    case sdkUnknown(String)
}

extension Profile : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Profile] {
        return [
            .hbbtv15,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hbbtv15: return "HBBTV_1_5"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Profile(rawValue: rawValue) ?? Profile.sdkUnknown(rawValue)
    }
}

extension RotateChannelCredentialsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RotateChannelCredentialsInput(id: \(String(describing: id)))"}
}

extension RotateChannelCredentialsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RotateChannelCredentialsInputHeadersMiddleware: Middleware {
    public let id: String = "RotateChannelCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RotateChannelCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<RotateChannelCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RotateChannelCredentialsInput>
    public typealias MOutput = OperationOutput<RotateChannelCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RotateChannelCredentialsOutputError>
}

public struct RotateChannelCredentialsInputQueryItemMiddleware: Middleware {
    public let id: String = "RotateChannelCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RotateChannelCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<RotateChannelCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RotateChannelCredentialsInput>
    public typealias MOutput = OperationOutput<RotateChannelCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RotateChannelCredentialsOutputError>
}

@available(*, deprecated)
public struct RotateChannelCredentialsInput: Equatable {
    /// The ID of the channel to update.
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct RotateChannelCredentialsInputBody: Equatable {
}

extension RotateChannelCredentialsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RotateChannelCredentialsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RotateChannelCredentialsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RotateChannelCredentialsOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RotateChannelCredentialsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RotateChannelCredentialsOutputResponse(arn: \(String(describing: arn)), description: \(String(describing: description)), egressAccessLogs: \(String(describing: egressAccessLogs)), hlsIngest: \(String(describing: hlsIngest)), id: \(String(describing: id)), ingressAccessLogs: \(String(describing: ingressAccessLogs)), tags: \(String(describing: tags)))"}
}

extension RotateChannelCredentialsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RotateChannelCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated)
public struct RotateChannelCredentialsOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public let arn: String?
    /// A short text description of the Channel.
    public let description: String?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public let hlsIngest: HlsIngest?
    /// The ID of the Channel.
    public let id: String?
    /// Configure ingress access logging.
    public let ingressAccessLogs: IngressAccessLogs?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        description: String? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        hlsIngest: HlsIngest? = nil,
        id: String? = nil,
        ingressAccessLogs: IngressAccessLogs? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct RotateChannelCredentialsOutputResponseBody: Equatable {
    public let arn: String?
    public let description: String?
    public let egressAccessLogs: EgressAccessLogs?
    public let hlsIngest: HlsIngest?
    public let id: String?
    public let ingressAccessLogs: IngressAccessLogs?
    public let tags: [String:String]?
}

extension RotateChannelCredentialsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RotateIngestEndpointCredentialsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RotateIngestEndpointCredentialsInput(id: \(String(describing: id)), ingestEndpointId: \(String(describing: ingestEndpointId)))"}
}

extension RotateIngestEndpointCredentialsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RotateIngestEndpointCredentialsInputHeadersMiddleware: Middleware {
    public let id: String = "RotateIngestEndpointCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RotateIngestEndpointCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<RotateIngestEndpointCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RotateIngestEndpointCredentialsInput>
    public typealias MOutput = OperationOutput<RotateIngestEndpointCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RotateIngestEndpointCredentialsOutputError>
}

public struct RotateIngestEndpointCredentialsInputQueryItemMiddleware: Middleware {
    public let id: String = "RotateIngestEndpointCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RotateIngestEndpointCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<RotateIngestEndpointCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RotateIngestEndpointCredentialsInput>
    public typealias MOutput = OperationOutput<RotateIngestEndpointCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RotateIngestEndpointCredentialsOutputError>
}

public struct RotateIngestEndpointCredentialsInput: Equatable {
    /// The ID of the channel the IngestEndpoint is on.
    public let id: String?
    /// The id of the IngestEndpoint whose credentials should be rotated
    public let ingestEndpointId: String?

    public init (
        id: String? = nil,
        ingestEndpointId: String? = nil
    )
    {
        self.id = id
        self.ingestEndpointId = ingestEndpointId
    }
}

struct RotateIngestEndpointCredentialsInputBody: Equatable {
}

extension RotateIngestEndpointCredentialsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RotateIngestEndpointCredentialsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RotateIngestEndpointCredentialsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RotateIngestEndpointCredentialsOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RotateIngestEndpointCredentialsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RotateIngestEndpointCredentialsOutputResponse(arn: \(String(describing: arn)), description: \(String(describing: description)), egressAccessLogs: \(String(describing: egressAccessLogs)), hlsIngest: \(String(describing: hlsIngest)), id: \(String(describing: id)), ingressAccessLogs: \(String(describing: ingressAccessLogs)), tags: \(String(describing: tags)))"}
}

extension RotateIngestEndpointCredentialsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RotateIngestEndpointCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct RotateIngestEndpointCredentialsOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public let arn: String?
    /// A short text description of the Channel.
    public let description: String?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public let hlsIngest: HlsIngest?
    /// The ID of the Channel.
    public let id: String?
    /// Configure ingress access logging.
    public let ingressAccessLogs: IngressAccessLogs?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        description: String? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        hlsIngest: HlsIngest? = nil,
        id: String? = nil,
        ingressAccessLogs: IngressAccessLogs? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct RotateIngestEndpointCredentialsOutputResponseBody: Equatable {
    public let arn: String?
    public let description: String?
    public let egressAccessLogs: EgressAccessLogs?
    public let hlsIngest: HlsIngest?
    public let id: String?
    public let ingressAccessLogs: IngressAccessLogs?
    public let tags: [String:String]?
}

extension RotateIngestEndpointCredentialsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension S3Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName = "bucketName"
        case manifestKey = "manifestKey"
        case roleArn = "roleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let manifestKey = manifestKey {
            try encodeContainer.encode(manifestKey, forKey: .manifestKey)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let manifestKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestKey)
        manifestKey = manifestKeyDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension S3Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Destination(bucketName: \(String(describing: bucketName)), manifestKey: \(String(describing: manifestKey)), roleArn: \(String(describing: roleArn)))"}
}

/// Configuration parameters for where in an S3 bucket to place the harvested content
public struct S3Destination: Equatable {
    /// The name of an S3 bucket within which harvested content will be exported
    public let bucketName: String?
    /// The key in the specified S3 bucket where the harvested top-level manifest will be placed.
    public let manifestKey: String?
    /// The IAM role used to write to the specified S3 bucket
    public let roleArn: String?

    public init (
        bucketName: String? = nil,
        manifestKey: String? = nil,
        roleArn: String? = nil
    )
    {
        self.bucketName = bucketName
        self.manifestKey = manifestKey
        self.roleArn = roleArn
    }
}

public enum SegmentTemplateFormat {
    case numberWithDuration
    case numberWithTimeline
    case timeWithTimeline
    case sdkUnknown(String)
}

extension SegmentTemplateFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SegmentTemplateFormat] {
        return [
            .numberWithDuration,
            .numberWithTimeline,
            .timeWithTimeline,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .numberWithDuration: return "NUMBER_WITH_DURATION"
        case .numberWithTimeline: return "NUMBER_WITH_TIMELINE"
        case .timeWithTimeline: return "TIME_WITH_TIMELINE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SegmentTemplateFormat(rawValue: rawValue) ?? SegmentTemplateFormat.sdkUnknown(rawValue)
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred.
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SpekeKeyProvider: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "certificateArn"
        case encryptionContractConfiguration = "encryptionContractConfiguration"
        case resourceId = "resourceId"
        case roleArn = "roleArn"
        case systemIds = "systemIds"
        case url = "url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let encryptionContractConfiguration = encryptionContractConfiguration {
            try encodeContainer.encode(encryptionContractConfiguration, forKey: .encryptionContractConfiguration)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let systemIds = systemIds {
            var systemIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .systemIds)
            for __listof__string0 in systemIds {
                try systemIdsContainer.encode(__listof__string0)
            }
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let encryptionContractConfigurationDecoded = try containerValues.decodeIfPresent(EncryptionContractConfiguration.self, forKey: .encryptionContractConfiguration)
        encryptionContractConfiguration = encryptionContractConfigurationDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let systemIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .systemIds)
        var systemIdsDecoded0:[String]? = nil
        if let systemIdsContainer = systemIdsContainer {
            systemIdsDecoded0 = [String]()
            for string0 in systemIdsContainer {
                if let string0 = string0 {
                    systemIdsDecoded0?.append(string0)
                }
            }
        }
        systemIds = systemIdsDecoded0
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension SpekeKeyProvider: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SpekeKeyProvider(certificateArn: \(String(describing: certificateArn)), encryptionContractConfiguration: \(String(describing: encryptionContractConfiguration)), resourceId: \(String(describing: resourceId)), roleArn: \(String(describing: roleArn)), systemIds: \(String(describing: systemIds)), url: \(String(describing: url)))"}
}

/// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
public struct SpekeKeyProvider: Equatable {
    /// An Amazon Resource Name (ARN) of a Certificate Manager certificate
    /// that MediaPackage will use for enforcing secure end-to-end data
    /// transfer with the key provider service.
    public let certificateArn: String?
    /// Use encryptionContractConfiguration to configure one or more content encryption keys for your endpoints that use SPEKE 2.0.
    /// The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream.
    /// To configure the encryption contract, specify which audio and video encryption presets to use.
    /// Note the following considerations when using encryptionContractConfiguration:
    /// encryptionContractConfiguration can be used for DASH endpoints that use SPEKE 2.0. SPEKE 2.0 relies on the CPIX 2.3 specification.
    /// You must disable key rotation for this endpoint by setting keyRotationIntervalSeconds to 0.
    public let encryptionContractConfiguration: EncryptionContractConfiguration?
    /// The resource ID to include in key requests.
    public let resourceId: String?
    /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental
    /// MediaPackage will assume when accessing the key provider service.
    public let roleArn: String?
    /// The system IDs to include in key requests.
    public let systemIds: [String]?
    /// The URL of the external key provider service.
    public let url: String?

    public init (
        certificateArn: String? = nil,
        encryptionContractConfiguration: EncryptionContractConfiguration? = nil,
        resourceId: String? = nil,
        roleArn: String? = nil,
        systemIds: [String]? = nil,
        url: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.encryptionContractConfiguration = encryptionContractConfiguration
        self.resourceId = resourceId
        self.roleArn = roleArn
        self.systemIds = systemIds
        self.url = url
    }
}

public enum Status {
    case failed
    case inProgress
    case succeeded
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .failed,
            .inProgress,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

public enum StreamOrder {
    case original
    case videoBitrateAscending
    case videoBitrateDescending
    case sdkUnknown(String)
}

extension StreamOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamOrder] {
        return [
            .original,
            .videoBitrateAscending,
            .videoBitrateDescending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .original: return "ORIGINAL"
        case .videoBitrateAscending: return "VIDEO_BITRATE_ASCENDING"
        case .videoBitrateDescending: return "VIDEO_BITRATE_DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamOrder(rawValue: rawValue) ?? StreamOrder.sdkUnknown(rawValue)
    }
}

extension StreamSelection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxVideoBitsPerSecond = "maxVideoBitsPerSecond"
        case minVideoBitsPerSecond = "minVideoBitsPerSecond"
        case streamOrder = "streamOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxVideoBitsPerSecond != 0 {
            try encodeContainer.encode(maxVideoBitsPerSecond, forKey: .maxVideoBitsPerSecond)
        }
        if minVideoBitsPerSecond != 0 {
            try encodeContainer.encode(minVideoBitsPerSecond, forKey: .minVideoBitsPerSecond)
        }
        if let streamOrder = streamOrder {
            try encodeContainer.encode(streamOrder.rawValue, forKey: .streamOrder)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxVideoBitsPerSecondDecoded = try containerValues.decode(Int.self, forKey: .maxVideoBitsPerSecond)
        maxVideoBitsPerSecond = maxVideoBitsPerSecondDecoded
        let minVideoBitsPerSecondDecoded = try containerValues.decode(Int.self, forKey: .minVideoBitsPerSecond)
        minVideoBitsPerSecond = minVideoBitsPerSecondDecoded
        let streamOrderDecoded = try containerValues.decodeIfPresent(StreamOrder.self, forKey: .streamOrder)
        streamOrder = streamOrderDecoded
    }
}

extension StreamSelection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamSelection(maxVideoBitsPerSecond: \(String(describing: maxVideoBitsPerSecond)), minVideoBitsPerSecond: \(String(describing: minVideoBitsPerSecond)), streamOrder: \(String(describing: streamOrder)))"}
}

/// A StreamSelection configuration.
public struct StreamSelection: Equatable {
    /// The maximum video bitrate (bps) to include in output.
    public let maxVideoBitsPerSecond: Int
    /// The minimum video bitrate (bps) to include in output.
    public let minVideoBitsPerSecond: Int
    /// A directive that determines the order of streams in the output.
    public let streamOrder: StreamOrder?

    public init (
        maxVideoBitsPerSecond: Int = 0,
        minVideoBitsPerSecond: Int = 0,
        streamOrder: StreamOrder? = nil
    )
    {
        self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
        self.minVideoBitsPerSecond = minVideoBitsPerSecond
        self.streamOrder = streamOrder
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    public let resourceArn: String?
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client has exceeded their resource or throttling limits.
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessableEntityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnprocessableEntityException(message: \(String(describing: message)))"}
}

extension UnprocessableEntityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnprocessableEntityExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameters sent in the request are not valid.
public struct UnprocessableEntityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnprocessableEntityExceptionBody: Equatable {
    public let message: String?
}

extension UnprocessableEntityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    public let resourceArn: String?
    /// The key(s) of tag to be deleted
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChannelOutputError>
}

extension UpdateChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateChannelInput(description: \(String(describing: description)), id: \(String(describing: id)))"}
}

extension UpdateChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChannelOutputError>
}

/// Configuration parameters used to update the Channel.
public struct UpdateChannelInput: Equatable {
    /// A short text description of the Channel.
    public let description: String?
    /// The ID of the Channel to update.
    public let id: String?

    public init (
        description: String? = nil,
        id: String? = nil
    )
    {
        self.description = description
        self.id = id
    }
}

struct UpdateChannelInputBody: Equatable {
    public let description: String?
}

extension UpdateChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateChannelOutputResponse(arn: \(String(describing: arn)), description: \(String(describing: description)), egressAccessLogs: \(String(describing: egressAccessLogs)), hlsIngest: \(String(describing: hlsIngest)), id: \(String(describing: id)), ingressAccessLogs: \(String(describing: ingressAccessLogs)), tags: \(String(describing: tags)))"}
}

extension UpdateChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public let arn: String?
    /// A short text description of the Channel.
    public let description: String?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public let hlsIngest: HlsIngest?
    /// The ID of the Channel.
    public let id: String?
    /// Configure ingress access logging.
    public let ingressAccessLogs: IngressAccessLogs?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        description: String? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        hlsIngest: HlsIngest? = nil,
        id: String? = nil,
        ingressAccessLogs: IngressAccessLogs? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct UpdateChannelOutputResponseBody: Equatable {
    public let arn: String?
    public let description: String?
    public let egressAccessLogs: EgressAccessLogs?
    public let hlsIngest: HlsIngest?
    public let id: String?
    public let ingressAccessLogs: IngressAccessLogs?
    public let tags: [String:String]?
}

extension UpdateChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateOriginEndpointInputBodyMiddleware: Middleware {
    public let id: String = "UpdateOriginEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOriginEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOriginEndpointInput>
    public typealias MOutput = OperationOutput<UpdateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOriginEndpointOutputError>
}

extension UpdateOriginEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOriginEndpointInput(authorization: \(String(describing: authorization)), cmafPackage: \(String(describing: cmafPackage)), dashPackage: \(String(describing: dashPackage)), description: \(String(describing: description)), hlsPackage: \(String(describing: hlsPackage)), id: \(String(describing: id)), manifestName: \(String(describing: manifestName)), mssPackage: \(String(describing: mssPackage)), origination: \(String(describing: origination)), startoverWindowSeconds: \(String(describing: startoverWindowSeconds)), timeDelaySeconds: \(String(describing: timeDelaySeconds)), whitelist: \(String(describing: whitelist)))"}
}

extension UpdateOriginEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorization = "authorization"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case timeDelaySeconds = "timeDelaySeconds"
        case whitelist = "whitelist"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorization = authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let cmafPackage = cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let dashPackage = dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsPackage = hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let mssPackage = mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let origination = origination {
            try encodeContainer.encode(origination.rawValue, forKey: .origination)
        }
        if startoverWindowSeconds != 0 {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
        if timeDelaySeconds != 0 {
            try encodeContainer.encode(timeDelaySeconds, forKey: .timeDelaySeconds)
        }
        if let whitelist = whitelist {
            var whitelistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whitelist)
            for __listof__string0 in whitelist {
                try whitelistContainer.encode(__listof__string0)
            }
        }
    }
}

public struct UpdateOriginEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateOriginEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOriginEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOriginEndpointInput>
    public typealias MOutput = OperationOutput<UpdateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOriginEndpointOutputError>
}

public struct UpdateOriginEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateOriginEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOriginEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOriginEndpointInput>
    public typealias MOutput = OperationOutput<UpdateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOriginEndpointOutputError>
}

/// Configuration parameters used to update an existing OriginEndpoint.
public struct UpdateOriginEndpointInput: Equatable {
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public let cmafPackage: CmafPackageCreateOrUpdateParameters?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public let dashPackage: DashPackage?
    /// A short text description of the OriginEndpoint.
    public let description: String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public let hlsPackage: HlsPackage?
    /// The ID of the OriginEndpoint to update.
    public let id: String?
    /// A short string that will be appended to the end of the Endpoint URL.
    public let manifestName: String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public let mssPackage: MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public let origination: Origination?
    /// Maximum duration (in seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    public let startoverWindowSeconds: Int
    /// Amount of delay (in seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    public let timeDelaySeconds: Int
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public let whitelist: [String]?

    public init (
        authorization: Authorization? = nil,
        cmafPackage: CmafPackageCreateOrUpdateParameters? = nil,
        dashPackage: DashPackage? = nil,
        description: String? = nil,
        hlsPackage: HlsPackage? = nil,
        id: String? = nil,
        manifestName: String? = nil,
        mssPackage: MssPackage? = nil,
        origination: Origination? = nil,
        startoverWindowSeconds: Int = 0,
        timeDelaySeconds: Int = 0,
        whitelist: [String]? = nil
    )
    {
        self.authorization = authorization
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.timeDelaySeconds = timeDelaySeconds
        self.whitelist = whitelist
    }
}

struct UpdateOriginEndpointInputBody: Equatable {
    public let authorization: Authorization?
    public let cmafPackage: CmafPackageCreateOrUpdateParameters?
    public let dashPackage: DashPackage?
    public let description: String?
    public let hlsPackage: HlsPackage?
    public let manifestName: String?
    public let mssPackage: MssPackage?
    public let origination: Origination?
    public let startoverWindowSeconds: Int
    public let timeDelaySeconds: Int
    public let whitelist: [String]?
}

extension UpdateOriginEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorization = "authorization"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case timeDelaySeconds = "timeDelaySeconds"
        case whitelist = "whitelist"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(CmafPackageCreateOrUpdateParameters.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let timeDelaySecondsDecoded = try containerValues.decode(Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([String?].self, forKey: .whitelist)
        var whitelistDecoded0:[String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension UpdateOriginEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOriginEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOriginEndpointOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOriginEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOriginEndpointOutputResponse(arn: \(String(describing: arn)), authorization: \(String(describing: authorization)), channelId: \(String(describing: channelId)), cmafPackage: \(String(describing: cmafPackage)), dashPackage: \(String(describing: dashPackage)), description: \(String(describing: description)), hlsPackage: \(String(describing: hlsPackage)), id: \(String(describing: id)), manifestName: \(String(describing: manifestName)), mssPackage: \(String(describing: mssPackage)), origination: \(String(describing: origination)), startoverWindowSeconds: \(String(describing: startoverWindowSeconds)), tags: \(String(describing: tags)), timeDelaySeconds: \(String(describing: timeDelaySeconds)), url: \(String(describing: url)), whitelist: \(String(describing: whitelist)))"}
}

extension UpdateOriginEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateOriginEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.authorization = output.authorization
            self.channelId = output.channelId
            self.cmafPackage = output.cmafPackage
            self.dashPackage = output.dashPackage
            self.description = output.description
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.manifestName = output.manifestName
            self.mssPackage = output.mssPackage
            self.origination = output.origination
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
            self.timeDelaySeconds = output.timeDelaySeconds
            self.url = output.url
            self.whitelist = output.whitelist
        } else {
            self.arn = nil
            self.authorization = nil
            self.channelId = nil
            self.cmafPackage = nil
            self.dashPackage = nil
            self.description = nil
            self.hlsPackage = nil
            self.id = nil
            self.manifestName = nil
            self.mssPackage = nil
            self.origination = nil
            self.startoverWindowSeconds = 0
            self.tags = nil
            self.timeDelaySeconds = 0
            self.url = nil
            self.whitelist = nil
        }
    }
}

public struct UpdateOriginEndpointOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public let arn: String?
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public let channelId: String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public let cmafPackage: CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public let dashPackage: DashPackage?
    /// A short text description of the OriginEndpoint.
    public let description: String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public let hlsPackage: HlsPackage?
    /// The ID of the OriginEndpoint.
    public let id: String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public let manifestName: String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public let mssPackage: MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public let origination: Origination?
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    public let startoverWindowSeconds: Int
    /// A collection of tags associated with a resource
    public let tags: [String:String]?
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    public let timeDelaySeconds: Int
    /// The URL of the packaged OriginEndpoint for consumption.
    public let url: String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public let whitelist: [String]?

    public init (
        arn: String? = nil,
        authorization: Authorization? = nil,
        channelId: String? = nil,
        cmafPackage: CmafPackage? = nil,
        dashPackage: DashPackage? = nil,
        description: String? = nil,
        hlsPackage: HlsPackage? = nil,
        id: String? = nil,
        manifestName: String? = nil,
        mssPackage: MssPackage? = nil,
        origination: Origination? = nil,
        startoverWindowSeconds: Int = 0,
        tags: [String:String]? = nil,
        timeDelaySeconds: Int = 0,
        url: String? = nil,
        whitelist: [String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

struct UpdateOriginEndpointOutputResponseBody: Equatable {
    public let arn: String?
    public let authorization: Authorization?
    public let channelId: String?
    public let cmafPackage: CmafPackage?
    public let dashPackage: DashPackage?
    public let description: String?
    public let hlsPackage: HlsPackage?
    public let id: String?
    public let manifestName: String?
    public let mssPackage: MssPackage?
    public let origination: Origination?
    public let startoverWindowSeconds: Int
    public let tags: [String:String]?
    public let timeDelaySeconds: Int
    public let url: String?
    public let whitelist: [String]?
}

extension UpdateOriginEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case url = "url"
        case whitelist = "whitelist"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decode(Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([String?].self, forKey: .whitelist)
        var whitelistDecoded0:[String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

public enum UtcTiming {
    case httpHead
    case httpIso
    case `none`
    case sdkUnknown(String)
}

extension UtcTiming : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UtcTiming] {
        return [
            .httpHead,
            .httpIso,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .httpHead: return "HTTP-HEAD"
        case .httpIso: return "HTTP-ISO"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UtcTiming(rawValue: rawValue) ?? UtcTiming.sdkUnknown(rawValue)
    }
}

public enum __AdTriggersElement {
    case `break`
    case distributorAdvertisement
    case distributorOverlayPlacementOpportunity
    case distributorPlacementOpportunity
    case providerAdvertisement
    case providerOverlayPlacementOpportunity
    case providerPlacementOpportunity
    case spliceInsert
    case sdkUnknown(String)
}

extension __AdTriggersElement : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [__AdTriggersElement] {
        return [
            .break,
            .distributorAdvertisement,
            .distributorOverlayPlacementOpportunity,
            .distributorPlacementOpportunity,
            .providerAdvertisement,
            .providerOverlayPlacementOpportunity,
            .providerPlacementOpportunity,
            .spliceInsert,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .break: return "BREAK"
        case .distributorAdvertisement: return "DISTRIBUTOR_ADVERTISEMENT"
        case .distributorOverlayPlacementOpportunity: return "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
        case .distributorPlacementOpportunity: return "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
        case .providerAdvertisement: return "PROVIDER_ADVERTISEMENT"
        case .providerOverlayPlacementOpportunity: return "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
        case .providerPlacementOpportunity: return "PROVIDER_PLACEMENT_OPPORTUNITY"
        case .spliceInsert: return "SPLICE_INSERT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = __AdTriggersElement(rawValue: rawValue) ?? __AdTriggersElement.sdkUnknown(rawValue)
    }
}

public enum __PeriodTriggersElement {
    case ads
    case sdkUnknown(String)
}

extension __PeriodTriggersElement : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [__PeriodTriggersElement] {
        return [
            .ads,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ads: return "ADS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = __PeriodTriggersElement(rawValue: rawValue) ?? __PeriodTriggersElement.sdkUnknown(rawValue)
    }
}
